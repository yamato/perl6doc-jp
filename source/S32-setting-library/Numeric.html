<!DOCTYPE html>
<html lang="ja">
<head>
<title>Numeric</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Aug 30 10:16:53 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Function_Packages'>Function Packages</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Bool'>Bool</a>
    <li class='indexItem indexItem2'><a href='#Numeric'>Numeric</a>
    <li class='indexItem indexItem2'><a href='#Real'>Real</a>
    <li class='indexItem indexItem2'><a href='#Num'>Num</a>
    <li class='indexItem indexItem2'><a href='#Complex'>Complex</a>
    <li class='indexItem indexItem2'><a href='#Trigonometric_functions'>Trigonometric functions</a>
    <li class='indexItem indexItem2'><a href='#Int'>Int</a>
    <li class='indexItem indexItem2'><a href='#Rat'>Rat</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Additions'>Additions</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>DRAFT: Synopsis 32: Setting Library - Numeric</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Rod Adams &#60;rod@rodadams.net&#62;
Larry Wall &#60;larry@wall.org&#62;
Aaron Sherman &#60;ajs@ajs.com&#62;
Mark Stosberg &#60;mark@summersault.com&#62;
Carl M&#228;sak &#60;cmasak@gmail.com&#62;
Moritz Lenz &#60;moritz@faui2k3.org&#62;
Tim Nelson &#60;wayland@wayland.id.au&#62;
Stefan O&#39;Rear &#60;stefanor@cox.net&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 19 Mar 2009 extracted from S29-functions.pod

Last Modified: 28 Dec 2013
Version: 18</code></pre>

<p>The document is a draft.</p>

<p>If you read the HTML version, it is generated from the Pod in the specs repository under <a href="https://github.com/perl6/specs/blob/master/S32-setting-library/Numeric.pod" class="podlinkurl"
>https://github.com/perl6/specs/blob/master/S32-setting-library/Numeric.pod</a> so edit it there in the git repository if you would like to make changes.</p>

<p>This documents Bit, Int, Numeric, Rat, Complex, and Bool.</p>

<p>XXX So where are Bit, Int, and Rat</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Function_Packages"
>Function Packages</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Bool"
>Bool</a></h2>

<dl>
<dt><a name="succ"
>succ</a></dt>

<dd>
<pre><code> multi method succ ( Bool $b: --&#62; Bool ) is export</code></pre>

<p>Returns <code>Bool::True</code>.</p>

<dt><a name="pred"
>pred</a></dt>

<dd>
<pre><code> multi method pred ( Bool $b: --&#62; Bool ) is export</code></pre>

<p>Returns <code>Bool::False</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Numeric"
>Numeric</a></h2>

<p><code>Numeric</code> is a role for everything that&#39;s a scalar number. So <code>Num</code>, <code>Int</code>, <code>Rat</code>, <code>Complex</code> and other numeric types do that role. However it is an abstract interface, so <code>$number.WHAT</code> will never return <code>Numeric</code>.</p>

<p>Users who provide their own scalar numeric types are encouraged to implement the <code>Numeric</code> role. It is intended that such types support the basic arithmetic operators to the extent possible, as well as <code>==</code>. In addition, it is hoped that comparison operators will at least return consistent results, even if there is no sensible mathematical ordering of your type. That allows functions like sort to not choke and die if they are handed a value of your type. (See also the <code>Real</code> role for scalar numeric types that represent real numbers.)</p>

<p>The following are all defined in the <code>Numeric</code> role:</p>

<p><code>Numeric</code> provides some constants in addition to the basic mathematical functions.</p>

<pre><code>constant pi is export = 3.14159_26535_89793_23846_26433_83279_50288;
constant e  is export = 2.71828_18284_59045_23536_02874_71352_66249;
constant i  is export = 1i;</code></pre>

<dl>
<dt><a name="Real"
>Real</a></dt>

<dd>
<pre><code> multi method Real ( --&#62; Real )</code></pre>

<p>If this <code>Numeric</code> is equivalent to a <code>Real</code>, return that <code>Real</code>. (For instance, if this number is a <code>Complex</code> with a zero imaginary part.) Fail with <code>X::Numeric::Real</code> otherwise.</p>

<dt><a name="Int"
>Int</a></dt>

<dd>
<pre><code> multi method Int ( --&#62; Int )</code></pre>

<p>If this <code>Numeric</code> is equivalent to a <code>Real</code>, return the equivalent of calling <code>truncate</code> on that <code>Real</code> to get an <code>Int</code>. Fail with <code>X::Numeric::Real</code> otherwise.</p>

<dt><a name="Rat"
>Rat</a></dt>

<dd>
<pre><code> multi method Rat ( Real $epsilon = 1.0e-6 --&#62; Rat )</code></pre>

<p>If this <code>Numeric</code> is equivalent to a <code>Real</code>, return a <code>Rat</code> which is within <code>$epsilon</code> of that <code>Real</code>&#39;s value. Fail with <code>X::Numeric::Real</code> otherwise.</p>

<dt><a name="Num"
>Num</a></dt>

<dd>
<pre><code> multi method Num ( --&#62; Num )</code></pre>

<p>If this <code>Numeric</code> is equivalent to a <code>Real</code>, return that <code>Real</code> as a <code>Num</code> as accurately as is possible. Fail with <code>X::Numeric::Real</code> otherwise.</p>

<dt><a name="succ"
>succ</a></dt>

<dd>
<pre><code> multi method succ ( Numeric $x: --&#62; Numeric ) is export
 multi method succ ( Int $x: --&#62; Int     )     is export</code></pre>

<p>Returns the successor of <code>$x</code>. This method is used by <code>prefix:&#60;++&#62;</code> and <code>postfix:&#60;++&#62;</code> to increment the value in a container.</p>

<dt><a name="pred"
>pred</a></dt>

<dd>
<pre><code> multi method pred ( Numeric $x: --&#62; Numeric ) is export
 multi method pred ( Int $x: --&#62; Int     ) is export</code></pre>

<p>Returns the predecessor of <code>$x</code>. This method is used by <code>prefix:&#60;--&#62;</code> and <code>postfix:&#60;--&#62;</code> to decrement the value in a container.</p>

<dt><a name="abs"
>abs</a></dt>

<dd>
<pre><code> multi method abs ( Numeric $x: --&#62; Numeric ) is export</code></pre>

<p>Absolute Value.</p>

<dt><a name="conj"
>conj</a></dt>

<dd>
<pre><code> multi method conj ( Numeric $x: --&#62; Numeric ) is export</code></pre>

<p>The complex conjugate of the value. For non-complex types, returns self.</p>

<dt><a name="exp"
>exp</a></dt>

<dd>
<pre><code> multi method exp ( Numeric $exponent: Numeric :$base = Num::e --&#62; Numeric ) is export</code></pre>

<p>Performs similar to <code>$base ** $exponent</code>. <code>$base</code> defaults to the constant <i>e</i>.</p>

<dt><a name="log"
>log</a></dt>

<dd>
<pre><code> multi method log ( Numeric $x: Numeric $base = Num::e --&#62; Numeric ) is export</code></pre>

<p>Logarithm of base <code>$base</code>, default Natural. Calling with <code>$x == 0</code> is an error.</p>

<dt><a name="log10"
>log10</a></dt>

<dd>
<pre><code> multi method log10 (Numeric $x: --&#62; Numeric ) is export</code></pre>

<p>A base <code>10</code> logarithm, otherwise identical to <code>log</code>.</p>

<dt><a name="rand"
>rand</a></dt>

<dd>
<pre><code> sub term:&#60;rand&#62; ( --&#62; Num )</code></pre>

<p>Pseudo random number in range <code>0 ..^ 1</code>. That is, <code>0</code> is theoretically possible, while <code>1</code> is not. Note that there is no unary <code>rand</code> function in Perl 6, but there is a <code>rand</code> method. For picking a random integer you probably want to use something like <code>(1..6).pick</code> instead.</p>

<dt><a name="sqrt"
>sqrt</a></dt>

<dd>
<pre><code> multi method sqrt ( Numeric $x: --&#62; Numeric ) is export</code></pre>

<p>Returns the principal square root of the parameter.</p>

<dt><a name="roots"
>roots</a></dt>

<dd>
<pre><code>  method roots (Numeric $x: Int $n ) is export</code></pre>

<p>Returns a list of all <code>$n</code>th (complex) roots of <code>$x</code>. Returns <code>NaN</code> if <code>$n &#60;= 0</code>, itself if <code>$n == 0</code>, and is free to return a single <code>NaN</code> if <code>$x</code> is <code>NaN</code> or <code>Inf</code>, or in case of complex numbers if one of the components is.</p>

<dt><a name="i"
>i</a></dt>

<dd>
<pre><code> multi postfix:&#60;i&#62; ( Numeric $x --&#62; Complex )</code></pre>

<p>Returns a complex number representing the parameter multiplied by the imaginary unit <code>i</code>. Note that there is no <code>.i</code> method. To follow a variable name with the postfix, it&#39;s necessary to use a backslash or parentheses:</p>

<pre><code>$land\i
($land)i</code></pre>

<dt><a name="to-radians"
>to-radians</a></dt>

<dd>
<pre><code> multi method to-radians ( Numeric $x: TrigBase $base --&#62; Numeric ) is export</code></pre>

<p>Convert from <code>$base</code> to radians.</p>

<dt><a name="from-radians"
>from-radians</a></dt>

<dd>
<pre><code> multi method from-radians ( Numeric $x: TrigBase $base --&#62; Numeric ) is export</code></pre>

<p>Convert from radians to <code>$base</code>.</p>

<dt><a name="narrow"
>narrow</a></dt>

<dd>
<pre><code> multi method narrow ( Numeric $x: ) is export</code></pre>

<p>Attempts to coerce the number to the narrowest type that can represent it accurately; for instance, a <code>Rat</code> with a denominator of 1 maybe be coerced to an <code>Int</code> instead; an integral <code>Num</code> may likewise turn into an <code>Int</code>. (Neither <code>Num</code> nor <code>Rat</code> convert to each other, however.) <code>Complex</code> with a 0 imaginary part may narrow to a <code>Real</code> type. Conjecturally, wide native types could narrow to narrower native types.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Real"
>Real</a></h2>

<pre><code>role Real does Numeric;</code></pre>

<p><code>Real</code>, like <code>Numeric</code>, is an abstract role that represents the interface of a real scalar number (i.e. neither <code>Complex</code> nor vector-like). For example <code>Num</code>, <code>Int</code>, <code>Bool</code> and <code>Rat</code> implement the <code>Real</code> role.</p>

<p>Users who provide their own scalar real numeric types are encouraged to implement the <code>Real</code> role. Because real numbers are strictly-totally-ordered and <code>Real</code> types try to emulate that property, it is desirable that any two <code>Real</code> types be mutually compatible, even if they are not aware of each other. The current proposal requires you to define a <code>Bridge</code> method in your <code>Real</code> type, which converts your type into a neutral <code>Real</code> type by restating it in terms of the fundamental Perl 6 types and calling <code>Bridge</code> on them. This then makes the default <code>Real</code> methods and operators all work with your <code>Real</code> type. While the name of this method may changed, it is hoped that something like this will remain in the spec.</p>

<dl>
<dt><a name="Complex"
>Complex</a></dt>

<dd>
<pre><code> multi method Complex ( --&#62; Complex )</code></pre>

<p>Returns a <code>Complex</code> whose real part is this <code>Real</code> and whose imaginary part is 0.</p>

<dt><a name="Str"
>Str</a></dt>

<dd>
<pre><code> multi method Str ( --&#62; Str )</code></pre>

<p>Returns the <code>Real</code> as a <code>Str</code>. All built-in <code>Real</code> types format it as a decimal number, so for example, the <code>Rat</code> <code>5/4</code> is returned as <code>&#34;1.2&#34;</code>.</p>

<dt><a name="base"
>base</a></dt>

<dd>
<pre><code>  multi method base(Cool $base as Int)</code></pre>

<p>Returns a <code>Str</code> representing the invocant in base <code>$base</code>. Fails if <code>$base</code> is smaller than <code>2</code> or larger than <code>36</code>.</p>

<p>For bases above ten, the digit repertoire is enhanced with uppercase latin characters starting from <code>A</code>.</p>

<dt><a name="floor"
>floor</a></dt>

<dd>
<pre><code> multi method floor ( Real $x: --&#62; Int ) is export</code></pre>

<p>Returns the highest integer not greater than <code>$x</code>.</p>

<dt><a name="ceiling"
>ceiling</a></dt>

<dd>
<pre><code> multi method ceiling ( Real $x: --&#62; Int ) is export</code></pre>

<p>Returns the lowest integer not less than <code>$x</code>.</p>

<dt><a name="round"
>round</a></dt>

<dd>
<pre><code> multi method round ( Real $x: $scale = 1 --&#62; Real ) is export</code></pre>

<p>With no arguments, returns the nearest integer to <code>$x</code>. If <code>$scale</code> is given, rounds $x to the nearest multiple of <code>$scale</code>. The algorithm is:</p>

<pre><code>floor($x / $scale + 0.5) * $scale</code></pre>

<p>(Other rounding algorithms will be given extended names beginning with &#34;round&#34;.)</p>

<dt><a name="truncate"
>truncate</a></dt>

<dd>
<pre><code> multi method truncate ( Real $x: --&#62; Int ) is export</code></pre>

<p>Returns the closest integer to <code>$x</code> whose absolute value is not greater than the absolute value of <code>$x</code>. (In other words, just chuck any fractional part.) This is the default rounding function used by implicit integer conversions.</p>

<p>You may also truncate using explicit integer casts, either <code>Int()</code> for an arbitrarily large integers, or <code>int()</code> for native integers.</p>

<dt><a name="sign"
>sign</a></dt>

<dd>
<pre><code> multi method sign ( Real $x: --&#62; Int ) is export</code></pre>

<p>Returns 1 when <code>$x</code> is greater than 0, -1 when it is less than 0, 0 when it is equal to 0, or undefined when the value passed is undefined.</p>

<dt><a name="srand"
>srand</a></dt>

<dd>
<pre><code> multi srand ( Real $seed = default_seed_algorithm())</code></pre>

<p>Seed the generator <code>rand</code> uses. <code>$seed</code> defaults to some combination of various platform dependent characteristics to yield a non-deterministic seed. Note that you get one <code>srand()</code> for free when you start a Perl program, so you <i>must</i> call <code>srand()</code> yourself if you wish to specify a deterministic seed (or if you wish to be differently nondeterministic).</p>

<dt><a name="rand"
>rand</a></dt>

<dd>
<pre><code> multi method rand (Real $x: --&#62; Num ) is export</code></pre>

<p>Pseudo random number in range <code>0 ..^ $x</code>. That is, <code>0</code> is theoretically possible, while <code>$x</code> is not. For picking a random integer you probably want to use something like <code>(1..6).pick</code> instead.</p>

<dt><a name="cis"
>cis</a></dt>

<dd>
<pre><code>multi method cis (Real $angle: --&#62; Complex ) is export</code></pre>

<p>Returns 1.unpolar($angle)</p>

<dt><a name="unpolar"
>unpolar</a></dt>

<dd>
<pre><code>multi method unpolar (Real $mag: Real $angle --&#62; Complex ) is export</code></pre>

<p>Returns a complex number specified in polar coordinates. Angle is in radians.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Num"
>Num</a></h2>

<pre><code>class Num does Real;</code></pre>

<p><code>Num</code> is a machine-precision numeric real value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Complex"
>Complex</a></h2>

<p><code>Complex</code> is an immutable type. Each <code>Complex</code> object stores two numbers, the real and imaginary part. For all practical purposes a <code>Complex</code> with a <code>NaN</code> in real or imaginary part may be considered a <code>NaN</code> itself (and <code>(NaN+1i) ~~ NaN</code> is <code>True</code>).</p>

<p>Coercion of a <code>Complex</code> to any <code>Real</code> returns the real part (coerced, if necessary) if the imaginary part is 0, and fails otherwise. Comparison between a <code>Real</code> number and a <code>Complex</code> must be smart enough not to coerce the <code>Complex</code> to a real number blindly.</p>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code>multi method new(Real $re, Real $im --&#62; Complex )</code></pre>

<p>Constructs a <code>Complex</code> number from real and imaginary part. This is the method form of <code>$re+$im\i</code>. (But use the <code>&#60;1+2i&#62;</code> form for literals, so that you don&#39;t have to worry about precedence or rely on constant folding.)</p>

<dt><a name="polar"
>polar</a></dt>

<dd>
<pre><code>multi method polar (Complex $nim: --&#62; Seq ) is export</code></pre>

<p>Returns (magnitude, angle) corresponding to the complex number. The magnitude is non-negative, and the angle in the range <code>-&#960; ..^ &#960;</code>.</p>

<dt><a name="re"
>re</a></dt>

<dd>
<pre><code>multi method re( --&#62; Real )</code></pre>

<p>Returns the real part of the complex number.</p>

<dt><a name="im"
>im</a></dt>

<dd>
<pre><code>multi method im( --&#62; Real )</code></pre>

<p>Returns the imaginary part of a complex number.</p>

<dt><a name="conj"
>conj</a></dt>

<dd>
<pre><code>multi method conj(Complex $c --&#62; Complex )</code></pre>

<p>Returns <code>($c.re - $c.im\i)</code>, the complex conjugate.</p>

<dt><a name="gist"
>gist</a></dt>

<dd>
<pre><code>multi method gist( --&#62; Str )</code></pre>

<p>Returns a string representation of the form &#34;<code>1+2i</code>&#34;, without internal spaces. (<code>Str</code> coercion also returns this.)</p>

<dt><a name="perl"
>perl</a></dt>

<dd>
<pre><code>multi method perl( --&#62; Str )</code></pre>

<p>Returns a string representation corresponding to the unambiguous <code>val()</code>-based representation of complex literals, of the form &#34;<code>&#60;1+2i&#62;</code>&#34;, without internal spaces, and including the angles that keep the <code>+</code> from being treated as a normal addition operator.</p>

<dt><a name="floor"
>floor</a></dt>

<dd>
<pre><code> multi method floor ( Complex $c: --&#62; Complex ) is export</code></pre>

<p>Returns <code>$c.re.floor + $c.im.floor</code>. That is, each of the real and imaginary parts is rounded to the highest integer not greater that the value of that part.</p>

<dt><a name="ceiling"
>ceiling</a></dt>

<dd>
<pre><code> multi method ceiling ( Complex $c: --&#62; Complex ) is export</code></pre>

<p>Returns <code>$c.re.ceiling + $c.im.ceiling</code>. That is, each of the real and imaginary parts is rounded to the lowest integer not less that the value of that part.</p>

<dt><a name="round"
>round</a></dt>

<dd>
<pre><code> multi method round ( Complex $c: $scale = 1 --&#62; Complex ) is export</code></pre>

<p>With no arguments, rounds both the real and imaginary parts to the nearest integer and returns a new Complex number. If <code>$scale</code> is given, rounds both parts of $c to the nearest multiple of <code>$scale</code>. Uses the same algorithm as Real.round on each part of the number.</p>

<dt><a name="truncate"
>truncate</a></dt>

<dd>
<pre><code> multi method truncate ( Complex $c: --&#62; Complex ) is export</code></pre>

<p>Removes the fractional part of both the real and imaginary parts of the number, using Real.truncate, and returns the result as a new Complex.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Trigonometric_functions"
>Trigonometric functions</a></h2>

<p>The following are also defined in <code>Numeric</code>. Most trig functions are specified to operate in terms of radians, as the mathematical and programming standard. Functions are provided to convert other angle specifications to and from radians. Angle specifications are given in terms of enum TrigBase:</p>

<pre><code> enum TrigBase is export (
Radians  =&#62; 1,
Degrees  =&#62; (pi / 180),
Gradians =&#62; (pi / 200),
Circles  =&#62; 2*pi
 );</code></pre>

<dl>
<dt><a name="Standard_Trig_Functions"
><i>Standard Trig Functions</i></a></dt>

<dd>
<pre><code> Numeric multi method func ( Numeric  $x ) is export</code></pre>

<p>where <i>func</i> is one of: sin, cos, tan, asin, acos, atan, sec, cosec, cotan, asec, acosec, acotan, sinh, cosh, tanh, asinh, acosh, atanh, sech, cosech, cotanh, asech, acosech, acotanh.</p>

<p>Performs the various trigonometric functions. The argument is always expressed in radians. The return value from <code>CORE::</code> versions of these functions is always <code>Num</code>, unless domain limits force it to be <code>Complex</code> instead.</p>

<dt><a name="Converting_Angles"
><i>Converting Angles</i></a></dt>

<dd>
<p>If you prefer to express angles in units other than radians, you have two choices. First, you can convert the angles into radians, by multiplication:</p>

<pre><code> sin(90 * Degrees)</code></pre>

<p>or by using the <code>to-radians</code> method:</p>

<pre><code> sin(90.to-radians(Degrees));</code></pre>

<p>Alternatively, you can use the <code>trigbase</code> pragma to install a new set of trigonometric functions into the current lexical scope, which will handle a different unit:</p>

<pre><code> use trigbase Degrees;
 sin(90)</code></pre>

<p>The parameter to the trigbase pragma must be something that is usable as a number. The above code fragment is more or less equivalent to:</p>

<pre><code> constant $?TRIGBASE = Degrees;
 sub sin($x) { CORE::sin($x * Degrees) }
 # repeat for all the other trig operators
 sin(90)</code></pre>

<p>Two points must be emphasized. First, <code>trigbase</code> has no effect on the method forms of trig operators; <code>.sin</code> always expects radians. Second, because it defines dozens of subs, it&#39;s probably a good idea to use <code>trigbase</code> in the highest scope where it makes sense.</p>

<p>The <code>$?TRIGBASE</code> constant is not used by the trig operators themselves. It exists only to allow modules to be <code>trigbase</code> aware.</p>

<dt><a name="atan2"
>atan2</a></dt>

<dd>
<pre><code> multi method atan2 ( Real $y: Real $x = 1, TrigBase $base = CALLER::&#60;$?TRIGBASE&#62; --&#62; Real )
 multi atan2 ( Real $y, Real $x = 1, TrigBase $base = CALLER::&#60;$?TRIGBASE&#62; --&#62; Real )</code></pre>

<p>This second form of <code>atan</code> computes the arctangent of <code>$y/$x</code>, and takes the quadrant into account. Otherwise behaves as other trigonometric functions.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Int"
>Int</a></h2>

<p>An <code>Int</code> is an immutable, integral number of arbitrary size.</p>

<dl>
<dt><a name="expmod"
>expmod</a></dt>

<dd>
<pre><code> multi method expmod ( Int $x: Int $y, Int $mod --&#62; Int ) is export</code></pre>

<p>Returns <code>$x</code> raised to the <code>$y</code> power within modulus <code>$mod</code>.</p>

<dt><a name="is-prime"
>is-prime</a></dt>

<dd>
<pre><code> multi method is-prime ( Int $x: Int $tries = 100) is export</code></pre>

<p>Returns True if <code>$x</code> is known to be a prime, or is likely to be a prime based on a probabalistic Miller-Rabin test. (The optional argument tells how many times to iterate the probabalistic test, if such is necessary.)</p>

<p>Returns False if <code>$x</code> is known not to be a prime.</p>

<dt><a name="lsb"
>lsb</a></dt>

<dd>
<pre><code> multi method lsb ( Int $x: ) is export</code></pre>

<p>Returns the least significant bit position containing a 1 bit, counting bit positions from least significant to most significant. (In other words, it&#39;s the base 2 logarithm of number represented by that 1 bit.)</p>

<p>This function returns <code>Nil</code> on a 0 value, since there are no bits set. Negative integers are treated as 2&#39;s complement, so always have a lowest bit set somewhere, if only the sign bit. Hence, a -32768 returns an lsb of 15 regardless of whether it&#39;s stored in an <code>int16</code> or an <code>Int</code>.</p>

<dt><a name="msb"
>msb</a></dt>

<dd>
<pre><code> multi method msb ( Int $x: ) is export</code></pre>

<p>Returns the most significant bit position containing a 1 bit, that is, the base 2 logarithm of the top 1 bit.</p>

<p>This function returns <code>Nil</code> on a 0 value. For negative values, the function is dependent on the type. For native types, signed integers are treated as unsigned, so a negative number stored in <code>int64</code> will always return 63. Negative integers stored in an <code>Int</code> notionally have an infinite number of 1 bits on top, which is a problem. Instead of returning <code>+Inf</code>, which is relatively useless, we return the position of the first of that infinite supply of sign bits. So <code>msb(-1)</code> returns 0, <code>msb(-2)</code> returns 1, and <code>msb(-32768)</code> returns 15, just as if we&#39;d converted it from <code>int16</code> to <code>uint16</code> and examined that for its top bit.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Rat"
>Rat</a></h2>

<pre><code>class Rat does Real;</code></pre>

<p>An immutable rational number, represented by two <code>Int</code>s, a numerator and a denominator. All interface methods return values as if the numerator and denominator were stored in a normal form: both numerator and denominator are minimal in their magnitude, and the denominator is positive. So <code>Rat.new(2, -4).denominator</code> return <code>2</code>, because the normal form is <code>-1/2</code>.</p>

<p>(An implementation is allowed to be lazy about this internally when it determines that normalizing repeatedly is detrimental to performance, such as when adding a column of numbers that all have an internal denominator of 100.)</p>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code>multi method new(Int $num, Int $denom)</code></pre>

<p>Constructs a <code>Rat</code> object from the numerator and denominator. Fails if <code>$denom == 0</code>. You can use division to produce a <code>Rat</code> through constant folding, but generally if you know the values in advance, you should use one of literal forms so that you don&#39;t have to rely on precedence. You may use the <code>val()</code>-based <code>&#60;3/5&#62;</code> form, or you can simply write decimal numbers with a decimal point, since <code>12.34</code> is essentially identical to <code>&#60;1234/100&#62;</code> as a literal.</p>

<dt><a name="nude"
>nude</a></dt>

<dd>
<pre><code>multi method nude( --&#62; Parcel[Int] )</code></pre>

<p>Returns a <code>Parcel</code> of numerator and denominator.</p>

<dt><a name="denominator"
>denominator</a></dt>

<dd>
<pre><code>multi method denominator( --&#62; Int )</code></pre>

<p>Returns the denominator.</p>

<dt><a name="numerator"
>numerator</a></dt>

<dd>
<pre><code>multi method numerator( --&#62; Int )</code></pre>

<p>Returns the numerator.</p>

<dt><a name="gist"
>gist</a></dt>

<dd>
<pre><code>multi method gist( --&#62; Str )</code></pre>

<p>Returns a string representation of the number in decimal. If the number can be represented exactly in decimal, it will be. In any case, the portion before the decimal point (the &#34;integer&#34; part) is guaranteed to be exact. The precision of the fractional part is defined to be one more digit than the size of the denominator after the integer part has been removed, but at least 6 digits for repeating fractions. The final digit of the fractional part is rounded.</p>

<p><code>Str</code> coercion is identical to <code>gist</code>.</p>

<dt><a name="perl"
>perl</a></dt>

<dd>
<pre><code>multi method perl( --&#62; Str )</code></pre>

<p>Returns a string representation corresponding to the unambiguous <code>val()</code>-based representation of rational literals. If the number can be represented exactly in decimal, it will be. Otherwise uses the form &#34;<code>&#60;3/5&#62;</code>&#34;, without internal spaces, and including the angles that keep the <code>/</code> from being treated as a normal division operator.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Additions"
>Additions</a></h1>

<p>Please post errors and feedback to perl6-language. If you are making a general laundry list, please separate messages by topic.</p>

<!-- end doc -->

</body></html>
