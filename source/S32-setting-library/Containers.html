<!DOCTYPE html>
<html lang="ja">
<head>
<title>Containers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Aug 30 10:16:52 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Function_Roles'>Function Roles</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Positional'>Positional</a>
    <li class='indexItem indexItem2'><a href='#Associative'>Associative</a>
    <li class='indexItem indexItem2'><a href='#List'>List</a>
    <li class='indexItem indexItem2'><a href='#Array'>Array</a>
    <li class='indexItem indexItem2'><a href='#Hash'>Hash</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Classes_and_Roles'>Classes and Roles</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Range'>Range</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Methods'>Methods</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Buf'>Buf</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Methods'>Methods</a>
      <li class='indexItem indexItem3'><a href='#Buf_Operators'>Buf Operators</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Enum_and_Pair'>Enum and Pair</a>
    <li class='indexItem indexItem2'><a href='#EnumMap'>EnumMap</a>
    <li class='indexItem indexItem2'><a href='#PairMap'>PairMap</a>
    <li class='indexItem indexItem2'><a href='#Set'>Set</a>
    <li class='indexItem indexItem2'><a href='#SetHash'>SetHash</a>
    <li class='indexItem indexItem2'><a href='#Bag'>Bag</a>
    <li class='indexItem indexItem2'><a href='#BagHash'>BagHash</a>
    <li class='indexItem indexItem2'><a href='#QuantHash'>QuantHash</a>
    <li class='indexItem indexItem2'><a href='#MixHash'>MixHash</a>
    <li class='indexItem indexItem2'><a href='#Junction'>Junction</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Additions'>Additions</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>DRAFT: Synopsis 32: Setting Library - Containers.pod</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Rod Adams &#60;rod@rodadams.net&#62;
Larry Wall &#60;larry@wall.org&#62;
Aaron Sherman &#60;ajs@ajs.com&#62;
Mark Stosberg &#60;mark@summersault.com&#62;
Carl M&#228;sak &#60;cmasak@gmail.com&#62;
Moritz Lenz &#60;moritz@faui2k3.org&#62;
Tim Nelson &#60;wayland@wayland.id.au&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 19 Feb 2009 extracted from S29-functions.pod

Last Modified: 24 Feb 2014
Version: 47</code></pre>

<p>If you read the HTML version, it is generated from the Pod in the specs repository under <a href="https://github.com/perl6/specs/blob/master/S32-setting-library/Containers.pod" class="podlinkurl"
>https://github.com/perl6/specs/blob/master/S32-setting-library/Containers.pod</a> so edit it there in the git repository if you would like to make changes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Function_Roles"
>Function Roles</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Positional"
>Positional</a></h2>

<pre><code>role Positional {...}</code></pre>

<p>The <code>Positional</code> role implies the ability to support <code>postcircumfix:&#60;[ ]&#62;</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Associative"
>Associative</a></h2>

<pre><code>role Associative {...}</code></pre>

<p>The <code>Associative</code> role implies the ability to support <code>postcircumfix:&#60;{ }&#62;</code>.</p>

<dl>
<dt><a name="cat"
>cat</a></dt>

<dd>
<pre><code> multi cat( **@list --&#62; Cat )</code></pre>

<p><code>cat</code> reads arrays serially rather than in parallel as <code>zip</code> does. It returns all of the elements of the containers that were passed to it like so:</p>

<pre><code> cat(@a;@b;@c);</code></pre>

<p>Typically, you could just write <code>(@a,@b,@c)</code>, but sometimes it&#39;s nice to be explicit about that:</p>

<pre><code> @foo := [[1,2,3],[4,5,6]]; say cat(||@foo); # 1,2,3,4,5,6</code></pre>

<p>In addition, a <code>Cat</code> in item context emulates the <code>Str</code> interface lazily.</p>

<p>[Conjecture: Cats should maybe just do the lazy strings, and leave flattening to other operators.]</p>

<dt><a name="roundrobin"
>roundrobin</a></dt>

<dd>
<pre><code> multi roundrobin( **@list --&#62; Parcel )</code></pre>

<p><code>roundrobin</code> is very similar to <code>zip</code>. The difference is that <code>roundrobin</code> will not stop on lists that run out of elements but simply skip any undefined value:</p>

<pre><code> my @a = 1;
 my @b = 1..2;
 my @c = 1..3;
 for roundrobin( @a; @b; @c ) -&#62; $x { ... }</code></pre>

<p>will get the following values for <code>$x</code>: <code>1, 1, 1, 2, 2, 3</code></p>

<dt><a name="zip"
>zip</a></dt>

<dd>
<pre><code> multi zip ( **@list --&#62; Parcel of Parcel )
 multi infix:&#60;Z&#62; ( **@list --&#62; Parcel of Parcel )</code></pre>

<p>zip takes any number of arrays and returns one tuple for every index. This is easier to read in an example:</p>

<pre><code> for zip(@a;@b;@c) -&#62; $nth_a, $nth_b, $nth_c {
   ...
 }</code></pre>

<p>Mnemonic: the input arrays are &#34;zipped&#34; up like a zipper.</p>

<p>The <code>zip</code> function defaults to stopping as soon as any of its lists is exhausted. This behavior may be modified by conceptually extending any short list using <code>*</code>, which replicates the final element.</p>

<p>If all lists are potentially infinite, an evaluation in <code>eager</code> context will automatically fail as soon as it can be known that all sublists in the control of iterators of infinite extent, such as indefinite ranges or arbitrary replication. If it can be known at compile time, a compile-time error results.</p>

<p><code>Z</code> is an infix equivalent for zip:</p>

<pre><code> for @a Z @b Z @c -&#62; $a, $b, $c {...}</code></pre>

<p>In lol context a list of <code>List</code> is returned instead of a flat list.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="List"
>List</a></h2>

<p>The following are defined in the <code>List</code> class:</p>

<pre><code>class List does Positional {...}</code></pre>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code> multi method new(*@args --&#62; List )</code></pre>

<p>Constructs an <code>List</code> that can visit all iterable elements of all the arguments.</p>

<dt><a name="list"
>list</a></dt>

<dd>
<pre><code> sub list(*@args --&#62; List )</code></pre>

<p>Constructs a <code>List</code> that can visit all iterable elements of all the arguments.</p>

<dt><a name="cat"
>cat</a></dt>

<dd>
<pre><code> multi cat ( @values --&#62; Cat )</code></pre>

<p>Returns a <code>Cat</code> object, a concatenated version of the list that does the <code>Str</code> interface, but generates the string lazily to the extent permitted by the pattern of access to the string. Its two primary uses are matching against an array of strings and doing the equivalent of a <code>join(&#39;&#39;)</code>, except that <code>join</code> is always eager. However, a <code>Cat</code> in an interpolative context is also effectively eager, since the interpolator needs to know the string length. List context is lazy, though, so a <code>cat</code> of a <code>cat</code> is also lazy, and in fact, you just get a flat cat because <code>cat</code> in a list context is a no-op. The <code>Cat</code> interface also lets you interrogate the object at a particular string position without actually stringifying the element; the regex engine can make use of this to match a tree node, for instance, without serializing the entire subtree.</p>

<p>Accessing a filehandle as both a filehandle and as a <code>Cat</code> is undefined, because lazy objects are not required to be as lazy as possible, but may instead choose to precalculate values in semi-eager batches to maximize cache hits.</p>

<dt><a name="classify"
>classify</a></dt>

<dd>
<pre><code> multi method classify ( @values: &#38;mapper --&#62; Hash )
 multi method classify ( @values: %mapper --&#62; Hash )
 multi method classify ( @values: @mapper --&#62; Hash )
 multi classify ( &#38;mapper, *@values --&#62; Hash )
 multi classify ( %mapper, *@values --&#62; Hash )
 multi classify ( @mapper, *@values --&#62; Hash )</code></pre>

<p><code>classify</code> transforms a finite list or array of values into a hash representing the classification of those values according to a mapper; each hash key represents the classification for one or more of the incoming list values, and the corresponding hash value contains an array of those list values classified by the mapper into the category of the associated key. For example:</p>

<pre><code>  @list = (1, 2, 3, 4);
  (:@even, :@odd) := @list.classify: { $_ % 2 ?? &#39;odd&#39; !! &#39;even&#39; };
  (:@even, :@odd) := classify { $_ % 2 ?? &#39;odd&#39; !! &#39;even&#39; }, @list; # same</code></pre>

<p>In this example, @even will contain all even numbers from <code>@list</code> and <code>@odd</code> will contain all odd numbers from <code>@list</code>. Please note that for performance reasons, an implementation is free to <code>bind</code> values to the resulting arrays. So you should consider these arrays to be immutable.</p>

<p>To simply transform a list into a hash of arrays:</p>

<pre><code>  %cars_by_color := @cars.classify: { .color };
  %cars_by_color := classify { .color }, @cars; # same
  red_car_owners(%cars_by_color&#60;red&#62;.map:{.owner});</code></pre>

<p>A mapper may be any unary function, hash, or array. Values that have no mapping will be classified under an undefined failure key (whatever is returned by the mapper in use). [Conjecture: if a hash comes with a default value, it can map anything.]</p>

<p><code>classify</code> always assumes that the mapper returns a single value. However, this may also be a <a href="http://search.cpan.org/perldoc?Parcel" class="podlinkpod"
>Parcel</a> to indicate a multi-level classification. In such a case, only the classification of the lowest level, will actually yield a Hash of Lists. All higher up classifications, will necessarily always be a Hash of Hashes. Please note that all Parcels must have the same number of elements.</p>

<p>To categorize values into multiple categories, see <code>categorize</code>.</p>

<dt><a name="categorize"
>categorize</a></dt>

<dd>
<pre><code> multi method categorize ( @values: &#38;mapper --&#62; Hash )
 multi method categorize ( @values: %mapper --&#62; Hash )
 multi method categorize ( @values: @mapper --&#62; Hash )
 multi categorize ( &#38;mapper, *@values --&#62; Hash )
 multi categorize ( %mapper, *@values --&#62; Hash )
 multi categorize ( @mapper, *@values --&#62; Hash )</code></pre>

<p>Like <code>classify</code>, <code>categorize</code> transforms a finite list or array of values into a hash representing the categorizations of those values according to a mapper; each hash key represents one possible categorization for one or more of the incoming list values, and the corresponding hash value contains an array of those list values categorized by the mapper into the category of the associated key. Please note that for performance reasons, an implementation is free to <code>bind</code> values to the resulting arrays. So you should consider these arrays to be immutable.</p>

<p>Unlike <code>classify</code>, <code>categorize</code> always assumes that the return value of the mapper is a list of categories that are appropriate to the current value. Hence, if the mapper returns <code>()</code>, the value is discarded rather than being stored under any key. On the other hand, if the mapper returns a list of categories, the value in question will be pushed into multiple hash locations (while <code>classify</code> would merely make a key out of the list returned from the mapper). However, a category may also be a <a href="http://search.cpan.org/perldoc?Parcel" class="podlinkpod"
>Parcel</a> to indicate a multi-level categorization. In such a case, only the categorization of the lowest level, will actually yield a Hash of Lists. All higher up categorizations, will necessarily always be a Hash of Hashes. Please note that all Parcels must have the same number of elements.</p>

<dt><a name="grep"
>grep</a></dt>

<dd>
<pre><code> multi method grep ( @values: Matcher $test --&#62; List )
 multi grep ( Matcher $test, *@values --&#62; List )</code></pre>

<p><code>grep</code> takes a list or array of values and returns a lazily evaluated list comprised of all of the values from the original list for which the <code>$test</code> smart-matches as true.</p>

<p>Here is an example of its use:</p>

<pre><code> @friends = @coworkers.grep: { .is_friend };
 @friends = grep { .is_friend }, @coworkers; # same</code></pre>

<p>This takes the array <code>@coworkers</code>, checks every element to see which ones return true for the <code>.is_friend</code> method, and returns the resulting list to store into <code>@friends</code>.</p>

<p>Note that, unlike in Perl 5, a comma is required after the <code>Matcher</code> in the multi form.</p>

<p>Note that <code>grep</code> is an implicit loop, so <code>next</code> and <code>last</code> without an argument will iterate or terminate the <code>grep</code> itself, not some loop surrounding the statement containing the <code>grep</code>. Use a label if you mean the other thing.</p>

<dt><a name="grep-index"
>grep-index</a></dt>

<dd>
<pre><code> multi method grep-index ( @values: Matcher $test --&#62; List )
 multi grep-index ( Matcher $test, *@values --&#62; List )</code></pre>

<p>Like <code>grep</code>, but returns a lazy list of ordinal numbers of the matching values, or <code>Nil</code> if not found.</p>

<dt><a name="first"
>first</a></dt>

<dd>
<pre><code> multi method first ( @values: Matcher $test --&#62; Parcel )
 multi first ( Matcher $test, *@values --&#62; Parcel )</code></pre>

<p><code>first</code> searches exactly like <code>grep</code> but returns only the first matching value, or <code>Nil</code> if not found.</p>

<dt><a name="first-index"
>first-index</a></dt>

<dd>
<pre><code> multi method first-index ( @values: Matcher $test --&#62; Parcel )
 multi first-index ( Matcher $test, *@values --&#62; Parcel )</code></pre>

<p>Like <code>first</code>, but returns the ordinal number of the first matching value, or <code>Nil</code> if not found.</p>

<dt><a name="last-index"
>last-index</a></dt>

<dd>
<pre><code> multi method last-index ( @values: Matcher $test --&#62; Parcel )
 multi last-index ( Matcher $test, *@values --&#62; Parcel )</code></pre>

<p>Like <code>first-index</code>, but starts checking from the end of the <code>List</code>. Returns the ordinal number of the first matching value (counted from the beginning, just as <code>first-index</code>), or <code>Nil</code> if not found.</p>

<dt><a name="pick"
>pick</a></dt>

<dd>
<pre><code> multi method pick ( @values: Int $num = 1 --&#62; Any )
 multi method pick ( @values: Whatever --&#62; Any )
 multi pick ( Int $num, *@values --&#62; Any )
 multi pick ( Whatever, *@values --&#62; Any )</code></pre>

<p><code>pick</code> takes a list or array of values and returns a random selection of elements from the list (without replacement; see <code>roll</code> for dice roll aka replacement semantics). If <code>*</code> is specified as the number (or if the number of elements in the list is less than the specified number), all the available elements are returned in random order:</p>

<pre><code>@team = @volunteers.pick(5);
@shuffled = @deck.pick(*);</code></pre>

<p>Due to the normal semantics of returning a <code>Parcel</code>, a pick of a single element may be used as an item without requiring <code>.[0]</code>.</p>

<dt><a name="roll"
>roll</a></dt>

<dd>
<pre><code> multi method roll ( @values: Int $num = 1 --&#62; Any )
 multi method roll ( @values: Whatever --&#62; Any )
 multi roll ( Int $num, *@values --&#62; Any )
 multi roll ( Whatever, *@values --&#62; Any )</code></pre>

<p><code>roll</code> takes a list or array of values and returns a random selection of elements from the list, like rolling N independent dice, where each list element corresponds to one side of your dice. This is also known as &#34;pick with replacement&#34;, that is, like pulling one marble out of bag and putting it back, and doing this N times; see <code>pick</code> for the non-replacement semantics. If <code>*</code> is specified as the number, <code>*</code> provides an infinite list of random choices from <code>@values</code>:</p>

<pre><code>@byte = (0,1).roll(8);                   # 8d2
for (1..20).roll(*) -&#62; $die_roll { ... } # 1d20 xx *</code></pre>

<p>Due to the normal semantics of returning a <code>Parcel</code>, a roll of a single element may be used as an item without requiring <code>.[0]</code>.</p>

<p>Note that <code>roll 1, 6</code> is not the same as a 1d6, but always returns <code>6</code> as a degenerate one-sided die. Use <code>roll 1, 1..6</code> to simulate a six-sided die.</p>

<dt><a name="join"
>join</a></dt>

<dd>
<pre><code> multi method join ( @values: Str $separator = &#39;&#39; --&#62; Str )
 multi join ( Str $separator = &#39;&#39;, *@values --&#62; Str )</code></pre>

<p><code>join</code> returns a single string comprised of all of the elements of <code>@values</code>, separated by <code>$separator</code>.</p>

<p>Given an empty list, <code>join</code> returns the empty string.</p>

<p>The separator defaults to the null string. To join with space, just coerce to <code>Str</code>.</p>

<dt><a name="map"
>map</a></dt>

<dd>
<pre><code> multi method map ( @values: Code *&#38;expression --&#62; List of Parcel )
 multi map ( Code $expression, *@values --&#62; List of Parcel )
 multi map ( Code $expression --&#62; List of Parcel )</code></pre>

<p><code>map</code> returns a lazily evaluated list which is comprised of the return value of the expression, evaluated once for every one of the <code>@values</code> that are passed in.</p>

<p>If the expression returns no values or multiple values, then the resulting list may not be the same length as the number of values that were passed.</p>

<p>The actual return value is a multislice containing one slice per map iteration. In most contexts these slices are flattened into a single list.</p>

<p>Note that <code>map</code> is an implicit loop, so <code>next</code> and <code>last</code> without an argument will iterate or terminate the <code>map</code> itself, not some loop surrounding the statement containing the <code>map</code>. Use a label if you mean the other thing.</p>

<p>In some situations, specifically with concurrent processes, the return values of a <code>map</code> may not directly relate to a list of values: in that case it is possible to specify a map with just a <code>Whatever</code>:</p>

<pre><code>  map {                    # actual implementation of Channel.list
  winner $self {
      more * { $_ }
      done * { last }
  }
  }, *;</code></pre>

<p>This effectively becomes a lazy loop returning values until it is exited with <code>last</code>. This may be a cheaper alternative to a <code>gather</code>, <code>loop</code>, <code>take</code> setup.</p>

<dt><a name="duckmap"
>duckmap</a></dt>

<dd>
<pre><code> multi method duckmap ( @values: Code *&#38;expression --&#62; List of Parcel )
 multi duckmap ( Code $expression, *@values --&#62; List of Parcel )</code></pre>

<p>Like <code>map</code>, <code>duckmap</code> evaluates the expression for each of the values that is passed in. Unlike <code>map</code>, if the evaluation produces an undefined value, a failover looks to see if this element actually contains subelements, and if so, reapplies the duckmap recursively, returning the structured result for that element, so that the structure of the original is (largely) retained in the result. Unlike <code>deepmap</code>, it does not guarantee the same structure, since the mapping expression takes precedence over structure in cases where either would succeed.</p>

<p>Because <code>duckmap</code> is defined as a recursive implicit loop, loop controls apply only to the current level of the tree.</p>

<dt><a name="deepmap"
>deepmap</a></dt>

<dd>
<pre><code> multi method deepmap ( @values: Code *&#38;expression --&#62; List of Parcel )
 multi deepmap ( Code $expression, *@values --&#62; List of Parcel )</code></pre>

<p>Like <code>map</code> and <code>duckmap</code>, <code>deepmap</code> evaluates the expression for each of the values you give it. Unlike <code>map</code> and <code>duckmap</code>, an element is considered a value only if it does not do the <code>Iterable</code> role. If the element is iterable, the algorithm recurses to produce an identical structure to its input. Elements that are not iterable are considered leaf values and mapped through the supplied expression.</p>

<p>Because <code>deepmap</code> is defined as a recursive implicit loop, loop controls apply only to the current level of the tree.</p>

<dt><a name="reduce"
>reduce</a></dt>

<dd>
<pre><code> multi method reduce ( @values: Code *&#38;expression --&#62; Item )
 multi reduce ( Code $expression ;; *@values --&#62; Item ) {
   my $res;
   for @values -&#62; $cur {
 FIRST {$res = $cur; next;}
 $res = &#38;$expression($res, $cur);
   }
   $res;
 }</code></pre>

<p>Note that <code>reduce</code> is an implicit loop, so <code>next</code> and <code>last</code> without an argument will iterate or terminate the <code>reduce</code> itself, not some loop surrounding the statement containing the <code>reduce</code>. Use a label if you mean the other thing.</p>

<dt><a name="reverse"
>reverse</a></dt>

<dd>
<pre><code> multi method reverse ( @values: --&#62; List ) is export
 multi reverse ( *@values --&#62; List ) {
gather {
    1 while take pop @values;
}
 }</code></pre>

<p>Note that strings are now reversed with <code>flip</code>.</p>

<dt><a name="rotate"
>rotate</a></dt>

<dd>
<pre><code> multi method rotate ( @values is copy: Int $n = 1 --&#62; List ) is export</code></pre>

<p>Produces a new list with the same elements as the old list, rotated by the specified amount. See Array::rotate for more info.</p>

<dt><a name="sort"
>sort</a></dt>

<dd>
<pre><code> multi method sort( @values: *&#38;by --&#62; Array )
 multi method sort( @values: Ordering @by --&#62; Array )
 multi method sort( @values: Ordering $by = &#38;infix:&#60;cmp&#62; --&#62; Array )

 multi sort( Ordering @by,  *@values --&#62; List )
 multi sort( Ordering $by, *@values --&#62; List )</code></pre>

<p>Returns <code>@values</code> sorted, using criteria <code>$by</code> or <code>@by</code> for comparisons. <code>@by</code> differs from <code>$by</code> in that each criterion is applied, in order, until a non-zero (tie) result is achieved.</p>

<p>If <code>$by</code> is a code object of arity zero or one, it is applied on each item of <code>@values</code>, and <code>@values</code> is sorted by comparing the result values with <code>&#38;infix:&#60;cmp&#62;</code> (Schwartzian Transform).</p>

<p><code>Ordering</code> is as described in <a href="http://search.cpan.org/perldoc?S29#Type_Declarations" class="podlinkpod"
>&#34;Type Declarations&#34; in S29</a>. Any <code>Ordering</code> may receive either or both of the mixins <code>descending</code> and <code>canon(Code $how)</code> to reverse the order of sort, or to adjust the case, sign, or other order sensitivity of <code>cmp</code>. (Mixins are applied to values using <code>but</code>.) If a <code>Signature</code> is used as an <code>Ordering</code> then sort-specific traits such as <code>is canon($how)</code> are allowed on the positional elements.</p>

<p>If all criteria are exhausted when comparing two elements, sort should return them in the same relative order they had in <code>@values</code>.</p>

<p>To sort an array in place use the <code>.=sort</code> mutator form.</p>

<p>See <a href="http://www.nntp.perl.org/group/perl.perl6.language/16578" class="podlinkurl"
>http://www.nntp.perl.org/group/perl.perl6.language/16578</a> for more details and examples (with <code>is insensitive</code> meaning <code>is canonicalized(&#38;lc)</code>.)</p>

<dt><a name="uniq"
>uniq</a></dt>

<dd>
<pre><code> multi method uniq(List:D: --&#62; List:D, :&#38;as)

 multi sub uniq(*@values --&#62; List:D, :&#38;as)</code></pre>

<p>Returns a list of unique values from the invocant/argument list, such that only the first occurrence of each duplicated value remains in the result list. <code>uniq</code> uses <code>&#38;infix:&#60;===&#62;</code> semantics to compare whether two objects are the same. The order of the original list is preserved even as duplicates are removed.</p>

<pre><code>say &#60;a a b b b c c&#62;.uniq    # a b c
say &#60;a b b c c b a&#62;.uniq    # a b c</code></pre>

<p>(Use <code>squish</code> instead if you know the input is sorted such that identical objects are adjacent.)</p>

<p>The optional <code>:as</code> parameter allows you to normalize/canonicalize the elements before uniq-ing. The values are transformed for the purposes of comparison, but it&#39;s still the original values that make it to the result list:</p>

<pre><code>say &#60;a A B b c b C&#62;.uniq(:as(&#38;lc))          # a B c</code></pre>

<p>This makes it possible to effectively compare with other comparison operators, too. For example, if you want to compare with <code> infix:&#60;==</code> &#62; semantics, this might work for you:</p>

<pre><code>say +uniq [100, 100e0, 200/2], :as(*.Num)   # 1</code></pre>

<dt><a name="squish"
>squish</a></dt>

<dd>
<pre><code> multi method squish(List:D: --&#62; List:D, :&#38;as)

 multi sub squish(*@values --&#62; List:D, :&#38;as)</code></pre>

<p>Returns a list of values from the invocant/argument list where runs of more than one value are replaced with only the first instance. Like <code>uniq</code>, <code>squish</code> uses <code>&#38;infix:&#60;===&#62;</code> semantics to compare whether two objects are the same. Unlike <code>uniq</code>, this function only removes adjacent duplicates; identical values further apart are still kept. The order of the original list is preserved even as duplicates are removed.</p>

<pre><code>say &#60;a a b b b c c&#62;.squish  # a b c
say &#60;a b b c c b a&#62;.squish  # a b c b a</code></pre>

<p>The optional <code> :as </code> parameter, just like with <code> uniq </code>, allows values to be temporarily transformed before comparison.</p>

<dt><a name="min"
>min</a></dt>

<dd>
<pre><code> multi method min( @values: *&#38;by --&#62; Any )
 multi method min( @values: Ordering @by --&#62; Any )
 multi method min( @values: Ordering $by = &#38;infix:&#60;cmp&#62; --&#62; Any )

 multi min( *@values, Ordering :@by --&#62; Any )
 multi min( *@values, Ordering :$by --&#62; Any )</code></pre>

<p>Returns the earliest (i.e., lowest index) minimum element of <code>@values</code> , using criteria <code>$by</code> or <code>@by</code> for comparisons. <code>@by</code> differs from <code>$by</code> in that each criterion is applied, in order, until a non-zero (tie) result is achieved.</p>

<p><code>Ordering</code> is as described in <a href="http://search.cpan.org/perldoc?S29#Type_Declarations" class="podlinkpod"
>&#34;Type Declarations&#34; in S29</a>. Any <code>Ordering</code> may receive the mixin <code>canonicalized(Code $how)</code> to adjust the case, sign, or other order sensitivity of <code>cmp</code>. (Mixins are applied to values using <code>but</code>.) If a <code>Signature</code> is used as an <code>Ordering</code> then sort-specific traits such as <code>is canonicalized($how)</code> are allowed on the positional elements.</p>

<p>For a <code>min</code> function that does not require an ordering, see the <code>[min]</code> reduction operator.</p>

<dt><a name="max"
>max</a></dt>

<dd>
<pre><code> multi method max( @values: *&#38;by --&#62; Any )
 multi method max( @values: Ordering @by --&#62; Any )
 multi method max( @values: Ordering $by = &#38;infix:&#60;cmp&#62; --&#62; Any )

 multi max(*@values, Ordering :@by, --&#62; Any )
 multi max(*@values, Ordering :$by, --&#62; Any )</code></pre>

<p>Returns the earliest (i.e., lowest index) maximum element of <code>@values</code> , using criteria <code>$by</code> or <code>@by</code> for comparisons. <code>@by</code> differs from <code>$by</code> in that each criterion is applied, in order, until a non-zero (tie) result is achieved.</p>

<p><code>Ordering</code> is as described in <a href="http://search.cpan.org/perldoc?S29#Type_Declarations" class="podlinkpod"
>&#34;Type Declarations&#34; in S29</a>. Any <code>Ordering</code> may receive the mixin <code>canonicalized(Code $how)</code> to adjust the case, sign, or other order sensitivity of <code>cmp</code>. (Mixins are applied to values using <code>but</code>.) If a <code>Signature</code> is used as an <code>Ordering</code> then sort-specific traits such as <code>is canonicalized($how)</code> are allowed on the positional elements.</p>

<p>For a <code>max</code> function that does not require an ordering, see the <code>[max]</code> reduction operator.</p>

<dt><a name="minmax"
>minmax</a></dt>

<dd>
<pre><code> multi method minmax( @values: *&#38;by --&#62; Any )
 multi method minmax( @values: Ordering @by --&#62; Any )
 multi method minmax( @values: Ordering $by = &#38;infix:&#60;cmp&#62; --&#62; Any )

 multi minmax( *@values, Ordering :@by --&#62; Any )
 multi minmax( *@values, Ordering :$by --&#62; Any )</code></pre>

<p>Returns a <code>Range</code> from the minimum element of <code>@values</code> to the maximum element, using criteria <code>$by</code> or <code>@by</code> for comparisons. <code>@by</code> differs from <code>$by</code> in that each criterion is applied, in order, until a non-zero (tie) result is achieved. <code>Range</code> elements in <code>@values</code> are treated as if their minimum and maximum values were passed individually, except that if the corresponding <code>excludes</code> flag is set in Range, the excludes flag is also set in the returned <code>Range</code>.</p>

<p><code>Ordering</code> is as described in <a href="http://search.cpan.org/perldoc?S29#Type_Declarations" class="podlinkpod"
>&#34;Type Declarations&#34; in S29</a>. Any <code>Ordering</code> may receive the mixin <code>canonicalized(Code $how)</code> to adjust the case, sign, or other order sensitivity of <code>cmp</code>. (Mixins are applied to values using <code>but</code>.) If a <code>Signature</code> is used as an <code>Ordering</code> then sort-specific traits such as <code>is canonicalized($how)</code> are allowed on the positional elements.</p>

<p>For a <code>minmax</code> function that does not require an ordering, see the <code>[minmax]</code> reduction operator.</p>

<dt><a name="any"
>any</a></dt>

<dd>
<pre><code> multi method any( @values: --&#62; Junction )
 multi any( *@values --&#62; Junction ) is export</code></pre>

<p>Returns a junction with all the values of the list <code>|</code>-ed together. The junction will only match against another value if at least one of the values in the list matches.</p>

<dt><a name="all"
>all</a></dt>

<dd>
<pre><code> multi method all( @values: --&#62; Junction )
 multi all( *@values --&#62; Junction ) is export</code></pre>

<p>Returns a junction with all the values of the list <code>&#38;</code>-ed together. The junction will only match against another value if all of the values in the list match.</p>

<dt><a name="one"
>one</a></dt>

<dd>
<pre><code> multi method one( @values: --&#62; Junction )
 multi one( *@values --&#62; Junction ) is export</code></pre>

<p>Returns a junction with all the values of the list <code>^</code>-ed together. The junction will only match against another value if exactly one of the values in the list matches.</p>

<dt><a name="none"
>none</a></dt>

<dd>
<pre><code> multi method none( @values: --&#62; Junction )
 multi none( *@values --&#62; Junction ) is export</code></pre>

<p>Returns a junction which will only match against another value if none of the values in the list matches.</p>

<dt><a name="comb"
>comb</a></dt>

<dd>
<pre><code> multi method comb ( Regex $matcher, Int $limit = * )</code></pre>

<p>Treats the list as a string (by simply <code>join</code>ing them together), and calls <code>.comb</code> on that string with the same parameters. See <code>Str::comb</code>.</p>

<dt><a name="combinations"
>combinations</a></dt>

<dd>
<pre><code> multi method combinations ( Int $of )
 multi method combinations ( Range $of = 0 .. * )
 multi combinations ( $n, $k )</code></pre>

<p>Returns all combinations of the list taken N at a time (specified by the <code>$of</code> parameter). If the range option is taken, then the range is iterated, and for each integer N in the range, appends all combinations taken N at a time to the resulting list. If the max of the range is greater than the size of the list, iteration stops at the size of the list. Hence, if the default of <code>0..*</code> is taken, the first return value will be an empty array, and the final return value will be an array containing every value in the list. The return value is a list of (presumably immutable) array values. (Note: When used on actual sets and other iterable structures, specialized versions of this method are allowed to bypass turning it into a list first. Also, the return values are allowed to be specialized to any non-flattening container, so that subsets of sets can actually be a set of sets. If the ordering of the input doesn&#39;t matter, neither does the ordering of the subsets.)</p>

<p>Note that, without an argument, the first returned combination will always be the empty list, and the last combination will always be the entire list.</p>

<p>It is erroneous to ask for the combinations of any infinite list. The compiler is allowed to complain if it notices, however.</p>

<p>The functional form assumes it is working on a list of integers <code>^$n</code> taken <code>$k</code> at a time.</p>

<dt><a name="permutations"
>permutations</a></dt>

<dd>
<pre><code> multi method permutations ( )
 multi permutations ( $n )</code></pre>

<p>Permutes the values of the list, returning the permutations as a list of (presumably immutable) array values. (Types such as <code>Range</code> are converted to a list of individual values before permuting them.)</p>

<p>The functional form assumes it is working on a list of integers <code>^$n</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Array"
>Array</a></h2>

<p>All these methods are defined in the <code>Array</code> role/class.</p>

<pre><code>role Array does List {...}</code></pre>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code> multi method new(*@args --&#62; Array )</code></pre>

<p>Constructs a new <code>Array</code> containing the arguments passed to <code>new</code>.</p>

<dt><a name="shape"
>shape</a></dt>

<dd>
<pre><code> method shape (@array: --&#62; Parcel ) is export</code></pre>

<p>Returns the declared shape of the array, as described in S09.</p>

<dt><a name="end"
>end</a></dt>

<dd>
<pre><code> method end (@array: --&#62; Any ) is export</code></pre>

<p>Returns the final subscript of the first dimension; for a one-dimensional array this simply the index of the final element. For fixed dimensions this is the declared maximum subscript. For non-fixed dimensions (undeclared or explicitly declared with <code>*</code>), the index of the actual last element is used. So that the degenerate case of an empty range works correctly, <code>-1</code> is returned if the array is empty. (If you actually try to index with <code>-1</code>, you&#39;ll get a failure.)</p>

<dt><a name="elems"
>elems</a></dt>

<dd>
<pre><code> method elems (@array: --&#62; Int ) is export</code></pre>

<p>Returns the length of the array counted in elements.</p>

<dt><a name="delete_(DEPRECATED)"
>delete (DEPRECATED)</a></dt>

<dd>
<p>The &#34;delete&#34; method is considered to be a deprecated internal method: the normal way to mark an element as deleted, is to apply the <code>:delete</code> adverb to a subscripting operation.</p>

<dt><a name=":delete"
>:delete</a></dt>

<dd>
<p>This adverb may be applied to any subscripting operation. The operation returns the elements normally, but reads them out destructively.</p>

<dt><a name="exists_(DEPRECATED)"
>exists (DEPRECATED)</a></dt>

<dd>
<p>The &#34;exists&#34; method is considered to be a deprecated internal method: the normal way to test for existence is to apply the <code>:exists</code> adverb to a subscripting operation.</p>

<dt><a name=":exists"
>:exists</a></dt>

<dd>
<p>This adverb may be applied to any subscripting operation. The operation returns true if specified element exists. If a slice is specified by the subscript, a <code>Parcel</code> of <code>Bool</code> is returned, which can be processed using junctions.</p>

<dt><a name="pop"
>pop</a></dt>

<dd>
<pre><code> multi method pop ( @array: --&#62; Scalar ) is export</code></pre>

<p>Remove the last element of <code>@array</code> and return it. If <code>@array</code> is empty returns a failure.</p>

<dt><a name="push"
>push</a></dt>

<dd>
<pre><code> multi method push ( @array: *@values --&#62; Array ) is export</code></pre>

<p>Adds all the values to the end of <code>@array</code> eagerly. Returns the modified array.</p>

<dt><a name="plan"
>plan</a></dt>

<dd>
<pre><code> multi method plan ( @array: *@list --&#62; Array ) is export</code></pre>

<p>Adds the list to the end of <code>@array</code> lazily as a kind of &#34;lazy push&#34;. (That is, the reified part of the array is not modified, but the list is appended to the not-yet-reified specifications for how to extend the array on demand, if it is subscripted or shifted beyond the currently reified elements.) Returns the modified array.</p>

<p>Note that the semantics of these are different:</p>

<pre><code>@ro := (0,1,*+*...*);
@rw.plan(0,1,*+*...*);</code></pre>

<p>In the first case, <code>@ro</code> is bound directly to the list, so its values are memoized but not considered mutable. In contrast, <code>@rw</code> allows modification of any reified element; new elements are merely initialized to the fibonacci sequence. If you try to modify a non-reified element, the array will be reified to that point before the modification is attempted.</p>

<p>For all external purposes, the array considers that its plan is part of the array. If you ask for <code>.elems</code>, for instance, it will try to reify the entire array, which might take a long time in the case of infinite arrays (though a list may return <code>Inf</code> if it can determine this). Methods such as <code>.splice</code> can refer to the rest of the list in the abstract, and need only reify those elements necessary to perform the operation in question. (Hence, there is no need for an <code>.unplan</code> method, since the plan of an array may be thrown away by using <code>splice</code> without the risk of memory exhaustion.)</p>

<dt><a name="rotate"
>rotate</a></dt>

<dd>
<pre><code> multi method rotate ( @array is copy: Int $n = 1, Int *@n --&#62; Array ) is export</code></pre>

<p>Produces a new array with the same elements as the old array, rotated by the specified amount. A positive rotation of 1 is defined as:</p>

<pre><code>@array.push(@array.shift);</code></pre>

<p>A negative rotation of 1 is defined as:</p>

<pre><code>@array.unshift(@array.pop);</code></pre>

<p>If the magnitude of <code>$n</code> is larger than the number of elements, the rotational semantics must be equivalent to doing:</p>

<pre><code>@array.rotate(sign($n)) for ^abs($n)</code></pre>

<p>The new array to be returned contains nothing but aliases for the old array&#39;s elements; however, you can use this to get any of three different semantic behaviors:</p>

<pre><code>@a.=rotate       # @a is rotated in place
@b = @a.rotate   # @b contains copied elements of rotated @a
@b := @a.rotate  # @b contains aliased elements of rotated @a</code></pre>

<p>If additional rotations are specified via the slurpy, they are applied to subdimensions of multidimensional arrays. (To perform a flat rotation on a shaped array requires flattening to a list and rotating that instead.)</p>

<dt><a name="shift"
>shift</a></dt>

<dd>
<pre><code> multi method shift ( @array: --&#62; Scalar ) is export</code></pre>

<p>Remove the first element from <code>@array</code> and return it. If <code>@array</code> is empty returns a failure.</p>

<dt><a name="splice"
>splice</a></dt>

<dd>
<pre><code> multi method splice( @array is rw: $offset = 0, $size = Inf, *@values --&#62; Any ) is export</code></pre>

<p><code>splice</code> fills many niches in array-management, but its fundamental behavior is to remove zero or more elements from an array and replace them with a new (and potentially empty) list. This operation can shorten or lengthen the target array.</p>

<p><code>$offset</code> is the index of the array element to start with. A WhateverCode whose argument is the number of elements in the <code>@array</code> may also be used.</p>

<p><code>$size</code> is the number of elements to remove from <code>@array</code>. A WhateverCode similar to <code>$offset</code> may be used instead (note that this specifies a position, not an actual number of elements to remove).</p>

<p>The slurpy list of values (if any) is then inserted at <code>$offset</code>.</p>

<p>Calling splice with a traditional parameter list, you must define <code>$offset</code> and <code>$size</code> if you wish to pass a replacement list of values. To avoid having to pass these otherwise optional parameters, use the piping operator(s):</p>

<pre><code> splice(@array,10) &#60;== 1..*;</code></pre>

<p>which replaces <code>@array[10]</code> and all subsequent elements with an infinite sequence starting at <code>1</code>.</p>

<p>If <code>@array</code> is multidimensional, <code>splice</code> operates only on the first dimension, and works with Array References.</p>

<p><code>splice</code> returns a <code>Parcel</code> of the deleted elements, which behaves as expected in either list or item context.</p>

<p><code>$offset</code> and <code>$size</code> will be treated as <code>Int</code>. The function fails if either parameter is negative, or undefined.</p>

<p>Either of <code>$offset</code> or <code>$size</code> may be specified relative to the length of the array using a WhateverCode whose argument will be the number of elements in the array.</p>

<p>While it is illegal for the offset to be larger than the size of the array, it is allowed for the final position to be off the end of the array; in this case the entire rest of the array is spliced, whatever is available.</p>

<dt><a name="unshift"
>unshift</a></dt>

<dd>
<pre><code> multi method unshift ( @array: *@values --&#62; Array ) is export</code></pre>

<p><code>unshift</code> adds the values onto the start of the <code>@array</code> and returns the modified array.</p>

<dt><a name="keys"
>keys</a></dt>

<dd>
<dt><a name="kv"
>kv</a></dt>

<dd>
<dt><a name="pairs"
>pairs</a></dt>

<dd>
<dt><a name="values"
>values</a></dt>

<dd>
<pre><code> multi method keys   ( @array: ) is export
 multi method kv     ( @array: ) is export
 multi method pairs  ( @array: ) is export
 multi method enums  ( @array: ) is export
 multi method values ( @array: ) is export</code></pre>

<p>Iterates the elements of <code>@array</code>, in order.</p>

<p>What is returned at each element of the iteration varies with function. <code>values</code> returns the value of the associated element; <code>kv</code> returns a 2 element list in (index, value) order, <code>pairs</code> a <code>Pair(index, value)</code>. With <code>pairs</code> the values are references back to the original containers, while with <code>enums</code> a snapshot of those values is taken. That is, <code>.pairs</code> returns a <code>PairMap</code> while <code>enums</code> returns an <code>EnumMap</code>.</p>

<p>If <code>@array</code> is declared to be multi-dimensional, the keys returned may in fact be slice lists. (Arrays that are effectively multi-dimensional by containing other arrays or hashes are treat with their declared dimensionality, not their effective dimensionality.)</p>

<p>Note that <code>kv @array</code> returns the same as <code>zip(^@array; @array)</code></p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Hash"
>Hash</a></h2>

<p>The following are defined in the <code>Hash</code> class.</p>

<pre><code>class Hash is EnumMap {...}</code></pre>

<dl>
<dt><a name="delete_(DEPRECATED)"
>delete (DEPRECATED)</a></dt>

<dd>
<p>The &#34;delete&#34; method is considered to be a deprecated internal method: the normal way to remove a key from a hash, is to apply the <code>:delete</code> adverb to a subscripting operation.</p>

<dt><a name=":delete"
>:delete</a></dt>

<dd>
<p>This adverb may be applied to any subscripting operation. The operation returns the elements normally, but reads them out destructively.</p>

<dt><a name="exists_(DEPRECATED)"
>exists (DEPRECATED)</a></dt>

<dd>
<p>The &#34;exists&#34; method is considered to be a deprecated internal method: the normal way to test for existence is to apply the <code>:exists</code> adverb to a subscripting operation.</p>

<dt><a name=":exists"
>:exists</a></dt>

<dd>
<p>This adverb may be applied to any subscripting operation. The operation returns true if specified element exists. If a slice is specified by the subscript, a <code>Parcel</code> of <code>Bool</code> is returned, which can be processed using junctions.</p>

<dt><a name="keys"
>keys</a></dt>

<dd>
<dt><a name="kv"
>kv</a></dt>

<dd>
<dt><a name="pairs"
>pairs</a></dt>

<dd>
<dt><a name="values"
>values</a></dt>

<dd>
<pre><code> multi method keys   ( %hash: ) is export
 multi method kv     ( %hash: ) is export
 multi method pairs  ( %hash: ) is export
 multi method enums  ( %hash: ) is export
 multi method values ( %hash: ) is export</code></pre>

<p>Iterates the elements of <code>%hash</code>. The order is implementation dependent and arbitrary, but will be the same between successive calls to these functions, as long as <code>%hash</code> doesn&#39;t change.</p>

<p>What is returned at each element of the iteration varies with function. <code>keys</code> only returns the key; <code>values</code> the value; <code>kv</code> returns both as a 2 element list in (key, value) order, <code>pairs</code> a <code>Pair(key, value)</code>. With <code>pairs</code> the values are references back to the original containers, while with <code>enums</code> a snapshot of those values is taken. That is, <code>.pairs</code> returns a <code>PairMap</code> while <code>enums</code> returns an <code>EnumMap</code>.</p>

<p>Note that <code>kv %hash</code> returns the same as <code>zip(keys %hash; values %hash)</code></p>

<p>The lvalue form of <code>keys</code> is no longer supported. Use the <code>.buckets</code> property instead.</p>

<dt><a name="any"
>any</a></dt>

<dd>
<pre><code> multi method any( %hash: --&#62; Junction ) is export</code></pre>

<p>Returns a junction with all the keys of the hash <code>|</code>-ed together. The junction will only match against another value if at least one of the keys in the hash matches.</p>

<dt><a name="all"
>all</a></dt>

<dd>
<pre><code> multi method all( %hash: --&#62; Junction ) is export</code></pre>

<p>Returns a junction with all the keys of the hash <code>&#38;</code>-ed together. The junction will only match against another value if all of the keys in the hash match.</p>

<dt><a name="one"
>one</a></dt>

<dd>
<pre><code> multi method one( %hash: --&#62; Junction ) is export</code></pre>

<p>Returns a junction with all the keys of the hash <code>^</code>-ed together. The junction will only match against another value if exactly one of the keys in the hash matches.</p>

<dt><a name="none"
>none</a></dt>

<dd>
<pre><code> multi method none( %hash: --&#62; Junction ) is export</code></pre>

<p>Returns a junction which will only match against another value if none of the keys in the hash matches.</p>

<dt><a name="invert"
>invert</a></dt>

<dd>
<pre><code> multi method invert ( %hash: --&#62; List ) is export {
 map -&#62; $k, $v { $v X=&#62; $k }, %hash.kv;
 }</code></pre>

<p>Produces a backmapping of values to keys, expanding list values into multiple pairs. (The <code>X=&#62;</code> expands <code>$v</code> if it is a list.) [NB: this may need refinement to handle keys that do <code>Positional</code>.]</p>

<dt><a name="push"
>push</a></dt>

<dd>
<pre><code> multi method push ( %hash: *@values --&#62; Hash ) is export</code></pre>

<p>Like hash assignment insofar as it accepts either <code>Pair</code> objects or alternating keys and values; also like in that it returns the new hash. However, unlike assignment, when a duplicate key is detected, <code>push</code> coerces the colliding entry&#39;s value to an array and pushes the <code>Pair</code>&#39;s value onto that array. Hence to invert a hash containing duplicate values without losing (associative) information, say:</p>

<pre><code>%out.push(%in.invert)</code></pre>

<p>Note that when reading the values of such a hash, you must not assume that all the elements are arrays, since the first instance of a key merely sets the value without turning it into an array. (Fortunately, most list operators create a list of one element when used on an object that is not a list.)</p>

<p>The intent is that reversing a hash twice produces a hash equivalent to the original hash.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Classes_and_Roles"
>Classes and Roles</a></h1>

<p>This documents Buf, List, Range, Set, Bag, Junction, Array, Hash, MixHash, SetHash, BagHash, Pair, and PairMap.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Range"
>Range</a></h2>

<pre><code>class Range does Positional does Iterable {
    method min() {...}
    method max() {...}
    method bounds() returns Parcel {...}
    method excludes_min {...}
    method excludes_max {...}
    method sample {...}
}</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Methods"
>Methods</a></h3>

<dl>
<dt><a name="sample"
>sample</a></dt>

<dd>
<pre><code>multi method sample ( $range: Int $num = 1 --&#62; List )
multi method sample ( $range: Whatever --&#62; List )</code></pre>

<p>Returns a lazy list of <code>Num</code> values, taken as linearly distributed samples from the real interval specified by the invocant. The argument, if any, indicates how many samples to return. Hence, <code>(^1).sample</code> is equivalent to <code>rand</code>, and <code>(^10).sample(*)</code> is equivalent to <code>rand * 10 xx *</code>. Ranges with exclusions other than <code>..^</code> may be less efficient by virtue of having to generate from a larger interval, throwing out values that are outside the specified interval.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Buf"
>Buf</a></h2>

<pre><code>class Buf does Positional does Stringy {...}</code></pre>

<p>A mutable container for an array of integer values in contiguous memory. The default constructor takes a single array parameter of integers, the largest of which determines the actual type. So</p>

<pre><code>Buf.new([:16&#60;c3&#62;, :16&#60;B6&#62;]) # or
Buf.new([195, 182])         # which is exactly the same</code></pre>

<p>returns a <code>buf8</code> containing two <code>uint8</code> items, while</p>

<pre><code>Buf.new([256])</code></pre>

<p>returns a <code>buf16</code> which consists of a single <code>uint16</code>.</p>

<p>To explicit request a <code>Buf</code> of a specific size, you can use</p>

<pre><code>Buf.new([127], :size(16))     # returns a buf16
Buf.new([1024], :size(8))     # dies, because 1024 &#62;= 2**8</code></pre>

<p>Subtypes with additional constraints like <code>utf8</code> (which only allows valid UTF-8 byte sequences) exist and provide similar constructors. See <a href="http://search.cpan.org/perldoc?S02#Built-In_Data_Types" class="podlinkpod"
>&#34;Built-In Data Types&#34; in S02</a>.</p>

<p>The array in the constructor used to be slurpy rather than positional, but the former was deemed to be too inefficient (during signature construction) for arrays of many elements.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Methods"
>Methods</a></h3>

<dl>
<dt><a name="decode"
>decode</a></dt>

<dd>
<pre><code>method decode($encoding = $?ENC, $nf = $?NF --&#62; Str )</code></pre>

<p>Decode the <code>Buf</code> into a <code>Str</code>. For subtypes that know their encoding (like <code>utf8</code>, <code>utf16</code>) the <code>$encoding</code> parameter defaults to their intrinsic encoding instead.</p>

<dt><a name="subbuf"
>subbuf</a></dt>

<dd>
<pre><code>method subbuf($from, $elems?) returns Buf:D</code></pre>

<p>Returns a part of the original buffer, starting from index <code>$from</code> and taking <code>$elems</code> elements (or to the end of the buffer, if not provided).</p>

<p>The method fails with <code>X::OutOfRange</code> if either <code>$from</code> or <code>$elems</code> are negative. The method also fails if <code>$from</code> is larger than the amount of elemens in the buffer.</p>

<p><code>$from</code> may be specified relative to the end of the string using a WhateverCode:</p>

<pre><code> Buf.new(0x00, 0xFF).subbuf(*-1, 1)</code></pre>

<dt><a name="subbuf-rw"
>subbuf-rw</a></dt>

<dd>
<pre><code>   method subbuf-rw( $from; $elems?) is rw

 A version of C&#60;.subbuf&#62; that returns a writable reference to a part of a
 buffer:

  $b.subbuf-rw($from,$to) = Buf.new(0x00, 0x77);</code></pre>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Buf_Operators"
><code>Buf</code> Operators</a></h3>

<p>Two <code>Buf</code> objects of the same bit size can be compared with the same operators as strings (in particular <code>eq</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>, <code>ne</code> and <code>leg</code>), but actually compares the stored integers, not characters. Concatenating two compatible <code>Buf</code>s produces an object of the most specific type possible, for example <code>buf8.new() ~ utf8.new()</code> results in a <code>buf8</code> object.</p>

<p>Comparing or concatenating two <code>Buf</code> objects of different bit sizes, or a <code>Buf</code> that doesn&#39;t know its encoding with a <code>Str</code> throws an exception.</p>

<p>Likewise, coercing an encoding-unaware <code>Buf</code> to <code>Str</code> dies.</p>

<p>[Conjecture: The behaviour of encoding-aware <code>Buf</code> objects on string operators is intentionally not defined yet, because I have no idea what implications on speed and usage they might have --moritz].</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Enum_and_Pair"
>Enum and Pair</a></h2>

<pre><code>class Enum does Associative {...}
class Pair does Associative {...}</code></pre>

<p>A value formed by associating a single key with a single value. In an <code>Enum</code>, both key and value are immutable. In a <code>Pair</code>, the key is immutable but the value mutable. <code>Enum</code> works identically to <code>Pair</code> unless you try to modify it.)</p>

<dl>
<dt><a name="invert"
>invert</a></dt>

<dd>
<pre><code>multi method invert ( $pair: --&#62; List ) is export {
 $pair.value X=&#62; $pair.key
}</code></pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="EnumMap"
>EnumMap</a></h2>

<pre><code>class EnumMap does Associative does Positional {...}</code></pre>

<p>An immutable hash value, viewable either as a (constant) hash or as a sequence of <code>Enum</code>s. The keys may not contain duplicates, while the values may. The implementation of <code>EnumMap</code> associativity is not guaranteed to be as efficient as a <code>Hash</code> lookup. (A brute force linear scan for the matching key is allowed. Optimization is also allowed.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PairMap"
>PairMap</a></h2>

<pre><code>class PairMap does Associative does Positional {...}</code></pre>

<p>A hash value that is mutable only in values, differing from a normal hash insofar as the key set is frozen. It may be accessed either as a frozen hash or as a sequence of <code>Pair</code>s. The keys may not contain duplicates, while the values may. The implementation of <code>PairMap</code> associativity is not guaranteed to be as efficient as a <code>Hash</code> lookup. (A brute force linear scan for the matching key is allowed. Optimization to something like an ordered hash is also allowed.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Set"
>Set</a></h2>

<pre><code>class Set does Associative {...}</code></pre>

<p>A set of unique values or objects. (Sets are notionally &#34;object hashes&#34;, that is, hashes that allow more than just strings as keys; as such, they are subject to <code>===</code> equality rather than <code>eqv</code> equality.) A <code>Set</code> responds to hash operators as if it were a <code>Hash of True</code>. that is, when used as a hash, a set always treats the set&#39;s elements as the keys of the hash, returning <code>True</code> for existing set elements, and <code>False</code> for any key not found in the set.</p>

<p>See <code>SetHash</code> for a container that can represent different sets as keys are added or deleted.</p>

<p>Regardless of their behavior as hashes, set (and bag) types do not flatten in list context; in the absence of explicit interpolation instructions (such as use of the <code>@</code> sigil or <code>.keys</code> method) they are returned as items in list context. On the other end, the constructors for set and bag types do not automatically interpolate the contents of sets or bags (or any other other item type). They simply take the list of objects slurped in and turn them into a set. Together these rules allow us to constructs sets and bags containing sets and bags as elements.</p>

<p>Use the <code>set</code> composer to construct a set of the elements of the list. The empty set may be indicated with either <code>set()</code> or <code>&#8709;</code> (U+2205 EMPTY SET).</p>

<p>The <code>set</code> composer will very literally make a set of whatever you pass it; in particular, it will make a set of Pairs if you try to pass it a list of Pairs (recall that a hash returns a list of Pairs in list context). To create a set from the keys of a list of Pairs, use a <code>Set()</code> coercion rather than a constructor. Or to create a set from a hash, use the <code>.keys</code> or <code>:k</code> to extract only the keys.</p>

<dl>
<dt><a name="pick"
>pick</a></dt>

<dd>
<pre><code> multi method pick ( $set: Int $num = 1 --&#62; Any )
 multi method pick ( $set: Whatever --&#62; Any )</code></pre>

<p>Works like an ordinary list <code>pick</code>.</p>

<dt><a name="roll"
>roll</a></dt>

<dd>
<pre><code> multi method roll ( $set: Int $num = 1 --&#62; Any )
 multi method roll ( $set: Whatever --&#62; Any )</code></pre>

<p>Works like an ordinary list <code>roll</code>.</p>

<dt><a name="combinations"
>combinations</a></dt>

<dd>
<pre><code> multi method combinations ( Int $of )
 multi method combinations ( Range $of = 0 .. * )</code></pre>

<p>Works as if the set were turned into a list of elements and then the combinations were turned back into a list of sets, ordered by increasing size. You may, of course, turn that list back into a set of sets.</p>

<p>Note that, without an argument, this method basically calculates the powerset.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="SetHash"
>SetHash</a></h2>

<p>A mutable Set container, represented as <code>QuantHash[Bool,False]</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Bag"
>Bag</a></h2>

<pre><code>class Bag does Associative {...}</code></pre>

<p>A collection of values or objects that work just like sets, except that they need not be unique. The count of each value or object is represented by an associative mapping from each key value/object to its replication number. The <code>.total</code> method returns the sum of all replication values. The <code>.minpairs</code> and <code>.maxpairs</code> methods return the pairs with the minimum and maximum replication number.</p>

<p>Sets and bags do not flatten into list context, nor do the constructors interpolate items passed to them, even if they look like sets or bags. (To create a bag from a list of Pairs or a hash, use a <code>Bag()</code> coercion rather than a constructor.)</p>

<dl>
<dt><a name="pick"
>pick</a></dt>

<dd>
<pre><code> multi method pick ( $bag: Int $num = 1 --&#62; Any )
 multi method pick ( $bag: Whatever --&#62; Any )
 multi method pickpairs ( $bag: Int $num = 1 --&#62; Pairs )
 multi method pickpairs ( $bag: Whatever --&#62; Pairs )</code></pre>

<p>Like an ordinary list <code>pick</code>, but returns keys of the bag weighted by values, as if the keys were replicated the number of times indicated by the corresponding value and then list pick used. <code>BagHash</code> is the mutable form of <code>Bag</code>. A <code>Bag</code> responds to hash operators as if it were a <code>Hash of UInt</code>.</p>

<p>The underlying metaphor for picking is that you&#39;re pulling colored marbles out a bag. (For &#34;picking with replacement&#34; see <code>roll</code> instead.) Picking require tracking the temporary state, so the immutable <code>Bag</code> is copied to a temporary private <code>BagHash</code>, and the picks are made from that using the corresponding <code>.grab</code> or <code>.grabpairs</code> method (see below).</p>

<p>Each <code>.pick</code>/<code>.pickpairs</code> invocation maintains its own private state and has no effect on subsequent <code>.pick</code>/<code>.pickpairs</code> invocations.</p>

<p>The <code>.pickpairs</code> version returns the grabbed values as a list of <code>Pair</code> objects, whose keys are the keys and whose values are the replication values.</p>

<dt><a name="roll"
>roll</a></dt>

<dd>
<pre><code> multi method roll ( $bag: Int $num = 1 --&#62; Any )
 multi method roll ( $bag: Whatever --&#62; Any )</code></pre>

<p>Like an ordinary list <code>roll</code>, but returns keys of the bag weighted by values, as if the keys were replicated the number of times indicated by the corresponding value and then list <code>roll</code> used. The underlying metaphor for rolling is that you&#39;re throwing <code>$num</code> dice that are independent of each other, which (in bag terms) is equivalent to picking a colored marble out your bag and then putting it back, and doing this <code>$num</code> times. In dice terms, the number of marbles corresponds to the number of sides, and the number of marbles of the same color corresponds to number of sides with the same color. (For &#34;picking without replacement&#34; see <code>pick</code> instead.) Rolling requires no temporary state.</p>

<dt><a name="kxxv"
>kxxv</a></dt>

<dd>
<pre><code> method kxxv (--&#62;List)</code></pre>

<p>Returns a list of the keys of the bag, with each key multiplied by its replication factor (hence the name: .k xx .v).</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="BagHash"
>BagHash</a></h2>

<p>A mutable <code>Bag</code> container, represented as <code>QuantHash[UInt,0]</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="QuantHash"
>QuantHash</a></h2>

<pre><code>role QuantHash[::T, $default = Any] does Mixy does Associative {...}</code></pre>

<p>A <code>QuantHash</code> represents a mutable set of objects, represented as the keys of a <code>Hash</code>. When asked to behave as a list it ignores its <code>.values</code> and returns only <code>.keys</code> (possibly replicated by weight in the case of bag types). <code>SetHash</code> and <code>BagHash</code> are derived from this type, but constrain their hash values to be <code>Bool</code> and <code>UInt</code>, respectively. A <code>QuantHash</code> automatically deletes any key whose corresponding value goes to the default value for the hash. For any <code>QuantHash</code>, the <code>.total</code> methods returns the current sum of the values, which the <code>QuantHash</code> must either track or compute on demand. Tracking is preferable for efficient implementation of <code>.pick</code> and <code>.grab</code>.</p>

<p>All standard <code>QuantHash</code> containers have a default value that is false (such as <code>0</code> or <code>&#39;&#39;</code> or <code>Nil</code> or <code>Bool::False</code>), and keep around only those entries with non-default values, automatically deleting any entry if its value goes to that (false) default value.</p>

<dl>
<dt><a name="grab"
>grab</a></dt>

<dd>
<pre><code> multi method grab ( $bag: Int $num = 1 --&#62; Any )
 multi method grab ( $bag: Whatever --&#62; Any )
 multi method grabpairs ( $bag: Int $num = 1 --&#62; Any )
 multi method grabpairs ( $bag: Whatever --&#62; Any )</code></pre>

<p>Like <code>pick</code>, a <code>grab</code> returns a random selection of elements, weighted by the values corresponding to each key. Unlike <code>pick</code>, it works only on mutable structures. Use of <code>grab</code> on an immutable structure results in an exception (much like <code>push</code> would). Since a <code>QuantHash</code>, unlike a <code>Set</code> or <code>Bag</code>, is mutable, <code>.grab</code> works directly on the <code>QuantHash</code>, modifying it in place. (You may use <code>.pick</code> to treat the <code>QuantHash</code> as immutable; this will copy it and grab only from the temporary copy.)</p>

<p>Grabbing decrements the grabbed key&#39;s replication value by one (deleting the key when it goes to 0). By definition, <code>.total</code> of the bag also decreases by one, so the probabilities stay consistent through subsequent grab operations.</p>

<p>With the <code>.grabpairs</code> version, the replication value of the picked key is forced immediately to 0, removing all marbles of that color from the bag, as it were. Instead of returning keys, returns the grabbed values as a list of <code>Pair</code> objects, whose keys are the deleted keys and whose values are the deleted replication values.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MixHash"
>MixHash</a></h2>

<p>A <code>QuantHash[Real,0]</code>; like a <code>BagHash</code> but may have non-integral weights for use in weighted picking. Keys with fractional weights are deleted if they go to 0. Negative weights are not deleted, but the implementation may complain if it notices you attempting to use such a weight.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Junction"
>Junction</a></h2>

<p>All method calls on junctions autothread because the type provides no public methods.</p>

<dl>
<dt><a name="!eigenstates"
>!eigenstates</a></dt>

<dd>
<pre><code>method !eigenstates (Junction $j: --&#62; Parcel)</code></pre>

<p>Returns an unordered list of the values that constitute the junction (formerly called <code>.values</code>). It flattens nested junctions of the same type, so <code>(1|(2|3)).eigenstates</code> returns an arbitrary permutation of the list <code>1, 2, 3</code>.</p>

<p>Note this is a private method; you must arrange for yourself to be trusted by the junctions class in order to call it, which probably involves evil MONKEY_TYPING.</p>

<p>Alternately, the values may be explicitly converted to a set value using <code>.Set</code> or <code>Set()</code>. Note, however, that the set of eigenstates for a <code>none</code> junction defines the values that are *not* there, so the resulting <code>Set</code> will be the <i>complement</i> to the universe of values recognized by the junction! Also note that <code>any</code> and <code>all</code> junctions represent <i>sets</i> of sets of items, not sets of items. Since set items are by definition unique, only the <code>one</code> junction can be unthinkingly mapped to and from a given set. (This is why we discourage casual use of the eigenstates as a set.)</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Additions"
>Additions</a></h1>

<p>Please post errors and feedback to perl6-language. If you are making a general laundry list, please separate messages by topic.</p>

<!-- end doc -->

</body></html>
