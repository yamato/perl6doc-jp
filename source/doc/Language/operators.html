<!doctype html>
<html>
<head>
  <title>Operators</title>
  <meta charset="UTF-8" />
  <style>
    /* code gets the browser-default font
     * kbd gets a slightly less common monospace font
     * samp gets the hard pixelly fonts
     */
    kbd { font-family: "Droid Sans Mono", "Luxi Mono", "Inconsolata", monospace }
    samp { font-family: "Terminus", "Courier", "Lucida Console", monospace }
    /* WHATWG HTML frowns on the use of <u> because it looks like a link,
     * so we make it not look like one.
     */
    u { text-decoration: none }
    .nested {
        margin-left: 3em;
    }
    // footnote things:
    aside, u { opacity: 0.7 }
    a[id^="fn-"]:target { background: #ff0 }
  </style>
  <link rel="stylesheet" href="http://perlcabal.org/syn/perl.css">
  
  
</head>
<body class="pod" id="___top">


<h1 class='title'>Operators</h1>
<p class='subtitle'>Common Perl 6 infixes, prefixes, postfixes, and more!</p>
<nav class="indexgroup">
<ol class="indexList indexList1">
  <li class="indexItem indexItem1"><a href="#Operator_Precedence">Operator Precedence</a></li>
  <li class="indexItem indexItem1"><a href="#Operator_classification">Operator classification</a></li>
  <li class="indexItem indexItem1"><a href="#Term_Precedence">Term Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#circumfix_%3C_%3E">circumfix &lt; &gt;</a></li>
    <li class="indexItem indexItem2"><a href="#circumfix_(_)">circumfix ( )</a></li>
    <li class="indexItem indexItem2"><a href="#circumfix_%7B_%7D">circumfix { }</a></li>
    <li class="indexItem indexItem2"><a href="#circumfix_%5B_%5D">circumfix [ ]</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Method_Postfix_Precedence">Method Postfix Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#postcircumfix_%7B_%7D">postcircumfix { }</a></li>
    <li class="indexItem indexItem2"><a href="#postcircumfix_%3C_%3E">postcircumfix &lt; &gt;</a></li>
    <li class="indexItem indexItem2"><a href="#postcircumfix_(_)">postcircumfix ( )</a></li>
    <li class="indexItem indexItem2"><a href="#postcircumfix_%5B_%5D">postcircumfix [ ]</a></li>
    <li class="indexItem indexItem2"><a href="#postfix_.">postfix .</a></li>
    <li class="indexItem indexItem2"><a href="#postfix_.%3F">postfix .?</a></li>
    <li class="indexItem indexItem2"><a href="#postfix_.%2B">postfix .+</a></li>
    <li class="indexItem indexItem2"><a href="#postfix_.*">postfix .*</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Autoincrement_Precedence">Autoincrement Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#prefix_%2B%2B">prefix ++</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_--">prefix --</a></li>
    <li class="indexItem indexItem2"><a href="#postfix_%2B%2B">postfix ++</a></li>
    <li class="indexItem indexItem2"><a href="#postfix_--">postfix --</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Exponentiation_Precedence">Exponentiation Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_**">infix **</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Symbolic_Unary_Precedence">Symbolic Unary Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#prefix_%3F">prefix ?</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_!">prefix !</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_%2B">prefix +</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_-">prefix -</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_~">prefix ~</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_%7C">prefix |</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_%2B%5E">prefix +^</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_%3F%5E">prefix ?^</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_%5E">prefix ^</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Multiplicative_Precedence">Multiplicative Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_*">infix *</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%2F">infix /</a></li>
    <li class="indexItem indexItem2"><a href="#infix_div">infix div</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%25">infix %</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%25%25">infix %%</a></li>
    <li class="indexItem indexItem2"><a href="#infix_mod">infix mod</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%2B%26">infix +&amp;</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%2B%3C">infix +&lt;</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%2B%3E">infix +&gt;</a></li>
    <li class="indexItem indexItem2"><a href="#infix_gcd">infix gcd</a></li>
    <li class="indexItem indexItem2"><a href="#infix_lcm">infix lcm</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Additive_Precedence">Additive Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_%2B">infix +</a></li>
    <li class="indexItem indexItem2"><a href="#infix_-">infix -</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%2B%7C">infix +|</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%2B%5E">infix +^</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3F%7C">infix ?|</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Replication_Precedence">Replication Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_x">infix x</a></li>
    <li class="indexItem indexItem2"><a href="#infix_xx">infix xx</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Concatenation">Concatenation</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_~">infix ~</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Junctive_AND_(all)_Precedence">Junctive AND (all) Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_%26">infix &amp;</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Junctive_OR_(any)_Precedence">Junctive OR (any) Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_%7C">infix |</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%5E">infix ^</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Named_Unary_Precedence">Named Unary Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#prefix_temp">prefix temp</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_let">prefix let</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Nonchaining_Binary_Precedence">Nonchaining Binary Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_does">infix does</a></li>
    <li class="indexItem indexItem2"><a href="#infix_but">infix but</a></li>
    <li class="indexItem indexItem2"><a href="#infix_cmp">infix cmp</a></li>
    <li class="indexItem indexItem2"><a href="#infix_leg">infix leg</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3C%3D%3E">infix &lt;=&gt;</a></li>
    <li class="indexItem indexItem2"><a href="#infix_..">infix ..</a></li>
    <li class="indexItem indexItem2"><a href="#infix_..%5E">infix ..^</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%5E..">infix ^..</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%5E..%5E">infix ^..^</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Chaining_Binary_Precedence">Chaining Binary Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_%3D%3D">infix ==</a></li>
    <li class="indexItem indexItem2"><a href="#infix_!%3D">infix !=</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3C">infix &lt;</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3C%3D">infix &lt;=</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3E">infix &gt;</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3E%3D">infix &gt;=</a></li>
    <li class="indexItem indexItem2"><a href="#infix_eq">infix eq</a></li>
    <li class="indexItem indexItem2"><a href="#infix_ne">infix ne</a></li>
    <li class="indexItem indexItem2"><a href="#infix_gt">infix gt</a></li>
    <li class="indexItem indexItem2"><a href="#infix_ge">infix ge</a></li>
    <li class="indexItem indexItem2"><a href="#infix_lt">infix lt</a></li>
    <li class="indexItem indexItem2"><a href="#infix_le">infix le</a></li>
    <li class="indexItem indexItem2"><a href="#infix_before">infix before</a></li>
    <li class="indexItem indexItem2"><a href="#infix_after">infix after</a></li>
    <li class="indexItem indexItem2"><a href="#infix_eqv">infix eqv</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3D%3D%3D">infix ===</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3D%3A%3D">infix =:=</a></li>
    <li class="indexItem indexItem2"><a href="#infix_~~">infix ~~</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Tight_AND_Precedence">Tight AND Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_%26%26">infix &amp;&amp;</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Tight_OR_Precedence">Tight OR Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_%7C%7C">infix ||</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%5E%5E">infix ^^</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%2F%2F">infix //</a></li>
    <li class="indexItem indexItem2"><a href="#infix_min">infix min</a></li>
    <li class="indexItem indexItem2"><a href="#infix_max">infix max</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Conditional_Operator_Precedence">Conditional Operator Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_%3F%3F_!!">infix ?? !!</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Item_Assignment_Precedence">Item Assignment Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_%3D">infix =</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3D%3E">infix =&gt;</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Loose_Unary_Precedence">Loose Unary Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#prefix_not">prefix not</a></li>
    <li class="indexItem indexItem2"><a href="#prefix_so">prefix so</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Comma_Operator_Precedence">Comma Operator Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_%2C">infix ,</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3A">infix :</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#List_Infix_Precedence">List Infix Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_Z">infix Z</a></li>
    <li class="indexItem indexItem2"><a href="#infix_X">infix X</a></li>
    <li class="indexItem indexItem2"><a href="#infix_...">infix ...</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#List_Prefix_Precedence">List Prefix Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_%3D">infix =</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3A%3D">infix :=</a></li>
    <li class="indexItem indexItem2"><a href="#infix_%3A%3A%3D">infix ::=</a></li>
    <li class="indexItem indexItem2"><a href="#listop_...">listop ...</a></li>
    <li class="indexItem indexItem2"><a href="#listop_!!!">listop !!!</a></li>
    <li class="indexItem indexItem2"><a href="#listop_%3F%3F%3F">listop ???</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Loose_AND_precedence">Loose AND precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_and">infix and</a></li>
    <li class="indexItem indexItem2"><a href="#infix_andthen">infix andthen</a></li>
  </ol>
  <li class="indexItem indexItem1"><a href="#Loose_OR_Precedence">Loose OR Precedence</a></li>
  <ol class="indexList indexList2">
    <li class="indexItem indexItem2"><a href="#infix_or">infix or</a></li>
    <li class="indexItem indexItem2"><a href="#infix_orelse">infix orelse</a></li>
  </ol>
</ol>
</nav>
<h1 id="Operator_Precedence"><a class="u" href="#___top" title="go to top of document">Operator Precedence</a></h1>
<p>In an expression like <code>1 + 2 * 3</code>, the <code>2 * 3</code> is evaluated first because the infix <code>*</code> has tighter <strong>precedence</strong> than the <code>+</code>.</p>
<p>The following table summarizes the precedence levels in Perl 6, from tightest to loosest:</p>
<table>
<tbody>
<tr>
<td>A Level Examples</td>
<td>A</td>
<td>Level</td>
<td>Examples</td>
</tr>
<tr>
<td>= ===== ========</td>
<td>=</td>
<td>=====</td>
<td>========</td>
</tr>
<tr>
<td>N Terms 42 3.14 &quot;eek&quot; qq[&quot;foo&quot;] $x :!verbose @$array</td>
<td>N</td>
<td>Terms</td>
<td>42 3.14 &quot;eek&quot; qq[&quot;foo&quot;] $x :!verbose @$array</td>
</tr>
<tr>
<td>L Method postfix .meth .+ .? .* .() .[] .{} .&lt;&gt; .«» .:: .= .^ .:</td>
<td>L</td>
<td>Method postfix</td>
<td>.meth .+ .? .* .() .[] .{} .&lt;&gt; .«» .:: .= .^ .:</td>
</tr>
<tr>
<td>N Autoincrement ++ --</td>
<td>N</td>
<td>Autoincrement</td>
<td>++ --</td>
</tr>
<tr>
<td>R Exponentiation **</td>
<td>R</td>
<td>Exponentiation</td>
<td>**</td>
</tr>
<tr>
<td>L Symbolic unary ! + - ~ ? | || +^ ~^ ?^ ^</td>
<td>L</td>
<td>Symbolic unary</td>
<td>! + - ~ ? | || +^ ~^ ?^ ^</td>
</tr>
<tr>
<td>L Multiplicative * / % %% +&amp; +&lt; +&gt; ~&amp; ~&lt; ~&gt; ?&amp; div mod gcd lcm</td>
<td>L</td>
<td>Multiplicative</td>
<td>* / % %% +&amp; +&lt; +&gt; ~&amp; ~&lt; ~&gt; ?&amp; div mod gcd lcm</td>
</tr>
<tr>
<td>L Additive + - +| +^ ~| ~^ ?| ?^</td>
<td>L</td>
<td>Additive</td>
<td>+ - +| +^ ~| ~^ ?| ?^</td>
</tr>
<tr>
<td>L Replication x xx</td>
<td>L</td>
<td>Replication</td>
<td>x xx</td>
</tr>
<tr>
<td>X Concatenation ~</td>
<td>X</td>
<td>Concatenation</td>
<td>~</td>
</tr>
<tr>
<td>X Junctive and &amp;</td>
<td>X</td>
<td>Junctive and</td>
<td>&amp;</td>
</tr>
<tr>
<td>X Junctive or | ^</td>
<td>X</td>
<td>Junctive or</td>
<td>| ^</td>
</tr>
<tr>
<td>L Named unary temp let</td>
<td>L</td>
<td>Named unary</td>
<td>temp let</td>
</tr>
<tr>
<td>N Structural infix but does &lt;=&gt; leg cmp .. ..^ ^.. ^..^</td>
<td>N</td>
<td>Structural infix</td>
<td>but does &lt;=&gt; leg cmp .. ..^ ^.. ^..^</td>
</tr>
<tr>
<td>C Chaining infix != == &lt; &lt;= &gt; &gt;= eq ne lt le gt ge ~~ === eqv !eqv</td>
<td>C</td>
<td>Chaining infix</td>
<td>!= == &lt; &lt;= &gt; &gt;= eq ne lt le gt ge ~~ === eqv !eqv</td>
</tr>
<tr>
<td>X Tight and &amp;&amp;</td>
<td>X</td>
<td>Tight and</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>X Tight or || ^^ // min max</td>
<td>X</td>
<td>Tight or</td>
<td>|| ^^ // min max</td>
</tr>
<tr>
<td>R Conditional ?? !! ff fff</td>
<td>R</td>
<td>Conditional</td>
<td>?? !! ff fff</td>
</tr>
<tr>
<td>R Item assignment = =&gt; += -= **= xx= .=</td>
<td>R</td>
<td>Item assignment</td>
<td>= =&gt; += -= **= xx= .=</td>
</tr>
<tr>
<td>L Loose unary so not</td>
<td>L</td>
<td>Loose unary</td>
<td>so not</td>
</tr>
<tr>
<td>X Comma operator , :</td>
<td>X</td>
<td>Comma operator</td>
<td>, :</td>
</tr>
<tr>
<td>X List infix Z minmax X X~ X* Xeqv ...</td>
<td>X</td>
<td>List infix</td>
<td>Z minmax X X~ X* Xeqv ...</td>
</tr>
<tr>
<td>R List prefix print push say die map substr ... [+] [*] any Z=</td>
<td>R</td>
<td>List prefix</td>
<td>print push say die map substr ... [+] [*] any Z=</td>
</tr>
<tr>
<td>X Loose and and andthen</td>
<td>X</td>
<td>Loose and</td>
<td>and andthen</td>
</tr>
<tr>
<td>X Loose or or xor orelse</td>
<td>X</td>
<td>Loose or</td>
<td>or xor orelse</td>
</tr>
<tr>
<td>X Sequencer &lt;==, ==&gt;, &lt;&lt;==, ==&gt;&gt;</td>
<td>X</td>
<td>Sequencer</td>
<td>&lt;==, ==&gt;, &lt;&lt;==, ==&gt;&gt;</td>
</tr>
<tr>
<td>N Terminator ; {...}, unless, extra ), ], }</td>
<td>N</td>
<td>Terminator</td>
<td>; {...}, unless, extra ), ], }</td>
</tr>
</tbody>
</table><p>Using two <code>!</code> symbols below generically to represent any pair of operators that have the same precedence, the associativities specified above for binary operators are interpreted as follows:</p>
<table>
<tbody>
<tr>
<td>A Assoc Meaning of $a ! $b ! $c</td>
<td>A</td>
<td>Assoc</td>
<td>Meaning of $a ! $b ! $c</td>
</tr>
<tr>
<td>= ===== =======================</td>
<td>=</td>
<td>=====</td>
<td>=======================</td>
</tr>
<tr>
<td>L left ($a ! $b) ! $c</td>
<td>L</td>
<td>left</td>
<td>($a ! $b) ! $c</td>
</tr>
<tr>
<td>R right $a ! ($b ! $c)</td>
<td>R</td>
<td>right</td>
<td>$a ! ($b ! $c)</td>
</tr>
<tr>
<td>N non ILLEGAL</td>
<td>N</td>
<td>non</td>
<td>ILLEGAL</td>
</tr>
<tr>
<td>C chain ($a ! $b) and ($b ! $c)</td>
<td>C</td>
<td>chain</td>
<td>($a ! $b) and ($b ! $c)</td>
</tr>
<tr>
<td>X list infix:&lt;!&gt;($a; $b; $c)</td>
<td>X</td>
<td>list</td>
<td>infix:&lt;!&gt;($a; $b; $c)</td>
</tr>
</tbody>
</table><p>For unary operators this is interpreted as:</p>
<table>
<tbody>
<tr>
<td>A Assoc Meaning of !$a!</td>
<td>A</td>
<td>Assoc</td>
<td>Meaning of !$a!</td>
</tr>
<tr>
<td>= ===== =========================</td>
<td>=</td>
<td>=====</td>
<td>=========================</td>
</tr>
<tr>
<td>L left (!$a)!</td>
<td>L</td>
<td>left</td>
<td>(!$a)!</td>
</tr>
<tr>
<td>R right !($a!)</td>
<td>R</td>
<td>right</td>
<td>!($a!)</td>
</tr>
<tr>
<td>N non ILLEGAL</td>
<td>N</td>
<td>non</td>
<td>ILLEGAL</td>
</tr>
</tbody>
</table><p>In the operator descriptions below, a default associativity of <em>left</em> is assumed.</p>
<h1 id="Operator_classification"><a class="u" href="#___top" title="go to top of document">Operator classification</a></h1>
<p>Operators can occur in several positions relative to a term:</p>
<table>
<tbody>
<tr>
<td>+term prefix</td>
<td>+term</td>
<td>prefix</td>
</tr>
<tr>
<td>term1 + term2 infix</td>
<td>term1 + term2</td>
<td>infix</td>
</tr>
<tr>
<td>term++ postfix</td>
<td>term++</td>
<td>postfix</td>
</tr>
<tr>
<td>(term) circumfix</td>
<td>(term)</td>
<td>circumfix</td>
</tr>
<tr>
<td>term1[term2] postcircumfix</td>
<td>term1[term2]</td>
<td>postcircumfix</td>
</tr>
</tbody>
</table><p>Each operator is also available as a routine; postcircumfix operators as methods, all others as subroutines. The name of the routine is formed of the operator category, then a colon, and a list quote construct with the symbol(s) that make up the operator:</p>
<pre>infix:&lt;+&gt;(1, 2)                 # same as 1 + 2
circumfix:«( )»(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)  # same as (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</pre>
<p>As a special case the <em>listop</em> (list operator) can stand either as a term or as a prefix. Subroutine calls are the most common listops. Other cases include meta-reduced infix operators (<code>[+]| 1, 2, 3</code>) and the <a href="#prefix_...">prefix ...</a> etc. stub operators.</p>
<p>(Niecza currently turns postcircumfix operators in a subroutine call, while Rakudo interprets them as methods).</p>
<h1 id="Term_Precedence"><a class="u" href="#___top" title="go to top of document">Term Precedence</a></h1>
<h2 id="circumfix_<_>"><a class="u" href="#___top" title="go to top of document">circumfix &lt; &gt;</a></h2>
<p>The quote-words construct. Breaks up the contents on whitespace, and returns a <code>Parcel</code> of the words. If a word looks like a number literal or a <code>Pair</code> literal, it is converted the appropriate number.</p>
<pre>say &lt;a b c&gt;[1];     # b</pre>
<p>(Rakudo currently always returns a parcel of strings).</p>
<h2 id="circumfix_(_)"><a class="u" href="#___top" title="go to top of document">circumfix ( )</a></h2>
<p>The grouping operator.</p>
<p>An empty group <code>()</code> creates an empty <a href="Parcel">Parcel</a>. Parens around non-empty expressions simply structure the expression, but not have additional semantics.</p>
<p>In an argument list, putting parenthesis around an argument prevents it from being interpreted as a named argument.</p>
<pre>multi sub p(:$a!) { say &#39;named&#39;      }
multi sub p($a)   { say &#39;positional&#39; }
p a =&gt; 1;       # named
p (a =&gt; 1);     # positional</pre>
<h2 id="circumfix_{_}"><a class="u" href="#___top" title="go to top of document">circumfix { }</a></h2>
<p>Block or <a href="Hash">Hash</a> constructor.</p>
<p>If the contents looks like a list of pairs and does not use <a href="$_">$_</a> or other placeholder parameters, returns an itemized <a href="Hash">Hash</a>.</p>
<p>Otherwise it constructs a <a href="Block">Block</a>.</p>
<p>Note that this construct does not re-parse the contents; rather the contents are always parsed as a statement list (i.e. like a block), and if the later analysis shows that it needs to be interpreted as a hash, the block is executed and coerced to <a href="Hash">Hash</a>.</p>
<h2 id="circumfix_[_]"><a class="u" href="#___top" title="go to top of document">circumfix [ ]</a></h2>
<p>The <a href="Array">Array</a> constructor. Returns an itemized <a href="Array">Array</a> which does not flatten in list context.</p>
<h1 id="Method_Postfix_Precedence"><a class="u" href="#___top" title="go to top of document">Method Postfix Precedence</a></h1>
<h2 id="postcircumfix_{_}"><a class="u" href="#___top" title="go to top of document">postcircumfix { }</a></h2>
<p>The hash indexing postcircumfix. Fail on type <a href="Any">Any</a>, and on <a href="EnumMap">EnumMap</a>, <a href="Hash">Hash</a> and related types it allows lookup of hash elements by key.</p>
<pre>my %h = a =&gt; 1, b =&gt; 2;
say %h{&#39;a&#39;};        # 1
say %h{&#39;a&#39;, &#39;b&#39;};   # 1, 2</pre>
<h2 id="postcircumfix_<_>"><a class="u" href="#___top" title="go to top of document">postcircumfix &lt; &gt;</a></h2>
<p>The hash indexing quote-words operator. Interprets the argument list as a list of words, just like <code>circumfix &lt; &gt; </code>, and then calls <code>postcircumfix:&lt;{ }&gt; </code>, i.e. the hash indexing operator.</p>
<p>Thus you can write</p>
<pre>my %h = a =&gt; 1, b =&gt; 2;
say %h&lt;a&gt;;          # 1
say %h&lt;b a&gt;;        # 2, 1</pre>
<h2 id="postcircumfix_(_)"><a class="u" href="#___top" title="go to top of document">postcircumfix ( )</a></h2>
<p>The call operator. Treats the invocant as a <a href="Callable">Callable</a> and invokes it, using the expression between the parens as arguments.</p>
<p>Note that an identifier followed by a pair of parens is always parsed as a subroutine call.</p>
<p>If you want your objects to respond to the call operator, you need to implement a <code>method postcircumfix:&lt;( )&gt; </code>.</p>
<h2 id="postcircumfix_[_]"><a class="u" href="#___top" title="go to top of document">postcircumfix [ ]</a></h2>
<p>The array indexing operator. Treats the invocant as a <a href="Positional">Positional</a> and indexes it by position.</p>
<pre>my @a = &#39;a&#39; .. &#39;z&#39;;
say @a[0];                      # a</pre>
<p>Lists of indexes produce list of results as if they were all indexed separately.</p>
<pre>my @a = &#39;a&#39; .. &#39;z&#39;;
say @a[15, 4, 17, 11].join;     # perl</pre>
<p><a href="Callable">Callable</a> indexes are invoked with the number of elements as arguments.</p>
<p>This lets you write</p>
<pre>my @a[*-1];                     # z</pre>
<p>to index lists and arrays from the end.</p>
<p>Non-<a href="Positional">Positional</a> invocants are interpreted as a one-list element of the object.</p>
<h2 id="postfix_."><a class="u" href="#___top" title="go to top of document">postfix .</a></h2>
<p>The operator for calling one method, <code>$invocant.method</code>.</p>
<p>Technically this is not an operator, but syntax special-cased in the compiler.</p>
<h2 id="postfix_.?"><a class="u" href="#___top" title="go to top of document">postfix .?</a></h2>
<p>Potential method calls. <code>$invocant.?method</code> calls method <code>method</code> on <code>$invocant</code> if it has a method of such name. Otherwise it returns <a href="Nil">Nil</a>.</p>
<p>Technically this is not an operator, but syntax special-cased in the compiler.</p>
<h2 id="postfix_.+"><a class="u" href="#___top" title="go to top of document">postfix .+</a></h2>
<p><code>$invocant.+method</code> calls all methods called <code>method</code> from <code>$invocant</code>, and returns a <a href="Parcel">Parcel</a> of the results. Dies if no such method was found.</p>
<p>Technically this is not an operator, but syntax special-cased in the compiler.</p>
<h2 id="postfix_.*"><a class="u" href="#___top" title="go to top of document">postfix .*</a></h2>
<p><code>$invocant.*method</code> calls all methods called <code>method</code> from <code>$invocant</code>, and returns a <a href="Parcel">Parcel</a> of the results. If no such method was found, an empty <a href="Parcel">Parcel</a> is returned.</p>
<p>Technically this is not an operator, but syntax special-cased in the compiler.</p>
<p># TODO: .= .^ .:: .() .[] .{} .&lt;&gt;</p>
<h1 id="Autoincrement_Precedence"><a class="u" href="#___top" title="go to top of document">Autoincrement Precedence</a></h1>
<h2 id="prefix_++"><a class="u" href="#___top" title="go to top of document">prefix ++</a></h2>
<pre>multi sub prefix:&lt;++&gt;($x is rw) is assoc&lt;none&gt;</pre>
<p>Increments its argument by one, and returns the incremented value.</p>
<pre>my $x = 3;
say ++$x;       # 4
say $x;         # 4</pre>
<p>It works by calling the <a href="succ">succ</a> method (for <em>successor</em>) on its argument, which gives custom types the freedom to implement their own incrementation semantics.</p>
<h2 id="prefix_--"><a class="u" href="#___top" title="go to top of document">prefix --</a></h2>
<pre>multi sub prefix:&lt;--&gt;($x is rw) is assoc&lt;none&gt;</pre>
<p>Decrements its argument by one, and returns the decremented value.</p>
<pre>my $x = 3;
say --$x;       # 2
say $x;         # 2</pre>
<p>It works by calling the <a href="pred">pred</a> method (for <em>predecessor</em>) on its argument, which gives custom types the freedom to implement their own decrementation semantics.</p>
<h2 id="postfix_++"><a class="u" href="#___top" title="go to top of document">postfix ++</a></h2>
<pre>multi sub postfix:&lt;++&gt;($x is rw) is assoc&lt;none&gt;</pre>
<p>Increments its argument by one, and returns the unincremented value.</p>
<pre>my $x = 3;
say $x++;       # 3
say $x;         # 4</pre>
<p>It works by calling the <a href="succ">succ</a> method (for <em>successor</em>) on its argument, which gives custom types the freedom to implement their own incrementation semantics.</p>
<p>Note that this does not necessarily return its argument. For example for undefined values, it returns 0:</p>
<pre>my $x;
say $x++;       # 0
say $x;         # 1</pre>
<h2 id="postfix_--"><a class="u" href="#___top" title="go to top of document">postfix --</a></h2>
<pre>multi sub postfix:&lt;--&gt;($x is rw) is assoc&lt;none&gt;</pre>
<p>Decrements its argument by one, and returns the undecremented value.</p>
<pre>my $x = 3;
say $x--;       # 3
say $x;         # 2</pre>
<p>It works by calling the <a href="pred">pred</a> method (for <em>predecessor</em>) on its argument, which gives custom types the freedom to implement their own decrementation semantics.</p>
<p>Note that this does not necessarily return its argument. For example for undefined values, it returns 0:</p>
<pre>my $x;
say $x--;       # 0
say $x;         # -1</pre>
<h1 id="Exponentiation_Precedence"><a class="u" href="#___top" title="go to top of document">Exponentiation Precedence</a></h1>
<h2 id="infix_**"><a class="u" href="#___top" title="go to top of document">infix **</a></h2>
<pre>multi sub infix:&lt;**&gt;(Any, Any) returns Numeric:D is assoc&lt;right&gt;</pre>
<p>The exponentiation operator coerces both arguments to <a href="Numeric">Numeric</a> and calculates the left-hand-side raised to the power of the right-hand side.</p>
<p>If the right-hand side is a non-negative integer and the left-hand side is an arbitrary precision type (<a href="Int">Int</a>, <a href="FatRat">FatRat</a>), then the calculation is carried out without loss of precision.</p>
<h1 id="Symbolic_Unary_Precedence"><a class="u" href="#___top" title="go to top of document">Symbolic Unary Precedence</a></h1>
<h2 id="prefix_?"><a class="u" href="#___top" title="go to top of document">prefix ?</a></h2>
<pre>multi sub prefix:&lt;?&gt;(Mu) returns Bool:D</pre>
<p>Boolean context operator.</p>
<p>Coerces the argument to <a href="Bool">Bool</a> by calling the <code>Bool</code> method on it. Note that this collapses <a href="Junction">Junction</a>s.</p>
<h2 id="prefix_!"><a class="u" href="#___top" title="go to top of document">prefix !</a></h2>
<pre>multi sub prefix:&lt;!&gt;(Mu) returns Bool:D</pre>
<p>Negated boolean context operator.</p>
<p>Coerces the argument to <a href="Bool">Bool</a> by calling the <code>Bool</code> method on it, and returns the negation of the result. Note that this collapses <a href="Junction">Junction</a>s.</p>
<h2 id="prefix_+"><a class="u" href="#___top" title="go to top of document">prefix +</a></h2>
<pre>multi sub prefix:&lt;+&gt;(Any) returns Numeric:D</pre>
<p>Numeric context operator.</p>
<p>Coerces the argument to <a href="Numeric">Numeric</a> by calling the <code>Numeric</code> method on it.</p>
<h2 id="prefix_-"><a class="u" href="#___top" title="go to top of document">prefix -</a></h2>
<pre>multi sub prefix:&lt;-&gt;(Any) returns Numeric:D</pre>
<p>Negative numeric context operator.</p>
<p>Coerces the argument to <a href="Numeric">Numeric</a> by calling the <code>Numeric</code> method on it, and then negates the result.</p>
<h2 id="prefix_~"><a class="u" href="#___top" title="go to top of document">prefix ~</a></h2>
<pre>multi sub prefix:&lt;-&gt;(Any) returns Str:D</pre>
<p>String context operator.</p>
<p>Coerces the argument to <a href="Str">Str</a> by calling the <code>Str</code> method on it.</p>
<h2 id="prefix_|"><a class="u" href="#___top" title="go to top of document">prefix |</a></h2>
<p>Flattens objects of type <a href="Capture">Capture</a>, <a href="Enum">Enum</a>, <a href="Pair">Pair</a>, <a href="List">List</a>, <a href="Parcel">Parcel</a>, <a href="EnumMap">EnumMap</a> and <a href="Hash">Hash</a> into an argument list.</p>
<p>(In Rakudo, this is implemented not as a proper operator but as a special case in the compiler, which means it only works in argument lists, not in arbitrary code).</p>
<h2 id="prefix_+^"><a class="u" href="#___top" title="go to top of document">prefix +^</a></h2>
<pre>multi sub prefix:&lt;+^&gt;(Any) returns Int:D</pre>
<p>Integer bitwise negation.</p>
<p>Coerces the argument to <a href="Int">Int</a> and does a bitwise negation on the result, assuming <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two&#39;s complement</a>.</p>
<h2 id="prefix_?^"><a class="u" href="#___top" title="go to top of document">prefix ?^</a></h2>
<pre>multi sub prefix:&lt;?^&gt;(Mu) returns Bool:D</pre>
<p>Boolean bitwise negation.</p>
<p>Coerces the argument to <a href="Bool">Bool</a> and then does a bit flip, which makes it the same as <code>prefix:&lt;!&gt; </code>.</p>
<h2 id="prefix_^"><a class="u" href="#___top" title="go to top of document">prefix ^</a></h2>
<pre>multi sub prefix:&lt;^&gt;(Any) returns Range:D</pre>
<p><em>upto</em> operator.</p>
<p>Coerces the argument to <a href="Numeric">Numeric</a>, and generates a range from 0 up to (but excluding) the argument.</p>
<pre>say ^5;         # 0..^5
for ^5 { }      # 5 iterations</pre>
<h1 id="Multiplicative_Precedence"><a class="u" href="#___top" title="go to top of document">Multiplicative Precedence</a></h1>
<h2 id="infix_*"><a class="u" href="#___top" title="go to top of document">infix *</a></h2>
<pre>multi sub infix:&lt;*&gt;(Any, Any) returns Numeric:D</pre>
<p>Coerces both arguments to <a href="Numeric">Numeric</a> and multiplies them. The result is of the wider type. See <a href="Numeric">Numeric</a> for details.</p>
<h2 id="infix_/"><a class="u" href="#___top" title="go to top of document">infix /</a></h2>
<pre>multi sub infix:&lt;/&gt;(Any, Any) returns Numeric:D</pre>
<p>Coerces both argument to <a href="Numeric">Numeric</a> and divides the left through the right number. Division of <a href="Int">Int</a> values returns <a href="Rat">Rat</a>, otherwise the &quot;wider type&quot; rule described in <a href="Numeric">Numeric</a> holds.</p>
<h2 id="infix_div"><a class="u" href="#___top" title="go to top of document">infix div</a></h2>
<pre>multi sub infix:&lt;div&gt;(Int:D, Int:D) returns Int:D</pre>
<p>Integer division. Rounds down.</p>
<h2 id="infix_%"><a class="u" href="#___top" title="go to top of document">infix %</a></h2>
<pre>multi sub infix:&lt;%&gt;($x, $y) return Numeric:D</pre>
<p>Modulo operator. Coerces to <a href="Numeric">Numeric</a> first.</p>
<p>Generally the following identity holds:</p>
<pre>$x % $y == $x - floor($x / $y) * $y</pre>
<h2 id="infix_%%"><a class="u" href="#___top" title="go to top of document">infix %%</a></h2>
<pre>multi sub infix:&lt;%%&gt;($a, $b) returns Bool:D</pre>
<p>Divisibility operator. Returns <code>True</code> if <code>$a % $b == 0</code>.</p>
<h2 id="infix_mod"><a class="u" href="#___top" title="go to top of document">infix mod</a></h2>
<pre>multi sub infix:&lt;mod&gt;(Int:D $a, Int:D $b) returns Int:D</pre>
<p>Integer modulo operator. Returns the remainder of an integer modulo operation.</p>
<h2 id="infix_+&"><a class="u" href="#___top" title="go to top of document">infix +&amp;</a></h2>
<pre>multi sub infix:&lt;+&amp;&gt;($a, $b) returns Int:D</pre>
<p>Numeric bitwise <em>AND</em>. Coerces both arguments to <a href="Int">Int</a> and does a bitwise <em>AND</em> operation assuming two&#39;s complement.</p>
<h2 id="infix_+<"><a class="u" href="#___top" title="go to top of document">infix +&lt;</a></h2>
<pre>multi sub infix:&lt;&lt; +&lt; &gt;&gt;($a, $b) returns Int:D</pre>
<p>Integer bit shift to the left.</p>
<h2 id="infix_+>"><a class="u" href="#___top" title="go to top of document">infix +&gt;</a></h2>
<pre>multi sub infix:&lt;&lt; +&gt; &gt;&gt;($a, $b) returns Int:D</pre>
<p>Integer bit shift to the right.</p>
<h2 id="infix_gcd"><a class="u" href="#___top" title="go to top of document">infix gcd</a></h2>
<pre>multi sub infix:&lt;gcd&gt;($a, $b) returns Int:D</pre>
<p>Coerces both arguments to <a href="Int">Int</a> and returns the greatest common denominator.</p>
<h2 id="infix_lcm"><a class="u" href="#___top" title="go to top of document">infix lcm</a></h2>
<pre>multi sub infix:&lt;lcm&gt;($a, $b) returns Int:D</pre>
<p>Coerces both arguments to <a href="Int">Int</a> and returns the least common multiple, that is the smallest integer that is smallest integer that is evenly divisible by both arguments.</p>
<h1 id="Additive_Precedence"><a class="u" href="#___top" title="go to top of document">Additive Precedence</a></h1>
<h2 id="infix_+"><a class="u" href="#___top" title="go to top of document">infix +</a></h2>
<pre>multi sub infix:&lt;+&gt;($a, $b) returns Numeric:D</pre>
<p>Coerces both arguments to <a href="Numeric">Numeric</a> and adds them.</p>
<h2 id="infix_-"><a class="u" href="#___top" title="go to top of document">infix -</a></h2>
<pre>multi sub infix:&lt;-&gt;($a, $b) returns Numeric:D</pre>
<p>Coerces both arguments to <a href="Numeric">Numeric</a> and subtracts the second from the first.</p>
<h2 id="infix_+|"><a class="u" href="#___top" title="go to top of document">infix +|</a></h2>
<pre>multi sub infix:&lt;+|&gt;($a, $b) returns Int:D</pre>
<p>Coerces both arguments to <a href="Int">Int</a> and does a bitwise <em>OR</em> (inclusive OR) operation.</p>
<h2 id="infix_+^"><a class="u" href="#___top" title="go to top of document">infix +^</a></h2>
<pre>multi sub infix:&lt;+^&gt;($a, $b) returns Int:D</pre>
<p>Coerces both arguments to <a href="Int">Int</a> and does a bitwise <em>XOR</em> (exclusive OR) operation.</p>
<h2 id="infix_?|"><a class="u" href="#___top" title="go to top of document">infix ?|</a></h2>
<pre>multi sub infix:&lt;?|&gt;($a, $b) returns Bool:D</pre>
<p>Coerces both arguments to <a href="Bool">Bool</a> and does a logical <em>OR</em> (inclusive OR) operation.</p>
<h1 id="Replication_Precedence"><a class="u" href="#___top" title="go to top of document">Replication Precedence</a></h1>
<h2 id="infix_x"><a class="u" href="#___top" title="go to top of document">infix x</a></h2>
<pre>proto sub infix:&lt;x&gt;(Any, Any) returns Str:D
multi sub infix:&lt;x&gt;(Any, Any)
multi sub infix:&lt;x&gt;(Str:D, Int:D)</pre>
<p>Coerces <code>$a</code> to <a href="Str">Str</a> and <code>$b</code> to <a href="Int">Int</a> and repeats the string <code>$b</code> times. Return the empty string if <code>$b &lt;= 0 </code>.</p>
<pre>say &#39;ab&#39; x 3;       # ababab
say 42 x 3;         # 424242</pre>
<h2 id="infix_xx"><a class="u" href="#___top" title="go to top of document">infix xx</a></h2>
<pre>multi sub infix:&lt;xx&gt;($a, $b) returns List:D</pre>
<p>Returns a list of <code>$a</code> repeated and evaluated <code>$b</code> times (<code>$b</code> is coerced to <a href="Int">Int</a>). If <code>$b &lt;= 0 </code>, the empty list is returned.</p>
<p>The left-hand side is evaluated for each repetition, so</p>
<pre>[1, 2] xx 5</pre>
<p>returns five distinct arrays (but with the same content each time), and</p>
<pre>rand xx 3</pre>
<p>returns three pseudo random numbers that are determined independently.</p>
<p>The right-hand side can be <code>*</code>, in which case a lazy, infinite list is returned.</p>
<h1 id="Concatenation"><a class="u" href="#___top" title="go to top of document">Concatenation</a></h1>
<h2 id="infix_~"><a class="u" href="#___top" title="go to top of document">infix ~</a></h2>
<pre>proto sub infix:&lt;~&gt;(Any, Any) returns Str:D
multi sub infix:&lt;~&gt;(Any,   Any)
multi sub infix:&lt;~&gt;(Str:D, Str:D)</pre>
<p>Coerces both arguments to <a href="Str">Str</a> and concatenates them.</p>
<pre>say &#39;ab&#39; ~ &#39;c&#39;;     # abc</pre>
<h1 id="Junctive_AND_(all)_Precedence"><a class="u" href="#___top" title="go to top of document">Junctive AND (all) Precedence</a></h1>
<h2 id="infix_&"><a class="u" href="#___top" title="go to top of document">infix &amp;</a></h2>
<pre>multi sub infix:&lt;&amp;&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;</pre>
<p>Creates an <em>all</em> <a href="Junction">Junction</a> from its arguments. See <a href="Junction">Junction</a> for more details.</p>
<h1 id="Junctive_OR_(any)_Precedence"><a class="u" href="#___top" title="go to top of document">Junctive OR (any) Precedence</a></h1>
<h2 id="infix_|"><a class="u" href="#___top" title="go to top of document">infix |</a></h2>
<pre>multi sub infix:&lt;|&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;</pre>
<p>Creates an <em>any</em> <a href="Junction">Junction</a> from its arguments. See <a href="Junction">Junction</a> for more details.</p>
<h2 id="infix_^"><a class="u" href="#___top" title="go to top of document">infix ^</a></h2>
<pre>multi sub infix:&lt;^&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;</pre>
<p>Creates a <em>one</em> <a href="Junction">Junction</a> from its arguments. See <a href="Junction">Junction</a> for more details.</p>
<h1 id="Named_Unary_Precedence"><a class="u" href="#___top" title="go to top of document">Named Unary Precedence</a></h1>
<h2 id="prefix_temp"><a class="u" href="#___top" title="go to top of document">prefix temp</a></h2>
<pre>sub prefix:&lt;temp&gt;(Mu $a is rw)</pre>
<p>&quot;temporizes&quot; the variable passed as the argument, which means it is reset to its old value on scope exit. (This is similar to the <a href="http://perldoc.perl.org/functions/local.html">local</a> operator in Perl 5, except that <code>temp</code> does not reset the value).</p>
<h2 id="prefix_let"><a class="u" href="#___top" title="go to top of document">prefix let</a></h2>
<pre>sub prefix:&lt;let&gt;(Mu $a is rw)</pre>
<p>Hypothetical reset: if the current scope is exited either through an exception or <code>fail()</code>, the old value is restored.</p>
<h1 id="Nonchaining_Binary_Precedence"><a class="u" href="#___top" title="go to top of document">Nonchaining Binary Precedence</a></h1>
<h2 id="infix_does"><a class="u" href="#___top" title="go to top of document">infix does</a></h2>
<pre>sub infix:&lt;does&gt;(Mu $obj, Mu $role) is assoc&lt;none&gt;</pre>
<p>Mixes <code>$role</code> into <code>$obj</code> at run time. Requires <code>$obj</code> to be mutable.</p>
<p><code>$role</code> doesn&#39;t need to a be a role, it can be something that knows how to act like a role, for example enum values.</p>
<h2 id="infix_but"><a class="u" href="#___top" title="go to top of document">infix but</a></h2>
<pre>sub infix:&lt;but&gt;(Mu $obj, Mu $role) is assoc&lt;none&gt;</pre>
<p>Creates a copy of <code>$obj</code> with <code>$role</code> mixed in. Since <code>$obj</code> is not modified, <code>but</code> can be used to created immutable values with mixins.</p>
<p><code>$role</code> doesn&#39;t need to a be a role, it can be something that knows how to act like a role, for example enum values.</p>
<h2 id="infix_cmp"><a class="u" href="#___top" title="go to top of document">infix cmp</a></h2>
<pre>proto sub infix:&lt;cmp&gt;(Any, Any) returns Order:D is assoc&lt;none&gt;
multi sub infix:&lt;cmp&gt;(Any,       Any)
multi sub infix:&lt;cmp&gt;(Real:D,    Real:D)
multi sub infix:&lt;cmp&gt;(Str:D,     Str:D)
multi sub infix:&lt;cmp&gt;(Enum:D,    Enum:D)
multi sub infix:&lt;cmp&gt;(Version:D, Version:D)</pre>
<p>Generic, &quot;smart&quot; three-way comparator.</p>
<p>Compares strings with string semantics, numbers with number semantics, <a href="Pair">Pair</a> objects first by key and then by value etc.</p>
<p>if <code>$a eqv $b</code>, then <code>$a cmp $b</code> always returns <code>Order::Same</code>.</p>
<pre>say (a =&gt; 3) cmp (a =&gt; 4);      # Less
say 4        cmp 4.0;           # Same
say &#39;b&#39;      cmp &#39;a&#39;;           # More</pre>
<h2 id="infix_leg"><a class="u" href="#___top" title="go to top of document">infix leg</a></h2>
<pre>proto sub infix:&lt;leg&gt;($a, $b) returns Order:D is assoc&lt;none&gt;
multi sub infix:&lt;leg&gt;(Any,   Any)
multi sub infix:&lt;leg&gt;(Str:D, Str:D)</pre>
<p>String three-way comparator.</p>
<p>Coerces both arguments to <a href="Str">Str</a>, and then does a lexicographic comparison.</p>
<h2 id="infix_<=>"><a class="u" href="#___top" title="go to top of document">infix &lt;=&gt;</a></h2>
<pre>multi sub infix:«&lt;=&gt;»($a, $b) returns Order:D is assoc&lt;none&gt;</pre>
<p>Numeric three-way comparator.</p>
<p>Coerces both arguments to <a href="Real">Real</a>, and then does a numeric comparison.</p>
<h2 id="infix_.."><a class="u" href="#___top" title="go to top of document">infix ..</a></h2>
<pre>multi sub infix:&lt;..&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</pre>
<p>Constructs a <a href="Range">Range</a> from the arguments.</p>
<h2 id="infix_..^"><a class="u" href="#___top" title="go to top of document">infix ..^</a></h2>
<pre>multi sub infix:&lt;..^&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</pre>
<p>Constructs a <a href="Range">Range</a> from the arguments, excluding the end point.</p>
<h2 id="infix_^.."><a class="u" href="#___top" title="go to top of document">infix ^..</a></h2>
<pre>multi sub infix:&lt;^..&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</pre>
<p>Constructs a <a href="Range">Range</a> from the arguments, excluding the start point.</p>
<h2 id="infix_^..^"><a class="u" href="#___top" title="go to top of document">infix ^..^</a></h2>
<pre>multi sub infix:&lt;^..^&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</pre>
<p>Constructs a <a href="Range">Range</a> from the arguments, excluding both start and end point.</p>
<h1 id="Chaining_Binary_Precedence"><a class="u" href="#___top" title="go to top of document">Chaining Binary Precedence</a></h1>
<h2 id="infix_=="><a class="u" href="#___top" title="go to top of document">infix ==</a></h2>
<pre>proto sub infix:&lt;==&gt;($, $) returns Bool:D is assoc:&lt;chain&gt;
multi sub infix:&lt;==&gt;(Any, Any)
multi sub infix:&lt;==&gt;(Int:D, Int:D)
multi sub infix:&lt;==&gt;(Num:D, Num:D)
multi sub infix:&lt;==&gt;(Rational:D, Rational:D)
multi sub infix:&lt;==&gt;(Real:D, Real:D)
multi sub infix:&lt;==&gt;(Complex:D, Complex:D)
multi sub infix:&lt;==&gt;(Numeric:D, Numeric:D)</pre>
<p>Coerces both arguments to <a href="Numeric">Numeric</a> if necessary, and returns <code>True</code> if they are equal.</p>
<h2 id="infix_!="><a class="u" href="#___top" title="go to top of document">infix !=</a></h2>
<pre>proto sub infix:&lt;!=&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;</pre>
<p>Coerces both arguments to <a href="Numeric">Numeric</a> (if necessary), and returns <code>True</code> if they are distinct.</p>
<h2 id="infix_<"><a class="u" href="#___top" title="go to top of document">infix &lt;</a></h2>
<pre>proto sub infix:«&lt;»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&lt;»(Int:D, Int:D)
multi sub infix:«&lt;»(Num:D, Num:D)
multi sub infix:«&lt;»(Real:D, Real:D)</pre>
<p>Coerces both arguments to <a href="Real">Real</a> (if necessary), and returns <code>True</code> if the first argument is smaller than the second.</p>
<h2 id="infix_<="><a class="u" href="#___top" title="go to top of document">infix &lt;=</a></h2>
<pre>proto sub infix:«&lt;=»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&lt;=»(Int:D, Int:D)
multi sub infix:«&lt;=»(Num:D, Num:D)
multi sub infix:«&lt;=»(Real:D, Real:D)</pre>
<p>Coerces both arguments to <a href="Real">Real</a> (if necessary), and returns <code>True</code> if the first argument is smaller than or equal to the second.</p>
<h2 id="infix_>"><a class="u" href="#___top" title="go to top of document">infix &gt;</a></h2>
<pre>proto sub infix:«&gt;»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&gt;»(Int:D, Int:D)
multi sub infix:«&gt;»(Num:D, Num:D)
multi sub infix:«&gt;»(Real:D, Real:D)</pre>
<p>Coerces both arguments to <a href="Real">Real</a> (if necessary), and returns <code>True</code> if the first argument is larger than the second.</p>
<h2 id="infix_>="><a class="u" href="#___top" title="go to top of document">infix &gt;=</a></h2>
<pre>proto sub infix:«&gt;=»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&gt;=»(Int:D, Int:D)
multi sub infix:«&gt;=»(Num:D, Num:D)
multi sub infix:«&gt;=»(Real:D, Real:D)</pre>
<p>Coerces both arguments to <a href="Real">Real</a> (if necessary), and returns <code>True</code> if the first argument is larger than or equal to the second.</p>
<h2 id="infix_eq"><a class="u" href="#___top" title="go to top of document">infix eq</a></h2>
<pre>proto sub infix:&lt;eq&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;eq&gt;(Any,   Any)
multi sub infix:&lt;eq&gt;(Str:D, Str:D)</pre>
<p>Coerces both arguments to <a href="Str">Str</a> (if necessary), and returns <code>True</code> if both are equal.</p>
<p>Mnemonic: <em>equal</em></p>
<h2 id="infix_ne"><a class="u" href="#___top" title="go to top of document">infix ne</a></h2>
<pre>proto sub infix:&lt;ne&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;ne&gt;(Mu,    Mu)
multi sub infix:&lt;ne&gt;(Str:D, Str:D)</pre>
<p>Coerces both arguments to <a href="Str">Str</a> (if necessary), and returns <code>False</code> if both are equal.</p>
<p>Mnemonic: <em>not equal</em></p>
<h2 id="infix_gt"><a class="u" href="#___top" title="go to top of document">infix gt</a></h2>
<pre>proto sub infix:&lt;gt&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;gt&gt;(Mu,    Mu)
multi sub infix:&lt;gt&gt;(Str:D, Str:D)</pre>
<p>Coerces both arguments to <a href="Str">Str</a> (if necessary), and returns <code>True</code> if the first is larger than the second, as determined by lexicographic comparison.</p>
<p>Mnemonic: <em>greater than</em></p>
<h2 id="infix_ge"><a class="u" href="#___top" title="go to top of document">infix ge</a></h2>
<pre>proto sub infix:&lt;ge&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;ge&gt;(Mu,    Mu)
multi sub infix:&lt;ge&gt;(Str:D, Str:D)</pre>
<p>Coerces both arguments to <a href="Str">Str</a> (if necessary), and returns <code>True</code> if the first is equal to or larger than the second, as determined by lexicographic comparison.</p>
<p>Mnemonic: <em>greater or equal</em></p>
<h2 id="infix_lt"><a class="u" href="#___top" title="go to top of document">infix lt</a></h2>
<pre>proto sub infix:&lt;lt&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;lt&gt;(Mu,    Mu)
multi sub infix:&lt;lt&gt;(Str:D, Str:D)</pre>
<p>Coerces both arguments to <a href="Str">Str</a> (if necessary), and returns <code>True</code> if the first is smaller than the second, as determined by lexicographic comparison.</p>
<p>Mnemonic: <em>less than</em></p>
<h2 id="infix_le"><a class="u" href="#___top" title="go to top of document">infix le</a></h2>
<pre>proto sub infix:&lt;le&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;le&gt;(Mu,    Mu)
multi sub infix:&lt;le&gt;(Str:D, Str:D)</pre>
<p>Coerces both arguments to <a href="Str">Str</a> (if necessary), and returns <code>True</code> if the first is equal to or smaller than the second, as determined by lexicographic comparison.</p>
<p>Mnemonic: <em>less or equal</em></p>
<h2 id="infix_before"><a class="u" href="#___top" title="go to top of document">infix before</a></h2>
<pre>proto sub infix:&lt;before&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;before&gt;(Any,       Any)
multi sub infix:&lt;before&gt;(Real:D,    Real:D)
multi sub infix:&lt;before&gt;(Str:D,     Str:D)
multi sub infix:&lt;before&gt;(Enum:D,    Enum:D)
multi sub infix:&lt;before&gt;(Version:D, Version:D)</pre>
<p>Generic ordering, uses the same semantics as <a href="#infix_cmp">cmp</a>. Returns <code>True</code> if the first argument is smaller than the second.</p>
<h2 id="infix_after"><a class="u" href="#___top" title="go to top of document">infix after</a></h2>
<pre>proto sub infix:&lt;after&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;after&gt;(Any,       Any)
multi sub infix:&lt;after&gt;(Real:D,    Real:D)
multi sub infix:&lt;after&gt;(Str:D,     Str:D)
multi sub infix:&lt;after&gt;(Enum:D,    Enum:D)
multi sub infix:&lt;after&gt;(Version:D, Version:D)</pre>
<p>Generic ordering, uses the same semantics as <a href="#infix_cmp">cmp</a>. Returns <code>True</code> if the first argument is larger than the second.</p>
<h2 id="infix_eqv"><a class="u" href="#___top" title="go to top of document">infix eqv</a></h2>
<pre>proto sub infix:&lt;eqv&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
proto sub infix:&lt;eqv&gt;(Any, Any)</pre>
<p>Equivalence operator. Returns <code>True</code> if the two arguments are structurally the same, i.e. from the same type and (recursively) contain the same values.</p>
<h2 id="infix_==="><a class="u" href="#___top" title="go to top of document">infix ===</a></h2>
<pre>proto sub infix:&lt;===&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
proto sub infix:&lt;===&gt;(Any, Any)</pre>
<p>Value identity. Returns <code>True</code> if both arguments are the same object.</p>
<pre>class A { };
my $a = A.new;
say $a === $a;              # True
say A.new === A.new;        # False
say A === A;                # True</pre>
<p>For value types, <code>===</code> behaves like <code>eqv</code>:</p>
<pre>say &#39;a&#39; === &#39;a&#39;;            # True
say &#39;a&#39; === &#39;b&#39;;            # False</pre>
<pre># different types
say 1 === 1.0;              # False</pre>
<p><code>===</code> uses the <a href="WHICH">WHICH</a> method to obtain the object identity, so all value types must override method <code>WHICH</code>.</p>
<h2 id="infix_=:="><a class="u" href="#___top" title="go to top of document">infix =:=</a></h2>
<pre>proto sub infix:&lt;=:=&gt;(Mu $a is rw, Mu $b is rw) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;=:=&gt;(Mu $a is rw, Mu $b is rw)</pre>
<p>Container identity. Returns <a href="True">True</a> if both arguments are bound to the same container.</p>
<h2 id="infix_~~"><a class="u" href="#___top" title="go to top of document">infix ~~</a></h2>
<p>The smart-match operator. Aliases the left-hand side to <code>$_</code>, then evaluates the right-hand side, and calls <code>.ACCEPTS($_)</code> on it. The semantics are left to the type of the right-hand side operand.</p>
<p>Here is an excerpt of built-in smart-matching functionality:</p>
<table>
<tbody>
<tr>
<td>Right-hand side Comparison semantics</td>
<td>Right-hand side</td>
<td>Comparison semantics</td>
</tr>
<tr>
<td>=============== ====================</td>
<td>===============</td>
<td>====================</td>
</tr>
<tr>
<td>Mu:U type check</td>
<td>Mu:U</td>
<td>type check</td>
</tr>
<tr>
<td>Str string equality</td>
<td>Str</td>
<td>string equality</td>
</tr>
<tr>
<td>Numeric numeric equality</td>
<td>Numeric</td>
<td>numeric equality</td>
</tr>
<tr>
<td>Regex regex match</td>
<td>Regex</td>
<td>regex match</td>
</tr>
<tr>
<td>Callable boolean result of invocation</td>
<td>Callable</td>
<td>boolean result of invocation</td>
</tr>
<tr>
<td>Any:D object identity</td>
<td>Any:D</td>
<td>object identity</td>
</tr>
</tbody>
</table><h1 id="Tight_AND_Precedence"><a class="u" href="#___top" title="go to top of document">Tight AND Precedence</a></h1>
<h2 id="infix_&&"><a class="u" href="#___top" title="go to top of document">infix &amp;&amp;</a></h2>
<p>Returns the first argument that evaluates to <code>False</code> in boolean context, or otherwise the last argument.</p>
<p>Note that this short-circuits, i.e. if one of the arguments evaluates to a false value, the arguments to the right of are never evaluated.</p>
<pre>sub a { 1 }
sub b { 0 }
sub c { die &quot;never called&quot; };
say a() &amp;&amp; b() &amp;&amp; c();      # 0</pre>
<h1 id="Tight_OR_Precedence"><a class="u" href="#___top" title="go to top of document">Tight OR Precedence</a></h1>
<h2 id="infix_||"><a class="u" href="#___top" title="go to top of document">infix ||</a></h2>
<p>Returns the first argument that evaluates to <code>True</code> in boolean context, or otherwise the last argument.</p>
<p>Note that this short-circuits, i.e. if one of the arguments evaluates to a true value, the arguments to the right of are never evaluated.</p>
<pre>sub a { 0 }
sub b { 1 }
sub c { die &quot;never called&quot; };
say a() || b() || c();      # 1</pre>
<h2 id="infix_^^"><a class="u" href="#___top" title="go to top of document">infix ^^</a></h2>
<p>Returns the first true argument if there is only one, and <a href="Nil">Nil</a> otherwise. Short-circuits as soon as two true arguments are found.</p>
<pre>say 0 ^^ 42;                # 42
say 0 ^^ 42 ^^ 1 ^^ die 8;  # (empty line)</pre>
<h2 id="infix_//"><a class="u" href="#___top" title="go to top of document">infix //</a></h2>
<p>Defined-or operator. Returns the first defined operand. Short-circuits.</p>
<pre>say Any // 0 // 42;         # 0</pre>
<h2 id="infix_min"><a class="u" href="#___top" title="go to top of document">infix min</a></h2>
<p>Returns the smallest of the arguments, as determined by <a href="cmp">cmp</a> semantics.</p>
<pre>$foo min= 0  # read as: $foo decreases to 0</pre>
<h2 id="infix_max"><a class="u" href="#___top" title="go to top of document">infix max</a></h2>
<p>Returns the largest of the arguments, as determined by <a href="cmp">cmp</a> semantics.</p>
<pre>$foo max= 0  # read as: $foo increases to 0</pre>
<h1 id="Conditional_Operator_Precedence"><a class="u" href="#___top" title="go to top of document">Conditional Operator Precedence</a></h1>
<h2 id="infix_??_!!"><a class="u" href="#___top" title="go to top of document">infix ?? !!</a></h2>
<p>Ternary operator, conditional operator.</p>
<p><code>$condition ?? $true !! $false</code> evaluates and returns the expression from the <code>$true</code> branch if <code>$condition</code> is a true value. Otherwise it evaluates and returns the <code>$false</code> branch.</p>
<p># TODO: ff, ^ff, ff^, ^ff^, fff, ^fff, fff^, ^fff^</p>
<h1 id="Item_Assignment_Precedence"><a class="u" href="#___top" title="go to top of document">Item Assignment Precedence</a></h1>
<h2 id="infix_="><a class="u" href="#___top" title="go to top of document">infix =</a></h2>
<pre>sub infix:&lt;=&gt;(Mu $a is rw, Mu $b)</pre>
<p>Item assignment.</p>
<p>Places the value of the right-hand side into the container on the left-hand side. Its exact semantics are left to the container type on the left-hand side.</p>
<p>(Note that item assignment and list assignment have different precedence levels, and the syntax of the left-hand side decides whether an equal sign <code>=</code> is parsed as item assignment or list assignment operator).</p>
<h2 id="infix_=>"><a class="u" href="#___top" title="go to top of document">infix =&gt;</a></h2>
<pre>sub infix:«=&gt;»($key, Mu $value) returns Pair:D</pre>
<p><a href="Pair">Pair</a> constructor.</p>
<p>Constructs a <a href="Pair">Pair</a> object with the left-hand side as the key and the right-hand side as the value.</p>
<p>Note that the <code>=&gt; </code> operator is syntactically special-cased, in that it allows unquoted identifier on the left-hand side.</p>
<pre>my $p = a =&gt; 1;
say $p.key;         # a
say $p.value;       # 1</pre>
<p>A <a href="Pair">Pair</a> within an argument list with an unquoted identifier on the left is interpreted as a named argument.</p>
<p>See <a href="/language/terms#Pair">the Terms language documentation</a> for more ways to create <code>Pair</code> objects.</p>
<h1 id="Loose_Unary_Precedence"><a class="u" href="#___top" title="go to top of document">Loose Unary Precedence</a></h1>
<h2 id="prefix_not"><a class="u" href="#___top" title="go to top of document">prefix not</a></h2>
<pre>multi sub prefix:&lt;not&gt;(Mu $x) returns Bool:D</pre>
<p>Evaluates its argument in boolean context (and thus collapses <a href="Junction">Junction</a>s), and negates the result.</p>
<h2 id="prefix_so"><a class="u" href="#___top" title="go to top of document">prefix so</a></h2>
<pre>multi sub prefix:&lt;so&gt;(Mu $x) returns Bool:D</pre>
<p>Evaluates its argument in boolean context (and thus collapses <a href="Junction">Junction</a>s), and returns the result.</p>
<h1 id="Comma_Operator_Precedence"><a class="u" href="#___top" title="go to top of document">Comma Operator Precedence</a></h1>
<h2 id="infix_,"><a class="u" href="#___top" title="go to top of document">infix ,</a></h2>
<pre>sub infix:&lt;,&gt;(*@a) is assoc&lt;list&gt; returns Parcel:D</pre>
<p>Constructs a <a href="Parcel">Parcel</a> from its arguments. Also used syntactically as the separator of arguments in calls.</p>
<h2 id="infix_:"><a class="u" href="#___top" title="go to top of document">infix :</a></h2>
<p>Used as an argument separator just like infix <code>,</code> and marks the argument to its left as the invocant. That turns what would otherwise be a function call into a method call.</p>
<pre>substr(&#39;abc&#39;: 1);       # same as &#39;abc&#39;.substr(1)</pre>
<p>Infix <code>:</code> is only allowed after the first argument of a non-method call. In other positions it is a syntax error.</p>
<h1 id="List_Infix_Precedence"><a class="u" href="#___top" title="go to top of document">List Infix Precedence</a></h1>
<h2 id="infix_Z"><a class="u" href="#___top" title="go to top of document">infix Z</a></h2>
<pre>sub infix:&lt;Z&gt;(**@lists) returns List:D is assoc&lt;chain&gt;</pre>
<p>Zip operator.</p>
<p>Interleaves the lists passed to <code>Z</code> like a zipper, stopping as soon as the first input list is exhausted:</p>
<pre>say (1, 2 Z &lt;a b c&gt; Z &lt;+ -&gt;).perl;  # ((1, &quot;a&quot;, &quot;+&quot;), (2, &quot;b&quot;, &quot;-&quot;)).list</pre>
<p>The <code>Z</code> operator also exists as a meta operator, in which case the inner parcels are replaced by the value from applying the meta&#39;ed operator to the list:</p>
<pre>say 100, 200 Z+ 42, 23;             # 142, 223
say 1..3 Z~ &lt;a b c&gt; Z~ &#39;x&#39; xx 3;    # 1ax 2bx 3cx</pre>
<h2 id="infix_X"><a class="u" href="#___top" title="go to top of document">infix X</a></h2>
<pre>sub infix:&lt;X&gt;(**@lists) returns List:D is assoc&lt;chain&gt;</pre>
<p>Creates a cross product from all the lists, order so that the rightmost elements vary most rapidly</p>
<pre>1..3 X &lt;a b c&gt; X 9
# produces   (1, &#39;a&#39;, 9), (1, &#39;b&#39;, 9), (1, &#39;c&#39;, 9),
             (2, &#39;a&#39;, 9), (2, &#39;b&#39;, 9), (2, &#39;c&#39;, 9),
             (3, &#39;a&#39;, 9), (3, &#39;b&#39;, 9), (3, &#39;c&#39;, 9)</pre>
<p>The <code>X</code> operator also exists as a meta operator, in which case the inner parcels are replaced by the value from applying the meta&#39;ed operator to the list:</p>
<pre>1..3 X~ &lt;a b c&gt; X~ 9
# produces   &#39;1a9&#39;, &#39;1b9&#39;, &#39;1c9&#39;,
             &#39;2a9&#39;, &#39;2b9&#39;, &#39;2c9&#39;,
             &#39;3a9&#39;, &#39;3b9&#39;, &#39;3c9&#39;</pre>
<h2 id="infix_..."><a class="u" href="#___top" title="go to top of document">infix ...</a></h2>
<pre>multi sub infix:&lt;...&gt;(**@) is assoc&lt;list&gt;
multi sub infix:&lt;...^&gt;(**@) is assoc&lt;list&gt;</pre>
<p>The sequence operator is a generic operator to produce lazy lists.</p>
<p>It can have initial elements and a generator on left-hand side, and an endpoint on the right-hand side.</p>
<p>The sequence operator invokes the generator with as many arguments as necessary. The arguments are taken from the initial elements and the already generated elements.</p>
<p>The default generator is <code>*.</code><a href="succ">succ</a> or <code>*.</code><a href="pred">pred</a>, depending on how the end points compare:</p>
<pre>say 1 ... 4;        # 1 2 3 4
say 4 ... 1;        # 4 3 2 1
say &#39;a&#39; ... &#39;e&#39;;    # a b c d e
say &#39;e&#39; ... &#39;a&#39;;    # e d c b a</pre>
<p>An endpoint of <code>*</code> (<a href="Whatever">Whatever</a>) generates an infinite sequence, with a default generator of *.succ</p>
<pre>say (1 ... *)[^5];  # 1 2 3 4 5</pre>
<p>Custom generators are the last argument before the &#39;...&#39; operator. This one takes two arguments, and generates the Fibonacci numbers</p>
<pre>say (1, 1, -&gt; $a, $b { $a + $b } ... *)[^8];    # 1 1 2 3 5 8 13 21
# same but shorter
say (1, 1, *+* ... *)[^8];                      # 1 1 2 3 5 8 13 21</pre>
<p>Of course the generator can also take only one argument.</p>
<pre>say 5, { $_ * 2 } ... 40;                       # 5 10 20 40</pre>
<p>There must be at least as many initial elements as arguments to the generator.</p>
<p>Without a generator, and more than one initial element, and all initial elements numeric, the sequence operator tries to deduce the generator. It knows about arithmetic and geometric sequences.</p>
<pre>say 2, 4, 6 ... 12;     # 2 4 6 8 10 12
say 1, 2, 4 ... 32;     # 1 2 4 8 16 32</pre>
<p>If the endpoint is not <code>*</code>, it is smart-matched against each generated element, and the sequence is terminated when the smart-match succeeded. For the <code>...</code> operator, the final element is included, for the <code>...^</code> operator it is excluded.</p>
<p>This allows you to write</p>
<pre>say 1, 1, *+* ...^ *&gt;= 100;</pre>
<p>To generate all Fibonacci numbers up to but excluding 100.</p>
<p>The <code>...</code> operators consider the initial values as &quot;generated elements&quot; as well, so the are also checked against the endpoint:</p>
<pre>my $end = 4;
say 1, 2, 4, 8, 16 ... $end;
# outputs 1 2 4</pre>
<h1 id="List_Prefix_Precedence"><a class="u" href="#___top" title="go to top of document">List Prefix Precedence</a></h1>
<h2 id="infix_="><a class="u" href="#___top" title="go to top of document">infix =</a></h2>
<p>List assignment. Its exact semantics are left to the container type on the left-hand side. See <a href="Array">Array</a> and <a href="Hash">Hash</a> for common cases.</p>
<p>The distinction between item assignment and list assignment is determined by the parser depending on the syntax of the left-hand side.</p>
<h2 id="infix_:="><a class="u" href="#___top" title="go to top of document">infix :=</a></h2>
<p>Binding. Whereas <code>$x = $y</code> puts the value in <code>$y</code> into <code>$x</code>, <code>$x := $y</code> makes <code>$x</code> and <code>$y</code> the same thing.</p>
<pre>    my $a = 42;
    my $b <strong>=</strong> $a;
    $b<a href="++">++</a>;
    say $a;
</pre>
<p>This will output 42, because <code>$a</code> and <code>$b</code> both contained the number <code>42</code>, but the <a href="/language/containters.html#Binding">containers</a> were different.</p>
<pre>    my $a = 42;
    my $b <strong>:=</strong> $a;
    $b<a href="++">++</a>;
    say $a;
</pre>
<p>This will output 43, since <code>$b</code> and <code>$a</code> both represented the same object.</p>
<h2 id="infix_::="><a class="u" href="#___top" title="go to top of document">infix ::=</a></h2>
<p>Read-only binding. See <a href=":="><code>infix :=</code></a>.</p>
<h2 id="listop_..."><a class="u" href="#___top" title="go to top of document">listop ...</a></h2>
<p>The <em>yada, yada, yada</em> operator or <em>stub</em> operator. If it is the only statement in a routine or type, it marks that routine or type as a stub (which is significant in the context of pre-declaring types and composing roles).</p>
<p>If the <code>...</code> statement is executed, it calls <a href="&fail">&amp;fail</a>, with the default message <code>stub code executed</code>.</p>
<h2 id="listop_!!!"><a class="u" href="#___top" title="go to top of document">listop !!!</a></h2>
<p>If it is the only statement in a routine or type, it marks that routine or type as a stub (which is significant in the context of pre-declaring types and composing roles).</p>
<p>If the <code>!!!</code> statement is executed, it calls <a href="&die">&amp;die</a>, with the default message <code>stub code executed</code>.</p>
<h2 id="listop_???"><a class="u" href="#___top" title="go to top of document">listop ???</a></h2>
<p>If it is the only statement in a routine or type, it marks that routine or type as a stub (which is significant in the context of pre-declaring types and composing roles).</p>
<p>If the <code>???</code> statement is executed, it calls <a href="&warn">&amp;warn</a>, with the default message <code>stub code executed</code>.</p>
<h1 id="Loose_AND_precedence"><a class="u" href="#___top" title="go to top of document">Loose AND precedence</a></h1>
<h2 id="infix_and"><a class="u" href="#___top" title="go to top of document">infix and</a></h2>
<p>Same as <a href="#infix_%26%26">infix &amp;&amp;</a>, except with looser precedence.</p>
<p>Returns the first operand that evaluates to <code>False</code> in boolean context, or otherwise the last operand. Short-circuits.</p>
<h2 id="infix_andthen"><a class="u" href="#___top" title="go to top of document">infix andthen</a></h2>
<p>Returns the first undefined argument, otherwise the last argument. Short-circuits.</p>
<h1 id="Loose_OR_Precedence"><a class="u" href="#___top" title="go to top of document">Loose OR Precedence</a></h1>
<h2 id="infix_or"><a class="u" href="#___top" title="go to top of document">infix or</a></h2>
<p>Same as <code>infix ||</code>, except with looser precedence.</p>
<p>Returns the first argument that evaluates to <code>True</code> in boolean context, or otherwise the last argument. Short-circuits.</p>
<h2 id="infix_orelse"><a class="u" href="#___top" title="go to top of document">infix orelse</a></h2>
<p>Same as <code>infix //</code>, except with looser precedence.</p>
<p>Returns the first defined argument, or else the last argument. Short-circuits.</p>



</body>
</html>

