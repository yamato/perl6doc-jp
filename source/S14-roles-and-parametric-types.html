<!DOCTYPE html>
<html lang="ja">
<head>
<title>S14-roles-and-parametric-types</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Aug 30 10:16:51 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Roles'>Roles</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Compile-time_Composition'>Compile-time Composition</a>
    <li class='indexItem indexItem2'><a href='#Run-time_Mixins'>Run-time Mixins</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Traits'>Traits</a>
  <li class='indexItem indexItem1'><a href='#Parametric_Roles'>Parametric Roles</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Relationship_Between_of_And_Types'>Relationship Between of And Types</a>
    <li class='indexItem indexItem2'><a href='#Parametric_Subtyping'>Parametric Subtyping</a>
    <li class='indexItem indexItem2'><a href='#Interaction_of_typed_and_untyped_data_structures'>Interaction of typed and untyped data structures</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 14: Roles and Parametric Types [DRAFT]</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Larry Wall &#60;larry@wall.org&#62;
Tim Nelson &#60;wayland@wayland.id.au&#62;
Jonathan Worthington &#60;jnthn@jnthn.net&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 24 Feb 2009 (extracted from S12-objects.pod)

Last Modified: 24 Nov 2012
Version: 11</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis discusses roles and parametric types, which were originally discussed in A12.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Roles"
>Roles</a></h1>

<p>Classes are primarily in charge of object management, and only secondarily in charge of software reuse. In Perl 6, roles take over the job of managing software reuse. Depending on how you care to look at it, a role is like a partial class, or an interface with default implementation, or a set of generic methods and their associated data, or a class closed at compile time.</p>

<p>Roles may be composed into a class at compile time, in which case you get automatic detection of conflicting methods. A role may also be mixed into a class or object at run time to produce an anonymous derived class with extra capabilities, but in this case conflicting methods are overridden by the new role silently. In either case, a class is necessary for instantiation--a role may not be directly instantiated.</p>

<p>A role is declared like a class, but with a <code>role</code> keyword:</p>

<pre><code>role Pet {
    method feed ($food) {
        $food.open_can;
        $food.put_in_bowl;
        self.eat($food);
    }
}</code></pre>

<p>A role may not inherit from a class, but may be composed of other roles. However, this &#34;crony&#34; composition is not evaluated until class composition time. This means that if two roles bring in the same crony, there&#39;s no conflict--it&#39;s just as if the class pulled in the crony role itself and the respective roles didn&#39;t. A role may never conflict with itself regardless of its method of incorporation. A role that brings in two conflicting crony roles <i>may</i> resolve them as if it were a class. This solution is accepted by the class unless the class supplies its own solution. If two different roles resolve the same crony conflict two different ways, those roles are themselves in conflict and must be resolved by a &#34;more derived&#34; role or the class.</p>

<p>A role doesn&#39;t know its own type until it is composed into a class. Any mention of its main type (such as <code>::?CLASS</code>) is generic, as is any reference to <code>self</code> or the type of the invocant. You can use a role name as a type, but only for constraints, not for declaring actual objects. (However, if you use a role as if it were a class, an anonymous class is generated that composes the role, which provides a way to force a role to test its crony composition for infelicities.)</p>

<p>If a role merely declares methods without defining them, it degenerates to an interface:</p>

<pre><code>role Pet {
    method feed ($food) {...}
    method groom () {...}
    method scratch (:$where) {...}
}</code></pre>

<p>Note that, while these methods must become available at class composition time, they might be supplied by any of: another role, the class itself, or some superclass. We know the methods that are coming from the other roles or the class, but we don&#39;t necessarily know the complete set of methods supplied by our super classes if they are open or rely on wildcard delegation. However, the class composer is allowed to assume that only currently declared superclass methods or non-wildcard methods are going to be available. A stub can always be installed somewhere to &#34;supply&#34; a missing method&#39;s declaration.</p>

<p>Roles may have attributes:</p>

<pre><code>role Pet {
    has $.collar = Collar.new(tag =&#62; Tag.new);
    method id () { return $.collar.tag }
    method lose_collar () { undefine $.collar }
}</code></pre>

<p>Within a role the <code>has</code> declarator always indicates the declaration from the viewpoint of the class. Therefore a private attribute declared using <code>has</code> is private to the class, not to the role. You may wish to declare an attribute that is hidden even from the class; a completely private role attribute (that will exist per instance of the class) may be declared like this:</p>

<pre><code>my $!spleen;</code></pre>

<p>The name of such a private attribute is always considered lexically scoped. If a role declares private lexical items, those items are private to the role due to the nature of lexical scoping. Accessors to such items may be exported to the class, but this is not the default. In particular, a role may say</p>

<pre><code>trusts ::?Class;</code></pre>

<p>to allow <code>self!attr()</code> access to the role&#39;s <code>$!attr</code> variables with the class or from other roles composed into the class. Conflicts between private accessors are also caught at composition time, but of course need not consider super classes, since no-one outside the current class (or a trusted class) can call a private accessor at all. (Private accessors are never virtual, and must be package qualified if called from a trusted scope other than our own. That is, it&#39;s either <code>self!attr()</code> or <code>$obj!TrustsMe::attr().</code>)</p>

<p>A role may also distinguish a shared method</p>

<pre><code>has method foo ...
method foo ...      # same</code></pre>

<p>from a nonshared private method:</p>

<pre><code>my method !foo ...
my method foo ...   # same, but &#38;foo is aliased to &#38;!foo</code></pre>

<p>Generally you&#39;d just use a lexically scoped sub, though.</p>

<pre><code>my sub foo ...</code></pre>

<p>[Conjectural: To put a private sub into the class, say</p>

<pre><code>our sub !foo ...</code></pre>

<p>]</p>

<p>A role can abstract the decision to delegate:</p>

<pre><code>role Pet {
    has $groomer handles &#60;bathe groom trim&#62; = hire_groomer();
}</code></pre>

<p>Note that this puts the three methods into the class as well as <code>$groomer</code>. In contrast, &#34;<code>my $!groomer</code>&#34; would only put the three methods; the attribute itself is private to the role.</p>

<p>A role is allowed to declare an additional inheritance for its class when that is considered an implementation detail:</p>

<pre><code>role Pet {
    also is Friend;
}</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Compile-time_Composition"
>Compile-time Composition</a></h2>

<p>A class incorporates a role with the verb &#34;does&#34;, like this:</p>

<pre><code>class Dog is Mammal does Pet does Sentry {...}</code></pre>

<p>or equivalently, within the body of the class closure:</p>

<pre><code>class Dog {
    also is Mammal;
    also does Pet;
    also does Sentry;
    ...
}</code></pre>

<p>or</p>

<pre><code>class Dog {
    also is Mammal does Pet does Sentry;
    ...
}</code></pre>

<p>There is no ordering dependency among the roles.</p>

<p>A class&#39;s explicit method definition hides any role definition of the same name. A role method in turn hides any methods inherited from other classes.</p>

<p>If there are no method name conflicts between roles (or with the class), then each role&#39;s methods can be installed in the class. If, however, two roles try to introduce a method of the same name the composition of the class fails. (Two <code>has</code> attributes of the same name, whether public or private, are always a composition fail. Role-private attributes are exempt from this, and from the viewpoint of the composition, don&#39;t even exist, except to allocate a slot for each such attribute.)</p>

<p>There are several ways to solve method conflicts. The first is simply to write a class method that overrides the conflicting role methods, perhaps figuring out which role method to call.</p>

<p>Alternately, if the role&#39;s methods are declared <code>multi</code>, they can be disambiguated based on their long name. If the roles forget to declare them as multi, you can force a multi on the roles&#39; methods by installing a proto stub in the class being constructed:</p>

<pre><code>proto method shake {...}</code></pre>

<p>(This declaration need not precede the <code>does</code> clause textually, since roles are not actually composed until the end of the class definition, at which point we know which roles are to be composed together in a single logical operation, as well as how the class intends to override the roles.)</p>

<p>The proto method will be called if the multi fails:</p>

<pre><code>proto method shake { warn &#34;They couldn&#39;t decide&#34; }</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Run-time_Mixins"
>Run-time Mixins</a></h2>

<p>Run-time mixins are done with <code>does</code> and <code>but</code>. The <code>does</code> binary operator is a mutator that derives a new anonymous class (if necessary) and binds the object to it:</p>

<pre><code>$fido does Sentry</code></pre>

<p>The <code>does</code> infix operator is non-associative, so this is a syntax error:</p>

<pre><code>$fido does Sentry does Tricks does TailChasing does Scratch;</code></pre>

<p>You can, however, say</p>

<pre><code>$fido does Sentry;
$fido does Tricks;
$fido does TailChasing;
$fido does Scratch;</code></pre>

<p>And since it returns the left side, you can also say:</p>

<pre><code>((($fido does Sentry) does Tricks) does TailChasing) does Scratch;</code></pre>

<p>Unlike the compile-time role composition, each of these layers on a new mixin with a new level of inheritance, creating a new anonymous class for dear old Fido, so that a <code>.chase</code> method from <code>TailChasing</code> hides a <code>.chase</code> method from <code>Sentry</code>.</p>

<p>You can also mixin a precomposed set of roles:</p>

<pre><code>$fido does (Sentry, Tricks, TailChasing, Scratch);</code></pre>

<p>This will level the playing field for collisions among the new set of roles, and guarantees the creation of no more than one more anonymous class. Such a role still can&#39;t conflict with itself, but it can hide its previous methods in the parent class, and the calculation of what conflicts is done again for the set of roles being mixed in. If you can&#39;t do compile-time composition, we strongly recommend this approach for run-time mixins since it approximates a compile-time composition at least for the new roles involved.</p>

<p>A role applied with <code>does</code> may be parameterized with an initializer in parentheses, but only if the role supplies exactly one attribute to the mixin class:</p>

<pre><code>$fido does Wag($tail);
$line does taint($istainted);</code></pre>

<p>Note that the parenthesized form is <i>not</i> a subroutine or method call. It&#39;s just special initializing syntax for roles that contain a single property.</p>

<p>The supplied initializer will be coerced to the type of the attribute. Note that this initializer is in addition to any parametric type supplied in square brackets, which is considered part of the actual type name:</p>

<pre><code>$myobj does Array[Int](@initial)</code></pre>

<p>A property is defined by a role like this:</p>

<pre><code>role answer {
    has Int $.answer is rw = 1;
}</code></pre>

<p>The property can then be mixed in or, alternatively, applied using the <code>but</code> operator. <code>but</code> is like <code>does</code>, but creates a copy and mixes into that instead, leaving the original unmodified. Thus:</p>

<pre><code>$a = 0 but answer(42)</code></pre>

<p>Really means something like:</p>

<pre><code>$a = ($anonymous = 0) does answer(42);</code></pre>

<p>Which really means:</p>

<pre><code>(($anonymous = 0) does answer).answer = 42;
$a = $anonymous;</code></pre>

<p>Which is why there&#39;s a <code>but</code> operator.</p>

<p>If you put something that is not a role on the right hand side of the <code>does</code> or <code>but</code> operators then an anonymous role will be auto-generated containing a single method that returns that value. The name of the method is determined by doing .WHAT.perl on the value supplied on the RHS. The generated role is then mixed in to the object. For example:</p>

<pre><code>$x does 42</code></pre>

<p>Is equivalent to:</p>

<pre><code>$x does role { method Int() { return 42 } }</code></pre>

<p>Note that the role has no attributes and thus no storage; if you want that, then you should instead use:</p>

<pre><code>$x does Int(42)</code></pre>

<p>Which mixes in the Int role and initializes the single storage location Int that it declares with 42, and provides an lvalue accessor.</p>

<p>Note that .WHAT on an enumeration value stringifies to the name of the enumeration, and as a result:</p>

<pre><code>0 but True</code></pre>

<p>Is equivalent to:</p>

<pre><code>0 but role { method Bool() { return True } }</code></pre>

<p>And thus the resulting value will be considered true in boolean context.</p>

<p>The list syntax for composing multiple roles in a single <code>does</code> or <code>but</code> by putting them in a list also applies here. Thus:</p>

<pre><code>42 but (&#34;the answer&#34;, False)</code></pre>

<p>Is equivalent to:</p>

<pre><code>42 but (role { method Str() { return &#34;the answer&#34; } },
        role { method Bool() { return False } })</code></pre>

<p>Which gives you a compact way to build context-sensitive return values. Note that multiple roles rather than a single one are generated, so that anything like:</p>

<pre><code>42 but (True, False)</code></pre>

<p>Will fail as a result of standard role composition semantics (because two roles are both trying to provide a method Bool).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Traits"
>Traits</a></h1>

<p>Traits are just properties (roles) applied to something that is being declared (the <i>declarand</i>), such as containers or classes. It&#39;s the declaration of the item itself that makes traits seem more permanent than ordinary properties. In addition to adding the property, a trait can also have side effects.</p>

<p>Traits are generally applied with the &#34;is&#34; keyword, though not always. To define a trait handler for an &#34;is xxx&#34; trait, define one or more multisubs into a property role like this:</p>

<pre><code>role xxx {
    has Int $.xxx;
    multi trait_mod:&#60;is&#62;(::?CLASS:U $declarand, :$xxx!) {...}
    multi trait_mod:&#60;is&#62;(Any $declarand, :$xxx!) {...}
}</code></pre>

<p>Then it can function as a trait. A well-behaved trait handler will say</p>

<pre><code>$declarand does xxx($arg);</code></pre>

<p>somewhere inside to set the metadata on the declarand correctly. Since a class can function as a role when it comes to parameter type matching, you can also say:</p>

<pre><code>class MyBase {
    multi trait_mod:&#60;is&#62;(MyBase:U $declarand, MyBase $base) {...}
    multi trait_mod:&#60;is&#62;(Any $declarand, MyBase $tied) {...}
}</code></pre>

<p>These capture control if <code>MyBase</code> wants to capture control of how it gets used by any class or container. But usually you can just let it call the generic defaults:</p>

<pre><code>multi trait_mod:&#60;is&#62;(Any:U $declarand, $base) {...}</code></pre>

<p>which adds <code>$base</code> to the &#34;isa&#34; list of class <code>$declarand</code>, or</p>

<pre><code>multi trait_mod:&#60;is&#62;(Any $declarand, $tied) {...}</code></pre>

<p>which sets the &#34;tie&#34; type of the container declarand to the implementation type in <code>$tied</code>.</p>

<p>Most traits are really just adverbial pairs which, instead of being introduced by a colon, are introduced by a (hopefully) more readable &#34;helping verb&#34;, which could be something like &#34;<code>is</code>&#34;, or &#34;<code>will</code>&#34;, or &#34;<code>can</code>&#34;, or &#34;<code>might</code>&#34;, or &#34;<code>should</code>&#34;, or &#34;<code>does</code>&#34;. Any trait verb that is parsed the same as trait_mod:&#60;is&#62; may be defined the same way. Here&#39;s &#34;<code>will</code>&#34;, which (being syntactic sugar) merely delegates to back to &#34;is&#34;:</p>

<pre><code>multi sub trait_mod:&#60;will&#62;($declarand, :$trait) {
    trait_mod:&#60;is&#62;($declarand, :$trait);
}</code></pre>

<p>Other traits are applied with a single word, and require special parsing. For instance, the &#34;<code>of</code>&#34; trait is defined something like this:</p>

<pre><code>role of {
    has ReturnType $.of;
    multi sub trait_mod:&#60;of&#62;($declarand, ReturnType $arg) is parsed /&#60;typename&#62;/ {
        $declarand does of($arg);
    }
    ...
}</code></pre>

<p>Unlike compile-time roles, which all flatten out in the same class, compile-time traits are applied one at a time, like mixin roles. You can, in fact, apply a trait to an object at run time, but if you do, it&#39;s just an ordinary mixin role. You have to call the appropriate <code>trait_mod:&#60;is</code>()&#62; routine yourself if you want it to do any extra shenanigans. The compiler won&#39;t call it for you at run time like it would at compile time.</p>

<p>Note that the declarations above are insufficient to install new trait auxiliaries or verbs into the user&#39;s grammar, since macro definitions are lexically scoped, and in the declarations above extend only to the end of the role definition. The user&#39;s lexical scope must somehow have processed (or imported) a proto declaration introducing the new syntax before it can be parsed correctly. (This doesn&#39;t apply to pre-existing syntax such as <code>is</code>, of course.)</p>

<p>Calls to <code>trait_mod</code> routines are evaluated in sink context.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Parametric_Roles"
>Parametric Roles</a></h1>

<p>A role&#39;s main type is generic by default, but you can also parameterize other types explicitly using type parameters:</p>

<pre><code>role Pet[::Petfood = TableScraps] {
    method feed (Petfood $food) {...}
}</code></pre>

<p>(Note that in this case you must not use ::Petfood in the inner declaration, or it would rebind the type to type of the actual food parameter.)</p>

<p>If you want to parameterize the initial value of a role attribute, be sure to put a double semicolon if you don&#39;t want the parameter to be considered part of the long name:</p>

<pre><code>role Pet[::ID;; $tag] {
    has ID $.collar .= new($tag);
}</code></pre>

<p>You don&#39;t just have to parameterize on types; any value is fine. Imagine we wanted to factor out a &#34;greet&#34; method into a role, which takes somebody&#39;s name and greets them. We can parameterize it on the greeting.</p>

<pre><code>role Greet[Str $greeting] {
    method greet() { say &#34;$greeting!&#34;; }
}
class EnglishMan does Greet[&#34;Hello&#34;] { }
class Slovak does Greet[&#34;Ahoj&#34;] { }
class Lolcat does Greet[&#34;OH HAI&#34;] { }
EnglishMan.new.greet(); # Hello
Slovak.new.greet(); # Ahoj
Lolcat.new.greet(); # OH HAI</code></pre>

<p>Similarly, we could do a role for requests.</p>

<pre><code>role Request[Str $statement] {
    method request($object) { say &#34;$statement $object?&#34;; }
}
class EnglishMan does Request[&#34;Please can I have a&#34;] { }
class Slovak does Request[&#34;Prosim si&#34;] { }
class Lolcat does Request[&#34;I CAN HAZ&#34;] { }
EnglishMan.new.request(&#34;yorkshire pudding&#34;);
Slovak.new.request(&#34;borovicka&#34;);
Lolcat.new.request(&#34;CHEEZEBURGER&#34;);</code></pre>

<p>Sadly, the Slovak output sucks here. Borovicka is the nominative form of the word, and we need to decline it into the accusative case. But some languages don&#39;t care about that, and we don&#39;t want to have to make them all supply a transform. Thankfully, you can write many roles with the same short name, and a different signature, and multi-dispatch will pick the right one for you (it is the exact same dispatch algorithm used by multi-subs). So we can write:</p>

<pre><code>role Request[Str $statement] {
    method request($object) { say &#34;$statement $object?&#34;; }
}
role Request[Str $statement, &#38;transform] {
    method request($object) {
        say &#34;$statement &#34; ~ transform($object) ~ &#34;?&#34;;
    }
}
module Language::Slovak {
    sub accusative($nom) {
        # ...and before some smartass points it out, I know
        # I&#39;m missing some of the masculine animate declension...
        return $nom.subst(/a$/, &#39;u&#39;);
    }
}
class EnglishMan does Request[&#34;Please can I have a&#34;] { }
class Slovak does Request[&#34;Prosim si&#34;, &#38;Language::Slovak::accusative] { }
class Lolcat does Request[&#34;I CAN HAZ&#34;] { }
EnglishMan.new.request(&#34;yorkshire pudding&#34;);
Slovak.new.request(&#34;borovicka&#34;);
Lolcat.new.request(&#34;CHEEZEBURGER&#34;);</code></pre>

<p>Which means we can now properly order our borovicka in Slovakia, which is awesome. Until you do it in a loop and find the Headache[&#39;very bad&#39;] role got mixed into yourself overnight, anyway...</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Relationship_Between_of_And_Types"
>Relationship Between of And Types</a></h2>

<p>The of keyword is just syntactic sugar for providing a single parameter to a parametric type. Thus:</p>

<pre><code>my Array of Recipe %book;</code></pre>

<p>Actually means:</p>

<pre><code>my Array[Recipe] %book;</code></pre>

<p>This can be nested, so:</p>

<pre><code>my Hash of Array of Recipe @library;</code></pre>

<p>Is just:</p>

<pre><code>my Hash[Array[Recipe]] @library;</code></pre>

<p>Therefore:</p>

<pre><code>my Array @array;</code></pre>

<p>Means an Array of Array (actually, a Positional of Array).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parametric_Subtyping"
>Parametric Subtyping</a></h2>

<p>If you have two types in a subtyping relationship such that T1 is narrower than T2, then also the roles:</p>

<pre><code>role R[::T] { }
role R[::T1, ::T2] { }</code></pre>

<p>Will act such that R[T1] is narrower than R[T2]. This extends to multiple parameters, however they must all be narrower or the same (this is unlike in multiple dispatch where you can have one narrower and the rest narrower or tied). That is, assuming we have some unrelated type T3, then R[T2, T1] is narrower than R[T1,T1] but R[T2,T1] is not narrower than R[T1,T3].</p>

<p>Nesting follows naturally from this definition, so a role R[R[T2]] is narrower than a role R[R[T1]].</p>

<p>This all means that, for example, if you have a sub:</p>

<pre><code>sub f(Num @arr) { ... }</code></pre>

<p>Then you can also call it with an array of Int.</p>

<pre><code>my Int @a = 1,2,3;
f(@a);</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Interaction_of_typed_and_untyped_data_structures"
>Interaction of typed and untyped data structures</a></h2>

<p>Certainly so far as Perl 6.0.0 goes, only types that have been declared on a container count in the type check. That is, if we have a sub:</p>

<pre><code>sub f(Int @arr) { ... }</code></pre>

<p>And call it with any of:</p>

<pre><code>f([1,2,3]);
my @a = 1,2,3;
f(@a);</code></pre>

<p>Then neither of these calls will work. The type check is based on the declared type of the array, and the content is unknown to the type checker.</p>

<!-- end doc -->

</body></html>
