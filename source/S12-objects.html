<!DOCTYPE html>
<html lang="ja">
<head>
<title>S12-objects</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Aug 30 10:16:51 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Classes'>Classes</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Class_traits'>Class traits</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Single_inheritance'>Single inheritance</a>
      <li class='indexItem indexItem3'><a href='#Multiple_inheritance'>Multiple inheritance</a>
      <li class='indexItem indexItem3'><a href='#Composition'>Composition</a>
      <li class='indexItem indexItem3'><a href='#The_also_declarator'>The also declarator</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Metaclasses'>Metaclasses</a>
    <li class='indexItem indexItem2'><a href='#Closed_classes'>Closed classes</a>
    <li class='indexItem indexItem2'><a href='#Private_classes'>Private classes</a>
    <li class='indexItem indexItem2'><a href='#Class_composition'>Class composition</a>
    <li class='indexItem indexItem2'><a href='#Anonymous_class_declaration'>Anonymous class declaration</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Methods'>Methods</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Invocants'>Invocants</a>
    <li class='indexItem indexItem2'><a href='#Private_methods'>Private methods</a>
    <li class='indexItem indexItem2'><a href='#Method_scoping'>Method scoping</a>
    <li class='indexItem indexItem2'><a href='#Method_calls'>Method calls</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Fancy_method_calls'>Fancy method calls</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Lvalue_methods'>Lvalue methods</a>
    <li class='indexItem indexItem2'><a href='#Scalar_container_indirection'>Scalar container indirection</a>
    <li class='indexItem indexItem2'><a href='#FALLBACK_methods'>FALLBACK methods</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Class_methods'>Class methods</a>
  <li class='indexItem indexItem1'><a href='#Submethods'>Submethods</a>
  <li class='indexItem indexItem1'><a href='#Attributes'>Attributes</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Attribute_default_values'>Attribute default values</a>
    <li class='indexItem indexItem2'><a href='#Class_attributes'>Class attributes</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Construction_and_Initialization'>Construction and Initialization</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Semantics_of_bless'>Semantics of bless</a>
    <li class='indexItem indexItem2'><a href='#Cloning'>Cloning</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Mutating_methods'>Mutating methods</a>
  <li class='indexItem indexItem1'><a href='#Calling_sets_of_methods'>Calling sets of methods</a>
  <li class='indexItem indexItem1'><a href='#Parallel_dispatch'>Parallel dispatch</a>
  <li class='indexItem indexItem1'><a href='#Multisubs_and_Multimethods'>Multisubs and Multimethods</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#multi_Declarations'>multi Declarations</a>
    <li class='indexItem indexItem2'><a href='#only_Declarations'>only Declarations</a>
    <li class='indexItem indexItem2'><a href='#proto_Declarations'>proto Declarations</a>
    <li class='indexItem indexItem2'><a href='#proto_Signatures'>proto Signatures</a>
    <li class='indexItem indexItem2'><a href='#multi_Variables'>multi Variables</a>
    <li class='indexItem indexItem2'><a href='#multi_Routines'>multi Routines</a>
    <li class='indexItem indexItem2'><a href='#Multisub_Resolution'>Multisub Resolution</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Candidate_Tiebreaking'>Candidate Tiebreaking</a>
      <li class='indexItem indexItem3'><a href='#Parameter_Constraint_Exclusion'>Parameter Constraint Exclusion</a>
      <li class='indexItem indexItem3'><a href='#Constrained_Type_Candidates'>Constrained Type Candidates</a>
      <li class='indexItem indexItem3'><a href='#Multi_Submethods_et_Cetera'>Multi Submethods et Cetera</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Method_call_vs._Subroutine_call'>Method call vs. Subroutine call</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Trusts'>Trusts</a>
  <li class='indexItem indexItem1'><a href='#Delegation'>Delegation</a>
  <li class='indexItem indexItem1'><a href='#Types_and_Subtypes'>Types and Subtypes</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Abstract_vs_Concrete_types'>Abstract vs Concrete types</a>
    <li class='indexItem indexItem2'><a href='#Multiple_constraints'>Multiple constraints</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Enumerations'>Enumerations</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Value_Generation'>Value Generation</a>
    <li class='indexItem indexItem2'><a href='#The_Enumeration_Type'>The Enumeration Type</a>
    <li class='indexItem indexItem2'><a href='#Anonymous_Enumerations'>Anonymous Enumerations</a>
    <li class='indexItem indexItem2'><a href='#Composition_from_Pairs'>Composition from Pairs</a>
    <li class='indexItem indexItem2'><a href='#Anonymous_Mixin_Roles_using_but_or_does'>Anonymous Mixin Roles using but or does</a>
    <li class='indexItem indexItem2'><a href='#Adding_Traits'>Adding Traits</a>
    <li class='indexItem indexItem2'><a href='#Exporting'>Exporting</a>
    <li class='indexItem indexItem2'><a href='#Implying_a_Role'>Implying a Role</a>
    <li class='indexItem indexItem2'><a href='#Built-in_Enumerations'>Built-in Enumerations</a>
    <li class='indexItem indexItem2'><a href='#Miscellaneous_Rules'>Miscellaneous Rules</a>
    <li class='indexItem indexItem2'><a href='#The_.pick_Method'>The .pick Method</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Open_vs_Closed_Classes'>Open vs Closed Classes</a>
  <li class='indexItem indexItem1'><a href='#Representations'>Representations</a>
  <li class='indexItem indexItem1'><a href='#Interface_Consistency'>Interface Consistency</a>
  <li class='indexItem indexItem1'><a href='#Introspection'>Introspection</a>
  <li class='indexItem indexItem1'><a href='#Custom_Meta-objects'>Custom Meta-objects</a>
  <li class='indexItem indexItem1'><a href='#Autovivifying_objects'>Autovivifying objects</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 12: Objects</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Larry Wall &#60;larry@wall.org&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 27 Oct 2004

Last Modified: 30 Dec 2013
Version: 133</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis summarizes Apocalypse 12, which discusses object-oriented programming.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Classes"
>Classes</a></h1>

<p>A class is a module declared with the <code>class</code> keyword. As with modules, the public storage, interface, and name of the class is represented by a package and its name, which is usually (but not necessarily) a global name. A class is a module and thus can export stuff, but a class adds even more behavior to support Perl 6&#39;s standard class-based OO.</p>

<p>Taken as a type object, a class name represents all of the possible values of its type, and the type object can thus be used as a proxy for any &#34;real&#34; object of that type in calculating what a generic object of that type can do. The class object is an object, but it is not a Class, because there is no mandatory Class class in Perl 6, and because type objects in Perl 6 are considered undefined. We wish to support both class-based and prototype-based OO programming. So all metaprogramming is done through the current object&#39;s <code>HOW</code> object, which can delegate metaprogramming to any metamodel it likes. However, by default, objects derived from <code>Mu</code> support a fairly standard class-based model.</p>

<p>There are two basic class declaration syntaxes:</p>

<pre><code>class Foo;          # rest of file is class definition
has $.foo;

class Bar { has $.bar }     # block is class definition</code></pre>

<p>The first form is allowed only as the first declaration in a compilation unit (that is, file or <code>EVAL</code> string).</p>

<p>If the class body begins with a statement whose main operator is a single <code>prefix:&#60;...&#62;</code> (yada) listop, the class name is introduced without a definition, and a second declaration of that class in the same scope does not complain about redefinition. (Statement modifiers are allowed on such a <code>...</code> operator.) Thus you may forward-declare your classes:</p>

<pre><code>class A {...}     # introduce A as a class name without definition
class B {...}     # introduce B as a class name without definition

my A $root .= new(:a(B));

class A {
    has B $.a;
}

class B {
    has A $.b;
}</code></pre>

<p>As this example demonstrates, this allows for mutually recursive class definitions (though, of course, it can&#39;t allow recursive inheritance).</p>

<p>It is also possible to extend classes via the <code>augment</code> declarator, but that is considered somewhat antisocial and should not be used for forward declarations.</p>

<p>[Conjecture: we may also allow the <code>proto</code> and <code>multi</code> declarator modifiers on class definitions to explicitly declare classes with multiple bodies participating in a single definition intentionally.]</p>

<p>A named class declaration can occur as part of an expression, just like named subroutine declarations.</p>

<p>Classes are primarily for instance management, not code reuse. Consider using roles when you simply want to factor out common code.</p>

<p>Perl 6 supports multiple inheritance, anonymous classes, and autoboxing.</p>

<p>All public method calls are &#34;virtual&#34; in the C++ sense.</p>

<p>You may derive from any built-in type, but the derivation of a low-level type like <code>int</code> may only add behaviors, not change the representation. Use composition and/or delegation to change the representation.</p>

<p>Since there are no barewords in Perl 6, bare class names must be predeclared. You can predeclare a stub class and fill it in later just as you would a subroutine.</p>

<p>You can force interpretation of a name as a class or type name using the <code>::</code> prefix. In an rvalue context the <code>::</code> prefix is a no-op, but in a declarational context, it binds a new type name within the declaration&#39;s scope along with anything else being declared by the declaration.</p>

<p>Without a <code>my</code> or other scoping declarator, a bare <code>class</code> declarator declares an <code>our</code> declarator, that is, a name within the current package. Since class files begin parsing in the <code>GLOBAL</code> package, the first class declaration in the file installs itself as a global name, and subsequent declarations then install themselves into the current class rather than the global package.</p>

<p>Hence, to declare an inner class in the current package (or module, or class), use <code>our class</code> or just <code>class</code>. To declare a lexically scoped class, use <code>my class</code>. Class names are always searched for from innermost scopes to outermost. As with an initial <code>::</code>, the presence of a <code>::</code> within the name does not imply globalness (unlike in Perl 5). So the outward search can look in children of the searched namespaces.</p>

<p>An inner class or role in a generic context must be lexically scoped if it depends on any generic parameter or type; and such an inner class or role is also a generic type. [Conjecture: it is erroneous to assume that any generic type is uniquely associated with a package.]</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class_traits"
>Class traits</a></h2>

<p>Class traits are set using <code>is</code>:</p>

<pre><code>class MyStruct is rw {...}</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Single_inheritance"
>Single inheritance</a></h3>

<p>An &#34;isa&#34; is just a trait that happens to be another class:</p>

<pre><code>class Dog is Mammal {...}</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Multiple_inheritance"
>Multiple inheritance</a></h3>

<p>Multiple inheritance is specified with multiple <code>is</code> modifiers:</p>

<pre><code>class Dog is Mammal is Pet {...}</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Composition"
>Composition</a></h3>

<p>Roles use <code>does</code> instead of <code>is</code>:</p>

<pre><code>class Dog is Mammal does Pet {...}</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_also_declarator"
>The <code>also</code> declarator</a></h3>

<p>You may put these inside as well by use of the <code>also</code> declarator:</p>

<pre><code>class Dog {
    also is Mammal;
    also does Pet;
    ...
}</code></pre>

<p>(However, the <code>also</code> declarator is primarily intended for use in roles, to distinguish class traits that might not be properly understood as generic when placed in the role header, which tends to communicate the false impression that the trait in question is to be applied directly to the role rather than to the composed class.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Metaclasses"
>Metaclasses</a></h2>

<p>Every object (including any class-based object) delegates to an instance of its metaclass. You can get at the metaclass of any object via the <code>HOW</code> method, which returns an instance of the metaclass. A &#34;class&#34; object is just considered an &#34;empty&#34; instance in Perl 6, more properly called a &#34;prototype&#34; or &#34;generic&#34; object, or just &#34;type object&#34;. Perl 6 doesn&#39;t really have any classes named <code>Class</code>. Types of all kinds are instead named via these undefined type objects, which are considered to have exactly the same type as an instantiated version of themselves. But such type objects are inert, and do not manage the state of class instances.</p>

<p>The actual object that manages instances is the metaclass object pointed to by the <code>HOW</code> syntax. So when you say &#34;<code>Dog</code>&#34;, you&#39;re referring to both a package and a type object, the latter of which points to the object representing the class via <code>HOW</code>. The type object differs from an instance object not by having a different type but rather in the extent to which it is defined. Some objects may tell you that they are defined, while others may tell you that they are undefined. That&#39;s up to the object, and depends on how the metaclass chooses to dispatch the <code>.defined</code> method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Closed_classes"
>Closed classes</a></h2>

<p>Classes are open and non-final by default, but may easily be closed or finalized not by themselves but by the entire application, provided nobody issued an explicit compile-time request that the class stay open or non-final. (Or a site policy could close any applications that use the policy.) Platforms that do dynamic loading of sub-applications probably don&#39;t want to close or finalize classes wholesale, however.</p>

<p>Roles take on some of the compile-time function of closed classes, so you should probably use those instead anyway.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Private_classes"
>Private classes</a></h2>

<p>A private class can be declared using <code>my</code>; most privacy issues are handled with lexical scoping in Perl 6. The fact that importation is lexical by default also means that any names your class imports are also private by default.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class_composition"
>Class composition</a></h2>

<p>Class declarations (in particular, role composition) are strictly compile time statements. In particular, if a class declaration appears inside a nested scope, the class declaration is constrained to compose in exactly the same way on any possible execution. All named roles and superclasses must be bound as non-rebindable readonly values; any parameters to traits will be evaluated only in a non-cloning context. Names bound by the class declaration are made non-rebindable and read only so they may be used as superclasses.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Anonymous_class_declaration"
>Anonymous class declaration</a></h2>

<p>In an anonymous class declaration, <code>::</code> by itself may represent the anonymous class name if desired:</p>

<pre><code>class {...}                # ok
class is Mammal {...}      # WRONG
class :: is Mammal {...}   # ok
class { also is Mammal; ...}    # also ok</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Methods"
>Methods</a></h1>

<p>Methods are routines declared in a class with the <code>method</code> keyword:</p>

<pre><code>method doit ($a, $b, $c) { ... }
method doit ($self: $a, $b, $c) { ... }
method doit (MyName $self: $a, $b, $c) { ... }
method doit (::?CLASS $self: $a, $b, $c) { ... }</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Invocants"
>Invocants</a></h2>

<p>Declaration of the invocant is optional. You may always access the current invocant using the keyword <code>self</code>. You need not declare the invocant&#39;s type, since the lexical class of the invocant is known in any event because methods must be declared in the class of the invocant, though of course the actual (virtual) type may be a derived type of the lexical type. You could declare a more restrictive type, but that would probably be a bad thing for proper polymorphism. You may explicitly type the invocant with the lexical type, but any check for that will be optimized away. (The current lexically-determined class may always be named as <code>::?CLASS</code> even in anonymous classes or roles.)</p>

<p>To mark an explicit invocant, just put a colon after it:</p>

<pre><code>method doit ($x: $a, $b, $c) { ... }</code></pre>

<p>If you declare an explicit invocant for an Array type using an array variable, you may use that directly in list context to produce its elements</p>

<pre><code>method push3 (@x: $a, $b, $c) { ... any(@x) ... }</code></pre>

<p>Note that the <code>self</code> function is not context sensitive and thus always returns the current object as a single item even in list context. Hence if your current object happens to be an array but you did not declare it with an explicit array variable, you need to explicitly access the elements of the array somehow:</p>

<pre><code>any(self)     # WRONG
any(self[])   # okay
any(@(self))  # okay
any(@self)    # WRONG unless you declared @self yourself</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Private_methods"
>Private methods</a></h2>

<p>Private methods are declared using <code>!</code>:</p>

<pre><code>method !think (Brain $self: $thought)</code></pre>

<p>(Such methods are completely invisible to ordinary method calls, and are in fact called with a different syntax that uses <code>!</code> in place of the <code>.</code> character. See below.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Method_scoping"
>Method scoping</a></h2>

<p>Unlike with most other declarations, <code>method</code> declarations do not default to <code>our</code> semantics, or even <code>my</code> semantics, but rather <code>has</code> semantics. So instead of installing a symbol into a lexical or package symbol table, they merely install a public or private method in the current class or role via calls to its metaobject. (Likewise for <code>submethod</code> declarations--see <a href="#Submethods" class="podlinkpod"
>&#34;Submethods&#34;</a> below.)</p>

<p>Use of an explicit <code>has</code> declarator has no effect on the declaration. You may install additional aliases to the method in the lexical scope using <code>my</code> or in the current package using <code>our</code>. These aliases are named with <code>&#38;foo</code> notation and return a <code>Routine</code> object that may be called as a subroutine, in which case you must supply the expected invocant as the first argument.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Method_calls"
>Method calls</a></h2>

<p>To call an ordinary method with ordinary method-dispatch semantics, use either the dot notation or indirect object notation:</p>

<pre><code>$obj.doit(1,2,3)
doit $obj: 1,2,3</code></pre>

<p>Indirect object notation now requires a colon after the invocant, even if there are no arguments after the colon:</p>

<pre><code>$handle.close;
close $handle:;</code></pre>

<p>To reject method call and only consider subs, simply omit the colon from the invocation line:</p>

<pre><code>close($handle);
close $handle;</code></pre>

<p>However, here the built-in <b>IO</b> class defines <code>method close () is export</code>, which puts a <code>multi sub close (IO)</code> in scope by default. Thus if the <code>$handle</code> evaluates to an <code>IO</code> object, then the two subroutine calls above are still translated into method calls.</p>

<p>Dot notation can omit the invocant if it&#39;s in <code>$_</code>:</p>

<pre><code>.doit(1,2,3)</code></pre>

<p>Method calls use the C3 method resolution order.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Fancy_method_calls"
>Fancy method calls</a></h3>

<p>Note that there is no corresponding notation for private methods.</p>

<pre><code>!doit(1,2,3)        # WRONG, would be parsed as not(doit(1,2,3))
self!doit(1,2,3)    # okay</code></pre>

<p>There are several forms of indirection for the method name. You can replace the identifier with a quoted string, and it will be evaluated as a quote and then the result of that is used as the method name.</p>

<pre><code>$obj.&#34;$methodname&#34;(1,2,3)   # use contents of $methodname as method name
$obj.&#39;$methodname&#39;(1,2,3)   # no interpolation; call method with $ in name!

$obj!&#34;$methodname&#34;()          # indirect call to private method name</code></pre>

<p>As an aid to catching Perl 5 brainos, this quoted form always requires a parenthesized argument list to distinguish it from code that looks like a Perl 5 concatenation.</p>

<p>Within an interpolation, the double-quoted form may not contain whitespace. This does what the user expects in the common case of a quoted string ending with a period:</p>

<pre><code>say &#34;Foo = $foo.&#34;;</code></pre>

<p>If you really want to call a method with whitespace, you may work around this restriction with a closure interpolation:</p>

<pre><code>say &#34;Foo = {$foo.&#34;a method&#34;()}&#34;;  # OK</code></pre>

<p>[Note: to help catch the mistaken use of <code>infix:&#60;.&#62;</code> as a string concatenation operator, Perl 6 will warn you about &#34;useless use of quotes&#34; at compile time if the string inside quotes is an identifier. (It does not warn about non-identifier strings, but such strings are likely to produce missing method errors at run time in any case.) Also, if there is whitespace around an intended <code>.</code> concatenation, it cannot be parsed as a method call at all; instead it fails at compile time because standard Perl 6 has a pseudo <code>infix:&#60;.&#62;</code> operator that always fails at compile time.]</p>

<p>For situations where you already have a method located, you can use a simple scalar variable in place of method name:</p>

<pre><code>$methodobj = $foo ?? &#38;bar !! &#38;baz;
$obj.$methodobj(1,2,3)</code></pre>

<p>or more succinctly but less readably:</p>

<pre><code>$obj.$($foo ?? &#38;bar !! &#38;baz)(1,2,3)</code></pre>

<p>The variable must contain a <code>Callable</code> object (usually of type <code>Code</code>), that is, a closure of some sort. Regardless of whether the closure was defined as a method or a sub or a block, the closure is called directly without any class dispatch; from the closure&#39;s point of view, however, it is always called as a method, with the object as its first argument, and the rest of the arguments second, third, and so on. For instance, such a closure may be used to abstract a &#34;navigational&#34; path through a data structure without specifying the root of the path till later:</p>

<pre><code>$locator = -&#62; $root, $x, $y { $root.&#60;foo&#62;[$x]&#60;bar&#62;{$y}[3] }
$obj.$locator(42,&#34;baz&#34;)  # $obj&#60;foo&#62;[42]&#60;bar&#62;&#60;baz&#62;[3]

$locator = { .&#60;here&#62; }
$obj.$locator            # $obj&#60;here&#62;</code></pre>

<p>As a convenient form of documentation, such a closure may also be written in the form of an anonymous method:</p>

<pre><code>$locator = method ($root: $x, $y) { $root.&#60;foo&#62;[$x]&#60;bar&#62;{$y}[3] }
$obj.$locator(42,&#34;baz&#34;)  # $obj&#60;foo&#62;[42]&#60;bar&#62;&#60;baz&#62;[3]

$locator = method { self.&#60;here&#62; }
$obj.$locator            # $obj&#60;here&#62;</code></pre>

<p>Note however that, like any anonymous closure, an anonymous method can only be dispatched to directly, like a sub. You may, of course, bind an anonymous method to the name of a method in a class&#39;s public interface, in which case it is no longer anonymous, and may be dispatched to normally via the class. (And in fact, when the normal method dispatcher is calling individual candidates in its candidate list, it calls each candidate as a sub, not as a method, or you&#39;d end up with recursive dispatchers.) But fundamentally, there&#39;s no such thing as a method closure. The <code>method</code> declarator on an anonymous method has the primary effect of making the declaration of the invocant optional. (It also makes it an official <code>Routine</code> that can be returned from, just as if you&#39;d used <code>sub</code> to declare it.)</p>

<p>Instead of a scalar variable, an array variable may also be used:</p>

<pre><code>$obj.@candidates(1,2,3)</code></pre>

<p>As with the scalar variant, string method names are not allowed, only <code>Callable</code> objects, The list is treated as a list of candidates to call. After the first successful call the rest of the candidates are discarded. Failure of the current candidate is indicated by calling <code>nextwith</code> or <code>nextsame</code> (see <a href="#Calling_sets_of_methods" class="podlinkpod"
>&#34;Calling sets of methods&#34;</a> below).</p>

<p>Note also that the</p>

<pre><code>$obj.$candidates(1,2,3)</code></pre>

<p>form may dispatch to a list of candidates if <code>$candidates</code> is either a list or a special <code>Code</code> object representing a partial dispatch to a list of candidates. If <code>$candidates</code> (or any element of <code>@candidates</code>) is an iterable object it is expanded out recursively until <code>Callable</code> candidates are found. The call fails if it hits a candidate that is not <code>Callable</code>, <code>Iterable</code>, or <code>List</code>.</p>

<p>Another form of indirection relies on the fact that operators are named using a variant on pair notation, which gives you these forms:</p>

<pre><code>$x.infix:[$op]($y)
$x.prefix:[$op]
$x.postfix:[$op]</code></pre>

<p>Generally you see these with the literal angle bracket form of subscript:</p>

<pre><code>$a.infix:&#60;*&#62;($b)      # equivalent to $a * $b
$a.prefix:&#60;++&#62;        # equivalent to ++$a
$a.postfix:&#60;++&#62;       # equivalent to $a++</code></pre>

<p>If you omit the syntactic category, the call will be dispatched according to the number of arguments either as &#34;prefix&#34; or as &#34;infix&#34;:</p>

<pre><code>$a.:&#60;+&#62;($b)           # equivalent to $a + $b
$a.:&#60;++&#62;              # equivalent to ++$a
$a.:&#60;!&#62;               # equivalent to !$a
@a.:&#60;[*]&#62;             # equivalent to [*] @a</code></pre>

<p>But it&#39;s probably better to spell out the syntactic category when the actual operator is not obvious:</p>

<pre><code>$x.infix:[$op]($y)
$x.prefix:[$op]</code></pre>

<p>You must use a special syntax to call a private method:</p>

<pre><code>$mybrain!think($pinky)
self!think($pinky)</code></pre>

<p>For a call on your own private method, you may also use the attribute-ish form:</p>

<pre><code>$!think($pinky)     # short for $(self!think($pinky))</code></pre>

<p>Parentheses (or a colon) are required on the dot/bang notations if there are any arguments (not counting adverbial arguments). There may be no space between the method name and the left parenthesis unless you make use of &#34;unspace&#34;:</p>

<pre><code>.doit       # okay, no arguments
.doit()     # okay, no arguments
.doit ()    # ILLEGAL (two terms in a row)
.doit\ ()   # okay, no arguments, same as .doit() (unspace form)</code></pre>

<p>Note that the named method call forms are special and do not use the dot form of postfix. If you attempt to use the postfix operator form, it will assume you want to call the method with no arguments and then call the result of <i>that</i>:</p>

<pre><code>.doit.()    # okay, no arguments *twice*, same as .doit().()
.doit\ .()  # okay, no arguments *twice*, same as .doit.().() (unspace form)</code></pre>

<p>However, you can turn any of the named forms above into a list operator by appending a colon:</p>

<pre><code>.doit: 1,2,3        # okay, three arguments
.doit(1): 2,3       # okay, one argument plus list
.doit (): 1,2,3     # ILLEGAL (two terms in a row)</code></pre>

<p>In particular, this allows us to pass a final closure in addition to the &#34;normal&#34; arguments:</p>

<pre><code>.doit: { $^a &#60;=&#62; $^b }              # okay
.doit(): { $^a &#60;=&#62; $^b }            # okay
.doit(1,2,3): { $^a &#60;=&#62; $^b }       # okay</code></pre>

<p>Normally a space is required after the colon to disambiguate what follows from a pair that extends the previous name. However, names may not be extended with the <code>:{}</code> pair notation, and therefore it is allowed to drop the space after the colon if the first argument to the method is a closure. Hence, any of the above may be written without the space after the colon:</p>

<pre><code>.doit:{ $^a &#60;=&#62; $^b }              # okay
.doit():{ $^a &#60;=&#62; $^b }            # okay
.doit(1,2,3):{ $^a &#60;=&#62; $^b }       # okay</code></pre>

<p>These are parsed as if there were a space there, so the argument list may continue if the closure is followed by a comma.</p>

<p>In case of ambiguity between indirect object notation and dot form, the nearest thing wins:</p>

<pre><code>dothis $obj.dothat: 1,2,3</code></pre>

<p>means</p>

<pre><code>dothis ($obj.dothat(1,2,3))</code></pre>

<p>and you must say</p>

<pre><code>dothis ($obj.dothat): 1,2,3</code></pre>

<p>or</p>

<pre><code>$obj.dothat.dothis: 1,2,3</code></pre>

<p>if you mean the other thing.</p>

<p>Also note that if any term in a list is a bare closure or pointy sub, it will be considered to be the final argument of its list unless the closure&#39;s right curly is followed immediately by comma or colon. In particular, a method call does *not* extend the list, so you can say:</p>

<pre><code>@list.grep: { $_ % 2 }.map: { $_ - 1 }.say</code></pre>

<p>and that will be taken as equivalent to</p>

<pre><code>@list.grep({ $_ % 2 }).map({ $_ - 1 }).say</code></pre>

<p>Since the colon does not require a space in this case, and it looks slightly odd there anyway, it may be clearer to omit the space to make the method calls on the right look more like they attach to the term on the left in one cascade of method calls:</p>

<pre><code>@list.grep:{ $_ % 2 }.map:{ $_ - 1 }.say</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Lvalue_methods"
>Lvalue methods</a></h2>

<p>Methods (and subs) may be declared as lvalues with <code>is rw</code>. You can use an argumentless <code>rw</code> method anywhere you can use a variable, including in <code>temp</code> and <code>let</code> statements. (In fact, you can use an <code>rw</code> method with arguments as a variable as long as the arguments are used only to identify the actual value to change, and don&#39;t otherwise have strange side effects that differ between rvalue and lvalue usage. Setter methods that expect the new value as an argument do not fall into the well-behaved category, however.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Scalar_container_indirection"
>Scalar container indirection</a></h2>

<p>Method calls on mutable scalars always go to the object contained in the scalar (autoboxing value types as necessary):</p>

<pre><code>$result = $object.doit();
$length = &#34;mystring&#34;.codes;</code></pre>

<p>Method calls on non-scalar variables just calls the <code>Array</code>, <code>Hash</code> or <code>Code</code> object bound to the variable:</p>

<pre><code>$elems = @array.elems;
@keys  = %hash.keys;
$sig   = &#38;sub.signature;</code></pre>

<p>Use the prefix <code>VAR</code> macro on a scalar variable to get at its underlying <code>Scalar</code> object:</p>

<pre><code>if VAR($scalar).readonly {...}</code></pre>

<p><code>VAR</code> is a no-op on a non-scalar variables and values:</p>

<pre><code>VAR(1);     # 1
VAR(@x);    # @x</code></pre>

<p>There&#39;s also a corresponding <code>postfix:&#60;.VAR&#62;</code> macro that can be used as if it were a method:</p>

<pre><code>if $scalar.VAR.readonly {...}</code></pre>

<p>(But since it&#39;s a macro, <code>VAR</code> is not dispatched as a real method. To dispatch to a real <code>.VAR</code> method, use the indirect <code>$obj.&#34;VAR&#34;</code> form.)</p>

<p>You can also get at the container through the appropriate symbol table:</p>

<pre><code>if MY::&#60;$scalar&#62;.readonly {...}</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FALLBACK_methods"
>FALLBACK methods</a></h2>

<p>If your class defines a method with the special name <code>FALLBACK</code>, that method will be called if all other attempts to locate a method fail, including normal method dispatch as well as delegation (see below). The first argument to the method will be the method name (as a string) that was unsuccessfully searched for. The original call&#39;s arguments are passed in as rest of the <code>FALLBACK</code>&#39;s argument list.</p>

<p>It is legal for the <code>FALLBACK</code> method to be a proto method that dispatches to multi methods.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Class_methods"
>Class methods</a></h1>

<p>Other OO languages give you the ability to declare &#34;class&#34; methods that either don&#39;t need or actively prohibit calls on instances. Perl 6 gives you a choice. If you declare an ordinary method, it can function as a &#34;class&#34; method when you pass it a type object such as &#34;<code>Dog</code>&#34; regardless of how defined the prototype object is, as long as the method body doesn&#39;t try to access any information that is undefined in the current instance.</p>

<p>Alternately, you can associate a method with the current metaclass instance, which as a singleton object knows your package, and can function as a more traditional &#34;class&#34; method:</p>

<pre><code>our $count;
method ^count { return $count }</code></pre>

<p>Such a <i>metaclass method</i> is always delegated to the <code>HOW</code> object just as methods like <code>.does</code> are, so it&#39;s possible to call this as <code>Dog.count</code> or <code>$dog.count</code>. However, best practice is probably to call such a class method as <code>Dog.^count</code> or <code>$dog.^count</code> to make it clear that it&#39;s in its own namespace separate from ordinary methods, and so that your class method cannot be accidentally overridden by an ordinary method in a subclass--presuming you don&#39;t want to allow for that possibility.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Submethods"
>Submethods</a></h1>

<p>Submethods are for declaring infrastructural methods that shouldn&#39;t be inherited by subclasses, such as initializers:</p>

<pre><code>submethod BUILD (:$arg) {
    $!attr = $arg;
}</code></pre>

<p>Apart from the keyword, submethod declaration and call syntax is identical to method syntax. You may mix methods and submethods of the same name within the class hierarchy, but only the methods are visible to derived classes via inheritance. A submethod is called only when a method call is dispatched directly to the current class.</p>

<p>Conjecture: in order to catch spelling errors it is a compile-time warning to define a submethod in any class that does not inherit the corresponding method name from some base class. More importantly, this would help safeguard Liskov substitutability. (But note that the standard <code>Mu</code> class already supplies a default <code>BUILD</code> and <code>new</code>.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Attributes"
>Attributes</a></h1>

<p>Attributes are stored in an opaque datatype, not in a hash. Not even the class has to care how they&#39;re stored, since they&#39;re declared much like ordinary variables. Instead of <code>my</code>, use <code>has</code>:</p>

<pre><code>class Dog is Mammal {
    has $.name = &#34;fido&#34;;
    has $.tail is rw;
    has @.legs;
    has $!brain;
    ...
}</code></pre>

<p>Public attributes have a secondary sigil of &#34;dot&#34;, indicating the automatic generation of an accessor method of the same name (unless the class declares an explicit method of that name before the closing bracket). Private attributes use an exclamation to indicate that no public accessor is generated.</p>

<pre><code>    has $!brain;</code></pre>

<p>The &#34;true name&#34; of the private variable always has the exclamation, but much like with <code>our</code> variables, you may declare a lexically scoped alias to the private variable by saying:</p>

<pre><code>    has $brain;     # also declares $!brain;</code></pre>

<p>As with the <code>!</code> declaration, no accessor is generated.</p>

<p>And any later references to the private variable within the same block may either use or omit the exclamation, as you wish to emphasize or ignore the privacy of the variable. Outside the block, you must use the <code>!</code> form. If you declare with the <code>!</code> form, you must use that form consistently everywhere. If you declare with the <code>.</code> form, you also get the private <code>!</code> form as a non-virtual name for the actual storage location, and you may use either <code>!</code> or <code>.</code> form anywhere within the class, even if the class is reopened. Outside the class you must use the public <code>.</code> form, or rely on a method call (which can be a private method call, but only for trusted classes).</p>

<p>For public attributes, some traits are copied to the accessor method. The <code>rw</code> trait causes the generated accessor to be declared <code>rw</code>, making it an lvalue method. The default is a read-only accessor.</p>

<p>If you declare the class as <code>rw</code>, then all the class&#39;s attributes default to <code>rw</code>, much like a C struct.</p>

<p>You may write your own accessors to override any or all of the autogenerated ones.</p>

<p>The attribute variables may be used within instance methods to refer directly to the attribute values. Outside the instance methods, the only access to attributes is through the accessors since an object has to be specified. The dot form of attribute variables may be used in derived classes because the dot form always implies a virtual accessor call. Every <i>dot</i> declaration also declares a corresponding private <i>exclamation</i> storage location, and the exclamation form may be used only in the actual class, not in derived classes. Reference to the internal storage location via <code>$!foo</code> should generally be restricted to submethods. Ordinary methods should stick to the <code>$.foo</code> form.</p>

<p>In fact, within submethods, use of the <code>$.foo</code> form on attributes that are available as <code>$!foo</code> (that is, that are declared directly by this class) is illegal and produces a dire compile-time warning (which may be suppressed). Within a submethod the <code>$.foo</code> form may only be used on attributes from parent classes, because only the parent classes&#39; part of the object is guaranteed to be in a consistent state (because <code>bless</code> calls the <code>BUILD</code> routines of the parent classes before the child classes). If you attempt to get around this by declaring <code>BUILD</code> as a method rather than a submethod, that will also be flagged as a dire (but suppressible) compile-time warning. (It is <i>possible</i> to define an inheritable <code>BUILD</code> routine if you have access to all the metadata for the current class, but it&#39;s not easy, and it certainly doesn&#39;t happen by accident just because you change <code>submethod</code> to <code>method</code>.)</p>

<p>Because <code>$.foo</code>, <code>@.foo</code>, <code>%.foo</code>, <code>&#38;.foo</code> are just shorthands of <code>self.foo</code> with different contexts, the class does not need to declare any of those as an attribute -- a <code>method foo</code> declaration can work just as well.</p>

<p>As with the normal method call forms, only dotless parentheses may contain arguments. If you use the <code>.()</code> form it will perform an extra level of indirection after the method call:</p>

<pre><code>self.foo(1,2,3);    # a regular method call
self.foo.(1,2,3);   # self.foo().(1,2,3), call .() on closure returned by .foo
$.foo(1,2,3);       # calls self.foo under $ context
$.foo.(1,2,3);      # $.foo().(1,2,3), call .() on closure returned by .foo
&#38;.foo(1,2,3);       # calls self.foo under &#38; context
&#38;.foo.(1,2,3);      # &#38;.foo().(1,2,3), call .() on closure returned by .foo</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Attribute_default_values"
>Attribute default values</a></h2>

<p>Pseudo-assignment to an attribute declaration specifies the default value. The value on the right is treated as an implicit closure and evaluated at object build time, that is, when the object is being constructed, not when class is being composed. To refer to a value computed at compilation or composition time, you can either use a temporary or a temporal block of some sort:</p>

<pre><code>has $.r = rand;     # each object gets different random value

constant $random = rand;
has $.r = $random;  # every object gets same value

has $.r = BEGIN { rand };
has $.r = INIT { rand };
has $.r = ENTER { rand };
has $.r = FIRST { rand };
has $.r = constant $myrand = rand;</code></pre>

<p>When it is called at <code>BUILD</code> time, the topic of the implicit closure will be the attribute being initialized, while &#34;self&#34; refers to the entire object being initialized. The closure will be called at the end of the <code>BUILD</code> only if the attribute is not otherwise initialized in either the signature or the body of the <code>BUILD</code>. The closure actually defines the body of an anonymous method, so <code>self</code> is available with whatever attributes are constructed by that point in time (including all parent attributes). The initializers are run in order of declaration within the class, so a given initializer may refer back to an attribute defined in a preceding <code>has</code> declaration.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class_attributes"
>Class attributes</a></h2>

<p>Class attributes are declared with either <code>my</code> or <code>our</code>. The only difference from ordinary <code>my</code> or <code>our</code> variables is that an accessor is generated according to the secondary sigil:</p>

<pre><code>our $.count;        # generates a public read-only .count accessor
our %!cache is rw;  # generates no public accessor
our @items;         # generates no public accessor
my  $.count;        # generates a public read-only .count accessor
my  %!cache is rw;  # generates no public accessor
my  @items;         # generates no public accessor</code></pre>

<p>Unlike attributes declared with <code>has</code>, class attributes are shared between the undefined type, all instances of the class, and all subclasses.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Construction_and_Initialization"
>Construction and Initialization</a></h1>

<p>All classes inherit a default <code>new</code> constructor from <code>Mu</code>. It expects all arguments to be named parameters initializing attributes of the same name. You may write your own <code>new</code> to override the default, or write constructors with any other name you like. As in Perl 5, a constructor is any routine that calls <code>bless</code>. Unlike in Perl 5, you call it as a method on the class object (though any object may be used as a class object), passing the arguments to be used in building the object.</p>

<p>The representation of the class determines how to create the object, so it&#39;s not longer necessary for you to supply a candidate to <code>bless</code>. For example, a P5Hash object would give you an object representation that uses hashes just like P5 does. The default <code>P6Opaque</code> representation doesn&#39;t tell you what it&#39;s going to use for its representation, since that&#39;s why it&#39;s called &#34;opaque&#34;, after all.</p>

<p>The <code>bless</code> method allows one or more positional arguments representing autovivifying type objects. Such an object looks like a type name followed by a hash subscript (see &#34;Autovivifying objects&#34; below). These are used to initialize superclasses.</p>

<p>Other than a list of autovivifying type objects, all arguments to <code>bless</code> must be named arguments, not positional. Hence, the main purpose of custom constructors is to turn positional arguments into named arguments for <code>bless</code>. The <code>bless</code> method allows an object to be used for its class invocant. (Your constructor need not allow this). In any case, the object is not used as a prototype. Use <code>.clone</code> instead of <code>.bless</code> if that&#39;s what you mean.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Semantics_of_bless"
>Semantics of <code>bless</code></a></h2>

<p>Any named arguments to <code>bless</code> are automatically passed to the <code>BUILD</code> routines.</p>

<p>For for normal user classes, <code>P6opaque</code> is the default representation. Other possibilities are <code>P6hash</code>, <code>P5hash</code>, <code>P5array</code>, <code>PyDict</code>, <code>Cstruct</code>, etc. If you wish to pass special options to the representation layer for creating the object, that&#39;s between you and the representation. (A representation might look for additional class traits, for instance, telling it bit sizes and such.)</p>

<p>The <code>bless</code> method automatically calls all appropriate <code>BUILD</code> routines for the current class, which initializes the object in least-derived to most-derived order.</p>

<p>The default <code>BUILD</code> semantics are inherited from <code>Mu</code>, so you need to write initialization routines only if you wish to modify the default behavior. The <code>bless</code> method automatically passes the appropriate argument list to the <code>BUILD</code> of its various parent classes. If the type of the parent class corresponds to one of the type objects passed to bless, that type object&#39;s argument list is used. Otherwise all the arguments to bless are passed to the parent class&#39;s <code>BUILD</code>. For the final <code>BUILD</code> of the current object, all the arguments to <code>bless</code> are passed to the <code>BUILD</code>, so it can deal with any type objects that need special handling. (It is allowed to pass type objects that don&#39;t correspond to any parent class.)</p>

<pre><code>class Dog is Animal {...}
my $pet = Dog.new( :name&#60;Fido&#62;, Animal{ :blood&#60;warm&#62;, :legs(4) } );</code></pre>

<p>Here we are using an autovivifying <code>Animal</code> type object to specify what the arguments to <code>Animal</code>&#39;s <code>BUILD</code> routine should look like. (It does not actually autovivify an <code>Animal</code> apart from the one being created.)</p>

<p>You can write your own <code>BUILD</code> submethod to control initialization. If you name an attribute as a parameter, that attribute is initialized directly, so</p>

<pre><code>submethod BUILD (:$!tail, :$!legs) {}</code></pre>

<p>is equivalent to</p>

<pre><code>submethod BUILD (:$tail is copy, :$legs is copy) {
    $!tail := $tail;
    $!legs := $legs;
}</code></pre>

<p>Whether you write your own <code>BUILD</code> or not, at the end of the <code>BUILD</code>, any default attribute values are implicitly copied into any attributes that haven&#39;t otherwise been initialized. Note that the default <code>BUILD</code> will only initialize public attributes; you must write your own <code>BUILD</code> (as above) in order to present private attributes as part of your initialization API.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Cloning"
>Cloning</a></h2>

<p>You can clone an object, changing some of the attributes:</p>

<pre><code>$newdog = $olddog.clone(:trick&#60;RollOver&#62;);</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Mutating_methods"
>Mutating methods</a></h1>

<p>You can call an in-place mutator method like this:</p>

<pre><code>@array .= sort;</code></pre>

<p>One handy place for an in-place mutator is to call a constructor on a variable of a known type:</p>

<pre><code>my Dog $spot .= new(:tail&#60;LONG&#62;, :legs&#60;SHORT&#62;);</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Calling_sets_of_methods"
>Calling sets of methods</a></h1>

<p>For any method name, there may be some number of candidate methods that could handle the request: typically, inherited methods or multi variants. The ordinary &#34;dot&#34; operator dispatches to a method in the standard fashion. There are also &#34;dot&#34; variants that call some number of methods with the same name:</p>

<pre><code>$object.meth(@args)   # calls one method or dies
$object.?meth(@args)  # calls method if there is one, otherwise Nil
$object.*meth(@args)  # calls all methods (0 or more, () if none)
$object.+meth(@args)  # calls all methods (1 or more, die if none)</code></pre>

<p>The method name may be quoted when disambiguation is needed:</p>

<pre><code>$object.&#34;+meth&#34;(@args)
$object.&#39;VAR&#39;(@args)</code></pre>

<p>As with ordinary calls, the identifier supplying the literal method name may be replaced with an interpolated quote to specify the method name indirectly. It may also be replaced with an array to specify the exact list of candidates to be considered:</p>

<pre><code>my @candidates := $object.WALK(:name&#60;foo&#62;, :breadth, :omit($?CLASS));
$object.*@candidates(@args);</code></pre>

<p>The <code>WALK</code> method takes these arguments:</p>

<pre><code>:canonical      # canonical dispatch order
:ascendant      # most-derived first, like destruction order
:descendant     # least-derived first, like construction order
:preorder       # like Perl 5 dispatch
:breadth        # like multi dispatch

:super              # only immediate parent classes
:name&#60;name&#62;         # only classes containing named method declaration
:omit(Selector)     # only classes that don&#39;t match selector
:include(Selector)  # only classes that match selector</code></pre>

<p>Any method can defer to the next candidate method in the list by the special functions <code>callsame</code>, <code>callwith</code>, <code>nextsame</code>, and <code>nextwith</code>. The &#34;same&#34; variants reuse the original argument list passed to the current method, whereas the &#34;with&#34; variants allow a new argument list to be substituted for the rest of the candidates. The &#34;call&#34; variants dispatch to the rest of the candidates and return their values to the current method for subsequent processing, whereas while the &#34;next&#34; variants don&#39;t return, but merely defer to the rest of the candidate list:</p>

<pre><code>callsame;           # call with the original arguments (return here)
callwith();         # call with no arguments (return here)
callwith(1,2,3);    # call with a new set of arguments (return here)
nextsame;           # redispatch with the original arguments (no return)
nextwith();         # redispatch with no arguments (no return)
nextwith(1,2,3);    # redispatch with a new set of arguments (no return)
samewith(1,2,3);    # same dispatcher with new arguments (no return)</code></pre>

<p>For dispatches using <code>.</code> and <code>.?</code>, the return value is the <code>Capture</code> returned by the first method completed without deferring. (Such a return value may in fact be failure, but it still counts as a successful call from the standpoint of the dispatcher.) Likewise the return value of <code>.*</code> and <code>.+</code> is a list of <code>Captures</code> returned by those methods that ran to completion without deferring to next method.</p>

<p>It is also possible to trim the candidate list so that the current call is considered the final candidate. (This is implicitly the case already for the dispatch variants that want a single successful call.) For the multiple call variants, <code>lastcall</code> will cause the dispatcher to throw away the rest of the candidate list, and the subsequent return from the current method will produce the final <code>Capture</code> in the returned list. (If you were already on the last call of the candidate list, no candidates are thrown away, only the list. So you can&#39;t accidentally throw away the wrong list by running off the end, since the candidate list is ordinarily not thrown away by the dispatcher until after the last call.)</p>

<p>Since it&#39;s possible to be dispatching within more than one candidate list at a time, these control flow calls are defined to apply only to the dynamically innermost dispatcher. If, for instance, you have a single dispatch to a <code>proto</code> method that then calls into a multiple dispatch on the <code>multi</code> methods within a class, <code>nextsame</code> within one of those <code>multi</code>s would go to the next best <code>multi</code> method within the class, not the next method candidate in the original single dispatch. This is not a bad limitation, since dispatch loops are dynamically scoped; to get to the outermost lists you can &#34;pop&#34; unwanted candidate lists using <code>lastcall</code>:</p>

<pre><code>lastcall; nextsame;  # call next in grandparent dispatcher loop</code></pre>

<p>[Conjecture: if necessary, <code>lastcall</code> could have an argument or invocant to specify which kind of a dispatch loop we think we&#39;re throwing away, in case we&#39;re not sure about our context. This confusion could arise since we use <code>nextsame</code> semantics at least three different ways: single dispatch, multiple dispatch, and routine wrapper dispatch.]</p>

<p>The <code>samewith</code> redispatches the method call using the current dispatcher: this is mainly intended if you have one &#34;worker&#34; method, and several &#34;frontend&#34; methods in the same class to avoid code duplication. The frontend methods then mangle the parameters before sending them off to the worker method with <code>samewith</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Parallel_dispatch"
>Parallel dispatch</a></h1>

<p>Any of the method call forms may be turned into a hyperoperator by treating the method call as a postfix:</p>

<pre><code>@object&#187;.meth(@args)   # calls one method on each
@object&#187;.?meth(@args)  # calls method if there is one on each
@object&#187;.*meth(@args)  # calls all methods (0 or more) on each
@object&#187;.+meth(@args)  # calls all methods (1 or more) on each
@object&#187;.=meth(@args)  # calls mutator method on each
@object&#187;!meth(@args)   # calls private method on each</code></pre>

<p>The return value is a list with exactly the same number of elements as <code>@object</code>. Each such return value is a <code>Parcel</code> or <code>List</code> of <code>Parcel</code> as specified above for the non-hyper &#34;dot&#34; variants.</p>

<p>Hyperoperators treat a junction as a scalar value, so saying:</p>

<pre><code>$junction&#187;.meth(@args);</code></pre>

<p>is just like:</p>

<pre><code>$junction.meth(@args);</code></pre>

<p>As with other forms of method call, the &#34;meth&#34; above may be replaced with a quoted string or variable to do various forms of indirection.</p>

<p>Note that, as with any hyper operator, the methods may be evaluated in any order (although the method results are always returned in the same order as the list of invocants). Use an explicit loop if you want to do something with ordered side effects, such as I/O.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Multisubs_and_Multimethods"
>Multisubs and Multimethods</a></h1>

<p>The &#34;long name&#34; of a subroutine or method includes the type signature of its invocant arguments. The &#34;short name&#34; doesn&#39;t.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="multi_Declarations"
><code>multi</code> Declarations</a></h2>

<p>If you put <code>multi</code> in front of any sub declaration, it allows multiple long names to share a short name, provided all of them are declared <code>multi</code>, or there is a single prior or outer <code>proto</code> in the same file that causes all unmarked subs to default to multi in that lexical scope. If a sub is not marked with <code>multi</code> and it is not governed within that same file by a <code>proto</code> of the same short name, it is considered unique, an <i>only</i> sub. (An imported <code>proto</code> can function as such a governing declaration.)</p>

<p>For method declarations, the <code>proto</code>, <code>multi</code>, and <code>only</code> declarations work similarly but not identically. The explicit declarations work the same, except that calculation of governance and candidate sets proceeds via the inheritance tree rather than via lexical scoping. The other difference is that a proto method of a given short name forcing all unmarked method declarations to assume multi in all subclasses regardless of which file they are declared in, unless explicitly overridden via <code>only method</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="only_Declarations"
><code>only</code> Declarations</a></h2>

<p>An <code>only</code> sub (or method) doesn&#39;t share with anything outside of it or declared prior to it. Only one such sub (or method) can inhabit a given namespace (lexical scope or class), and it hides any outer subs (or less-derived methods) of the same short name. It is illegal for a <code>multi</code> or <code>proto</code> declaration to share the same scope with an <code>only</code> declaration of the same short name.</p>

<p>Since they come from a different file, the default <code>proto</code> declarations provided by Perl from the setting scope do <i>not</i> automatically set the defaults in the user&#39;s scope unless explicitly imported, so a <code>sub</code> declaration there that happens to be the same as a setting <code>proto</code> is considered <code>only</code> unless explicitly marked <code>multi</code>. (This allows us to add new <code>proto</code> declarations in the setting without breaking the user&#39;s old code.) In the absence of such an explicit <code>sub</code> declaration, however, the <code>proto</code> from the innermost outer lexical scope is used by the compiler in the analysis of any calls to that short name. (Since only list operators may be post-declared, as soon as the compiler sees a non-listop operator it is free to apply the setting&#39;s <code>proto</code> since any user-defined <code>only</code> version of it must of necessity be declared or imported earlier in the user&#39;s file or not at all.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="proto_Declarations"
><code>proto</code> Declarations</a></h2>

<p>A <code>proto</code> always functions as a dispatcher around any <code>multi</code>s declared after it in the same scope, More specifically, it is the generic prototype of a dispatcher, which must be instantiated anew in each scope that has a different candidate list. (This works much like type punning from roles to classes. Or you can think of this dispatcher as a priming of the proto&#39;s code with the candidate list appropriate to the scope.) For the sake of discussion, let us say that there is a declarator equivalent to <code>only</code> that is instead spelled <code>dispatch</code>. Generally a user never writes a <code>dispatch</code> sub (it might not even be allowed); a <code>dispatch</code> is always instantiated from the governing <code>proto</code>. A new <code>dispatch</code> sub or method is autogenerated in any scope that needs one, that is, in any scope that can see a different set of multi declarations than its parent scope (or scopes, in the case of multiple inheritance).</p>

<p>More precisely, for any given <code>proto</code> and a point of call, there is a candidate set of routines (functions or methods) that is the intersection of two sets: the set of routines governed downward by the <code>proto</code> and the set of routines visible upward from the point of a call. It is allowed to reuse the <code>dispatch</code> of a parent scope if and only if it would result in the same candidate list in the current scope (the scope at the point of call).</p>

<p>Since <code>dispatch</code> is nearly identical to <code>only</code>, saying <code>&#38;foo</code> always refers to the innermost visible <code>dispatch</code> or <code>only</code> sub, never to a <code>proto</code> or <code>multi</code>. Likewise, <code>$obj.can(&#39;foo&#39;)</code> will return the most-derived <code>dispatch</code> or <code>only</code> method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="proto_Signatures"
><code>proto</code> Signatures</a></h2>

<p>Within its scope, the signature of a <code>proto</code> also nails down the presumed order and naming of positional parameters, so that any call to that short name with named arguments in that scope can presume to rearrange those arguments into positional parameters based on that information. (Unrecognized names remain named arguments.) Any other type information or traits attached to the <code>proto</code> may also be passed along to the routines within its scope, so a <code>proto</code> definition can be used to factor out common traits. This is particularly useful for establishing grammatical categories in a grammar by declaring a <code>proto</code> <code>token</code> or <code>proto</code> <code>rule</code>. (Perl 6&#39;s grammar does this, for instance.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="multi_Variables"
><code>multi</code> Variables</a></h2>

<p>You can have multiple <code>multi</code> variables of the same name in the same scope, and they all share the same storage location and type. These are declared by one <code>proto</code> declaration at the top, in which case you may leave the <code>multi</code> implicit on the rest of the declarations in the same scope. You might do this when you suspect you&#39;ll have multiple declarations of the same variable name (such code might be produced by a macro or by a code generator, for instance) and you wish to suppress any possible warnings about redefinition.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="multi_Routines"
><code>multi</code> Routines</a></h2>

<p>In contrast, <code>multi</code> routines can have only one instance of the long name in any namespace, and that instance hides any outer (or less-derived) routines with the same long name. It does not hide any routines with the same short name but a different long name. In other words, <code>multi</code>s with the same short name can come from several different namespaces provided their long names differ and their short names aren&#39;t hidden by an <code>only</code> or <code>proto</code> declaration in some intermediate scope.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multisub_Resolution"
>Multisub Resolution</a></h2>

<p>When you call a routine with a particular short name, if there are multiple visible long names, they are all considered candidates. They are sorted into an order according to how close the run-time types of the arguments match up with the declared types of the parameters of each candidate. The best candidate is called, unless there&#39;s a tie, in which case the tied candidates are redispatched using any additional tiebreaker strategies (see below). For the purpose of this nominal typing, no constrained type is considered to be a type name; instead the constrained type is unwound into its base type plus constraint. Only the base type upon which the constrained type is based is considered for the nominal type match (along with the fact that it is constrained). That is, if you have a parameter:</p>

<pre><code>subset Odd of Int where { $_ % 2 }
proto foo {*}
multi foo (Odd $i) {...}</code></pre>

<p>it is treated as if you&#39;d instead said:</p>

<pre><code>multi foo (Int $i where { $_ % 2 }) {...}</code></pre>

<p>Any constrained type is considered to have a base type that is &#34;epsilon&#34; narrower than the corresponding unconstrained type. The compile-time topological sort takes into account the presence of at least one constraint, but nothing about the number or nature of any additional constraints. If we think of Int&#39; as any constrained version of Int, then Int&#39; is always tighter nominally than Int. (Int&#39; is a meta-notation, not Perl 6 syntax.)</p>

<p>The order in which candidates are considered is defined by a topological sort based on the &#34;type narrowness&#34; of each candidate&#39;s long name, where that in turn depends on the narrowness of each parameter that is participating. Identical types are considered tied. Parameters whose types are not comparable are also considered tied. A candidate is considered narrower than another candidate if at least one of its parameters is narrower and all the rest of its parameters are either narrower or tied. Also, if the signature has any additional required parameters not participating in the long name, the signature as a whole is considered epsilon tighter than any signature without extra parameters. In essence, the remaining arguments are added to the longname as if the user had declared a capture parameter to bind the rest of the arguments, and that capture parameter has a constraint that it must bind successfully to the additional required parameters. All such signatures within a given rank are considered equivalent, and subject to tiebreaker B below.</p>

<p>This defines the partial ordering of all the candidates. If the topological sort detects a circularity in the partial ordering, all candidates in the circle are considered tied. A warning will be issued at <code>CHECK</code> time if this is detected and there is no suitable tiebreaker that could break the tie.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Candidate_Tiebreaking"
>Candidate Tiebreaking</a></h3>

<p>There are three tiebreaking modes, in increasing order of desperation:</p>

<pre><code>A) inner or derived scope
B) run-time constraint processing
C) use of a candidate marked with &#34;is default&#34;</code></pre>

<p>Tiebreaker A simply prefers candidates in an inner or more derived scope over candidates in an outer or less derived scope. For candidates in the same scope, we proceed to tiebreaker B.</p>

<p>In the absence of any constraints, ties in tiebreaker A immediately failover to tiebreaker C; if not resolved by C, they warn at compile time about an ambiguous dispatch.</p>

<p>If there are any tied candidates with constraints, it follows from our definitions above that all of them are considered to be constrained. In the presence of longname parameters with constraints, or the implied constraint of extra required arguments, tiebreaker B is applied. Candidates which are tied nominally but have constraints are considered to be a completely different situation, insofar as it is assumed the user knows exactly why each candidate has the extra constraints it has. Thus, constrained signatures are considered to be much more like a switch defined by the user. So for tiebreaker B the candidates are simply called in the order they were declared, and the first one that successfully binds (and completes without calling nextsame or nextwith) is considered the winner, and all the other tied candidates are ignored. If all the constrained candidates fail, we throw out the rank of constrained variants and proceed to the next tighter rank, which may consist of the unconstrained variants without extra arguments.</p>

<p>For ranks that are not decided by constraint (tiebreaker B), tiebreaker C is used: only candidates marked with the <code>default</code> trait are considered, and the best matching default routine is used. If there are no default routines, or if two or more of the defaults are tied for best, the dispatch fails.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Parameter_Constraint_Exclusion"
>Parameter Constraint Exclusion</a></h3>

<p>Ordinarily all the parameters of a multi sub are considered for dispatch. Here&#39;s a declaration for an integer range operator with two parameters in its long name:</p>

<pre><code>multi sub infix:&#60;..&#62;(Int $min, Int $max) {...}</code></pre>

<p>Sometimes you want to have parameters that aren&#39;t counted as part of the long name. For instance, if you want to allow an optional &#34;step&#34; parameter to your range operator, but not consider it for multi dispatch, then put a double semicolon instead of a comma before it:</p>

<pre><code>multi sub infix:&#60;..&#62;(Int $min, Int $max;; Int $by = 1) {...}</code></pre>

<p>The double semicolon, if any, determines the complete long name of a <code>multi</code>. (In the absence of that, a double semicolon is assumed after the last declared argument, but before any return signature.) Note that a call to the routine must still be compatible with subsequent arguments.</p>

<p>Note that the <code>$by</code> is not a required parameter, so doesn&#39;t impose the kind of constraint that allows tiebreaker B. If the default were omitted, it would be a required parameter, and subject to tiebreaker B. Likewise an ordinary named parameter does not participate as a tiebreaker, but you can mark named parameters as required to effectively make a switch based on named binding:</p>

<pre><code>multi foo (Int $a;; :$x!) {...}     # constrained
multi foo (Int $a;; :$y!) {...}     # constrained
multi foo (Int $a;; :$z!) {...}     # constrained

multi foo (Int $a;; *%_) {...}      # unconstrained</code></pre>

<p>The first three are dispatched under tiebreaker B as a constrained rank. If none of them can match, the final one is dispatched as an unconstrained rank, since <code>*%_</code> is not considered a required parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Constrained_Type_Candidates"
>Constrained Type Candidates</a></h3>

<p>Likewise, constrained types sort before unconstrained:</p>

<pre><code>multi bar (Even $a) {...}   # constrained
multi bar (Odd $a) {...}    # constrained

multi bar (Int $a) {...}    # unconstrained</code></pre>

<p>And values used as subset types also sort first, and are dispatched on a first-to-match basis:</p>

<pre><code>multi baz (0) {...}         # constrained
multi baz (1) {...}         # constrained

multi baz (Int $x) {...}    # unconstrained</code></pre>

<p>If some of the constrained candidates come by import from other modules, they are all considered to be declared at the point of importation for purposes of tiebreaking; subsequent tiebreaking is provided by the original order in the used module.</p>

<p>[Conjecture: However, a given <code>multi</code> may advertise multiple long names, some of which are shorter than the complete long name. This is done by putting a semicolon after each advertised long name (replacing the comma, if present). A semicolon has the effect of inserting two candidates into the list. One of them is inserted with exactly the same types, as if the semicolon were a comma. The other is inserted as if all the types after the semicolon were of type <code>Any</code>, which puts it later in the list than the narrower actual candidate. This merely determines its sort order; the candidate uses its real type signature if the dispatcher gets to it after rejecting all earlier entries on the candidate list. If that set of delayed candidates also contains ties, then additional semicolons have the same effect within that sublist of ties. Note, however, that semicolon is a no-op if the types after it are all <code>Any</code>. (As a limiting case, putting a semicolon after every parameter produces dispatch semantics much like Common Lisp. And putting a semicolon after only the first argument is much like ordinary single-dispatch methods.) Note: This single-semicolon syntax is merely to be considered reserved until we understand the semantics of it, and more importantly, the pragmatics of it (that is, whether it has any valid use case). Until then only the double-semicolon form will be implemented in the standard language.]</p>

<p>A <code>method</code> or <code>submethod</code> doesn&#39;t ordinarily participate in any subroutine-dispatch process. However, they can be made to do so if prefixed with a <code>my</code> or <code>our</code> declarator.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Multi_Submethods_et_Cetera"
>Multi Submethods et Cetera</a></h3>

<p>Multi submethods work just like multi methods except they are constrained to an exact type match on the invocant, just as ordinary submethods are.</p>

<p>Perl 6.0.0 is not required to support multiple dispatch on named parameters, only on positional parameters. Note however that any dispatcher derived from <code>proto</code> will map named arguments to known declared positional parameters and call the <code>multi</code> candidates with positionals for those arguments rather than named arguments.</p>

<p>Within a multiple dispatch, <code>nextsame</code> means to try the next best match, or next best default in case of tie.</p>

<p>The <code>sub</code> keyword is optional immediately after a <code>proto</code>, <code>multi</code>, or <code>only</code> keyword, but the <code>method</code> keyword is not.</p>

<p>A <code>proto</code> declaration may not occur after a <code>multi</code> declaration in the same scope.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Method_call_vs._Subroutine_call"
>Method call vs. Subroutine call</a></h2>

<p>The caller indicates whether to make a method call or subroutine call by the call syntax. The &#34;dot&#34; form and the indirect object form default to method calls. All other prefix calls default to subroutine calls. This applies to prefix unary operators as well:</p>

<pre><code>!$obj;  # same as $obj.prefix:&#60;!&#62;</code></pre>

<p>A method call considers only methods (including multi-methods and submethods) from the class hierarchy of its invocant, and fails if none is found. The object in question is in charge of interpreting the meaning of the method name, so if the object is a foreign object, the name will be interpreted by that foreign runtime.</p>

<p>A subroutine call considers only visible subroutines (including submethods) of that name. The object itself has no say in the dispatch; the subroutine dispatcher considers only the types the arguments involved, along with the name. Hence foreign objects passed to subroutines are forced to follow Perl semantics (to the extent foreign types can be coerced into Perl types, otherwise they fail).</p>

<p>There is no fail-over either from subroutine to method dispatch or vice versa. However, you may use <code>is export</code> on a method definition to make it available also as a <code>multi</code> sub. As with indirect object syntax, the first argument is still always the invocant, but the export allows you to use a comma after the invocant instead of a colon, or to omit the colon entirely in the case of a method with no arguments other than the invocant. Many standard methods (such as <code>IO::close</code> and <code>Array::push</code>) are automatically exported to the <code>CORE</code> namespace by default. For other exported methods, you will not see the <code>multi</code> sub definition unless you <code>use</code> the class in your scope, which will import the <code>proto</code> (and associated <code>multi</code> subs) lexically, after which you can call it using normal subroutine call syntax.</p>

<p>In the absence of an explicit type on the method&#39;s invocant, the exported <code>multi</code> sub&#39;s first argument is implicitly constrained to match the class in which it was defined or composed, so for instance the <code>multi</code> version of <code>close</code> requires its first argument to be of type <code>IO</code> or one of its subclasses. If the invocant is explicitly typed, that will govern the type coverage of the corresponding <code>multi</code>&#39;s first argument, whether that is more specific or more general than the class&#39;s invocant would naturally be. (But be aware that if it&#39;s more specific than <code>::?CLASS</code>, the binding may reject an otherwise valid single dispatch as well as a multi dispatch.) In any case, it does no good to overgeneralize the invocant if the routine itself cannot handle the broader type. In such a situation you must write a wrapper to coerce to the narrower type.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Trusts"
>Trusts</a></h1>

<p>Attributes are tied to a particular class definition, so a method can only directly access the attributes of a class it&#39;s defined within when the invocant is the &#34;self&#34; of that attribute. However, it may call the private attribute accessors from a different class if that other class has indicated that it trusts the class the multi method is defined in:</p>

<pre><code>class MyClass {
    trusts YourClass;
    ...
}</code></pre>

<p>The trust really only applies to <code>MyClass</code>, not to possible subclasses thereof.</p>

<p>The syntax for calling back to <code>MyClass</code> is <code>$obj!MyClass::meth()</code>. Note that private attribute accessors are always invoked directly, never via a dispatcher, since there is never any question about which object is being referred to. Hence, the private accessor notation may be aggressively inlined for simple attributes, and no simpler notation is needed for accessing another object&#39;s private attributes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Delegation"
>Delegation</a></h1>

<p>Delegation lets you pretend that some other object&#39;s methods are your own. Delegation is specified by a <code>handles</code> trait verb with an argument specifying one or more method names that the current object and the delegated object will have in common:</p>

<pre><code>has $tail handles &#39;wag&#39;;</code></pre>

<p>Since the method name (but nothing else) is known at class construction time, the following <code>.wag</code> method is autogenerated for you:</p>

<pre><code>method wag (|args) { $!tail.wag(|args) }</code></pre>

<p>You can specify multiple method names:</p>

<pre><code>has $.legs handles &#60;walk run lope shake lift&#62;;</code></pre>

<p>It&#39;s illegal to call the outer method unless the attribute has been initialized to an object of a type supporting the method, such as by:</p>

<pre><code>has Tail $.tail handles &#39;wag&#39; .= new(|%_);</code></pre>

<p>Note that putting a <code>Tail</code> type on the attribute does not necessarily mean that the method is always delegated to the <code>Tail</code> class. The dispatch is still based on the <i>run-time</i> type of the object, not the declared type.</p>

<p>Any other kind of argument to <code>handles</code> is considered to be a smartmatch selector for method names. All such selectors establish a failover to be used only if normal method dispatch fails, so it cannot be used to override any method in the normal ancestry of the object. So you can say:</p>

<pre><code>has $.fur is rw handles /^get_/;</code></pre>

<p>If you say</p>

<pre><code>has $.fur is rw handles Groomable;</code></pre>

<p>then you get only those methods available via the <code>Groomable</code> role or class. To delegate everything, use the <code>Whatever</code> matcher:</p>

<pre><code>has $the_real_me handles *;</code></pre>

<p>Wildcard matches are evaluated only after it has been determined that there&#39;s no exact match to the method name anywhere in this object or in any of its parents. When you have multiple wildcard delegations to different objects, it&#39;s possible to have a conflict of method names. Wildcard method matches are evaluated in order, so the earliest one wins. (Non-wildcard method conflicts can be caught at class composition time.) If the wildcards for this class find nothing, then wildcards are checked for each of the ancestral classes in standard method resolution order.</p>

<p>The form with <code>*</code> checks only for existing methods in the delegate&#39;s class (or its parents). It will not call any kind of a fallback via the delegate. (This allows you to call a <code>FALLBACK</code> routine of your own if the delegation would fail, since your own <code>FALLBACK</code> always runs after delegation, even wildcard delegation.) If instead you want to delegate completely and utterly, including a search of the delegate for its own fallback methods, with abject failure if the delegate can&#39;t handle it, then use the &#34;HyperWhatever&#34; instead:</p>

<pre><code>has $the_real_me handles **;</code></pre>

<p>If, where you would ordinarily specify a string, you put a pair, then the pair maps the method name in this class to the method name in the other class. If you put a hash, each key/value pair is treated as such a mapping. Such mappings are not considered wildcards.</p>

<pre><code>has $.fur handles { :shakefur&#60;shake&#62;, :scratch&#60;get_fleas&#62; };</code></pre>

<p>You <i>can</i> do a wildcard renaming, but not with pairs. Instead do smartmatch with a substitution:</p>

<pre><code>has $.fur handles (s/^furget_/get_/);</code></pre>

<p>Ordinarily delegation is based on an attribute holding an object, but it can also be based on the return value of a method:</p>

<pre><code>method select_tail handles &#60;wag hang&#62; {...}</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Types_and_Subtypes"
>Types and Subtypes</a></h1>

<p>The type system of Perl consists of roles, classes, and subtypes. You can declare a subtype like this:</p>

<pre><code>my subset Str_not2b of Str where /^[isnt|arent|amnot|aint]$/;</code></pre>

<p>or this:</p>

<pre><code>my Str subset Str_not2b where /^[isnt|arent|amnot|aint]$/;</code></pre>

<p>An anonymous subtype looks like this:</p>

<pre><code>Str where /^[isnt|arent|amnot|aint]$/;</code></pre>

<p>A <code>where</code> clause implies future smartmatching of some kind: the as-yet unspecified object of the type on the left must match the selector on the right. Our example is roughly equivalent to this closure:</p>

<pre><code>{ $_.does(Str) and $_ ~~ /^[isnt|arent|amnot|aint]$/; }</code></pre>

<p>except that a subtype knows when to call itself.</p>

<p>A subtype is not a subclass. Subclasses add capabilities, whereas a subtype adds constraints (takes away capabilities). A subtype is primarily a handy way of sneaking smartmatching into multiple dispatch. Just as a role allows you to specify something more general than a class, a subtype allows you to specify something more specific than a class. A subtype specifies a subset of the values that the original type specified, which is why we use the <code>subset</code> keyword for it.</p>

<p>While subtypes are primarily intended for restricting parameter types for multiple dispatch, they also let you impose preconditions on assignment. If you declare any container with a subtype, Perl will check the constraint against any value you might try to bind or assign to the container.</p>

<pre><code>subset Str_not2b of Str where /^[isnt|arent|amnot|aint]$/;
subset EvenNum   of Num where { $^n % 2 == 0 }

my Str_not2b $hamlet;
$hamlet = &#39;isnt&#39;;   # Okay because &#39;isnt&#39; ~~ /^[isnt|arent|amnot|aint]$/
$hamlet = &#39;amnt&#39;;   # Bzzzzzzzt!   &#39;amnt&#39; !~~ /^[isnt|arent|amnot|aint]$/

my EvenNum $n;
$n = 2;             # Okay
$n = -2;            # Okay
$n = 0;             # Okay
$n = 3;             # Bzzzzzzzt</code></pre>

<p>It&#39;s legal to base one subtype on another; it just adds an additional constraint. That is, it&#39;s a subset of a subset.</p>

<p>You can use an anonymous subtype in a signature:</p>

<pre><code>sub check_even (Num where { $^n % 2 == 0 } $even) {...}</code></pre>

<p>That&#39;s a bit unwieldy, but by the normal type declaration rules you can turn it around to get the variable out front:</p>

<pre><code>sub check_even ($even of Num where { $^n % 2 == 0 }) {...}</code></pre>

<p>and just for convenience we also let you write it:</p>

<pre><code>sub check_even (Num $even where { $^n % 2 == 0 }) {...}</code></pre>

<p>since all the type constraints in a signature parameter are just anded together anyway.</p>

<p>You can leave out the block when matching against a literal value of some kind:</p>

<pre><code>proto sub fib (Int $) {*}
multi sub fib (Int $n where 0|1) { return $n }
multi sub fib (Int $n) { return fib($n-1) + fib($n-2) }</code></pre>

<p>In fact, you can leave out the <code>where</code> declaration altogether:</p>

<pre><code>multi sub fib (0) { return 0 }
multi sub fib (1) { return 1 }
multi sub fib (Int $n) { return fib($n-1) + fib($n-2) }</code></pre>

<p>Subtype constraints are used as tiebreakers in multiple dispatch:</p>

<pre><code>use Rules::Common :profanity;

multi sub mesg ($mesg of Str where /&#60;profanity&#62;/ is copy) {
    $mesg ~~ s:g/&#60;profanity&#62;/[expletive deleted]/;
    print $MESG_LOG: $mesg;
}

multi sub mesg ($mesg of Str) {
    print $MESG_LOG: $mesg;
}</code></pre>

<p>For multi dispatch, a long name with a matching constraint is preferred over an equivalent one with no constraint. So the first <code>mesg</code> above is preferred if the constraint matches; otherwise the second is preferred.</p>

<p>To export a subset type, put the export trait just before the <code>where</code>:</p>

<pre><code>subset Positive of Int is export where * &#62; 0;</code></pre>

<p>Note that the declaration of the <code>of</code> type for a subset doesn&#39;t really mean what an <code>of</code> type means elsewhere in the language. It is merely declaring the universe of input values for a boolean function. In fact, when used as a coercion, a subset type returns a <code>Bool</code> based on its condition, so it can be used directly as a predicate without the overhead of smartmatching:</p>

<pre><code>if Even($x) { ... }
.say if .Even for 1..10;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Abstract_vs_Concrete_types"
>Abstract vs Concrete types</a></h2>

<p>For any named type, certain other subset types may automatically be derived from it by appending an appropriate adverbial to its name:</p>

<pre><code>Int:_       Allow either defined or undefined Int values
Int:D       Allow only defined (concrete) Int values
Int:U       Allow only undefined (abstract or failure) Int values
Int:T       Allow Int only as a type object</code></pre>

<p>That is, these mean something like:</p>

<pre><code>Int:D       Int:_ where DEFINITE($_)
Int:U       Int:_ where not(DEFINITE($_))
Int:T       Int:U where none(Failure)</code></pre>

<p>where <code>DEFINITE</code> is a boolean macro that says whether the object in question has a valid concrete representation (see <a href="#Introspection" class="podlinkpod"
>&#34;Introspection&#34;</a> below).</p>

<p>In standard Perl 6, <code>Int</code> is generally assumed to mean <code>Int:_</code>, except for invocants, where the default is <code>Int:D</code>. (The default <code>new</code> method has a prototype whose invocant is <code>:T</code> instead, so all new methods all default to allowing type objects.)</p>

<p>These defaults may be changed within a lexical scope by various pragmas. In particular,</p>

<pre><code>use parameters :D;</code></pre>

<p>will cause non-invocant parameters to default to <code>:D</code>. Conjecturally,</p>

<pre><code>use variables :D;</code></pre>

<p>would do the same for types used in variable declarations.</p>

<p>In such lexical scopes you may use the <code>:_</code> form to get back to the standard behavior. In particular, since invocants default to defined,</p>

<pre><code>use invocant :_;</code></pre>

<p>will make invocants allow any sort of defined or undefined invocant.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multiple_constraints"
>Multiple constraints</a></h2>

<p>[Conjecture: This entire section is considered a guess at our post-6.0.0 direction. For 6.0.0 we will allow only a single constraint before the variable, and post constraints will all be considered &#34;epsilon&#34; narrower than the single type on the left. The single constraint on the left may, however, be a value like 0 or a named subset type. Such a named subset type may be predeclared with an arbitrarily complex <code>where</code> clause; for 6.0.0 any structure type information inferable from the <code>where</code> clause will be ignored, and the declared subset type will simply be considered nominally derived from the <code>of</code> type mentioned in the same declaration.]</p>

<p>More generally, a parameter can have a set of constraints, and the set of constraints defines the formal type of the parameter, as visible to the signature. (No one constraint is privileged as the storage type of the actual argument, unless it is a native type.) All constraints are considered in type narrowness. That is, these are equivalently narrow:</p>

<pre><code>Foo Bar @x
Bar Foo @x</code></pre>

<p>The constraint implied by the sigil also counts as part of the official type. The sigil is actually a constraint on the container, so the actual type of the parameter above is something like:</p>

<pre><code>Positional[subset :: of Any where Foo &#38; Bar }]</code></pre>

<p>Static <code>where</code> clauses also count as part of the official type. A <code>where</code> clause is considered static if it can be applied to the types to the left of it at compile time to produce a known finite set of values. For instance, a subset of an enum type is a static set of values. Hence</p>

<pre><code>Day $d where &#39;Mon&#39;..&#39;Fri&#39;</code></pre>

<p>is considered equivalent to</p>

<pre><code>subset Weekday of Day where &#39;Mon&#39;..&#39;Fri&#39;;
Weekday $d</code></pre>

<p>Types mentioned in a dynamic <code>where</code> class are not considered part of the official type, except insofar as the type includes the notion: &#34;is also constrained by a dynamic <code>where</code> clause&#34;, which narrows it by epsilon over the equivalent type without a <code>where</code> clause.</p>

<pre><code>Foo Bar @x              # type is Foo &#38; Bar &#38; Positional
Foo Bar @x where Baz    # slightly tighter than Foo Bar Positional</code></pre>

<p>The set of constraints for a parameter creates a subset type that implies some set of allowed values for the parameter. The set of allowed values may or may not be determinable at compile time. When the set of allowed values is determinable at compile time, we call it a static subtype.</p>

<p>Type constraints that resolve to a static subtype (that is, with a fixed set of elements knowable (if not known) at compile time) are considered to be narrower than type constraints that involve run-time calculation, or are otherwise intractable at compile time. Note that all values such as 0 or &#34;foo&#34; are considered singleton static subtypes. Singleton values are considered narrower than a subtype with multiple values, even if the subtype contains the value in question. This is because, for enumerable types, type narrowness is defined by doing set theory on the set of enumerated values.</p>

<p>So assuming:</p>

<pre><code>my enum Day [&#39;Sun&#39;,&#39;Mon&#39;,&#39;Tue&#39;,&#39;Wed&#39;,&#39;Thu&#39;,&#39;Fri&#39;,&#39;Sat&#39;];
subset Weekday of Day where &#39;Mon&#39; .. &#39;Fri&#39;; # considered static
subset Today of Day where *.today;</code></pre>

<p>we have the following pecking order:</p>

<pre><code>Parameter                   # Set of possible values
=========                   ========================
Int $n                      # Int

Int $n where Today          # Int plus dynamic where
Int $n where 1 &#60;= * &#60;= 5    # Int plus dynamic where

Day $n                      # 0..6

Day $n where Today          # 0..6 plus dynamic where

Day $n where 1 &#60;= * &#60;= 5    # 1..5
Int $n where Weekday        # 1..5
Day $n where Weekday        # 1..5
Weekday $n                  # 1..5

Tue                         # 2</code></pre>

<p>Note the difference between:</p>

<pre><code>Int $n where 1 &#60;= * &#60;= 5    # Int plus dynamic where
Day $n where 1 &#60;= * &#60;= 5    # 1..5</code></pre>

<p>The first <code>where</code> is considered dynamic not because of the nature of the comparisons but because <code>Int</code> is not finitely enumerable. Our <code>Weekday</code> subset type can calculate the set membership at compile time because it is based on the <code>Day</code> enum, and hence is considered static despite the use of a <code>where</code>. Had we based <code>Weekday</code> on <code>Int</code> it would have been considered dynamic. Note, however, that with &#34;anded&#34; constraints, any enum type governs looser types, so</p>

<pre><code>Int Day $n where 1 &#60;= * &#60;= 5</code></pre>

<p>is considered static, since <code>Day</code> is an enum, and cuts down the search space.</p>

<p>The basic principle we&#39;re trying to get at is this: in comparing two parameter types, the narrowness is determined by the subset relationships on the sets of possible values, not on the names of constraints, or the method by which those constraints are specified. For practical reasons, we limit our subset knowledge to what can be easily known at compile time, and consider the presence of one or more dynamic constraints to be epsilon narrower than the same set of possible values without a dynamic constraint.</p>

<p>As a first approximation for 6.0.0, subsets of enums are static, and other subsets are dynamic. We may refine this in subsequent versions of Perl.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Enumerations"
>Enumerations</a></h1>

<p>An enumeration is a type that facilitates the use of a set of symbols to represent a set of constant values. Its most obvious use is the translation of those symbols to their corresponding values. Each enumeration association is a constant pair known as an <i>enum</i>, which is of type <code>Enum</code>. Each enum associates an <i>enum key</i> with an <i>enum value</i>. Semantically therefore, an enumeration operates like a constant hash, but since it uses a package <code>Stash</code> to hold the entries, it presents itself to the user&#39;s namespace as a typename package containing a set of constant declarations. That is,</p>

<pre><code>enum E &#60;a b c&#62;;</code></pre>

<p>is largely syntactic sugar for:</p>

<pre><code>package E {
    constant a = 0;
    constant b = 1;
    constant c = 2;
}</code></pre>

<p>(However, the <code>enum</code> declaration supplies extra semantics.)</p>

<p>Such constant declarations allow the use of the declared names to stand in for the values where a value is desired. In addition, since a constant declaration introduces a name that behaves as a subtype matching a single value, the enum key can function as a typename in certain capacities where a typename is required. The name of the enumeration as a whole is also considered a typename, and may be used to represent the set of values. (Note that when we wish to verbally distinguish the enumeration as a whole from each individual enum pair, we use the long term &#34;enumeration&#34; for the former, despite the fact that it is declared using the <code>enum</code> keyword.)</p>

<p>In the <code>enum</code> declaration, the keys are specified as a parenthesized list, or an equivalent angle bracket list:</p>

<pre><code>my enum Day (&#39;Sun&#39;,&#39;Mon&#39;,&#39;Tue&#39;,&#39;Wed&#39;,&#39;Thu&#39;,&#39;Fri&#39;,&#39;Sat&#39;);
my enum Day &#60;Sun Mon Tue Wed Thu Fri Sat&#62;;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Value_Generation"
>Value Generation</a></h2>

<p>The values are generated implicitly by default, but may also be specified explicitly. If the first value is unspecified, it defaults to 0. To specify the first value, use pair notation (see below).</p>

<p>If the declared enumeration typename begins with an uppercase letter, the enum values will be derived from <code>Int</code> or <code>Str</code> as appropriate. If the enumeration typename is lowercase, the enumeration is assumed to be representing a set of native values, so the default value type is <code>int</code> or <code>buf</code>.</p>

<p>The base type can be specified if desired:</p>

<pre><code>my bit enum maybe &#60;no yes&#62;;
my Int enum day (&#39;Sun&#39;,&#39;Mon&#39;,&#39;Tue&#39;,&#39;Wed&#39;,&#39;Thu&#39;,&#39;Fri&#39;,&#39;Sat&#39;);
our enum day of uint4 &#60;Sun Mon Tue Wed Thu Fri Sat&#62;;</code></pre>

<p>The declared base type automatically distributes itself to the individual constant values. For non-native types, the enum objects are guaranteed only to be derived from and convertible to the specified type. The actual type of the enum object returned by using the symbol is the enumeration type itself.</p>

<pre><code>Fri.WHAT    # Day, not Int.
+Fri        # 5
Fri.Numeric # 5
Fri ~~ Int  # True, because derived from Int
Fri.perl    # &#39;Day::Fri&#39;
~Fri        # &#39;Fri&#39; (only for numeric enums)
Fri.Stringy # &#39;Fri&#39; (only for numeric enums)
Fri.Str     # &#39;Fri&#39; (only for numeric enums)
Fri.gist    # &#39;Fri&#39; (used by say)
Fri.key     # &#39;Fri&#39;
Fri.value   # 5
Fri.pair    # :Fri(5)
Fri.kv      # &#39;Fri&#39;, 5
Fri.defined # True</code></pre>

<p>Other than that, number valued enums act just like numbers, while string valued enums act just like strings. <code>Fri.so</code> is true because its value is 5 rather than 0. <code>Sun.so</code> is false.</p>

<p>Enums based on native types may be used only for their value, since a native value doesn&#39;t know its own type.</p>

<p>Since methods on native types delegate to their container&#39;s type, a variable typed with a native type will know which method to call:</p>

<pre><code>my day $d = 3;
$d.key     # returns &#34;Wed&#34;</code></pre>

<p>Such declarational forms are not always convenient; to translate native enum values back to their names operationally, you can pull out the enum type&#39;s <code>EnumMap</code> and invert it:</p>

<pre><code>constant %dayname := day.enums.invert;
%dayname{3} # Wed</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_Enumeration_Type"
>The Enumeration Type</a></h2>

<p>The enumeration type itself is an undefined type object, but supplies convenient methods:</p>

<pre><code>Day.defined   # False
3 ~~ Day($_)  # True, in range
8 ~~ Day($_)  # False, *not* in range
Day.enums     # map of key/value pairs</code></pre>

<p>The <code>.enums</code> method returns an <code>EnumMap</code> that may be used either as a constant hash value or as a list of pairs:</p>

<pre><code>my enum CoinFace &#60;Heads Tails&#62;;
CoinFace.enums.keys       # (&#39;Heads&#39;, &#39;Tails&#39;)
CoinFace.enums.values     # (0, 1)
CoinFace.enums.kv         # (&#39;Heads&#39;, 0, &#39;Tails&#39;, 1)
CoinFace.enums.invert     # (0 =&#62; &#39;Heads&#39;, 1 =&#62; &#39;Tails&#39;)
CoinFace.enums.[1]        # Tails =&#62; 1</code></pre>

<p>The enumeration typename itself may be used as a coercion operator from either the key name or a value. First the argument is looked up as a key; if that is found, the enum object is returned. If the key name lookup fails, the value is looked up using an inverted mapping table (which might have duplicates if the mapping is not one-to-one):</p>

<pre><code>Day(&#39;Tue&#39;)           # Tue constant, found as key
Day::(&#39;Tue&#39;)         # (same thing)

Day(3)               # Wed constant, found as value
Day.enums.invert{3}  # (same thing)</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Anonymous_Enumerations"
>Anonymous Enumerations</a></h2>

<p>An anonymous <code>enum</code> just makes sure each string turns into a pair with sequentially increasing values, so:</p>

<pre><code>%e = enum &#60; ook! ook. ook? &#62;;</code></pre>

<p>is equivalent to:</p>

<pre><code>%e = ();
%e&#60;ook!&#62; = 0;
%e&#60;ook.&#62; = 1;
%e&#60;ook?&#62; = 2;</code></pre>

<p>The return value of an anonymous enumeration is an <code>EnumMap</code>. The <code>enum</code> keyword is still a declarator here, so the list is evaluated at compile time. Use a coercion to <code>EnumMap</code> to get a run-time map.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Composition_from_Pairs"
>Composition from Pairs</a></h2>

<p>The enumeration composer inspects list values for pairs, where the value of the pair sets the next value explicitly. Non-pairs <code>++</code> the previous value. (Str and buf types increment like Perl 5 strings.) Since the <code>&#171;...&#187;</code> quoter automatically recognizes pair syntax along with interpolations, we can simply say:</p>

<pre><code>my enum DayOfWeek &#171;:Sun(1) Mon Tue Wed Thu Fri Sat&#187;;

our Str enum Phonetic &#171;:Alpha&#60;A&#62; Bravo Charlie Delta
                        Echo Foxtrot Golf Hotel India Juliet
                        Kilo Lima Mike November Oscar Papa
                        Quebec Romeo Sierra Tango Uniform
                        Victor Whiskey X-ray Yankee Zulu&#187;;

enum roman (i =&#62; 1,   v =&#62; 5,
            x =&#62; 10,  l =&#62; 50,
            c =&#62; 100, d =&#62; 500,
            m =&#62; 1000);

my Item enum hex &#171;:zero(0) one two three four five six seven eight nine
                  :ten&#60;a&#62; eleven twelve thirteen fourteen fifteen&#187;;</code></pre>

<p>Note that enumeration declaration evaluates its list at compile time, so any interpolation into such a list may not depend on run-time values. Otherwise enums wouldn&#39;t be constants. (If this isn&#39;t what you want, try initializing an ordinary declaration using <code>::=</code> to make a scoped readonly value.)</p>

<p>You may import enum types; only non-colliding symbols are imported. Colliding enum keys are hidden and must be disambiguated with the type name. Any attempt to use the ambiguous name will result in a fatal compilation error. (All colliding values are hidden, not just the new one, or the old one.) Any explicit sub or type definition hides all imported enum keys of the same name but will produce a warning unless <code>is redefined</code> is included.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Anonymous_Mixin_Roles_using_but_or_does"
>Anonymous Mixin Roles using <code>but</code> or <code>does</code></a></h2>

<p>Since non-native <code>Enum</code> values know their enumeration type, they may be used to name a desired property on the right side of a <code>but</code> or <code>does</code>. So these:</p>

<pre><code>$x = &#34;Today&#34; but Tue;
$y does True;</code></pre>

<p>expand to:</p>

<pre><code>$x = &#34;Today&#34; but Day::Tue;
$y does Bool::True;</code></pre>

<p>The <code>but</code> and <code>does</code> operators expect a role on their right side. An enum type is not in itself a role type; however, the <code>but</code> and <code>does</code> operators know that when a user supplies an enum type, it implies the generation of an anonymous mixin role that creates an appropriate accessor, read-write if an attribute is being created, and read-only otherwise. It depends on whether you mix in the whole or a specific enum or the whole enumeration:</p>

<pre><code>$x = &#34;Today&#34; but Tue;       # $x.Day is read-only
$x = &#34;Today&#34; but Day;       # $x.Day is read-write</code></pre>

<p>Mixing in a specific enum object implies only the readonly accessor.</p>

<pre><code>$x = &#34;Today&#34; but Tue;</code></pre>

<p>really means something like:</p>

<pre><code>$x = &#34;Today&#34;.clone;
$x does anon role { method Day { Day::Tue } };</code></pre>

<p>The fully qualified form does the same thing, and is useful in case of enum collision:</p>

<pre><code>$x = &#34;Today&#34; but Day::Tue;</code></pre>

<p>Note that the method name is still <code>.Day</code>, however. If you wish to mix in colliding method names, you&#39;ll have to mixin your own anonymous role with different method names.</p>

<p>Since an enumeration supplies the type name as a coercion, you can also say:</p>

<pre><code>$x = &#34;Today&#34; but Day(Tue);
$x = &#34;Today&#34; but Day(2);</code></pre>

<p>After any of those</p>

<pre><code>$x.Day</code></pre>

<p>returns <code>Day::Tue</code> (that is, the constant object representing 2), and both the general and specific names function as typenames in normal constraint and coercion uses. Hence,</p>

<pre><code>$x ~~ Day
$x ~~ Tue
$x.Day == Tue
Day($x) == Tue
$x.Tue</code></pre>

<p>all return true, and</p>

<pre><code>$x.Wed
$x.Day == Wed
8 ~~ Day($_)</code></pre>

<p>all return false.</p>

<p>Mixing in the full enumeration type produces a read-write attribute:</p>

<pre><code>$x = &#34;Today&#34; but Day;       # read-write .Day</code></pre>

<p>really means something like:</p>

<pre><code>$x = &#34;Today&#34;.clone;
$x does anon role { has Day $.Day is rw }</code></pre>

<p>except that nothing happens if there is already a <code>rw</code> attribute of that name.</p>

<p>Note that the attribute is not initialized. If that is desired you can supply a <code>WHENCE</code> closure:</p>

<pre><code>$x = &#34;Today&#34; but Day{ :Day(Tue) }
$x = &#34;Today&#34; but Day{ Tue }  # conjecturally, for &#34;simple&#34; roles</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Adding_Traits"
>Adding Traits</a></h2>

<p>To add traits to an enumeration declaration, place them after the declared name but before the list:</p>

<pre><code>enum Size is silly &#60;regular large jumbo&#62;;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Exporting"
>Exporting</a></h2>

<p>To export an enumeration, place the export trait just before the list:</p>

<pre><code>enum Maybe is export &#60;No Yes Dunno&#62;;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Implying_a_Role"
>Implying a Role</a></h2>

<p>To declare that an enumeration implies a particular role, supply a <code>does</code> in the same location</p>

<pre><code>enum Maybe does TristateLogic &#60;No Yes Dunno&#62;;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Built-in_Enumerations"
>Built-in Enumerations</a></h2>

<p>Two built-in enumerations are:</p>

<pre><code>our enum Bool does Boolean &#60;False True&#62;;
our enum Taint does Tainting &#60;Untainted Tainted&#62;;</code></pre>

<p>Note that <code>Bool</code> and <code>Taint</code> are not role names themselves but imply roles, and the enum values are really subset types of <code>Int</code>, though the constant objects themselves know that they are of type <code>Bool</code> or <code>Taint</code>, and can therefore be used correctly in multimethod dispatch.</p>

<p>You can call the low-level <code>.Bool</code> coercion on any built-in type, because all built-in types do the <code>Boolean</code> role, which requires a <code>.Bool</code> method. Hence, there is a great difference between saying</p>

<pre><code>    $x does Boolean;        # a no-op, since $x already does Boolean
    $x does Bool;           # create a $.Bool attribute, also does Boolean</code></pre>

<p>Conditionals evaluate the truth of a boolean expression by testing the return value of <code>.Bool</code>; how they do this is a mystery, except that they must do something mysterious and platform dependent to avoid calling <code>.Bool</code> recursively on the results of <code>.Bool</code>.</p>

<p>Never compare a value to &#34;<code>True</code>&#34;. Just use it in a boolean context. Well, almost never...</p>

<p>If you wish to be explicit about a boolean context, use the high-level <code>so</code> function or <code>?</code> prefix operator, which are underlying based on the <code>.Bool</code> method. Since <code>.Bool</code> always collapses junctions, so do these functions. (Hence if you really need to autothread a bunch of boolean values, you&#39;ll have to convert them to some other type such as <code>Bit</code> that can be used as a boolean value later. Generally it makes no sense to autothread booleans, so we have a policy of collapsing them sooner rather than later.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Miscellaneous_Rules"
>Miscellaneous Rules</a></h2>

<p>Like other type names and constant names, enum keynames are parsed as standalone tokens representing scalar values, and don&#39;t look for any arguments. Unlike type names but like constant names, enum keynames return defined values. Also unlike types and unlike the enum type as a whole, individual keynames do not respond to <code>.()</code> unless you mix in <code>Callable</code> somehow. (That is, it makes no sense to coerce Wednesday to Tuesday by saying <code>Tue($wed)</code>.) Enumerations may not be post-declared.</p>

<pre><code>our enum Maybe &#60;OK FAIL&#62;;
sub OK is redefined {...}
$x = OK;   # certainly the enum value
$x = OK()  # certainly the function</code></pre>

<p>Since there is an enum <code>OK</code>, the function <code>OK</code> may only be called using parentheses, never in list operator form. (If there is a collision on two enum values that cancels them both, the function still may only be called with parentheses, since the enum key is &#34;poisoned&#34;.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_.pick_Method"
>The <code>.pick</code> Method</a></h2>

<p>Enumeration types (and perhaps certain other finite, enumerable types such as finite ranges) define a <code>.pick</code> method on the type object of that type. Hence:</p>

<pre><code>my enum CoinFace &#60;Heads Tails&#62;;
CoinFace.pick</code></pre>

<p>returns <code>Heads</code> or <code>Tails</code> with equal probability, and</p>

<pre><code>Month.pick(*)</code></pre>

<p>will return the months in random order. Presumably</p>

<pre><code>StandardPlayingCards.pick(5)</code></pre>

<p>might return a Royal Flush, but a Full House is much more likely. It can never return Five Aces, since the pick is done without replacement. (If it <i>does</i> return Five Aces, it&#39;s time to walk away. Or maybe run.)</p>

<p>To pick from the list of keynames or values, derive them via the <code>.enums</code> method described above.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Open_vs_Closed_Classes"
>Open vs Closed Classes</a></h1>

<p>By default, all classes in Perl are non-final, which means you can potentially derive from them. They are also open, which means you can add more methods to them, though you have to be explicit that that is what you&#39;re doing:</p>

<pre><code>augment class Mu {
    method wow () { say &#34;Wow, I&#39;m in the Cosmic All.&#34; }
}</code></pre>

<p>Otherwise you&#39;ll get a class redefinition error. (Also, to completely replace a definition, use &#34;<code>supersede</code>&#34; instead of &#34;<code>augment</code>&#34;...but don&#39;t do that, since the compiler may have already committed to optimizations based on the old definition.)</p>

<p>In order to discourage casual misuse of these declarators, they are not allowed on global classes unless you put a special declaration at the top:</p>

<pre><code>use MONKEY_TYPING;</code></pre>

<p>For optimization purposes, Perl 6 gives the top-level application the right to close and finalize classes by the use of <code>oo</code>, a pragma for selecting global semantics of the underlying object-oriented engine:</p>

<pre><code>use oo :closed :final;</code></pre>

<p>This forces the optimizer to consider the current file to represent the top-level application; however, the optimizer is also allowed to assume these semantics when it can determine that it is linking an entire application, such as when the current file is being run from the command line or from a mouse click.</p>

<p>These pragmatics (whether explicit or assumed) merely change the application&#39;s default to closed and final, which means that at the end of the main compilation (<code>LINK</code> time) the optimizer is allowed to look for candidate classes to close or finalize. But anyone (including the main application) can request that any class stay open or nonfinal, and the class closer/finalizer must honor that.</p>

<pre><code>use class :open&#60;Mammal Insect&#62; :nonfinal&#60;Str&#62;</code></pre>

<p>These properties may also be specified on the class definition:</p>

<pre><code>class Mammal is open {...}
class Insect is open {...}
class Str is nonfinal {...}</code></pre>

<p>or by lexically scoped pragma around the class definition:</p>

<pre><code>{
    use class :open;
    class Mammal {...}
    class Insect {...}
}
{
    use class :nonfinal;
    class Str {...}
}</code></pre>

<p>There is <i>no</i> syntax for declaring individual classes closed or final. The application may only request that the optimizer close and finalize unmarked classes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Representations"
>Representations</a></h1>

<p>By default Perl 6 assumes that all objects have a representation of <code>P6opaque</code>. This may be overridden with a trait:</p>

<pre><code>class Mammal is repr(P6Hash) {...}</code></pre>

<p>Whether implicit or explicit, the representation is considered to be fixed for the class after declaration, and the optimizer is free to optimize based on this guarantee. It is illegal to create an object of the same type with any other representation. If you wish to allow objects to be created with run-time specified representations, you must specifically pessimize the class:</p>

<pre><code>class Mammal is repr(*) {...}</code></pre>

<p>An <code>augment</code> is allowed to do this as long as it is before the main <code>LINK</code> time, at which point the compiler commits to its optimization strategies. Compilers are not required to support run-time pessimizations (though they may). Compilers may also generate both optimal and pessimal code paths and choose which to run based on run-time information, as long as correct semantics are maintained.</p>

<p>All non-native representations are required to support undefined type objects that may contain unthrown exceptions (<code>Failure</code> objects); while this can be implemented using an alternate representation, Perl 6 doesn&#39;t think of it that way. All normal objects in Perl 6 may be used as a specific object (proper noun) if they are defined, or as a generic object (common noun) whether or not they are defined. You get this representation polymorphism for free independently of the restriction above.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Interface_Consistency"
>Interface Consistency</a></h1>

<p>By default, all methods and submethods that do not declare an explicit <code>*%</code> parameter will get an implicit <code>*%_</code> parameter declared for them whether they like it or not. In other words, all methods allow unexpected named arguments, so that <code>nextsame</code> semantics work consistently.</p>

<p>If you mark a class &#34;<code>is hidden</code>&#34;, it hides the current class from &#34;<code>nextsame</code>&#34; semantics, and incidentally suppresses the autogeneration of <code>*%_</code> parameters. Methods on hidden classes may still be called as <code>$obj.NameOfHiddenClass::yourmethod</code>.</p>

<p>A similar effect can be achieved from the derived class by saying <code>hides Base</code> instead of <code>is Base</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Introspection"
>Introspection</a></h1>

<p>Metamethods for objects are named with interrogative pronouns in uppercase:</p>

<pre><code>WHAT        the type object of the type, .gist returns MyClass()
WHICH       the object&#39;s identity value
WHO         the package supporting the object, stringifies to long name
WHERE       the memory address of the object
HOW         the metaclass object: &#34;Higher Order Workings&#34;
WHEN        (reserved for events?)
WHY         the attached Pod value
WHENCE      autovivification closure</code></pre>

<p>These may be used either as methods or as unary operators:</p>

<pre><code>$obj.WHAT   # method form of P5&#39;s ref
WHAT $obj   # unary form of P5&#39;s ref</code></pre>

<p>These are all actually macros, not true operators or methods. If you get a foreign object from another language and need to call its <code>.WHERE</code> method, you can say:</p>

<pre><code>$obj.&#34;WHERE&#34;()</code></pre>

<p>And if you don&#39;t know the method name in advance, you&#39;d be using the variable form anyway:</p>

<pre><code>$obj.&#34;$methodname&#34;()</code></pre>

<p>or:</p>

<pre><code>$obj.$methodobject</code></pre>

<p>which also bypasses the macros.</p>

<p>There is one more macro:</p>

<pre><code>DEFINITE    the object has a valid concrete representation</code></pre>

<p>The <code>DEFINITE</code> macro serves as the default for the <code>Mu.defined</code> method.</p>

<p>For now Perl 6 reserves the right to change how all these macros and the corresponding <code>^</code> forms are defined in terms of each other. In particular, the <code>.^</code> forms will automatically supply the invocant as the first argument to methods of the metaclass, while the other forms require you to pass this explicitly.</p>

<p>Note that <code>WHAT.gist</code> surrounds the name with parens to indicate undefinedness. Use <code>.perl</code> to get the bare name from a type object. Use one of <code>.Str</code>, <code>.Stringy</code>, <code>prefix:&#60;~&#62;</code>, or <code>infix:&#60;~&#62;</code> to get the Perl5ish semantics of returning the empty string (with a warning) on any type object. (There is no &#34;undef&#34;, in Perl 6; type objects provide typed undefs instead.)</p>

<p>In general, use of these uppercased accessors in ordinary code should be a red flag that Something Very Strange is going on. (Hence the allcaps.) Most code should use Perl 6&#39;s operators that make use of this information implicitly. For instance, instead of</p>

<pre><code>$obj.WHAT === Dog
$x.WHICH === $y.WHICH
$obj.WHAT.bless(%args)</code></pre>

<p>you usually just want:</p>

<pre><code>$obj ~~ Dog
$x === $y
$obj.bless(%args)</code></pre>

<p>Every class has a <code>HOW</code> function/method that lets you get at the class&#39;s metaobject, which lets you get at all the metadata properties for the class (or other metaobject protocol) implementing the objects of the class:</p>

<pre><code>MyClass.methods()           # call MyClass&#39;s .methods method (error?)
MyClass.HOW.methods($obj)       # get the method list of MyClass</code></pre>

<p>The <code>^</code> metasyntax is equivalent to <code>.HOW</code>:</p>

<pre><code>MyClass.HOW.methods($obj)   # get the method list of MyClass
MyClass.^methods()          # get the method list of MyClass</code></pre>

<p>Each object of the class also has a <code>.HOW</code> or <code>.^</code> method:</p>

<pre><code>$obj.HOW.methods($obj);
$obj.^methods();</code></pre>

<p>(If you are using prototype-based OO rather than class-based, you must use the object form, since every such object functions as its own class.)</p>

<p>Class traits may include:</p>

<pre><code>identifier  { :name&#60;Dog&#62; :auth&#60;http://www.some.com/~jrandom&#62; :ver&#60;1.2.1&#62; }
    name      Dog
    authority http://www.some.com/~jrandom
    version   v1.2.1
author        Joe Random
description   This class implements camera obscura.
subject       optics, boxes
language      ja_JP
licensed      Artistic|GPL
parents       list of parent classes
roles         list of roles
disambig      how to deal with ambiguous method names from roles
repr          P6opaque, P6hash, P5hash, P5array, PyDict, Cstruct, etc.</code></pre>

<p>These are for the standard Perl 6 Meta-Object Protocol, but other MOPs may define other traits. The identifier should probably be accessed through the <code>.WHO</code> object in any case, which may have its own object methods depending on how type namespaces evolve over time. Which of these items are actually part of the <code>.HOW</code> object and which are delegated back to the package and prototype objects is up to the MOP. (Note also that anonymous classes may have anonymous packages and prototype objects, in which case stringification is not likely to produce something of interest to non-gurus.)</p>

<p>The <code>.^parents</code> method by default returns a flattened list of all parents out to (but not including) <code>Cool</code> or <code>Any</code>, sorted in MRO (dispatch) order. Other options are:</p>

<pre><code>:local              just returns the immediate parents
:local($n)          return $n levels
:excl               exclude Cool and Any (the default)
:all                include Cool and Any
:tree               the inheritance hierarchy as nested arrays</code></pre>

<p>The <code>.^methods</code> method returns method-descriptors containing:</p>

<pre><code>name                the name of the method
signature           the parameters of the method
as                  the coercion type of the method
proto               whether this method governs a set of multi methods
do                  the method body</code></pre>

<p>The <code>.^methods</code> method has a selector parameter that lets you specify whether you want to see a flattened or hierarchical view, whether you&#39;re interested in private methods, and so forth.</p>

<pre><code>:local              only methods defined in the current class
:local($n)          out $n levels
:excl               exclude Cool and Any (the default)
:all                include Cool and Any
:tree               methods by class structure (inheritance hierarchy)
:private            include private methods</code></pre>

<p>Note that, since introspection is primarily for use by the outside world (the class already knows its own structure, after all), a set of <code>multi</code> methods are presented to be a single <code>proto</code> method. You need to use <code>.candidates</code> on that to break it down further.</p>

<p>The <code>.^attributes</code> method returns a list of <code>Attribute</code> objects that have methods like these:</p>

<pre><code>name
type
scope
rw
private
has-accessor
build
readonly
get_value($obj)
set_value($obj, $new_value)</code></pre>

<p>Note that an <code>Attribute</code> is not tied to a particular object of a type, but rather to the type itself. Which is why <code>get_value</code> and <code>set_value</code> need to receive the actual object as first positional parameter.</p>

<p>[Conjecture: if it&#39;s not feasible for a meta class or a representation to implement <code>set_value</code> and <code>get_value</code>, it may die with an helpful error message when these methods are called.]</p>

<p><code>set_value</code> and <code>get_value</code> violate the privacy of attributes, and thus should be used with care, and at the user&#39;s own risk.</p>

<p><code>.^attributes</code> also takes the parameters:</p>

<pre><code>:local              only methods defined in the current class
:local($n)          out $n levels
:excl               exclude Cool and Any (the default)
:all                include Cool and Any
:tree               attributes by class structure (inheritance hierarchy)</code></pre>

<p>Strictly speaking, metamethods like <code>.isa()</code>, <code>.does()</code>, and <code>.can()</code> should be called through the meta object:</p>

<pre><code>$obj.HOW.can($obj, &#34;bark&#34;)
$obj.HOW.does($obj, Dog)
$obj.HOW.isa($obj, Mammal)</code></pre>

<p>or</p>

<pre><code>$obj.^can(&#34;bark&#34;)
$obj.^does(Dog)
$obj.^isa(Mammal)</code></pre>

<p>But <code>Any</code> gives you shortcuts to those:</p>

<pre><code>$obj.can(&#34;bark&#34;)
$obj.does(Dog)
$obj.isa(Mammal)</code></pre>

<p>These, may, of course, be overridden in a subclass, so don&#39;t use the short form unless you wish to allow for overrides. In general, <code>Any</code> will delegate only those metamethods that read well when reasoning about an individual object. Infrastructural methods like <code>.^methods</code> and <code>.^attributes</code> are not delegated, so <code>$obj.methods</code> fails.</p>

<p>The smartmatch:</p>

<pre><code>$obj ~~ Dog</code></pre>

<p>actually calls:</p>

<pre><code>$obj.HOW.does($obj, Dog)</code></pre>

<p>which is true if <code>$obj</code> either &#34;does&#34; or &#34;isa&#34; <code>Dog</code> (or &#34;isa&#34; something that &#34;does&#34; <code>Dog</code>). If <code>Dog</code> is a subset, any additional <code>where</code> constraints must also evaluate true.</p>

<p>Unlike in Perl 5 where <code>.can</code> returns a single <code>Code</code> object, Perl 6&#39;s version of <code>.^can</code> returns a &#34;WALK&#34; iterator for a set of routines that match the name, including all autoloaded and wildcarded possibilities. In particular, <code>.^can</code> interrogates any class package&#39;s <code>CANDO</code> method for names that are to be considered autoloadable methods in the class, even if they haven&#39;t been declared yet. Role composition sometimes relies on this ability to determine whether a superclass supplies a method of a particular name if it&#39;s required and hasn&#39;t been supplied by the class or one of its roles.</p>

<p>The motivation for stopping at <code>Cool</code> and <code>Any</code> by default is that the first derivation from one of those is really what the user thinks of as the root class of the type hierarchy most of the time. Methods outside of that are really part of Perl 6&#39;s lexicon, recognizable across all types. Hence if you say, for example, <code>$object.sort</code> or <code>$object.arctan</code>, you&#39;re invoking well-known cultural concepts that tend to transcend the user&#39;s type hierarchy. When the user asks for $object.^methods, listing such methods by default is rather irritating.</p>

<p>Note that when we say &#34;<code>Cool</code> and <code>Any</code>&#34; above, we really mean those types as well as any types outside of them, such as <code>Mu</code> or <code>Junction</code>. But users should not generally be deriving from those types anyway.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Custom_Meta-objects"
>Custom Meta-objects</a></h1>

<p>[Note: This section is still subject to some changes, but does at least reflect current implementation reality fairly well.]</p>

<p>When the parser encounters a package declarator, it uses the name of the declarator (such as <code>class</code> or <code>grammar</code>) to look up the type of meta-object to use. The default meta-objects support the standard Perl 6 OO semantics. However, it is possible for a module to export different meta-objects with different semantics. This is done by declaring an <code>EXPORTHOW</code> package, which should be located in <code>UNIT</code> of the module (and thus can be lexically scoped).</p>

<p>Just as the <code>EXPORT</code> package never contains symbols directly, but instead contains packages that denote tags and directives (such as <code>DEFAULT</code>), the <code>EXPORTHOW</code> package expects meta-objects to be installed under one of the following packages:</p>

<pre><code>SUPERSEDE   Uses the exported meta-object for the named declarator in
            the scope that the module is imported in to
COMPOSE     Takes the meta-object currently in effect for the named
            declarator and composes the exported role into it
DECLARE     Like SUPERSEDE, but also adds a new package declarator to
            the grammar if required</code></pre>

<p>For example, a module can replace the meta-object used for the <code>grammar</code> keyword in any scope it is imported into by doing:</p>

<pre><code>my module EXPORTHOW::SUPERSEDE { }
EXPORTHOW::SUPERSEDE&#60;grammar&#62; = TracedGrammarHOW;</code></pre>

<p>An MVC framework could declare a new <code>controller</code> package declarator and associate it with a meta-class of its choosing by doing:</p>

<pre><code>my module EXPORTHOW::DECLARE { }
EXPORTHOW::DECLARE&#60;controller&#62; = ControllerHOW;</code></pre>

<p>The <code>COMPOSE</code> directive is perhaps the most sophisticated, and its usage is encouraged where possible. Instead of exporting an entirely new meta-object, <code>COMPOSE</code> enables exporting a role. At the point the declarator is first used, all roles exported for it through <code>COMPOSE</code> will be taken together and added to a class derived from the current meta-object for the declarator (which may have been provided by a SUPERSEDE or DECLARE export from another module used in the scope). This class will then be composed, with any conflicts indicated.</p>

<pre><code>my module EXPORTHOW::COMPOSE {
    # Provide a role that adds logging to class method calls.
    role class {
        method find_method($obj, $name) {
            say &#34;Calling $name&#34;;
            nextsame;
        }
        
        method publish_method_cache($obj) {
            # Make sure all dispatches go through find_method
        }
    }
}</code></pre>

<p>The benefit of <code>COMPOSE</code> is that it enables two modules that extend a meta-object in a non-conflicting way to be used together in the same scope, with explicit detection of conflicts if they occur. For example, if one module wishes to override <code>compose</code> and another wishes to override <code>find_method</code>, the two can be used together safely. By contrast, <code>SUPERSEDE</code> and <code>DECLARE</code> can only be used by one module per declarator in a given scope, thwarting composition. The compiler should produce an error if this rule is broken.</p>

<p>The easiest way to define a new meta-object is to inherit from an existing meta-object.</p>

<pre><code>my class TracedGrammarHOW is Metamodel::GrammarHOW {
}</code></pre>

<p>Here is a list of the various meta-objects that you may safely subclass and the name they are installed under by default.</p>

<pre><code>Metamodel::ClassHOW                 class
Metamodel::EnumHOW                  enum
Metamodel::GrammarHOW               grammar
Metamodel::ModuleHOW                module
Metamodel::PackageHOW               package
Metamodel::ParametricRoleHOW        role
Metamodel::ParametricRoleGroupHOW   role-group
Metamodel::SubsetHOW                subset</code></pre>

<p>All of these meta-objects inherit from <code>Any</code>. However, they will in turn be implemented by other meta-objects that may or may not do so. This is considered implementation specific, and implementations may re-arrange these details freely between versions. Thus, relying on them is erroneous.</p>

<pre><code>SomeP6Class.HOW         # Promises to (ultimately) inherit from Any
SomeP6Class.HOW.HOW     # Implementation specific</code></pre>

<p>Roles are a little interesting, since they involve multiple meta-objects. When you write:</p>

<pre><code>role Foo {
}</code></pre>

<p>Then a <code>ParametricRoleHOW</code> is created to represent the role declaration. It is in turn wrapped up inside a <code>ParametricRoleGroupHOW</code>, which is then installed under the name <code>Foo</code>. This is because one short name may have many long names due to signatured roles.</p>

<pre><code>role Foo[::T] {
}</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Autovivifying_objects"
>Autovivifying objects</a></h1>

<p>The <code>WHENCE</code> property of an object is its autovivifying closure. Any undefined prototype object may carry such a closure that can lazily create an object of the appropriate type. When the closure is eventually evaluated it is expected to return an argument list corresponding to the arguments to a <code>.bless</code> call. For instance, a <code>CANDO</code> routine, instead of creating a <code>Dog</code> object directly, could instead return something like:</p>

<pre><code>Dog but WHENCE({ :name&#60;Fido&#62; })</code></pre>

<p>which runs the closure if the object ever needs to be autovivified. The closure can capture whatever initializers were available in the original lexical scope.</p>

<p>The short form of the above is simply:</p>

<pre><code>Dog{ :name&#60;Fido&#62; }</code></pre>

<p>This form is also lazily evaluated:</p>

<pre><code>my $dog = Dog{ :name&#60;Fido&#62; };
defined $dog or say &#34;doesn&#39;t exist&#34;;  # Fido doesn&#39;t exist
$dog.wag()                            # Fido wags his tail</code></pre>

<p>When the typename happens to be a role, autovivifying it involves attempting to create a punned class of the same name as the role. Whether this succeeds or not depends on whether the role is sufficiently complete to serve as a class on its own. Regardless of whether such an attempt would succeed, it is always perfectly fine to define a lazy type object for a role just as long as it&#39;s only ever used as an argument to <code>bless</code>, since <code>bless</code> will only be using its closure to construct the role&#39;s <code>BUILD</code> arguments in the context of the complete new class. (Of course, an inconsistent or incomplete class composition may subsequently fail, and in fact the incomplete role autovivification mentioned above is likely to be implemented by failing at the point of class composition.)</p>

<p>Note that when used as an argument to a method like <code>bless</code>, the type object is sufficiently lazy that autovivifying is done only by the appropriate <code>BUILD</code> routine. It does not waste energy creating a <code>Dog</code> object when that object&#39;s attributes would later have to be copied into the actual object. (On top of which, such an implementation would make it impossible to use type objects to initialize incomplete roles.)</p>

<p>The object autovivification syntax works only for literal named types, so any indirection must be written more explicitly:</p>

<pre><code>::($dogproto){ :name&#60;Fido&#62; }
$dogproto but WHENCE({ :name&#60;Fido&#62; })
$dogproto.WHAT{ :name&#60;Fido&#62; }</code></pre>

<p>Note that in contrast to this syntax, a lookup of a symbol in the <code>Dog</code> package requires a final <code>::</code> before the subscript:</p>

<pre><code>Dog::{$varname}</code></pre>

<!-- end doc -->

</body></html>
