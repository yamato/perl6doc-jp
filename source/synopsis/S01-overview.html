<!DOCTYPE html>
<html lang="ja">
<head>
<title>S01-overview</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Sep 27 10:05:32 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Project_Plan'>Project Plan</a>
  <li class='indexItem indexItem1'><a href='#Random_Thoughts'>Random Thoughts</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 1: Overview</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Larry Wall &#60;larry@wall.org&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 10 Aug 2004

Last Modified: 2 Mar 2012
Version: 9</code></pre>

<p>This document originally summarized Apocalypse 1, which covers the initial design concept. That original summary may be found below under &#34;Random Thoughts&#34;. However, these Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &#34;historical documents&#34;. These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.</p>

<p>Another assumption has been that if we don&#39;t talk about something in these Synopses, it&#39;s the same as it is in Perl 5. Soon we plan to fill in the gaps with the Perl 5 details though.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Project_Plan"
>Project Plan</a></h1>

<p>Mostly, we&#39;re just a bunch of ants all cooperating (sort of) to haul food toward the nest (on average). There are many groups of people working on various bits and pieces as they see fit, since this is primarily a volunteer effort.</p>

<p>This document does not attempt to summarize all these subprojects--see <a href="http://perl6.org" class="podlinkurl"
>http://perl6.org</a> for such information. What we can say here is that, unlike how it was with Perl 5, none of these projects is designed to be the Official Perl. Perl 6 is anything that passes the official test suite. This test suite was initially developed under the Pugs project because that project was at one point the furthest along in exploring the high-level semantics of Perl 6. (Other projects may be better at other things, such as speed or interoperability. This is fine; it is not necessary that all implementations be equally good at everything.) The official test suite is community property, and is intended to be platform neutral, so that Perl 6 is defined primarily by its desired semantics, not by accidents of history.</p>

<p>Another aspect of this is the Perl 6 compiler will be self-hosting. That is, the compiler will eventually compile itself, at least down to the point where various code-generating backends can take over. This largely removes platform dependencies from the frontend, so that only the backends need to worry about platform-specific issues.</p>

<p>But above all, our project plan is simply to help people find a spot where they can feel like they&#39;re creating the future, both for themselves and for others. Around here, that&#39;s what we call fun.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Random_Thoughts"
>Random Thoughts</a></h1>

<ul>
<li>The word &#34;apocalypse&#34; historically meant merely &#34;a revealing&#34;, and we&#39;re using it in that unexciting sense.</li>

<li>If you ask for RFCs from the general public, you get a lot of interesting but contradictory ideas, because people tend to stake out polar positions, and none of the ideas can build on each other.</li>

<li>Larry&#39;s First Law of Language Redesign: Everyone wants the colon.</li>

<li>RFCs are rated on &#34;PSA&#34;: whether they point out a real <b>P</b>roblem, whether they present a viable <b>S</b>olution, and whether that solution is likely to be <b>A</b>ccepted as part of Perl 6.</li>

<li>Languages should be redesigned in roughly the same order as you would present the language to a new user.</li>

<li>Perl 6 should be malleable enough that it can evolve into the imaginary perfect language, Perl 7. This darwinian imperative implies support for multiple syntaxes above and multiple platforms below.</li>

<li>Many details may change, but the essence of Perl will remain unchanged. Perl will continue to be a multiparadigmatic, context-sensitive language. We are not turning Perl into any other existing language.</li>

<li>Migration is important. A Perl 6 interpreter, if invoked as &#34;<code>perl</code>&#34;, will assume that it is being fed Perl 5 code unless the code starts with a &#34;class&#34; or &#34;module&#34; keyword, or you specifically tell it you&#39;re running Perl 6 code in some other way, such as by:
<pre><code>#!/usr/bin/perl6
use v6.0;
v6;</code></pre>

<p>Also, a file with a <code>.p6</code> extension may be taken as indicative, as may any other extension containing the digit <code>6</code>, such as <code>p6l</code> or <code>p6m</code> or <code>pl6</code> or <code>pm6</code>. (Though <code>.pl</code> and <code>.pm</code> are still perfectly acceptable extensions as long as the Perl-6-ness is indicated by one of the other indicators.)</p>
</li>

<li>Migration in the other direction is also important. In Perl 6 mode, one can drop back to Perl 5 mode with <code>use v5</code> at the beginning of a lexical block. Such blocks may be nested:
<pre><code>use v6;
# ...some Perl 6 code...
{
    use v5;
    # ...some Perl 5 code...
    {
        use v6;
        # ...more Perl 6 code...
    }
}</code></pre>

<p>Some platforms may restrict this to a subset of Perl 5 when it is not expedient to include a full Perl 5 interpreter. The standard Perl 6 grammar will include the ability to parse a well-behaved subset of Perl 5 on its own (much like PPI does); implementations are required only to support this subset, though of course they may also choose to implement bug-for-bug compatibility.</p>
</li>

<li>Scaling is one of those areas where Perl needs to be multiparadigmatic and context sensitive. Perl 5 code is not strict by default, while Perl 6 code is. But it should be easy to relax with <code>-e</code> or a bare version number:
<pre><code>perl -e &#39;$x = 1&#39;

#!/usr/bin/perl
v6; $x = 1;</code></pre>
</li>

<li>It must be possible to write policy metamodules that invoke other modules on the user&#39;s behalf.</li>

<li>If you want to treat everything as objects in Perl 6, Perl will help you do that. If you don&#39;t want to treat everything as objects, Perl will help you with that viewpoint as well.</li>

<li>Operators are just functions with funny names and syntax.</li>

<li>Language designers are still necessary to synthesize unrelated ideas into a coherent whole.</li>

<li>The language designer is neither omniscient nor omnipotent, and never will be, despite requests for those particular features. Therefore the design process will be spiral, cooperative, and convergent. The rate of convergence is an emergent property, and cannot be forced, only encouraged. As long as anyone is hacking on any implementation of Perl 6 to make it conform to the test suite, or hacking on the test suite to make it reflect consensus of specification, the rate of convergence will be deemed to be positive. If you are unhappy with the current rate of convergence, please cooperate more with someone else you think is interested in convergence.</li>

<li>The spec will not be frozen prematurely, but will continue to solidify as various aspects of it are proven (or disproven) in various implementations. Many parts of the spec are already effectively frozen, or are in a slushy state. &#34;The future is already here, it&#39;s just unevenly distributed.&#34;</li>

<li>All specced features that have not been proven in an implementation should be considered somewhat conjectural, even if not so marked. As implementations start to agree on what is practical and what is not, do not be surprised if some features that are currently specced may be deferred to future versions; these should still be considered long-term direction in the evolution of Perl 6 over time, and the short-term design should be conservative in preserving that long-term evolution. Note that we are not in a hurry to defer any sections of the spec, even if that would give the illusion of progress. Convergence of specs and implementations will happen naturally as we get implementations that are closer to the spec. It is quite likely that the first practical implementation will largely determine which features are considered to be required in 6.0.0.</li>

<li>Everyone is allowed to panic <i>once</i>. However, continual panic will be deemed poisonous. Nobody gets special treatment, even if they think special treatment is necessary for success. This means you.</li>
</ul>

<!-- end doc -->

</body></html>
