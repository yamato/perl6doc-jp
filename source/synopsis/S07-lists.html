<!DOCTYPE html>
<html lang="ja">
<head>
<title>S07-lists</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Sep 27 10:05:33 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#The_List_type'>The List type</a>
    <li class='indexItem indexItem2'><a href='#The_Array_type'>The Array type</a>
    <li class='indexItem indexItem2'><a href='#The_Parcel_type'>The Parcel type</a>
    <li class='indexItem indexItem2'><a href='#Flattening_contexts%2C_the_Iterable_type'>Flattening contexts, the Iterable type</a>
    <li class='indexItem indexItem2'><a href='#Iterators'>Iterators</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#The_.reify_method'>The .reify method</a>
      <li class='indexItem indexItem3'><a href='#The_.infinite_method'>The .infinite method</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Levels_of_laziness'>Levels of laziness</a>
    <li class='indexItem indexItem2'><a href='#The_laziness_level_of_some_common_operations'>The laziness level of some common operations</a>
    <li class='indexItem indexItem2'><a href='#Common_list_operations'>Common list operations</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 7: Lists and Iteration</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Patrick R. Michaud &#60;pmichaud@pobox.com</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 12 July 2012

Last Modified: 29 May 2013
Version: 2</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>Lists and arrays have always been one of Perl&#39;s fundamental data types, and Perl 6 is no different. However, lists in Perl 6 have been greatly extended to accommodate lazy lists, infinite lists, lists of mutable and immutable elements, typed lists, flattening behaviors, and so on. So where lists and arrays in Perl 5 tended to be finite sequences of scalar values, in Perl 6 we have additional dimensions of behavior that must be addressed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_List_type"
>The <code>List</code> type</a></h2>

<p>The <code>List</code> class is the base class for dealing with other types of lists, including <code>Array</code>. To the programmer, a <code>List</code> is a potentially lazy and infinite sequence of elements. A <code>List</code> is mutable, in that one can manipulate the sequence via operations such as <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>, etc. A <code>List</code>&#39;s elements may be either mutable or immutable.</p>

<p><code>List</code> objects are <code>Positional</code>, meaning they can be bound to array variables and support the postfix <code>.[]</code> operator.</p>

<p>Lists are also lazy, in that the elements of a <code>List</code> may come from generator functions (called <code>Iterator</code>s) that produce elements on demand.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_Array_type"
>The <code>Array</code> type</a></h2>

<p>An <code>Array</code> is simply a <code>List</code> in which all of the elements are held in scalar containers. This allows assignment to the elements of the array.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_Parcel_type"
>The <code>Parcel</code> type</a></h2>

<p>The comma operator (<code>infix:&#60;,&#62;</code>) creates <code>Parcel</code> objects. These should not be confused with lists; a <code>Parcel</code> represents a raw syntactic sequence of elements. A <code>Parcel</code> is immutable, although the elements of a <code>Parcel</code> may be either mutable or immutable.</p>

<p>The name &#34;Parcel&#34; is derived from the phrase &#34;parenthesis cell&#34;, since many <code>Parcel</code> objects appear inside of parentheses. However, except for the empty parcel, it&#39;s the comma operator that creates <code>Parcel</code> objects.</p>

<pre><code>()       # empty Parcel
(1)      # an Int
(1,2)    # a Parcel with two Ints
(1,)     # a Parcel with one Int</code></pre>

<p>A <code>Parcel</code> is also <code>Positional</code>, and uses flattening context for list operations such as <code>.[]</code> and <code>.elems</code>. See &#34;Flattening contexts&#34; below. For raw access to the arguments without flattening, you may use <code>.arg($n)</code> instead of <code>.[$n]</code>, and <code>.args</code> instead of <code>.elems</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Flattening_contexts,_the_Iterable_type"
>Flattening contexts, the <code>Iterable</code> type</a></h2>

<p><code>List</code> and <code>Parcel</code> objects can have other container objects as elements. In some contexts we want to interpolate the values of container objects into the surrounding <code>List</code> or <code>Parcel</code>, while in other contexts we want any subcontainers to be preserved. Such interpolation is known as &#34;flattening&#34;.</p>

<p>The <code>Iterable</code> type is performed by container and generator objects that will interpolate their values in flattening contexts. Both <code>List</code> and <code>Parcel</code> are <code>Iterable</code>. <code>Iterable</code> implies support for <code>.iterator</code>, which returns an object capable of producing the elements of the <code>Iterable</code>.</p>

<p>Objects held in scalar containers are never interpolated in flattening context, even if the object is <code>Iterable</code>.</p>

<pre><code>my @a = 3,4,5;
for 1,2,@a { ... }        # five iterations

my $s = @a;
for 1,2,$s { ... }        # three iterations</code></pre>

<p>Here, both <code>$s</code> and <code>@a</code> refer to the same underlying <code>Array</code> object, but the presence of the scalar container prevents <code>$s</code> from being flattened into the <code>for</code> loop. The <code>.list</code> or <code>.flat</code> method may be used to restore the flattening behavior:</p>

<pre><code>for 1,2,$s.list { ... }   # five iterations
for 1,2,@($s) { ... }     # five iterations</code></pre>

<p>Conversely, the <code>.item</code> or <code>$()</code> contextualizer can be used to prevent an <code>Iterable</code> from being interpolated:</p>

<pre><code>my @b = 1,2,@a;           # @b has five elements
my @c = 1,2,@a.item;      # @c has three elements
my @c = 1,2,$(@a);        # same thing</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Iterators"
>Iterators</a></h2>

<p>An <code>Iterator</code> is an object that is able to generate or produce elements of a list (called &#34;reification&#34;). Because a single <code>Iterator</code> may be directly or indirectly referenced by multiple container objects simultaneously, <code>Iterator</code>s provide an immutable view of the sequence of elements produced, leaving it up to containers to provide any mutability.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_.reify_method"
>The <code>.reify</code> method</a></h3>

<p>The <code>.reify($n)</code> method requests an <code>Iterator</code> to return a <code>Parcel</code> consisting of at least <code>$n</code> reified elements, followed by any additional iterators needed for the remaining elements in the sequence. For example:</p>

<pre><code>my $r = 10..50;
say $r.iterator.reify(5).perl;  # (10, 11, 12, 13, 14, 15..50)</code></pre>

<p>Iterators are allowed to return more or fewer elements than requested by <code>$n</code>; it&#39;s up to the caller to properly handle any shortage or excess. (In general an iterator is expected to always reify at least one element, however.) If <code>$n</code> is <code>*</code>, then the iterator is asked to generate elements according to whatever is most natural for the thing being iterated. For a <code>Range</code> this might be a substantial number (or even all) of the elements of the range; for a filehandle it might read a single record; for a <code>List</code> it may return only the non-lazy portion of the list.</p>

<p>Once <code>.reify</code> is called on an iterator, the iterator is expected to return the same results for all subsequent calls to <code>.reify</code>. This is true even if the <code>$n</code> argument is different from one call to the next. The general pattern is often something like:</p>

<pre><code>class SomeIter is Iterator {
    has $!reified;

    method reify($n = 1) {
        unless $!reified.defined {
            # generate return Parcel and bind to $!reified
        }
        $!reified;
    }
}</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_.infinite_method"
>The <code>.infinite</code> method</a></h3>

<p>Because lists in Perl 6 can be lazy, they can also be infinite. Each <code>Iterator</code> must provide an <code>.infinite</code> method, which returns a value indicating the knowable finiteness of the iteration:</p>

<pre><code>.infinite     Meaning
----------------------------------------------
True          iteration is known to be infinite
False         iteration is known to be finite
Mu            finiteness isn&#39;t currently known</code></pre>

<p>As an example, <code>Range</code> iterators can generally know finiteness simply by looking at the endpoint of the <code>Range</code>. The iterator for the <code>infix:&#60;...&#62;</code> sequence operator treats any sequence ending in <code>*</code> as being &#34;known infinite&#34;, all other <code>...</code> sequences have unknown finiteness. In the general case it&#39;s not possible for loop iterators to definitively know if the sequence will be finite or infinite. (Conjecture: There will be a syntax or mechanism for the programmer to indicate that such sequences are to be treated as known finite or known infinite.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Levels_of_laziness"
>Levels of laziness</a></h2>

<p>Laziness is one of the primary virtues of a Perl programmer; it is also one of the virtues of Perl 6. However, it&#39;s also possible to succumb to false laziness, so there are times when Perl 6 chooses to be eager instead of lazy.</p>

<p>Perl 6 defines four levels of laziness:</p>

<dl>
<dt><a name="Strictly_Lazy"
>Strictly Lazy</a></dt>

<dd>
<p>Does not evaluate anything unless explicitly required by the caller, including not traversing non-lazy objects. This behavior generally occurs only by a pragma or by explicit lazy primitives.</p>

<dt><a name="Mostly_Lazy"
>Mostly Lazy</a></dt>

<dd>
<p>Try to obtain available elements without causing eager evaluation of other lazy objects. However, the implementation is allowed to do batching for efficiency. The programmer must not rely on circular side effects when the implementation is working ahead like this, or the results will be indeterminate. (However, this does not rule out pure <i>definitional</i> circularity; earlier array values may be used in the definition of subsequent values.)</p>

<dt><a name="Mostly_Eager"
>Mostly Eager</a></dt>

<dd>
<p>Obtain all leading items that are not known to be infinite. The remainder of the items are left for lazy evaluation. As with the &#34;mostly lazy&#34; case, the programmer must not depend on circular side effects in any situation where the implementation is allowed to work ahead. Note that there are no language-defined limits on the amount of conjectural evaluation allowed, up to the size of available memory; however, an implementation may allow the arbitrary limitation of workahead by use of pragmas.</p>

<p>In any case there should be no profound semantic differences between &#34;mostly lazy&#34; and &#34;mostly eager&#34;. These levels are primarily just hints to the implementation as to whether you are likely to want to use all the values in the list. Nothing transactional should be allowed to depend on the difference.</p>

<dt><a name="Strictly_Eager"
>Strictly Eager</a></dt>

<dd>
<p>Obtain all items, failing immediately with an appropriate message if asked to evaluate any data structures known to be infinite. (Data structures that are effectively infinite but not provably so will likely exhaust memory instead.)</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_laziness_level_of_some_common_operations"
>The laziness level of some common operations</a></h2>

<dl>
<dt><a name="List_assignment;_my_@a_=_@something;"
>List assignment; my @a = @something;</a></dt>

<dd>
<p>In order to provide p5-like behavior in list assignment, it is performed at the Mostly Eager level. This means that if you do</p>

<pre><code>my @a = foo();</code></pre>

<p>it will eagerly evaluate the return value from <code>foo()</code> to place elements into <code>@a</code>, stopping only when encountering something that is &#34;known infinite&#34; or upon reaching the end of the sequence.</p>

<dt><a name="for,_map,_grep,_etc."
><code>for</code>, <code>map</code>, <code>grep</code>, etc.</a></dt>

<dd>
<p>The <code>for</code> loop and looping routines such as <code>map</code>, <code>grep</code>, etc. are Mostly Lazy by default, but will be eager when evaluated in sink context. (Note, however, that we force <code>for</code>, <code>while</code>, <code>until</code>, <code>repeat</code> and <code>loop</code> loops to always be in sink context when used as a statement within a statementlist.)</p>

<dt><a name="Slurpy_parameters"
>Slurpy parameters</a></dt>

<dd>
<p>Slurpy parameters are Mostly Lazy.</p>

<dt><a name="Feed_operators"
>Feed operators</a></dt>

<dd>
<p>The feed operator is strictly lazy, meaning that no operation should be performed before the user requests any element. That&#39;s how</p>

<pre><code>  my @a &#60;== grep { ... } &#60;== map { ... } &#60;== grep { ... } &#60;== 1, 2, 3</code></pre>

<p>is completely lazy, even if 1,2,3 is a fairly small known compact list.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Common_list_operations"
>Common list operations</a></h2>

<!-- end doc -->

</body></html>
