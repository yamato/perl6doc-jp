<!DOCTYPE html>
<html lang="ja">
<head>
<title>S10-packages</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Aug 30 10:16:50 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Packages'>Packages</a>
  <li class='indexItem indexItem1'><a href='#Package_nesting'>Package nesting</a>
  <li class='indexItem indexItem1'><a href='#Autoloading'>Autoloading</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 10: Packages</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Larry Wall &#60;larry@wall.org&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 27 Oct 2004

Last Modified: 9 Jul 2010
Version: 13</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis summarizes Apocalypse 10, which discusses packages despite never having been written.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Packages"
>Packages</a></h1>

<p>As in Perl 5, packages are the basis of modules and classes. Unlike in Perl 5, modules and classes are declared with distinct keywords, but they&#39;re still just packages with extra behaviors. Likewise every typename has an associated package namespace, even if unused.</p>

<p>An ordinary package is declared with the <code>package</code> keyword. Unlike in earlier versions of Perl 5, in Perl 6 it can only be used with a block:</p>

<pre><code>package Bar {...}   # block is in package Bar</code></pre>

<p>A named package declaration can occur as part of an expression, just like named subroutine declarations.</p>

<p>As a special exception, if a braceless <code>package</code> declaration occurs as the first executable statement in a file, then it&#39;s taken to mean that the rest of the file is Perl 5 code.</p>

<pre><code>package Foo;        # the entire file is Perl 5
...</code></pre>

<p>This form is illegal in a Perl 6 file. If you wish to have a file-scoped package, either use the brace form or declare it with the <code>module</code> keyword instead.</p>

<p>Since there are no barewords in Perl 6, package names must be predeclared. Alternatively, the sigil-like <code>::PackageName</code> syntax may be used to indicate that the type will be supplied some other way, however this syntax is not valid in declarative scenarios, especially parameter lists where it has entirely different semantics. The <code>::</code> prefix does not imply globalness as it does in Perl 5. (Use <code>GLOBAL::</code> for that.)</p>

<p>A bare <code>package</code> declarator (without an explicit scope declarator such as <code>my</code>) declares an <code>our</code> package within the current package (or module, or class, or role, or...). Use <code>GLOBAL::</code> to declare a global package name.</p>

<p>To declare a lexically scoped package, use <code>my package</code>.</p>

<p>To declare an anonymous package you can use either of</p>

<pre><code>package {...}
package :: {...}</code></pre>

<p>All files start out being parsed in the <code>GLOBAL</code> package, but may switch to some other package scope depending on the first package-ish declaration. If that first declaration is not a package variant, then the parsing switches to the &#34;<code>main</code>&#34; package for Perl 5 code. Perl 6 code stays <code>GLOBAL</code> in that situation. The mainline code is thus in the <code>GLOBAL</code> namespace unless declared otherwise.</p>

<p>Package traits are set using <code>is</code>:</p>

<pre><code>package Foo is bar {...}</code></pre>

<p>All symbolic links are done with the <code>::($expr)</code> syntax, which is legal in any variable, package, module, or class name anywhere a <code>::Ident</code> is legal. The string returned by the expression will be parsed for <code>::</code> indicating subpackage names. Do not confuse this with the</p>

<pre><code>Foo::{$key}</code></pre>

<p>syntax that lets you do a lookup in a particular symbol table. In this case, the key is not parsed for <code>::</code>. It&#39;s just a hash lookup.</p>

<p>All package bodies (including module and class bodies) execute at the normal execution time of the code in which they are embedded. For normal mainline code, this is the normal flow of execution; if this is too late to initialize something in the package that you want to be initialized, consider use of a MAIN subroutine, which is invoked at the end of normal execution. See <a href="http://search.cpan.org/perldoc?S06#Declaring_a_MAIN_subroutine" class="podlinkpod"
>&#34;Declaring a <code>MAIN</code> subroutine&#34; in S06</a>.</p>

<p>For packages (modules, classes, roles, etc.) defined in separate files from the mainline code, there can be no mainline code by definition, but the top-level code in the used module needs to be executed at some point in case things need initialization. Invocation of this pseudo-mainline code in the module notionally happens no later than at the point of the <code>use</code> or <code>need</code> call in the process of compilation, but the module&#39;s code is assumed to be sufficiently uninteresting that it need be executed only once regardless of how many times the module is used subsequently in the compilation. (In fact, it might not need to run at all if the result of some previous compilation&#39;s run has been cached.)</p>

<p>If it is desired to have code that varies in meaning from run to run, then you should put such code into an <code>INIT</code> block. (Likewise, you could put code into a <code>CHECK</code> block that has inconsistent semantics from compilation to compilation, but that&#39;s probably a bad idea.)</p>

<p>In any case, it is erroneous for any external module to depend on any knowledge of its user with respect to compilation order or other dynamic information, since other users may also depend on this single &#34;first-use&#34; execution and expect consistent semantics. (Really, all such dynamic dependencies should be passed in at run time to the routines or methods of your module as normal parameters or as dynamic variables. For instance, you cannot know at module compile time whether your caller is going to be using &#39;fatal&#39; semantics or not. That is dynamically scoped info.)</p>

<p>If you wish to have a module that does something extra if invoked standalone, define a MAIN subroutine, which will be ignored if the module is merely used/needed elsewhere.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Package_nesting"
>Package nesting</a></h1>

<p>A declaration of any object of the form <code>A::B::c</code> also creates (if needed) an empty package <code>A</code>, and an empty package <code>B</code> inside of <code>A</code>, in addition to creating <code>c</code> inside of <code>B</code>. Such empty packages may subsequently be redeclared as any other package-like object (module, class, etc.), and no redeclaration warning will be issued for such a redeclaration. If a parent package already exists, no stub package needs to be created, and no declaration of the form <code>A::B::c</code> has anything to say about the type of package <code>A</code> or package <code>A::B</code>, since any package variant can function as a package for the purposes of naming things.</p>

<p>Apart of package declaration constructs, package names are always searched for from the innermost lexical scope to outermost. If not defined in any surrounding lexical scope, the package is searched for from the current package up through the containing packages to <code>GLOBAL</code>. If it is not found, a compiler error results.</p>

<p>As with an initial <code>::</code>, the presence of a <code>::</code> within the name does not imply globalness (unlike in Perl 5). True globals are always in the <code>GLOBAL::</code> namespace.</p>

<p>The <code>PROCESS::</code> namespace, shared by all interpreters within the process, is notionally outside of <code>GLOBAL::</code>, but package searches do not look there for anything. (Contextual variable searches do; <code>$*PID</code> will eventually locate <code>$PROCESS::PID</code> if not hidden by an inner callframe&#39;s <code>$*PID</code>.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Autoloading"
>Autoloading</a></h1>

<p>A package (or any other similar namespace) can control autoloading. However, Perl 5&#39;s <code>AUTOLOAD</code> is being superseded by MMD autoloaders that distinguish declaration from definition, but are not restricted to declaring subs. A run-time declarator multisub is declared as:</p>

<pre><code>multi CANDO ( MyPackage, $type, $name, *%args)</code></pre>

<p>which stands in for the declaration of a container object within another container object; it is called when anyone is searching for a name in the package (or module, or class), and the name doesn&#39;t already exist in the package. (In particular, <code>.can</code> calls <code>CANDO</code> when trying to determine if a class supports a particular method.) The arguments to <code>CANDO</code> include type information on what kind of object is expected in context, or this may be intuited from the name requested. In any case, there may be multiple <code>CANDO</code> routines that are dispatched via MMD:</p>

<pre><code>multi CANDO ( MyPackage, Item, $name, *%args)
multi CANDO ( MyPackage, Array, $name, *%args)
multi CANDO ( MyPackage, Hash, $name, *%args)
multi CANDO ( MyPackage, Code, $name, *%args)</code></pre>

<p>The package itself is just passed as the first argument, since it&#39;s the container object. Subsequent arguments identify the desired type of the inner container and the &#34;name&#34; or &#34;key&#34; by which the object is to be looked up in the outer container. Such a name does not include its container name, unlike Perl 5&#39;s magical <code>$AUTOLOAD</code> variable. Nor does it include the type information of a Code object&#39;s &#34;long name&#34;; this information comes in via the type parameter, and may be matched against using ordinary subsignature matching:</p>

<pre><code>multi CANDO ( MyPackage, &#38;:($), $name, *%args)     # 1 arg
multi CANDO ( MyPackage, &#38;:($,$), $name, *%args)   # 2 args</code></pre>

<p>The slurpy <code>%args</code> hash is likely to be empty in standard Perl 6 usage, but it&#39;s possible that some dialects of Perl will desire a mechanism to pass in additional contextual information, so this parameter is reserved for such purposes.</p>

<p>The <code>CANDO</code> is expected to return an inner container object of the proper sort (i.e. a variable, subroutine, or method object), or a proxy object that can &#34;autovivify&#34; lazily, or <code>Nil</code> if that name is not to be considered declared in the namespace in question. (Only bare <code>Nil</code> is interpreted as &#34;not there&#34;, since typed undefs may function as autovivifiable proxy objects. See S12.)</p>

<p>The declaration merely defines the interface to the new object. That object need not be completely defined yet, though the <code>CANDO</code> routine is certainly <i>allowed</i> to define it eagerly, and even install the inner object into the outer container (the symbol table) if it wants to cache the declaration.</p>

<p>At declaration time it might not yet be known whether the inner container object will be used in lvalue or rvalue context; the use of a proxy object can supply either readonly or rw semantics later.</p>

<p>When the package in question is a class, it is also possible to declare real methods or submethods:</p>

<pre><code>multi method CANDO ($self: Code, $name, *%args)

multi submethod CANDO ($self: Item, $name, *%args)</code></pre>

<p>The method form is inherited by subclasses. Submethods are never inherited but may still do MMD within the class. (Ordinary multisubs are &#34;inherited&#34; only to the extent allowed by nested lexical scopes.)</p>

<p>When the package in question is not a class, there is a slight problem insofar as Perl 6 doesn&#39;t by default look into packages for functions anymore, only lexical scopes. However, we&#39;d still like the ability to dynamic add functions to a package, so there are two ways to get around the lexical limitation.</p>

<p>First, presuming you have a <code>CANDO</code> that adds to your current package, you can simply call a newly-minted subroutine explicitly via the current package:</p>

<pre><code>OUR::($somename)();</code></pre>

<p>This bypasses the lexical namespaces entirely. Alternately, we can set up a mechanism whereby, if you import or define a <code>CANDO</code> into a given lexical scope, all calls from within that scope register a failover that adds the current package to the list of places to look for subroutines (or, obviously, call the <code>CANDO</code> as a last resort after that). There is no performance impact on existing lexically scoped definitions, including those from <code>CORE</code>. This approach does require that failure to find a function name cannot be reported at compile time, but must be delayed till run time instead. Another potential disadvantage is that the package&#39;s symbols are also shadowed by all symbols defined in your outer lexical scopes, including <code>CORE</code>. If this is a problem, use the direct <code>OUR</code> call above.</p>

<p>Another way to look at it is that a lexical <code>CANDO</code> adds itself to the end of the function dispatcher&#39;s search, but sets up the current package as a kind of cache for newly-defined functions just ahead of itself in the search path.</p>

<!-- end doc -->

</body></html>
