<!DOCTYPE html>
<html lang="ja">
<head>
<title>Str</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Sep 27 10:05:35 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Str'>Str</a>
  <li class='indexItem indexItem1'><a href='#Additions'>Additions</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>DRAFT: Synopsis 32: Setting Library - Str</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Rod Adams &#60;rod@rodadams.net&#62;
Larry Wall &#60;larry@wall.org&#62;
Aaron Sherman &#60;ajs@ajs.com&#62;
Mark Stosberg &#60;mark@summersault.com&#62;
Carl M&#228;sak &#60;cmasak@gmail.com&#62;
Moritz Lenz &#60;moritz@faui2k3.org&#62;
Tim Nelson &#60;wayland@wayland.id.au&#62;
Brent Laabs &#60;bslaabs@gmail.com&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 19 Mar 2009 extracted from S29-functions.pod

Last Modified: 2014-08-24
Version: 11</code></pre>

<p>The document is a draft.</p>

<p>If you read the HTML version, it is generated from the Pod in the specs repository under <a href="https://github.com/perl6/specs/blob/master/S32-setting-library/Str.pod" class="podlinkurl"
>https://github.com/perl6/specs/blob/master/S32-setting-library/Str.pod</a> so edit it there in the git repository if you would like to make changes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Str"
>Str</a></h1>

<p>General notes about strings:</p>

<p>A Str can exist at several Unicode levels at once. Which level you interact with typically depends on what your current lexical context has declared the &#34;working Unicode level to be&#34;. Default is <code>Grapheme</code>. [Default can&#39;t be <code>CharLingua</code> because we don&#39;t go into &#34;language&#34; mode unless there&#39;s a specific language declaration saying either exactly what language we&#39;re going into or, in the absence of that, how to find the exact language somewhere in the environment.]</p>

<p>Attempting to use a string at a level higher it can support is handled without warning. The current highest supported level of the string is simply mapped Char for Char to the new higher level. However, attempting to stuff something of a higher level a lower-level string is an error (for example, attempting to store Kanji in a Byte string). An explicit conversion function must be used to tell it how you want it encoded.</p>

<p>Attempting to use a string at a level lower than what it supports is not allowed.</p>

<p>If a function takes a <code>Str</code> and returns a <code>Str</code>, the returned <code>Str</code> will support the same levels as the input, unless specified otherwise.</p>

<p>The following are all provided by the <code>Str</code> role:</p>

<dl>
<dt><a name="chop"
>chop</a></dt>

<dd>
<pre><code> multi method chop ( Str  $string: --&#62; Str ) is export</code></pre>

<p>Returns string with one Char removed from the end.</p>

<dt><a name="chomp"
>chomp</a></dt>

<dd>
<pre><code> multi method chomp ( Str $string: --&#62; Str ) is export</code></pre>

<p>Returns string with one newline removed from the end. An arbitrary terminator can be removed if the input filehandle has marked the string for where the &#34;newline&#34; begins. (Presumably this is stored as a property of the string.) Otherwise a standard newline is removed.</p>

<p>Note: Most users should just let their I/O handles autochomp instead. (Autochomping is the default.)</p>

<dt><a name="lc"
>lc</a></dt>

<dd>
<pre><code> multi method lc ( Str $string: --&#62; Str ) is export</code></pre>

<p>Returns the input string after forcing each character to its lowercase form. Note that one-to-one mapping is not in general guaranteed; different forms may be chosen according to context.</p>

<dt><a name="uc"
>uc</a></dt>

<dd>
<pre><code> multi method uc ( Str $string: --&#62; Str ) is export</code></pre>

<p>Returns the input string after forcing each character to its uppercase (not titlecase) form. Note that one-to-one mapping is not in general guaranteed; different forms may be chosen according to context.</p>

<dt><a name="fc"
>fc</a></dt>

<dd>
<pre><code> multi method fc ( Str $string: --&#62; Str ) is export</code></pre>

<p>Does a Unicode &#34;fold case&#34; operation suitable for doing caseless string comparisons. (In general, the returned string is unlikely to be useful for any purpose other than comparison.)</p>

<dt><a name="tc"
>tc</a></dt>

<dd>
<pre><code> multi method tc ( Str $string: --&#62; Str ) is export</code></pre>

<p>Converts the first character of a string to titlecase form, leaving the rest of the characters unchanged, then returns the modified string. If there is no titlecase mapping for the first character, the entire string is returned unchanged. In any case, this function never changes any character after the first. (It is like the old Perl 5 <code>ucfirst</code> function in that respect.)</p>

<dt><a name="tclc"
>tclc</a></dt>

<dd>
<pre><code> multi method tclc ( Str $string: --&#62; Str ) is export</code></pre>

<p>Forces the first character of a string to titlecase and the rest of the characters to lowercase, then returns the modified string.</p>

<dt><a name="wordcase"
>wordcase</a></dt>

<dd>
<pre><code> multi method wordcase ( Str $string: :&#38;filter = &#38;tclc, :$where = True --&#62; Str ) is export</code></pre>

<p>Performs a substitutional mapping of each word in the string, defaulting to the <code>tclc</code> mapping. Words are defined as Perl 6 identifiers, hence admit hyphens and apostrophes when followed by a letter. (Note that trailing apostrophes don&#39;t matter when casemapping.) The following should have the same result:</p>

<pre><code>.wordcase;
.subst(:g, / &#60;ident&#62;+ % &#60;[ \- &#39; ]&#62; /, *.Str.tclc)</code></pre>

<p>The <code>filter</code> function is applied to the first and last word always, and to any intermediate word that the <code>where</code> parameter smartmatches. Assuming suitable definitions of word lists, standard English capitalization might be handled with something like this:</p>

<pre><code>my $where = none map *.fc, @conjunctions, @prepositions;
.wordcase(:$where);</code></pre>

<p>(Note that the &#34;standard&#34; authorities disagree on the prepositions!)</p>

<p>The smartmatching is done case insensitively, so you should store your exceptions in <code>fc</code> form. If the <code>where</code> smartmatch does not match, then the word will be forced to lowercase unless the filter is <code>&#38;tcuc</code>, in which case the exception will be forced to uppercase.</p>

<p>There is no provision for an alternate regex; if you need a custom word recognizer, you can write your own <code>.subst</code> as above.</p>

<dt><a name="samecase"
>samecase</a></dt>

<dd>
<pre><code> multi method samecase ( Str $string: Str $pattern --&#62; Str ) is export</code></pre>

<p>Has the effect of making the case of the string match the case pattern in <code>$pattern</code>. (Used by s:ii/// internally, see <a href="http://search.cpan.org/perldoc?S05" class="podlinkpod"
>S05</a>.)</p>

<dt><a name="samemark"
>samemark</a></dt>

<dd>
<pre><code> multi method samemark ( Str $string: Str $pattern --&#62; Str ) is export</code></pre>

<p>Has the effect of making the case of the string match the marking pattern in <code>$pattern</code>. (Used by s:mm/// internally, see <a href="http://search.cpan.org/perldoc?S05" class="podlinkpod"
>S05</a>.)</p>

<dt><a name="length"
>length</a></dt>

<dd>
<p>This word is banned in Perl 6. You must specify units.</p>

<dt><a name="chars"
>chars</a></dt>

<dd>
<pre><code> multi method chars ( Str $string: --&#62; Int ) is export</code></pre>

<p>Returns the number of characters in the string in the current (lexically scoped) idea of what a normal character is, usually graphemes.</p>

<dt><a name="graphs"
>graphs</a></dt>

<dd>
<pre><code> multi method graphs ( Str $string: --&#62; Int ) is export</code></pre>

<p>Returns the number of graphemes in the string in a language-independent way.</p>

<dt><a name="codes"
>codes</a></dt>

<dd>
<pre><code> multi method codes ( Str $string: $nf = $?NF --&#62; Int ) is export</code></pre>

<p>Returns the number of codepoints in the string as if it were canonicalized the specified way. Do not confuse codepoints with UTF-16 encoding. Characters above U+FFFF count as a single codepoint.</p>

<dt><a name="bytes"
>bytes</a></dt>

<dd>
<p>Gone. Use <code>$str.encode($encoding).bytes</code> instead.</p>

<dt><a name="encode"
>encode</a></dt>

<dd>
<pre><code>multi method encode($encoding = $?ENC, $nf = $?NF --&#62; Buf )</code></pre>

<p>Returns a <code>Blob</code> which represents the original string in the given encoding and normal form. The actual return type is as specific as possible, so <code>$str.encode(&#39;UTF-8&#39;)</code> returns a <code>utf8</code> object, <code>$str.encode(&#39;ISO-8859-1&#39;)</code> a <code>blob8</code>.</p>

<dt><a name="index"
>index</a></dt>

<dd>
<pre><code> multi method index( Str $string: Str $substring, StrPos $pos = StrPos(0) --&#62; StrPos ) is export
 multi method index( Str $string: Str $substring, Int $pos --&#62; StrPos ) is export</code></pre>

<p><code>index</code> searches for the first occurrence of <code>$substring</code> in <code>$string</code>, starting at <code>$pos</code>. If $pos is an <code>Int</code>, it is taken to be in the units of the calling scope, which defaults to &#34;graphemes&#34;.</p>

<p>The value returned is always a <code>StrPos</code> object. If the substring is found, then the <code>StrPos</code> represents the position of the first character of the substring. If the substring is not found, a bare <code>StrPos</code> containing no position is returned. This prototype <code>StrPos</code> evaluates to false because it&#39;s really a kind of undefined value. Do not evaluate as a number, because instead of returning -1 it will return 0 and issue a warning.</p>

<dt><a name="pack"
>pack</a></dt>

<dd>
<pre><code> multi pack( *@items where { all(@items) ~~ Pair } --&#62; buf8 )
 multi pack( Str $template, *@items --&#62; buf8 )</code></pre>

<p><code>pack</code> takes a list of pairs and formats the values according to the specification of the keys. Alternately, it takes a string <code>$template</code> and formats the rest of its arguments according to the specifications in the template string. The result is a sequence of bytes.</p>

<p>Templates are strings of the form:</p>

<pre><code>  grammar Str::PackTemplate {
regex TOP       { ^ &#60;template&#62; $ }
regex template  { [ &#60;group&#62; | &#60;specifier&#62; &#60;count&#62;? ]* }
token group     { \( &#60;template&#62; \) }
token specifier { &#60;[aAZbBhHcCsSiIlLnNvVqQjJfdFDpPuUwxX\@]&#62; \!? }
token count     { \*
                | \[ [ \d+ | &#60;specifier&#62; ] \]
                | \d+ }
  }</code></pre>

<p>In the pairwise mode, each key must contain a single <code>&#60;group&#62;</code> or <code>&#60;specifier&#62;</code>, and the values must be either scalar arguments or arrays.</p>

<p>[ Note: Need more documentation and need to figure out what Perl 5 things no longer make sense. Does Perl 6 need any extra formatting features? -ajs ]</p>

<p>[I think pack formats should be human readable but compiled to an internal form for efficiency. I also think that compact classes should be able to express their serialization in pack form if asked for it with .packformat or some such. -law]</p>

<dt><a name="quotemeta"
>quotemeta</a></dt>

<dd>
<pre><code> multi method quotemeta ( Str $string: --&#62; Str ) is export</code></pre>

<p>Returns the input string with all non-&#34;word&#34; characters back-slashed. That is, all characters not matching &#34;/&#60;[A..Za..z_0..9]&#62;/&#34; will be preceded by a backslash in the returned string, regardless of any locale settings.</p>

<p>[Note from Pm: Should that be &#34;/\w/&#34; instead? Or, if the intent is to duplicate p5 functionality, perhaps it should be &#34;p5quotemeta&#34;? Do we even want this method at all?]</p>

<dt><a name="rindex"
>rindex <!--
	INDEX: rindex
--></a></dt>

<dd>
<pre><code> multi method rindex( Str $string: Str $substring, StrPos $pos? --&#62; StrPos ) is export
 multi method rindex( Str $string: Str $substring, Int $pos --&#62; StrPos ) is export</code></pre>

<p>Returns the position of the last <code>$substring</code> in <code>$string</code>. If <code>$pos</code> is specified, then the search starts at that location in <code>$string</code>, and works backwards. See <code>index</code> for more detail.</p>

<dt><a name="split"
>split <!--
	INDEX: split
--></a></dt>

<dd>
<pre><code> multi split ( Str $delimiter, Str $input, Int $limit = Inf --&#62; List )
 multi split ( Regex $delimiter, Str $input, Int $limit = Inf --&#62; List )
 multi method split ( Str $input: Str $delimiter, Int $limit = Inf --&#62; List )
 multi method split ( Str $input: Regex $delimiter, Int $limit = Inf, Bool :$all = False --&#62; List )</code></pre>

<p>Splits a string up into pieces based on delimiters found in the string.</p>

<p>String delimiters must not be treated as rules but as constants. The default is no longer &#39;&#160;&#39; since that would be interpreted as a constant. P5&#39;s <code>split(&#39;&#160;&#39;)</code> will translate to <code>comb</code>. Null trailing fields are no longer trimmed by default.</p>

<p>The <code>split</code> function no longer has a default delimiter nor a default invocant. In general you should use <code>words</code> to split on whitespace now, or <code>comb</code> to break into individual characters. See below.</p>

<p>If the <code>:all</code> adverb is supplied to the <code>Regex</code> form, then the delimiters are returned as <code>Match</code> objects in alternation with the split values. Unlike with Perl 5, if the delimiter contains multiple captures they are returned as submatches of single <code>Match</code> object. (And since <code>Match</code> does <code>Capture</code>, whether these <code>Match</code> objects eventually flatten or not depends on whether the expression is bound into a list or slice context.)</p>

<p>You may also split lists and filehandles. <code>$*ARGS.split(/\n[\h*\n]+/)</code> splits on paragraphs, for instance. Lists and filehandles are automatically fed through <code>cat</code> in order to pretend to be string. The resulting <code>Cat</code> is lazy. Accessing a filehandle as both a filehandle and as a <code>Cat</code> is undefined.</p>

<dt><a name="comb"
>comb</a></dt>

<dd>
<pre><code> multi comb ( Str $matcher, Str $input, Int $limit = Inf, Bool :$match --&#62; List )
 multi comb ( Regex $matcher, Str $input, Int $limit = Inf, Bool :$match --&#62; List )
 multi method comb ( Str $input: Str $matcher, Int $limit = Inf, Bool :$match --&#62; List )
 multi method comb ( Str $input: Regex $matcher = /./, Int $limit = Inf, Bool :$match --&#62; List )</code></pre>

<p>The <code>comb</code> function looks through a string for the interesting bits, ignoring the parts that don&#39;t match. In other words, it&#39;s a version of split where you specify what you want, not what you don&#39;t want.</p>

<p>That means the same restrictions apply to the matcher rule as do to split&#39;s delimiter rule.</p>

<p>By default it pulls out all individual characters. Saying</p>

<pre><code>$string.comb(/pat/, $n)</code></pre>

<p>is equivalent to</p>

<pre><code>map {.Str}, $string.match(rx:global:x(0..$n):c/pat/)</code></pre>

<p>You may also comb lists and filehandles. <code>+$*IN.comb</code> counts the characters on standard input, for instance. <code>comb(/./, $thing)</code> returns a list of single <code>Char</code> strings from anything that can give you a <code>Str</code>. Lists and filehandles are automatically fed through <code>cat</code> in order to pretend to be string. This <code>Cat</code> is also lazy.</p>

<p>If the <code>:match</code> adverb is applied, a list of <code>Match</code> objects (one per match) is returned instead of strings. This can be used to access capturing subrules in the matcher. The unmatched portions are never returned -- if you want that, use <code>split :all</code>. If the function is combing a lazy structure, the return values may also be lazy. (Strings are not lazy, however.)</p>

<dt><a name="lines"
>lines</a></dt>

<dd>
<pre><code> multi method lines ( Str $input: Int $limit = Inf --&#62; List ) is export</code></pre>

<p>Returns a list of lines, i.e. the same as a call to <code>$input.comb( / ^^ \N* /, $limit )</code> would.</p>

<dt><a name="words"
>words</a></dt>

<dd>
<pre><code> multi method words ( Str $input: Int $limit = Inf --&#62; List ) is export</code></pre>

<p>Returns a list of non-whitespace bits, i.e. the same as a call to <code>$input.comb( / \S+ /, $limit )</code> would.</p>

<dt><a name="flip"
>flip</a></dt>

<dd>
<p>The <code>flip</code> function reverses a string character by character.</p>

<pre><code> multi method flip ( $str: --&#62; Str ) is export {
    $str.comb.reverse.join;
 }</code></pre>

<p>This function will misplace accents if used at a Unicode level less than graphemes.</p>

<dt><a name="sprintf"
>sprintf</a></dt>

<dd>
<pre><code> multi method sprintf ( Str $format: *@args --&#62; Str ) is export</code></pre>

<p>This function is mostly identical to the C library sprintf function.</p>

<p>The <code>$format</code> is scanned for <code>%</code> characters. Any <code>%</code> introduces a format token. Format tokens have the following grammar:</p>

<pre><code> grammar Str::SprintfFormat {
  regex format_token { &#39;%&#39;: &#60;index&#62;? &#60;precision&#62;? &#60;directive&#62; }
  token index { \d+ &#39;$&#39; }
  token precision { &#60;flags&#62;? &#60;vector&#62;? &#60;precision_count&#62; }
  token flags { &#60;[ \x20 + 0 \# \- ]&#62;+ }
  token precision_count { [ &#60;[1..9]&#62;\d* | &#39;*&#39; ]? [ &#39;.&#39; [ \d* | &#39;*&#39; ] ]? }
  token vector { &#39;*&#39;? v }
  token directive { &#60; % c s d u o x e f g X E G b p n i D U O F &#62; }
 }</code></pre>

<p>Directives guide the use (if any) of the arguments. When a directive (other than <code>%</code>) is used, it indicates how the next argument passed is to be formatted into the string.</p>

<p>The directives are:</p>

<pre><code> %   a literal percent sign
 c   a character with the given codepoint
 s   a string
 d   an integer, in decimal
 b   an integer, in binary
 o   an integer, in octal
 x   an integer, in hexadecimal
 X   like x, but using uppercase letters
 e   a floating-point number, in scientific notation
 f   a floating-point number, in fixed decimal notation
 g   a floating-point number, in %e or %f notation
 E   like e, but using an uppercase &#34;E&#34;
 G   like g, but with an uppercase &#34;E&#34; (if applicable)</code></pre>

<p>Compatibility:</p>

<pre><code> i   a synonym for %d
 u   a synonum for %d
 D   a synonym for %d
 U   a synonym for %u
 O   a synonym for %o
 F   a synonym for %f</code></pre>

<p>Perl 5 (non-)compatibility:</p>

<pre><code> n   produces a runtime exception
 p   produces a runtime exception</code></pre>

<dt><a name="fmt"
>fmt</a></dt>

<dd>
<pre><code>  multi method fmt( Scalar $scalar: Str $format = &#39;%s&#39; --&#62; Str )
  multi method fmt( List $list:
                Str $format = &#39;%s&#39;,
                Str $separator = &#39; &#39;
                --&#62; Str )
  multi method fmt( Hash $hash:
                Str $format = &#34;%s\t%s&#34;,
                Str $separator = &#34;\n&#34;
                --&#62; Str )
  multi method fmt( Pair $pair: Str $format = &#34;%s\t%s&#34; --&#62; Str )</code></pre>

<p>A set of wrappers around <code>sprintf</code>. A call to the scalar version <code>$o.fmt($format)</code> returns the result of <code>sprintf($format, $o)</code>. A call to the list version <code>@a.fmt($format, $sep)</code> returns the result of <code>join $sep, map { sprintf($format, $_) }, @a</code>. A call to the hash version <code>%h.fmt($format, $sep)</code> returns the result of <code>join $sep, map { sprintf($format, $_.key, $_.value) }, %h.pairs</code>. A call to the pair version <code>$p.fmt($format)</code> returns the result of <code>sprintf($format, $p.key, $p.value)</code>.</p>

<dt><a name="substr"
>substr</a></dt>

<dd>
<pre><code> multi method substr (Str $string: StrPos $start, StrLen $length? --&#62; Str ) is export
 multi method substr (Str $string: StrPos $start, StrPos $end --&#62; Str ) is export
 multi method substr (Str $string: StrPos $start, Int $length --&#62; Str ) is export
 multi method substr (Str $string: Int $start, StrLen $length? --&#62; Str ) is export
 multi method substr (Str $string: Int $start, StrPos $end --&#62; Str ) is export
 multi method substr (Str $string: Int $start, Int $length --&#62; Str ) is export</code></pre>

<p><code>substr</code> returns part of an existing string. You control what part by passing a starting position and optionally either an end position or length. If you pass a number as either the position or length, then it will be used as the start or length with the assumption that you mean &#34;chars&#34; in the current Unicode abstraction level, which defaults to graphemes. A number in the 3rd argument is interpreted as a length rather than a position (just as in Perl 5).</p>

<p>Here is an example of its use:</p>

<pre><code> $initials = substr($first_name,0,1) ~ substr($last_name,0,1);</code></pre>

<p>The function fails if either the start position or length is negative or undefined. (If the length argument is not given, it defaults to the rest of the string.) Either of start position or end position may be specified relative to the end of the string using a WhateverCode whose argument will be the position of the end of the string. While it is illegal for the start position to be outside of the string, it is allowed for the final position to be off the end of the string; in this case the entire rest of the string is returned, whatever is available.</p>

<dt><a name="substr-rw"
>substr-rw</a></dt>

<dd>
<pre><code> multi sub substr-rw($s is rw, $from = 0; $chars = $s.chars - $from) is rw</code></pre>

<p>A version of <code>substr</code> that returns a writable reference to a part of a string variable:</p>

<pre><code> $string ~~ /(barney)/;
 substr-rw($string, $0.from, $0.to) = &#34;fred&#34;;</code></pre>

<dt><a name="trim"
>trim</a></dt>

<dd>
<pre><code>  multi method trim() is export;
  multi method trim-leading() is export;
  multi method trim-trailing() is export;</code></pre>

<p>Returns a copy of the string, with leading and trailing whitespace removed.</p>

<p>The variants <code>trim-leading</code> and <code>trim-trailing</code> also return a copy of the string, but with whitespace removed only at their respective end of the string.</p>

<dt><a name="unpack"
>unpack</a></dt>

<dd>
<dt><a name="match"
>match</a></dt>

<dd>
<pre><code> method match(Str $self: Regex $search --&#62; Match );</code></pre>

<p>See <a href="http://search.cpan.org/perldoc?S05#Substitution" class="podlinkpod"
>&#34;Substitution&#34; in S05</a></p>

<dt><a name="subst"
>subst</a></dt>

<dd>
<pre><code> method subst(Str $self: Regex $search, Str $replacement --&#62; Str);</code></pre>

<dt><a name="trans"
>trans</a></dt>

<dd>
<pre><code> method trans(Str $self: Str $key, Str $val);

 multi trans(List of Pair %data --&#62; Any );</code></pre>

<dt><a name="indent"
>indent</a></dt>

<dd>
<pre><code> multi method indent ($str: $steps --&#62; Str ) is export;</code></pre>

<p>Returns a re-indented string wherein <code>$steps</code> number of spaces have been added to each line. If a line already begins with horizontal whitespace, the new spaces are added to the end of those.</p>

<p>If the whitespace at the beginning of the line consists of only <code>chr(32)</code> spaces, <code>chr(32)</code> spaces are added as indentation as well. If the whitespace at the beginning of the line consists of some other kind of horizontal whitespace, that kind of whitespace is added as indentation. If the whitespace at the beginning of the line consists of two or more different kinds of horizontal whitespace, again <code>chr(32)</code> spaces are used.</p>

<p>If <code>$steps</code> is negative, removes that many spaces instead. Should any line contain too few leading spaces, only those are removed and a warning is issued. At most one such warning is issued per <code>.indent</code> call.</p>

<p>If <code>$steps</code> is <code>*</code>, removes just enough indentation to make some line have zero indentation.</p>

<p>Empty lines don&#39;t participate in re-indenting at all. That is, a line with 0 characters will still have 0 characters after the call. It also will not cause a warning to be issued.</p>

<p>The method will assume hard tabs to be equivalent to <code>($?TABSTOP // 8)</code> spaces, and will treat any other horizontal whitespace character as equivalent to one <code>chr(32)</code> space. If the indenting doesn&#39;t &#34;add up evenly&#34;, one hard tab needs to be exploded into the equivalent number of spaces before the unindenting of that line.</p>

<p>Decisions on how to indent each line are based solely on characters on that line. Thus, an <code>.indent</code> call on a multiline string therefore amounts to <code> .lines&#187;.indent.join(&#34;\n&#34;) </code>, modulo exotic line endings in the original string, and the proviso about empty lines.</p>

<dt><a name="IO"
>IO</a></dt>

<dd>
<p>Returns an IO::Path, using the string as the file path.</p>

<dt><a name="path"
>path</a></dt>

<dd>
<p>A deprecated form of <code>IO</code>.</p>

<dt><a name="succ"
>succ</a></dt>

<dd>
<p>Increments the string to the next numeric or alphabetic value, and returns the resulting string. The autoincrement operator <code>++</code> uses <code>succ</code> to determine the new value.</p>

<p>The last portion of the string before the first period (which may be the entire string) is incremented, using <code> &#60;rangechar</code> &#62; to determine which characters are eligible to be incremented. See <a href="http://search.cpan.org/perldoc?S03#Autoincrement_precedence" class="podlinkpod"
>&#34;Autoincrement precedence&#34; in S03</a> for details.</p>

<dt><a name="pred"
>pred</a></dt>

<dd>
<p>Decrements the string to the next numeric or alphabetic value, and returns the resulting string. The autodecrement operator <code>--</code> uses <code>pred</code> to determine the new value.</p>

<p>When attempting to decrement a string, such as <code>&#34;a0&#34;</code>, where the result would remove the leftmost characters, <code>pred</code> returns failure instead.</p>

<p>The last portion of the string before the first period (which may be the entire string) is incremented, using <code> &#60;rangechar</code> &#62; to determine which characters are eligible to be incremented. See <a href="http://search.cpan.org/perldoc?S03#Autoincrement_precedence" class="podlinkpod"
>&#34;Autoincrement precedence&#34; in S03</a> for details.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Additions"
>Additions</a></h1>

<p>Please post errors and feedback to perl6-language. If you are making a general laundry list, please separate messages by topic.</p>

<!-- end doc -->

</body></html>
