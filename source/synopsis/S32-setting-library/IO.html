<!DOCTYPE html>
<html lang="ja">
<head>
<title>IO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Aug 30 10:16:53 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Functions'>Functions</a>
  <li class='indexItem indexItem1'><a href='#IO_Types'>IO Types</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#IO'>IO</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AHandle'>IO::Handle</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AFileTestable'>IO::FileTestable</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3APath'>IO::Path</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#OS_Specific_subclasses.'>OS Specific subclasses.</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#IO%3A%3ASpec'>IO::Spec</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Here_Be_Dragons'>Here Be Dragons</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#IO%3A%3ASocket'>IO::Socket</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3ASocket%3A%3AINET'>IO::Socket::INET</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AHandle_(opened_version)'>IO::Handle (opened version)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Conjectural_Stuff'>Conjectural Stuff</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AACL'>IO::ACL</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3APipe'>IO::Pipe</a>
    <li class='indexItem indexItem2'><a href='#OS-specific_classes'>OS-specific classes</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Unix'>Unix</a>
      <li class='indexItem indexItem3'><a href='#Path%3A%3AUnix'>Path::Unix</a>
      <li class='indexItem indexItem3'><a href='#IO%3A%3ASocket%3A%3AUnix'>IO::Socket::Unix</a>
      <li class='indexItem indexItem3'><a href='#IO%3A%3APOSIX'>IO::POSIX</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#Unfilled'>Unfilled</a>
  <li class='indexItem indexItem1'><a href='#Removed_functions'>Removed functions</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#IO%3A%3ABuffered'>IO::Buffered</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AStreamable'>IO::Streamable</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AEncoded'>IO::Encoded</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AReadable%3A%3AEncoded'>IO::Readable::Encoded</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>DRAFT: Synopsis 32: Setting Library - IO</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>The authors of the related Perl 5 docs
Rod Adams &#60;rod@rodadams.net&#62;
Larry Wall &#60;larry@wall.org&#62;
Aaron Sherman &#60;ajs@ajs.com&#62;
Mark Stosberg &#60;mark@summersault.com&#62;
Carl M&#228;sak &#60;cmasak@gmail.com&#62;
Moritz Lenz &#60;moritz@faui2k3.org&#62;
Tim Nelson &#60;wayland@wayland.id.au&#62;
Daniel Ruoso &#60;daniel@ruoso.com&#62;
Lyle Hopkins &#60;webmaster@cosmicperl.com&#62;
Brent Laabs &#60;bslaabs@gmail.com&#62;
Tobias Leich &#60;email@froggs.de&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 19 Feb 2009 extracted from S29-functions.pod; added stuff from S16-IO later

Last Modified: 05 May 2014
Version: 23</code></pre>

<p>The document is a draft.</p>

<p>If you read the HTML version, it is generated from the Pod in the specs repository under <a href="https://github.com/perl6/specs/blob/master/S32-setting-library/IO.pod" class="podlinkurl"
>https://github.com/perl6/specs/blob/master/S32-setting-library/IO.pod</a> so edit it there in the git repository if you would like to make changes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>The most common IO operations are <code>print</code> and <code>say</code> for writing and <code>lines</code> and <code>get</code> for reading. All four are available as subroutines (defaulting to the <code>$*OUT</code> and <code>$*ARGFILES</code> file handles) and as methods on file handles.</p>

<p>File handles are of type <code>IO::Handle</code>, and can be created with <code>&#38;open</code>. Paths are generally passed as strings or <code>IO::Path</code> objects.</p>

<p><code>&#38;dir</code> returns <code>IO::Path</code> objects.</p>

<pre><code>          default handle
routine   for sub form    purpose
=======   ===========     =======
print     $*OUT           string-based writing
say       $*OUT           string-based writing
get       $*ARGFILES      read a line (Str)
lines     $*ARGFILES      read all lines (Str)
read                      binary reading (Buf)
write                     binary writing (Buf)</code></pre>

<p>File tests are performed through <code>IO::Path</code> objects.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Functions"
>Functions</a></h1>

<dl>
<dt><a name="open"
>open <!--
	INDEX: open
--></a></dt>

<dd>
<pre><code>multi open (Str $name,
  # mode
    Bool :$r  = True,
    Bool :$w  = False,
    Bool :$rw = False,
    Bool :$a  = False,
  # encoding
    Bool :$bin = False,
    Str  :$enc = &#34;Unicode&#34;,
  # newlines
    Any  :$nl = &#34;\n&#34;,
    Bool :$chomp = True,
    ...
    --&#62; IO::Handle
) is export</code></pre>

<p>A convenience function that hides most of the OO complexity. It will only open normal files. Text is the default. Note that the &#34;Unicode&#34; encoding implies figuring out which actual UTF is in use, either from a BOM or other heuristics. If heuristics are inconclusive, UTF-8 will be assumed. (No 8-bit encoding will ever be picked implicitly.) A file opened with <code>:bin</code> may still be processed line-by-line, but IO will be in terms of <code>Buf</code> rather than <code>Str</code> types.</p>

<p>For a discussion of the read/write/append modes (:r, :w, :a), see <a href="#IO%3A%3AHandle%2Fopen" class="podlinkpod"
>&#34;IO::Handle/open&#34;</a> under IO::Handle.</p>

<dt><a name="dir"
>dir <!--
	INDEX: dir
--></a></dt>

<dd>
<pre><code>multi dir($directory = &#39;.&#39;, Mu :$test = none(&#39;.&#39;, &#39;..&#39;)) { ... }</code></pre>

<p>Returns a lazy list of file names in the <code>$directory</code>. By default the current and the parent directory are excluded, which can be controlled with the <code>$test</code> named parameter. Only items that smart-match against this test are returned.</p>

<p>The return value is a list of <code>IO::Path</code> objects. Because of this, you may want use the <code>basename</code> method on the results to get the just the file name, without its full path. If dir() fails, it returns an <a href="http://search.cpan.org/perldoc?S32%3A%3AException#X%3A%3AIO%3A%3ADir" class="podlinkpod"
>X::IO::Dir</a> failure.</p>

<dt><a name="glob"
>glob</a></dt>

<dd>
<pre><code>multi glob(Str $pattern --&#62; Array[Str])</code></pre>

<p>Accepts a pattern that will then be expanded into a array of filenames (the creation of <code>IO</code> objects from this list is left to the user).</p>

<p>The default <code>glob</code> function operates on POSIX rules, which may be read in more detail in the glob(7) manpage, however an overview is presented below.</p>

<p>The <code>glob</code> function understands a few metacharacters:</p>

<pre><code>\    Escape metacharacter
~    Home directory
?    Match exactly one character
*    Match zero or more characters
[    Start of character class (ends with ])</code></pre>

<p>Note that this is not a regex-like syntax, so the <code>?</code> and <code>*</code> are not quantifiers.</p>

<pre><code>glob(&#34;foo?&#34;);  # roughly equivalent to /^ foo. $/, NOT /^ foo? $/
glob(&#34;*bar&#34;);  # valid syntax; roughly equivalent to /^ .* bar $/</code></pre>

<p>The character class construct <code>[...]</code> matches all characters specified. It has a few metacharacters of its own:</p>

<pre><code>glob(&#34;[]]&#34;);     # matches the ] character
glob(&#34;[!abc]&#34;);  # matches all but &#39;a&#39;, &#39;b&#39;, or &#39;c&#39; (negation)
glob(&#34;[a-z]&#34;);   # matches all lowercase letters from a to z (range)
glob(&#34;[a-]&#34;);    # matches &#39;a&#39; and &#39;-&#39;
glob(&#34;[[:xdigit:]]&#34;); # matches hexadecimal digit (named character class)</code></pre>

<p>Ranges matches all the characters that fall between and the startpoint and endpoint, inclusively. Note that the <code>/</code> character can never be matched by a range. If contained within the a range (such as <code>[--0]</code>), the <code>/</code> is skipped. If explicitly specified as the start- or endpoint, it&#39;s considered a syntax error.</p>

<pre><code>glob(&#34;[--0]&#34;);   # matches &#39;-&#39;, &#39;.&#39;, or &#39;0&#39; (skips &#39;/&#39;)
glob(&#34;[a/b]&#34;);   # matches &#39;a&#39;, &#39;/&#39;, or &#39;b&#39;
glob(&#34;[/-0]&#34;);   # syntax error</code></pre>

<p>There are some notable departures from POSIX in terms of what the Perl 6 <code>&#38;glob</code> function allows with character classes. Namely, neither the <code>[[.ch.]]</code> nor <code>[[=ch=]]</code> forms are supported, and the <code>[^...]</code> form is not undefined, but rather matches the <code>^</code> character among other things.</p>

<p>Glob metacharacters that must be escaped outside character classes aren&#39;t within.</p>

<pre><code>glob(&#39;\[\*\?\~&#39;);    # Matches the filename &#34;[*?~&#34;
glob(&#34;[[*?~]&#34;);      # Matches the filenames &#34;[&#34;, &#34;*&#34;, &#34;?&#34;, and &#34;~&#34;</code></pre>

<p>Unlike Perl 5, no special attention is given to the interpolation rules of strings, particularly braces.</p>

<dt><a name="note"
>note</a></dt>

<dd>
<pre><code>multi note (*@LIST --&#62; Bool)</code></pre>

<p>Does a &#34;say&#34; to <code>$*ERR</code>, more or less. Like <code>warn</code>, it adds a newline only if the message does not already end in newline. Unlike <code>warn</code>, it is not trappable as a resumable exception because it outputs directly to <code>$*ERR</code>. You can suppress notes in a lexical scope by declaring:</p>

<pre><code>only note(*@) {}</code></pre>

<dt><a name="slurp"
>slurp</a></dt>

<dd>
<pre><code>multi slurp (IO::Handle $fh = $*ARGFILES,
    Bool :$bin = False,
    Str  :$enc = &#34;Unicode&#34;,
    --&#62; Str|Buf
)
multi slurp (Str $filename,
    Bool :$bin = False,
    Str  :$enc = &#34;Unicode&#34;,
    --&#62; Str|Buf
)</code></pre>

<p>Slurps the entire file into a <code>Str</code> (or <code>Buf</code> if <code>:bin</code>) regardless of context. (See also <code>lines</code>.)</p>

<p>The routine will <code>fail</code> if the file does not exist, or is a directory.</p>

<dt><a name="spurt"
>spurt</a></dt>

<dd>
<pre><code>multi spurt (IO::Handle $fh,
    Str   $contents,
    Str  :$enc = $?ENC,
    Bool :append = False,
    Bool :$createonly = False,
)
multi spurt (IO::Handle $fh,
    Buf   $contents,
    Bool :append = False,
    Bool :$createonly = False,
)
multi spurt (Str $filename,
    Str   $contents,
    Str  :$enc = $?ENC,
    Bool :append = False,
    Bool :$createonly = False,
)
multi spurt (Str $filename,
    Buf   $contents,
    Bool :append = False,
    Bool :$createonly = False,
)</code></pre>

<p>Opens the file for writing, dumps the contents, and closes the file.</p>

<p>This routine will <code>fail</code> if the file exists and <code>:createonly</code> is set.</p>

<p>If <code>:append</code> is provided, an existing file will not be clobbered, but the string will be appended.</p>

<p>The routine will also <code>fail</code> with the corresponding exception if there was any other error in opening, writing, or closing.</p>

<dt><a name="chdir"
>chdir</a></dt>

<dd>
<pre><code>multi sub chdir(Str:D)
multi sub chdir(IO::Path:D)</code></pre>

<p>Changes the current (emulated) working directory to the new value, scoped to the current scope of <code>$*CWD</code> (usually thread-local at worst, or the scope of a <code>visitdir</code> inside the current thread). Fails (X::IO::Chdir) on error. If <code>$*CWD</code> is not scoped to the current dynamic scope, you must call <code>chdir</code> again when exiting the dynamic scope to get back to the original directly, just as you would with a real <code>chdir</code>. In this case you would probably be better off using <code>visitdir</code> instead, which will automatically scope <code>$*CWD</code> to the current dynamic scope.</p>

<p>Note that actually changing the process&#39;s working directory requires a call to <code>PROCESS::chdir</code> (which will inform the chdir emulation that the process&#39;s actual current working directory has changed). This function is not threadsafe, however. And if calling out to a foreign function, only one thread can safely use it; in general it&#39;s better to pass absolute paths to foreign functions that don&#39;t allow you to set the working directory as a parameter.</p>

<dt><a name="visitdir"
>visitdir</a></dt>

<dd>
<pre><code>multi sub visitdir(Str:D)
multi sub visitdir(IO::Path:D)</code></pre>

<p>Changes the current (emulated) working directory to the new value, scoped to the current dynamic scope just as <code>temp $*CWD = newdir();</code> would. Fails (X::IO::Chdir) on error. Since <code>$*CWD</code> is dynamically scoped, leaving the current dynamic scope automatically restores the current (emulated) working directory.</p>

<dt><a name="unlink"
>unlink</a></dt>

<dd>
<pre><code>sub unlink(Cool:D $path)</code></pre>

<p>Unlinks an ordinary file, link, or symbolic link from disk -- that is, it is deleted. Returns True on success; otherwise returns an <a href="http://search.cpan.org/perldoc?S32%3A%3AException#X%3A%3AIO%3A%3AUnlink" class="podlinkpod"
>&#34;X::IO::Unlink&#34; in S32::Exception</a> failure.</p>

<dt><a name="rmdir"
>rmdir</a></dt>

<dd>
<pre><code>sub rmdir(Cool:D $directory)</code></pre>

<p>Removes the directory given from disk. Returns True on success, or an <a href="http://search.cpan.org/perldoc?S32%3A%3AException#X%3A%3AIO%3A%3ARmdir" class="podlinkpod"
>X::IO::Rmdir</a> failure.</p>

<dt><a name="mkdir"
>mkdir</a></dt>

<dd>
<pre><code>sub mkdir(Cool:D $directory)</code></pre>

<p>Makes (creates) the directory represented by the IO::Path. Returns True on success, or an <a href="http://search.cpan.org/perldoc?S32%3A%3AException#X%3A%3AIO%3A%3AMkdir" class="podlinkpod"
>X::IO::Mkdir</a> failure.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IO_Types"
>IO Types</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO"
>IO</a></h2>

<pre><code>role IO { };</code></pre>

<p>The base role only tags that this is an <code>IO</code> object for more generic purposes. It doesn&#39;t specify any methods or attributes.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Handle"
>IO::Handle</a></h2>

<pre><code>class IO::Handle does IO { ... }</code></pre>

<p>A handle of a file, pipe or anything else that supports reading or writing like a file.</p>

<dl>
<dt><a name="open"
>open</a></dt>

<dd>
<pre><code>multi method open (
  # mode
    Bool :$r  = True,
    Bool :$w  = False,
    Bool :$rw = False,
    Bool :$a  = False,
  # encoding
    Bool :$bin = False,
    Str  :$enc = &#34;Unicode&#34;,
  # newlines
    Any  :$nl = &#34;\n&#34;,
    Bool :$chomp = True,
    --&#62; IO::Handle
) is export</code></pre>

<p>Open the handle for reading or writing (or both). Specifying <code>:r</code>, the default, opens the handle as read-only, <code>:w</code> is write-only, <code>:rw</code> is read-write, and <code>:a</code> appends writes to the file.</p>

<p>The <code>:enc</code> parameter controls which text encoding the file is interpreted as. Unicode is the default encoding. See <a href="#encoding" class="podlinkpod"
>&#34;encoding&#34;</a> for encoding options.</p>

<p>The <code>:nl</code> option sets <a href="#input-line-separator" class="podlinkpod"
>&#34;input-line-separator&#34;</a>, and <code>:chomp</code> determines if the new line separator will be chopped removed by <code>get</code> and <code>lines</code>.</p>

<p>Conjectural: The &#60;:p&#62; parameter opens a pipe, which is readable with <code>:r</code> (default) and writable with <code>:w</code>.</p>

<dt><a name="get"
>get</a></dt>

<dd>
<pre><code>method get() returns Str:D</code></pre>

<p>Reads and returns one line from the handle. Uses <code>input-line-separator</code> to determine where a line ends.</p>

<dt><a name="lines"
>lines</a></dt>

<dd>
<pre><code>method lines($limit = Inf)</code></pre>

<p>Returns a lazy list of lines read via the <code>get</code> method, limited to <code>$limit</code> lines.</p>

<dt><a name="getc"
>getc <!--
	INDEX: getc
--></a></dt>

<dd>
<pre><code>method getc (IO::Handle:D: Int $chars = 1 --&#62; Str)</code></pre>

<p>Reads <code>$chars</code> and returns them</p>

<dt><a name="print"
>print <!--
	INDEX: print
--></a></dt>

<dd>
<pre><code>method print (IO::Handle:D: *@LIST --&#62; Bool)
multi print (*@LIST --&#62; Bool)</code></pre>

<p>Stringifies each element, concatenates those strings, and sends the result to the output. Returns <code>Bool::True</code> if successful, <code>Failure</code> otherwise.</p>

<p>The compiler will warn you if use a bare sub <code>print</code> without arguments. (However, it&#39;s fine if you have an explicit argument list that evaluates to the empty list at runtime.)</p>

<pre><code>print;             # warns
if $_ { print }    # warns
if $_ { print() }  # ok, but does nothing
if $_ { print () } # ok, but does nothing</code></pre>

<dt><a name="say"
>say <!--
	INDEX: say
--></a></dt>

<dd>
<pre><code>method say (IO::Handle:D: *@LIST --&#62; Bool)
multi say (*@LIST --&#62; Bool)</code></pre>

<p>This is identical to print() except that it stringifies its arguments by calling <code>.gist</code> on them and auto-appends a newline after the final argument.</p>

<pre><code>Was:    print &#34;Hello, world!\n&#34;;
Now:    say   &#34;Hello, world!&#34;;</code></pre>

<p>As with <code>print</code>, the compiler will warn you if you use a bare sub <code>say</code> without arguments.</p>

<dt><a name="printf"
>printf <!--
	INDEX: printf
--></a></dt>

<dd>
<pre><code>method printf (Str $fmt, *@LIST --&#62; Bool)
multi printf (IO::Handle:D: Str $fmt, *@LIST --&#62; Bool)</code></pre>

<p>Output through <code>Str.sprintf</code>. See <a href="http://search.cpan.org/perldoc?S32%3A%3AStr" class="podlinkpod"
>S32::Str</a> for details.</p>

<dt><a name="write"
>write</a></dt>

<dd>
<pre><code>method write(IO::Handle:D: Buf $buf --&#62; Int)</code></pre>

<p>Tries to write <code>$buf</code>. The actual number of bytes written is returned. It might return unthrown failures, to be specified by each <code>IO</code> implementation.</p>

<p>This is &#34;raw&#34; write. <code>$buf</code> contains plain octets. If you want to <code>write</code> a <code>Str</code>, you should <code>.encode</code> it first, or use &#34;print&#34; or other <code>IO::Writeable::Encoded</code> methods.</p>

<dt><a name="slurp"
>slurp</a></dt>

<dd>
<pre><code>method slurp(
    Bool :$bin = False,
    Str  :$enc = &#34;Unicode&#34;,
    --&#62; Str|Buf)</code></pre>

<p>Opens the handle if necessary, slurps the entire file into a <code>Str</code> (or <code>Buf</code> if <code>:bin</code> parameter is given) regardless of context. Closes the handle after it is done, and returns the contents of the file. (See also <a href="#lines" class="podlinkpod"
>&#34;lines&#34;</a>.)</p>

<p>The routine will <code>fail</code> if the file does not exist, or is a directory.</p>

<dt><a name="spurt"
>spurt</a></dt>

<dd>
<pre><code>multi method spurt (
    Str   $contents,
    Str  :$enc = $?ENC,
    Bool :append = False,
    Bool :$createonly = False)

multi method spurt (
    Buf   $contents,
    Bool :append = False,
    Bool :$createonly = False)</code></pre>

<p>Opens the file for writing, dumps the contents, and closes the file.</p>

<p>This routine will <code>fail</code> if the file exists and <code>:createonly</code> is set.</p>

<p>If <code>:append</code> is provided, an existing file will not be clobbered, but the string will be appended.</p>

<p>The routine will also <code>fail</code> with the corresponding exception if there was any other error in opening, writing, or closing.</p>

<dt><a name="t"
>t</a></dt>

<dd>
<pre><code>method t() returns Bool:D</code></pre>

<p>Returns <code>True</code> if the handle is opened to a tty.</p>

<dt><a name="p"
>p</a></dt>

<dd>
<pre><code>method p() returns Bool:D</code></pre>

<p>Returns <code>True</code> if the handle is opened to a pipe.</p>

<dt><a name="eof"
>eof</a></dt>

<dd>
<pre><code>method eof() returns Bool:D</code></pre>

<p>Returns <code>True</code> if the handle is exhausted.</p>

<dt><a name="seek"
>seek</a></dt>

<dd>
<p>method seek(Int $position, Int $whence --&#62; Bool)</p>

<p>Position this stream into <code>$position</code>. The meaning of this position is always in &#34;octets&#34;.</p>

<p>Fails if the handle is not seekable.</p>

<p>TODO: make $whence an Enum</p>

<dt><a name="tell"
>tell</a></dt>

<dd>
<pre><code>method tell() returns Int:D:</code></pre>

<p>Returns the current raw position in the stream in number of &#34;octets&#34;.</p>

<dt><a name="ins"
>ins</a></dt>

<dd>
<pre><code>method ins( --&#62; Int)</code></pre>

<p>Returns the number of lines that have been read with <code>get</code>.</p>

<dt><a name="input-line-separator"
>input-line-separator</a></dt>

<dd>
<pre><code>method input-line-separator( --&#62; Str) is rw</code></pre>

<p>This regulates how <code>get</code> and <code>lines</code> behave.</p>

<p>The input line (record) separator, newline by default. This influences Perl&#39;s idea of what a ``line&#39;&#39; is. Works like awk&#39;s RS variable, including treating empty lines as a terminator if set to the null string. (An empty line cannot contain any spaces or tabs.) You may set it to a multi-character string to match a multi-character terminator, or to Nil to read through the end of file. Setting it to &#34;\n\n&#34; means something slightly different than setting to &#34;&#34;, if the file contains consecutive empty lines. Setting to &#34;&#34; will treat two or more consecutive empty lines as a single empty line. Setting to &#34;\n\n&#34; will blindly assume that the next input character belongs to the next paragraph, even if it&#39;s a newline.</p>

<p>You may also set it to a regular expression. The value of <code>$/</code> will be (temporarily) set to the matched separator upon input, if you care about the contents of the separator.</p>

<dt><a name="encoding"
>encoding</a></dt>

<dd>
<pre><code>multi method encoding($enc?)</code></pre>

<p>With no arguments, simply returns the current encoding used on the handle. If supplied a string identifying a valid encoding, change the handle to read with that encoding. Options include <code>binary</code>, <code>utf8</code>, and other text encodings. An invalid encoding causes the method to fail.</p>

<dt><a name="IO"
>IO</a></dt>

<dd>
<p>Returns the handle itself (no-op).</p>

<dt><a name="close"
>close</a></dt>

<dd>
<p>Closes the handle. Fails on error.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::FileTestable"
>IO::FileTestable</a></h2>

<pre><code>role IO::FileTestable does IO { ... }</code></pre>

<p>Provides ways to inspect a file or path without opening it.</p>

<p>If you apply that role to a class, that class must provide a <code>Str</code> method which returns the full path. <code>IO::FileTestable</code> will call this method to obtain the path to test. Stringification must return <code>Str:D</code> here.</p>

<p>The methods are typically only one letter long (for now; Perl 5 tradition strikes) and are summarized in the following table:</p>

<pre><code>M  Test performed                              Returns
=  ==============                              =======
r  Path is readable by effective uid/gid.      Bool:D
w  Path is writable by effective uid/gid.      Bool:D
x  Path is executable by effective uid/gid.    Bool:D
o  Path is owned by effective uid.             Bool:D

R  Path is readable by real uid/gid.           Bool:D
W  Path is writable by real uid/gid.           Bool:D
X  Path is executable by real uid/gid.         Bool:D
O  Path is owned by real uid.                  Bool:D

e  Path exists.                                Bool:D
s  Size of the path in bytes.                  Int:D
z  Path has zero size (an empty file).         Bool:D

f  Path is a plain file.                       Bool:D
d  Path is a directory.                        Bool:D
l  Path is a symbolic link.                    Bool:D
p  Path is a named pipe (FIFO)                 Bool:D
S  Path is a socket.                           Bool:D
b  Path is a block special file.               Bool:D
c  Path is a character special file.           Bool:D

u  Path has setuid bit set.                    Bool:D
g  Path has setgid bit set.                    Bool:D
k  Path has sticky bit set.                    Bool:D</code></pre>

<p>All methods (except for <code>e</code>) return the appropriate type object if a path has been specified that does not exist.</p>

<dl>
<dt><a name="accessed"
>accessed <!--
	INDEX: stattimes
--></a></dt>

<dd>
<p>Returns the last access time (<code>atime</code>) of the path, to the degree that it is updated on that system.</p>

<dt><a name="modified"
>modified</a></dt>

<dd>
<p>Returns the time that the path was last modified (<code>mtime</code>).</p>

<dt><a name="changed"
>changed</a></dt>

<dd>
<p>Returns the time that the path was last changed (modified or a metadata change).</p>

<dt><a name="stat"
>stat</a></dt>

<dd>
<p>Returns a stat buffer for the path.</p>
</dd>
</dl>

<p>TODO: methods created, accessed, modified: return format, failure</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Path"
>IO::Path</a></h2>

<pre><code>class IO::Path is Cool does IO::FileTestable { }</code></pre>

<p>Holds a path of a file or directory. The path is generally divided into three parts, the <i>volume</i>, <i>directory</i> and <i>base name</i>.</p>

<p>On Windows, the volume is a drive letter like <code>C:</code>, or a UNC network volume like <code>\\share\</code>. On UNIX-based systems, the volume part is empty.</p>

<p>The base name is name of the file or directory that the IO::Path object represents, and the directory is the part of the path leading up to the base name.</p>

<pre><code>path              volume         directory  base name
/usr/bin/gvim                    /usr/bin   gvim   
/usr/bin/                        /usr       bin
foo/bar.txt                      foo        bar.txt
C:\temp\f.txt     C:             \temp      f.txt
\\server\share\a  \\server\share \          a</code></pre>

<p>IO::Path uses the syntax for the current operating system. If you want to work paths as if you were using another OS, use the OS-specific subclasses such as IO::Path::Cygwin.</p>

<p>There are several ways of creating an IO::Path. Both IO::Handle and Cool have a .path method, or you can construct it directly:</p>

<pre><code>    &#34;my/path&#34;.path
    $filehandle.path
    IO::Path.new( $full-path );
    IO::Path.new( :$volume, :$directory, :$basename);</code></pre>

<dl>
<dt><a name="Str"
>Str</a></dt>

<dd>
<p>Stringification returns the path (volume, directory and base name joined together) as a string.</p>

<dt><a name="volume"
>volume</a></dt>

<dd>
<p>Returns the volume part of the path. On Unix-like OSes or systems without a concept of volume in the path, returns the empty string.</p>

<dt><a name="directory"
>directory</a></dt>

<dd>
<p>Returns the directory part of the path, not including the last item. Functions equivalently to the <code>dirname</code> shell program on Unix-like systems.</p>

<dt><a name="basename"
>basename</a></dt>

<dd>
<p>Returns the base name part of the path -- that is, the last portion. Functions equivalently to the <code>basename</code> shell program on Unix-like systems.</p>

<dt><a name="path"
>path</a></dt>

<dd>
<p>Returns the entire IO::Path object (a no-op).</p>

<dt><a name="contents"
>contents</a></dt>

<dd>
<pre><code>method contents( Mu :$test = none(&#39;.&#39;, &#39;..&#39;) )</code></pre>

<p>Returns a lazy list of file names in the path, if it is a directory. The current and the parent directory are excluded, which can be controlled with the <code>$test</code> named parameter. Only items that smart-match against this test are returned.</p>

<p>The return value is a list of <code>IO::Path</code> objects. Because of this, you may want use the <code>basename</code> method on the results to get the just the file name, without its full path.</p>

<dt><a name="cleanup"
>cleanup</a></dt>

<dd>
<pre><code>    method cleanup( :$parent = False )</code></pre>

<p>Returns a new IO::Path object with the canonical path. This eliminates extra slashes and <code>&#39;.&#39;</code> directories, but leaves <code>&#39;..&#39;</code> in (or whatever the parent directory is called on that platform).</p>

<p>With <code>:parent</code>, cleanup will logically remove references to the parent directory without <i>checking the filesystem</i>. That is, the parent of a symbolic link will remove the symlink itself, not the parent of the symlink&#39;s destination.</p>

<dt><a name="resolve"
>resolve</a></dt>

<dd>
<p>Returns a new IO::Path object that is cleaned-up (as above), and all symbolic links and references to the parent directory (<code>..</code>) are physically resolved. This means that the filesystem is examined for each directory in the path, and any symlinks found are followed. Identical to <code>.cleanup(:parent)</code> on systems where symbolic links are not supported.</p>

<pre><code>   # bar is a symlink pointing to &#34;/baz&#34;
   my $path = &#34;foo/./bar///..&#34;.path;
   $path.=cleanup;  # now &#34;foo/bar/..&#34;
   $path.cleanup(:parent); # yields &#34;foo&#34;
   $path.=resolve;  # now &#34;/&#34; (the parent of &#34;/baz&#34;)</code></pre>

<dt><a name="is-relative"
>is-relative</a></dt>

<dd>
<p>Returns True if the path is a relative path (like <code>foo/bar</code>), False otherwise.</p>

<dt><a name="is-absolute"
>is-absolute</a></dt>

<dd>
<p>Returns True if the path is an absolute path (like <code>/usr/bin</code>), False otherwise.</p>

<dt><a name="absolute"
>absolute</a></dt>

<dd>
<pre><code>method absolute ( Str $base = $*CWD )</code></pre>

<p>Transforms the path into an absolute form, and returns the result as a new IO::Path. If <code>$base</code> is supplied, transforms it relative to that base directory; otherwise the current working directory is used. Paths that are already absolute are returned unchanged.</p>

<dt><a name="relative"
>relative</a></dt>

<dd>
<pre><code>method relative ( Str $base = $*CWD )</code></pre>

<p>Transforms the path into an relative form, and returns the result as a new IO::Path. If <code>$base</code> is supplied, transforms it relative to that base directory; otherwise the current working directory is used. Paths that are already relative are returned unchanged.</p>

<dt><a name="parent"
>parent</a></dt>

<dd>
<p>Removes the last portion the given path, and returns a new IO::Path. This does not remove <code>.</code>, <code>..</code>, or symbolic links, so you may want to consider calling cleanup or resolve first.</p>

<p>On a Unix/POSIX filesystem, if called recursively, it will work like so:</p>

<pre><code>parent level          relative       absolute
Starting Path (0)     foo/bar        /foo/bar
1                       foo            /foo
2                        .              /
3                        ..             /
4                      ../..            /
5                     ../../..          /</code></pre>

<dt><a name="child"
>child</a></dt>

<dd>
<pre><code>method child ( Str $childname )</code></pre>

<p>Appends <code>$childname</code> to the end of the path, adding path separators where needed and returns the result as a new IO::Path.</p>

<dt><a name="succ"
>succ</a></dt>

<dd>
<p>Increments the basename portion of the string, as Str.succ does, and returns that successor as an IO::Path.</p>

<p>This is useful for getting all the parts of say, a multi-part archive, but does not always return the next item in the folder. To crawl a folder, you probably want to iterate on the parent directory&#39;s contents.</p>

<dt><a name="pred"
>pred</a></dt>

<dd>
<p>Decrements the basename portion of the string, as Str.pred does, and returns that predecessor as an IO::Path.</p>

<dt><a name="copy"
>copy</a></dt>

<dd>
<pre><code>method copy ($dest, :$createonly = False )</code></pre>

<p>Copies a file from the path, to the destination specified. If :createonly is set to True, copy fails when a file already exists in the destination. If the operation cannot be completed, fails as X::IO::Copy.</p>

<dt><a name="unlink"
>unlink</a></dt>

<dd>
<p>Unlinks (deletes) the ordinary file, link, or symbolic link represented by the IO::Path. Returns True on success; on error, fails with an X::IO::Unlink.</p>

<dt><a name="rmdir"
>rmdir</a></dt>

<dd>
<p>Removes (deletes) the directory represented by the IO::Path. Typically fails unless the directory is empty. Returns True on success; fails with an X::IO::Rmdir on error.</p>

<dt><a name="mkdir"
>mkdir</a></dt>

<dd>
<p>Makes (creates) the directory represented by the IO::Path. Returns True on success. The method will <code>fail</code> with <a href="http://search.cpan.org/perldoc?S32%3A%3AException#X%3A%3AIO%3A%3AMkdir" class="podlinkpod"
>X::IO::Mkdir</a> if it can not create the directory, if file or directory already exists or if the parent directory of the path does not exist.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="OS_Specific_subclasses."
>OS Specific subclasses.</a></h3>

<p>IO::Path::Unix, IO::Path::Win32, and IO::Path::Cygwin subclasses are available for manipulating paths from different operating systems than the one you&#39;re currently using. Unix works with any POSIX-like operating system, such as Linux or Darwin. Win32 works for paths from Windows, DOS, OS/2, NetWare, and Symbian.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Spec"
>IO::Spec</a></h2>

<p>This class is a collection of methods dealing with file specifications (commonly known as file names, though it can include the entire directory path). Most of the methods are less convenient than in IO::Path, but it allows access to lower-level operations on file path strings.</p>

<p>As with IO::Path, these operations are significantly different on some operating systems, so we have the following subclasses: IO::Spec::Unix, IO::Spec::Win32, and IO::Spec::Cygwin. IO::Spec automatically loads the correct module for use on the current system.</p>

<p>Each class can (and should) be used in its undefined form:</p>

<pre><code>my $cleanpath = IO::Spec.canonpath(&#34;a/.//b/&#34;)  # gives &#34;a/b&#34;</code></pre>

<p>Although we inherit a lot from Perl 5&#39;s File::Spec, some things have changed: <code>no_updirs</code> has been removed (but see <code>no-parent-or-current-test</code>) and <code>case_tolerant</code> has also been removed (and put in a module). Method <code>join</code> is no longer an alias for catfile, but is now a function similar to <code>catpath</code>.</p>

<p>Each of the following methods are available under the subclasses, with the exception of <code>os</code>.</p>

<dl>
<dt><a name="os"
>os</a></dt>

<dd>
<p>The os method takes a single argument, an operating system string, and returns an IO::Spec object for the appropriate OS.</p>

<pre><code>my $mac_os_x_spec = File::Spec.os(&#39;darwin&#39;);
# returns a File::Spec::Unix object
my $windows_spec = File::Spec.os(&#39;MSWin32&#39;);
#returns File::Spec::Win32
say File::Spec.os(&#39;Win32&#39;).canonpath(&#39;C:\\foo\\.\\bar\\&#39;);
# prints &#34;C:\foo\bar&#34;</code></pre>

<p>The parameter can be either an operating system string, or the last part of the name of a subclass (&#39;Win32&#39;, &#39;Mac&#39;). The default is `$*OS`, which gives you the same subclass that IO::Spec already uses for your system.</p>

<p>This is only implemented by the IO::Spec class, and not its subclasses.</p>

<dt><a name="canonpath"
>canonpath <!--
	INDEX: canonpath
--></a></dt>

<dd>
<p>No physical check on the filesystem, but a logical cleanup of a path.</p>

<pre><code>$cpath = IO::Spec.canonpath( $path ) ;</code></pre>

<p>Note that this does *not* collapse <em>x/../y</em> sections into <em>y</em>. This is by design. If <em>/foo</em> on your system is a symlink to <em>/bar/baz</em>, then <em>/foo/../quux</em> is actually <em>/bar/quux</em>, not <em>/quux</em> as a naive <em>../</em>-removal would give you. If you want to do this kind of processing, you probably want IO::Path&#39;s <code>resolve</code> method to actually traverse the filesystem cleaning up paths like this.</p>

<dt><a name="is-absolute"
>is-absolute</a></dt>

<dd>
<p>Takes as its argument a path, and returns True if it is an absolute path, False otherwise. For File::Spec::Win32, it returns 1 if it&#39;s an absolute path with no volume, and 2 if it&#39;s absolute with a volume.</p>

<pre><code>$is_absolute = IO::Spec.is-absolute( $path );</code></pre>

<dt><a name="splitpath"
>splitpath <!--
	INDEX: splitpath
--></a></dt>

<dd>
<pre><code>method splitpath( $path, $nofile = False )</code></pre>

<p>Splits a path in to volume, directory, and filename portions. On systems with no concept of volume, returns &#39;&#39; for volume.</p>

<pre><code>my ($volume,$directories,$file) = IO::Spec.splitpath( $path );
my ($volume,$directories,$file) = IO::Spec.splitpath( $path, $no_file );</code></pre>

<p>For systems with no syntax differentiating filenames from directories, assumes that the last file is a path unless <code>$no_file</code> is true or a trailing separator or <em>/.</em> or <em>/..</em> is present. On Unix, this means that <code>$no_file</code> true makes this return ( &#39;&#39;, $path, &#39;&#39; ).</p>

<p>The directory portion may or may not be returned with a trailing &#39;/&#39;.</p>

<p>The results can be passed to <a href="#catpath()" class="podlinkpod"
>&#34;catpath()&#34;</a> to get back a path equivalent to (usually identical to) the original path.</p>

<dt><a name="split"
>split</a></dt>

<dd>
<p>A close relative of `splitdir`, this function also splits a path into volume, directory, and filename portions. Unlike splitdir, split returns paths compatible with dirname and basename <i>and</i> returns it arguments as a hash of <code>volume</code>, <code>directory</code>, and <code>basename</code>.</p>

<p>This means that trailing slashes will be eliminated from the directory and basename components, in Win32 and Unix-like environments. The basename component will always contain the last part of the path, even if it is a directory, <code>&#39;.&#39;</code>, or <code>&#39;..&#39;</code>. If a relative path&#39;s directory portion would otherwise be empty, the directory is set to <code>&#39;.&#39;</code> (or whatever <code>curdir</code> is).</p>

<p>On systems with no concept of volume, returns <code>&#39;&#39;</code> (the empty string) for volume.</p>

<pre><code>my %splitfile = IO::Spec.split( $path );
say IO::Spec::Win32( &#34;C:\\saga\\waffo\\&#34; );
    # (&#34;volume&#34; =&#62; &#34;C:&#34;, &#34;directory&#34; =&#62; &#34;\\saga&#34;, &#34;basename&#34; =&#62; &#34;waffo&#34;)</code></pre>

<p>The results can be passed to `.join` to get back a path equivalent to (but not necessarily identical to) the original path. If you want to keep all of the characters involved, use `.splitdir` instead.</p>

<dt><a name="Comparison_of_splitpath_and_split"
>Comparison of splitpath and split</a></dt>

<dd>
<pre><code>OS      Path       splitpath               split (.values)
linux   /a/b/c     (&#34;&#34;, &#34;/a/b/&#34;, &#34;c&#34;)      (&#34;&#34;, &#34;/a/b&#34;, &#34;c&#34;)
linux   /a/b//c/   (&#34;&#34;, &#34;/a/b//c/&#34;, &#34;&#34;)    (&#34;&#34;, &#34;/a/b&#34;, &#34;c&#34;)
linux   /a/b/.     (&#34;&#34;, &#34;/a/b/.&#34;, &#34;&#34;)      (&#34;&#34;, &#34;/a/b&#34;, &#34;.&#34;)
Win32   C:\a\b\    (&#34;C:&#34;, &#34;\\a\\b\\&#34;, &#34;&#34;)  (&#34;C:&#34;, &#34;\\a&#34;, &#34;b&#34;)
VMS     A:[b.c]    (&#34;A:&#34;, &#34;[b.c]&#34;, &#34;&#34;)     (&#34;A:&#34;, &#34;[b]&#34;, &#34;[c]&#34;)</code></pre>

<p>* The VMS section is still speculative, and not yet supported.</p>

<dt><a name="catpath()"
>catpath()</a></dt>

<dd>
<p>Takes volume, directory and file portions and returns an entire path string. Under Unix, <code>$volume</code> is ignored, and directory and file are concatenated. On other OSes, <code>$volume</code> is significant. Directory separators like slashes are inserted if need be.</p>

<pre><code>$full_path = IO::Spec.catpath( $volume, $directory, $file );</code></pre>

<dt><a name="join"
>join</a></dt>

<dd>
<p>A close relative of `.catpath`, this function takes volume, directory and basename portions and returns an entire path string. If the dirname is `&#39;.&#39;`, it is removed from the (relative) path output, because this function inverts the functionality of dirname and basename.</p>

<pre><code>$full-path = IO::Spec.join(:$volume, :$directory, :$basename);
say IO::Spec::Unix.join( directory =&#62; &#39;/hobbit&#39;, basename =&#62; &#39;frodo&#39; );
    # &#34;/hobbit/frodo&#34;</code></pre>

<p>Directory separators are inserted if necessary. Under Unix, $volume is ignored, and only directory and basename are concatenated. On other OSes, $volume is significant.</p>

<p>This method is the inverse of `.split`; the results can be passed to it to get the volume, dirname, and basename portions back.</p>

<dt><a name="Comparison_of_catpath_and_join"
>Comparison of catpath and join</a></dt>

<dd>
<pre><code>OS     Components            catpath        join
linux  (&#34;&#34;, &#34;/a/b&#34;, &#34;c&#34;)     /a/b/c         /a/b/c
linux  (&#34;&#34;, &#34;.&#34;, &#34;foo&#34;)      ./foo          foo
linux  (&#34;&#34;, &#34;/&#34;, &#34;/&#34;)        //             /
Win32  (&#34;C:&#34;, &#34;\a&#34;, &#34;b&#34;)     C:\a\b         C:\a\b
VMS    (&#34;A:&#34;, &#34;[b]&#34;, &#34;[c]&#34;)  A:[b][c]       A:[b.c]</code></pre>

<p>* The VMS section is still speculative, and not yet supported.</p>

<dt><a name="splitdir"
>splitdir <!--
	INDEX: splitdir
--></a></dt>

<dd>
<p>The opposite of <a href="#catdir" class="podlinkpod"
>&#34;catdir&#34;</a>.</p>

<pre><code>@dirs = IO::Spec.splitdir( $directories );</code></pre>

<p><code>$directories</code> must be only the directory portion of the path on systems that have the concept of a volume or that have path syntax that differentiates files from directories.</p>

<p>Unlike just splitting the directories on the separator, empty directory names (<code>&#39;&#39;</code>) can be returned, because these are significant on some OSes.</p>

<dt><a name="catdir"
>catdir <!--
	INDEX: catdir
--></a></dt>

<dd>
<p>Concatenate two or more directory names to form a complete path ending with a directory. Removes any trailing slashes from the resulting string, unless it&#39;s the root directory.</p>

<pre><code>$path = IO::Spec.catdir( @directories );</code></pre>

<dt><a name="catfile"
>catfile <!--
	INDEX: catfile
--></a></dt>

<dd>
<p>Concatenate one or more directory names and a filename to form a complete path ending with a filename</p>

<pre><code>$path = IO::Spec.catfile( @directories, $filename );</code></pre>

<dt><a name="abs2rel"
>abs2rel <!--
	INDEX: abs2rel
--></a></dt>

<dd>
<p>Takes a destination path and an optional base path returns a relative path from the base path to the destination path:</p>

<pre><code>$rel_path = IO::Spec.abs2rel( $path ) ;
$rel_path = IO::Spec.abs2rel( $path, $base ) ;</code></pre>

<p>If <code>$base</code> is not present or &#39;&#39;, then <code>$*CWD</code> is used. If <code>$base</code> is relative, then it is converted to absolute form using <a href="#IO%3A%3ASpec%2Frel2abs" class="podlinkpod"
>&#34;IO::Spec/rel2abs&#34;</a>. This means that it is taken to be relative to <code>$*CWD</code>.</p>

<p>On systems with the concept of volume, if <code>$path</code> and <code>$base</code> appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return <code>$path</code>.</p>

<p>On systems that have a grammar that indicates filenames, this ignores the <code>$base</code> filename as well. Otherwise all path components are assumed to be directories.</p>

<p>If <code>$path</code> is relative, it is converted to absolute form using <a href="#IO%3A%3ASpec%2Frel2abs" class="podlinkpod"
>&#34;IO::Spec/rel2abs&#34;</a>. This means that it is taken to be relative to <code>$*CWD</code>.</p>

<p>No checks against the filesystem are made.</p>

<dt><a name="rel2abs"
>rel2abs <!--
	INDEX: rel2abs
--></a></dt>

<dd>
<p>Converts a relative path to an absolute path.</p>

<pre><code>$abs_path = IO::Spec.rel2abs( $path ) ;
$abs_path = IO::Spec.rel2abs( $path, $base ) ;</code></pre>

<p>If <code>$base</code> is not present or &#39;&#39;, then <code>$*CWD</code> is used. If <code>$base</code> is also relative, then it is first converted to absolute form, relative to <code>$*CWD</code>.</p>

<p>On systems with the concept of volume, if <code>$path</code> and <code>$base</code> appear to be on two different volumes, IO::Spec will not attempt to resolve the two paths, and will instead simply return <code>$path</code>.</p>

<p>On systems that have a grammar that indicates filenames (like VMS), this ignores the <code>$base</code> filename as well. Otherwise all path components are assumed to be directories.</p>

<p>If <code>$path</code> is absolute, it is cleaned up and returned using <a href="#canonpath" class="podlinkpod"
>&#34;canonpath&#34;</a>.</p>

<p>No checks against the filesystem are made.</p>

<dt><a name="curdir"
>curdir <!--
	INDEX: curdir
--></a></dt>

<dd>
<p>Returns a string representation of the current directory (<code>.</code> on Linux and Windows).</p>

<pre><code>my $curdir = IO::Spec.curdir;</code></pre>

<dt><a name="updir"
>updir <!--
	INDEX: updir
--></a></dt>

<dd>
<p>Returns a string representation of the parent directory (<code>..</code> on Linux and Windows).</p>

<pre><code>my $updir = IO::Spec.updir;</code></pre>

<dt><a name="rootdir"
>rootdir <!--
	INDEX: rootdir
--></a></dt>

<dd>
<p>Returns a string representation of the root directory (<code>/</code> on Linux).</p>

<pre><code>my $rootdir = IO::Spec.rootdir;</code></pre>

<dt><a name="devnull"
>devnull <!--
	INDEX: devnull
--></a></dt>

<dd>
<p>Returns a string representation of the null device (<code>/dev/null</code> on Linux).</p>

<pre><code>my $devnull = IO::Spec.devnull;</code></pre>

<dt><a name="path"
>path <!--
	INDEX: path
--></a></dt>

<dd>
<p>Takes no argument. Returns the environment variable <code>PATH</code> (or the local platform&#39;s equivalent) as a list.</p>

<pre><code>my @PATH = IO::Spec.path;</code></pre>

<dt><a name="tmpdir"
>tmpdir <!--
	INDEX: tmpdir
--></a></dt>

<dd>
<p>Returns a string representation of the first writable directory from a list of possible temporary directories. Returns the current directory if no writable temporary directories are found. The list of directories checked depends on the platform; e.g. IO::Spec::Unix checks <code>%*ENV&#60;TMPDIR&#62;</code> and <em>/tmp</em>.</p>

<pre><code>$tmpdir = IO::Spec.tmpdir;</code></pre>

<dt><a name="no-parent-or-current-test"
>no-parent-or-current-test</a></dt>

<dd>
<p>Returns a test as to whether a given path is identical to the parent or the current directory. On Linux, this is simply <code>none(&#39;.&#39;, &#39;..&#39;)</code>. The <a href="#Functions%2Fdir" class="podlinkpod"
>&#34;Functions/dir&#34;</a> function automatically removes these for you in directory listings, so under normal circumstances you shouldn&#39;t need to use it directly.</p>

<pre><code>&#39;file&#39; ~~ IO::Spec.no-parent-or-current-test    #False
&#39;.&#39;    ~~ IO::Spec.no-parent-or-current-test    #True
&#39;..&#39;   ~~ IO::Spec.no-parent-or-current-test    #True</code></pre>

<p>This can, however, be used to extend <code>dir()</code> through its `$test` parameter:</p>

<pre><code>dir( &#34;my/directory&#34;, test=&#62;
  all(IO::Spec.no-parent-or-current-test, /^ &#39;.&#39; /));</code></pre>

<p>This example would return all files beginning with a period that are not `.` or `..` directories. This would work similarly with IO::Path.contents.</p>

<p>This method replaces the functionality of the Perl 5 <code>no_updirs</code> method.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Here_Be_Dragons"
>Here Be Dragons</a></h1>

<p>Everything below this point hasn&#39;t been reviewed properly</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Socket"
>IO::Socket</a></h2>

<pre><code>role IO::Socket {
    has %.options;
    has Bool $.Listener;
    ...
}</code></pre>

<p>Accessing the <code>%.options</code> would on Unix be done with <i>getsockopt(2)</i>/<i>setsockopt(2)</i>.</p>

<p>The $.Listener attribute indicates whether the socket will be a listening socket when opened, rather than indicating whether it is currently listening.</p>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code>method new(
    :$Listener, # initializes $.Listener
)</code></pre>

<p>The initial value of the $.Listener attribute is defined according to the following rules:</p>

<pre><code> * If $Listener is passed to .new(), then that value is used
 * If neither a local address nor a remote address are passed in, throw an exception
 * If no remote address is passed, then $.Listener is set to SOMAXCONN
 * If no local address is used, then $Listener is set to 0
 * If both local and remote addresses are used, throw an exception that asks people to
   specify $Listener</code></pre>

<dt><a name="open"
>open</a></dt>

<dd>
<pre><code>method open()</code></pre>

<p>If $.Listener is true, does a <i>bind(2)</i> and a <i>listen(2)</i>, otherwise does a <i>connect(2)</i>.</p>

<p>It&#39;s end-user use case is intended for the case where NoOpen is passed to .new(). .new() itself will presumably also call it.</p>

<dt><a name="close"
>close</a></dt>

<dd>
<pre><code>method close()</code></pre>

<p>Implements the close() function from IO::Closeable by doing a shutdown on the connection (see below) with @how set to (&#39;Readable&#39;, &#39;Writeable&#39;).</p>

<dt><a name="shutdown"
>shutdown</a></dt>

<dd>
<pre><code>method shutdown(Str @how)</code></pre>

<p>Does a <i>shutdown(2)</i> on the connection. See also IO::Readable.isReadable and IO::Writeable.isWriteable.</p>

<p>$how can contain 1 or more of the strings &#39;Readable&#39; and &#39;Writeable&#39;.</p>

<dt><a name="accept"
>accept</a></dt>

<dd>
<pre><code>method accept( --&#62; IO::Socket)</code></pre>

<dt><a name="method_read(Int_$bytes_--&#62;_Buf)"
>method read(Int $bytes --&#62; Buf)</a></dt>

<dd>
<p>Reads and returns <code>$bytes</code> bytes from the handle</p>

<dt><a name="method_write(Buf_$buf_--&#62;_Int)"
>method write(Buf $buf --&#62; Int)</a></dt>

<dd>
<p>Implements the IO::Writeable interface by doing a <i>send(2)</i>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Socket::INET"
>IO::Socket::INET</a></h2>

<pre><code>class IO::Socket::INET does IO::Socket {
    has Str $.proto = &#39;TCP&#39;;
    has Str $.host;
    has Int $.port;
    has Str $.localhost;
    has Int $.localport;
    ...
}</code></pre>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code>multi method new(:$host!, :$port, *%attributes) { ... }
multi method new(:$localhost!, :$localport, :$listen! *%attributes) { ... }</code></pre>

<p>Creates a new socket and opens it.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Handle_(opened_version)"
>IO::Handle (opened version)</a></h2>

<p>This role indicates that this object actually represents an open file descriptor in the os level.</p>

<dl>
<dt><a name="method_int_fileno()"
>method int fileno()</a></dt>

<dd>
<p>File descriptors are always native integers, conforming to C89.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Conjectural_Stuff"
>Conjectural Stuff</a></h1>

<p>Everything below this point should be considered as mere ideas for future evolution, not as things that a compiler write should implement unquestioningly.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::ACL"
>IO::ACL</a></h2>

<p>This is a basic abstraction; for better control, use the operating-system specific interfaces, over which this is a thin veneer.</p>

<pre><code>class IO::ACL {
    has Str $.type; # &#34;User&#34;, &#34;Group&#34;, &#34;Everyone&#34;, ???
    has Str $.id; # username or groupname; unused for $type eq &#34;Everyone&#34;
    has %.permissions;
            # Unsupported values may (or may not) throw
            # UnsupportedPermission when set or read
    has Path $.owningObject;
    ...
}</code></pre>

<p>The permissions used in <code>%permissions</code> are:</p>

<dl>
<dt><a name="Readable"
>Readable</a></dt>

<dd>
<p>Should be supported by all filesystems as an item to read from the hash for the group &#34;Everyone&#34;.</p>

<dt><a name="Writeable"
>Writeable</a></dt>

<dd>
<p>Should be supported by all filesystems as an item to read from the hash for the group &#34;Everyone&#34;.</p>

<dt><a name="Executable"
>Executable</a></dt>

<dd>
<p>Supported on most Unix systems, anyway. Windows should be able to guess when this is read, and throw an exception if written to.</p>

<dt><a name="Default"
>Default</a></dt>

<dd>
<p>An ACL of User,fred,Default sets the user &#34;fred&#34; to be the owner of the file. This can be done with groups too. Works on Unix, at least.</p>
</dd>
</dl>

<p>The <code>$.owningObject</code> attribute of <code>ACL</code> shows what the ACL is set on. On a Windows system, this can be a parent directory, as permissions are inherited.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Pipe"
>IO::Pipe</a></h2>

<pre><code>class IO::Pipe does IO::Streamable does IO::Readable does IO::Writable {
    ...
}</code></pre>

<p>Will need to set IO::Readable.isReadable and IO::Writable.isWriteable depending on opening method.</p>

<dl>
<dt><a name="close()"
>close()</a></dt>

<dd>
<p>If the file handle came from a piped open, <code>close</code> will additionally return <code>Failure</code> (aliased to <code>$!</code>) if one of the other system calls involved fails, or if the program exits with non-zero status. The exception object will contain any pertinent information. Closing a pipe also waits for the process executing on the pipe to complete, in case you want to look at the output of the pipe afterwards, and implicitly puts the exit status value into the <code>Failure</code> object if necessary.</p>

<dt><a name="IO::Pipe.to"
>IO::Pipe.to</a></dt>

<dd>
<pre><code>method to(Str $command, *%opts --&#62; Bool)
method to(Str *@command, *%opts --&#62; Bool)</code></pre>

<p>Opens a one-way pipe writing to <code>$command</code>. <code>IO</code> redirection for stderr is specified with <code>:err(IO)</code> or <code>:err&#60;Str&#62;</code>. Other <code>IO</code> redirection is done with feed operators. XXX how to specify &#34;2&#62;&#38;1&#34;?</p>

<dt><a name="IO::Pipe.from"
>IO::Pipe.from</a></dt>

<dd>
<pre><code>method from(Str $command, *%opts --&#62; Bool)
method from(Str *@command, *%opts --&#62; Bool)</code></pre>

<p>Opens a one-way pipe reading from $command. <code>IO</code> redirection for stderr is specified with <code>:err(IO)</code> or <code>:err&#60;Str&#62;</code>. Other <code>IO</code> redirection is done with feed operators. XXX how to specify &#34;2&#62;&#38;1&#34;?</p>

<dt><a name="IO::Pipe.pair"
>IO::Pipe.pair</a></dt>

<dd>
<pre><code>method pair(--&#62; List of IO::Pipe)</code></pre>

<p>A wrapper for <i>pipe(2)</i>, returns a pair of <code>IO</code> objects representing the reader and writer ends of the pipe.</p>

<pre><code>   ($r, $w) = IO::Pipe.pair;</code></pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="OS-specific_classes"
>OS-specific classes</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Unix"
>Unix</a></h3>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Path::Unix"
>Path::Unix</a></h3>

<dl>
<dt><a name="chown"
>chown</a></dt>

<dd>
<pre><code>multi chown ($uid = -1, $gid = -1, *@files --&#62; Int)</code></pre>

<p>Changes the owner (and group) of a list of files. The first two elements of the list must be the numeric uid and gid, in that order. A value of -1 in either position is interpreted by most systems to leave that value unchanged. Returns the number of files successfully changed.</p>

<pre><code>$count = chown $uid, $gid, &#39;foo&#39;, &#39;bar&#39;;
chown $uid, $gid, @filenames;</code></pre>

<p>On systems that support <code>fchown</code>, you might pass file handles among the files. On systems that don&#39;t support <code>fchown</code>, passing file handles produces a fatal error at run time.</p>

<p>Here&#39;s an example that looks up nonnumeric uids in the passwd file:</p>

<pre><code>   $user = prompt &#34;User: &#34;;
   $pattern = prompt &#34;Files: &#34;;

   ($login,$pass,$uid,$gid) = getpwnam($user)
   or die &#34;$user not in passwd file&#34;;

   @ary = glob($pattern);      # expand filenames
   chown $uid, $gid, @ary;</code></pre>

<p>On most systems, you are not allowed to change the ownership of the file unless you&#39;re the superuser, although you should be able to change the group to any of your secondary groups. On insecure systems, these restrictions may be relaxed, but this is not a portable assumption. On POSIX systems, you can detect this condition this way:</p>

<pre><code>use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);
$can-chown-giveaway = not sysconf(_PC_CHOWN_RESTRICTED);</code></pre>

<dt><a name="chmod_LIST"
>chmod LIST <!--
	INDEX: chmod
--> <!--
	INDEX: permission
--> <!--
	INDEX: mode
--></a></dt>

<dd>
<p>Changes the permissions of a list of files. The first element of the list must be the numerical mode, which should probably be an octal number, and which definitely should <i>not</i> be a string of octal digits: <code>0o644</code> is okay, <code>0644</code> is not. Returns the number of files successfully changed.</p>

<pre><code>$count = chmod 0o755, &#39;foo&#39;, &#39;bar&#39;;
chmod 0o755, @executables;
$mode = &#39;0644&#39;; chmod $mode, &#39;foo&#39;;      # !!! sets mode to --w----r-T
$mode = &#39;0o644&#39;; chmod $mode, &#39;foo&#39;;     # this is better
$mode = 0o644;   chmod $mode, &#39;foo&#39;;     # this is best</code></pre>

<dt><a name="stat"
>stat</a></dt>

<dd>
<dt><a name="IO.stat"
>IO.stat</a></dt>

<dd>
<pre><code>$node.stat(Bool :$link); # :link does an lstat instead</code></pre>

<p>Returns a stat buffer. If the lstat succeeds, the stat buffer evaluates to true, and additional file tests may be performed on the value. If the stat fails, all subsequent tests on the stat buffer also evaluate to false.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="IO::Socket::Unix"
>IO::Socket::Unix</a></h3>

<pre><code>role IO::Socket::Unix does IO::Socket {
    has Str $.RemoteAddr, # Remote Address
    has Str $.LocalAddr,  # Local Address
}</code></pre>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code>method new(
    Str  :$RemoteAddr,
    Str  :$LocalAddr,

    Bool :$Listener,   # Passed to IO::Socket.new()

    Bool :$Blocking,   # Passed to IO::Streamable.new()
    Bool :$NoOpen,     # Passed to IO::Streamable.new()

    --&#62; IO::Socket::Unix
) {...}</code></pre>

<dt><a name="pair"
>pair</a></dt>

<dd>
<pre><code>method pair(Int $domain, Int $type, Int $protocol --&#62; List of IO)</code></pre>

<p>A wrapper for <i>socketpair(2)</i>, returns a pair of <code>IO</code> objects representing the reader and writer ends of the socket.</p>

<pre><code>   use IO::Socket;
   ($r, $w) = IO::Socket::Unix.pair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);</code></pre>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="IO::POSIX"
>IO::POSIX</a></h3>

<p>Indicates that this object can perform standard posix <code>IO</code> operations. It implies <code>IO::Readable</code> and <code>IO::Writeable</code>.</p>

<dl>
<dt><a name="method_dup(_--&#62;_IO)"
>method dup( --&#62; IO)</a></dt>

<dd>
<dt><a name="has_Bool_$.blocking_is_rw"
>has Bool $.blocking is rw</a></dt>

<dd>
<dt><a name="method_flock(:$r,:$w_--&#62;_Bool)"
>method flock(:$r,:$w --&#62; Bool)</a></dt>

<dd>
<dt><a name="method_funlock(_--&#62;_Bool)"
>method funlock( --&#62; Bool)</a></dt>

<dd>
<dt><a name="..."
>...</a></dt>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Unfilled"
>Unfilled</a></h1>

<dl>
<dt><a name="IO.ioctl"
>IO.ioctl</a></dt>

<dd>
<p>Available only as a handle method.</p>

<dt><a name="alarm"
>alarm</a></dt>

<dd>
<dt><a name="prompt"
>prompt</a></dt>

<dd>
<pre><code>multi prompt (Str $prompt --&#62; Str)</code></pre>

<p>Should there be an IO::Interactive role?</p>

<dt><a name="Str.readpipe"
>Str.readpipe</a></dt>

<dd>
<dt><a name="sysopen"
>sysopen</a></dt>

<dd>
<dt><a name="IO.sysseek"
>IO.sysseek</a></dt>

<dd>
<dt><a name="umask"
>umask</a></dt>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Removed_functions"
>Removed functions</a></h1>

<dl>
<dt><a name="IO.eof"
>IO.eof</a></dt>

<dd>
<p>Gone, see eoi <code>IO::Seekable</code>.</p>

<dt><a name="IO.fileno"
>IO.fileno</a></dt>

<dd>
<p>See <code>IO::Handle</code>.</p>

<dt><a name="/(get|set)(host|net|proto|serv|sock).*/"
>/(get|set)(host|net|proto|serv|sock).*/</a></dt>

<dd>
<p>Should be implemented by an external library.</p>

<dt><a name="lstat"
>lstat</a></dt>

<dd>
<p>Use <code>stat</code> with the <code>:link</code> option.</p>

<dt><a name="IO.name"
>IO.name</a></dt>

<dd>
<p>Changed to <code>.path</code>, but we haven&#39;t gotten around to specifying this on all of them.</p>

<p>The <code>.name</code> method returns the name of the file/socket/uri the handle was opened with, if known. Returns Nil otherwise. There is no corresponding <code>name()</code> function.</p>

<dt><a name="pipe"
>pipe</a></dt>

<dd>
<p>Gone, see Pipe.pair</p>

<dt><a name="select(both)"
>select(both)</a></dt>

<dd>
<p>Gone. (Note: for sub-second sleep, just use sleep with a fractional argument.)</p>

<dt><a name="IO.shutdown()"
>IO.shutdown()</a></dt>

<dd>
<p>Gone, see <code>IO::Socket.close()</code>, <code>$IO::Readable.isReadable</code>, and <code>$IO::Writeable.isWriteable</code></p>

<dt><a name="socketpair"
>socketpair</a></dt>

<dd>
<p>Gone, see Socket.pair</p>

<dt><a name="IO.sysread"
>IO.sysread</a></dt>

<dd>
<p>Gone, see <code>IO::Readable.read()</code>.</p>

<dt><a name="IO.syswrite"
>IO.syswrite</a></dt>

<dd>
<p>Gone, see <code>IO::Writeable.read()</code>.</p>

<dt><a name="utime"
>utime</a></dt>

<dd>
<p>Gone, see <code>Path.times</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Buffered"
>IO::Buffered</a></h2>

<p>Indicates that this object performs buffering. The management of the buffer is completely implementation specific.</p>

<dl>
<dt><a name="method_flush(_--&#62;_Bool)"
>method flush( --&#62; Bool)</a></dt>

<dd>
<p>Flushes the buffers associated with this object.</p>

<dt><a name="method_autoflush(_--&#62;_Bool)_is_rw"
>method autoflush( --&#62; Bool) is rw</a></dt>

<dd>
<p>Forces this object to keep its buffers empty</p>

<p>If set to nonzero, forces a flush right away and after every write or print on the currently selected output channel. Default is 0 (regardless of whether the channel is really buffered by the system or not; <code>$OUT_FH.autoflush</code> tells you only whether you&#39;ve asked Perl explicitly to flush after each write). <code>$*OUT</code> will typically be line buffered if output is to the terminal and block buffered otherwise. Setting this variable is useful primarily when you are outputting to a pipe or socket, such as when you are running a Perl program under rsh and want to see the output as it&#39;s happening. This has no effect on input buffering.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Streamable"
>IO::Streamable</a></h2>

<p>This role represents objects that depend on some external resource, which means that data might not be available at request.</p>

<pre><code>role IO::Streamable does IO {...}</code></pre>

<dl>
<dt><a name="new()"
>new()</a></dt>

<dd>
<pre><code>method new(
    Bool :$NoOpen,
    Bool :$Blocking,
    --&#62; IO::Streamable
) {...}</code></pre>

<p>Unless the NoOpen option is passed, an open will be done on the <code>IO</code> object when it is created.</p>

<p>If blocking is passed in, .blocking() is called (see below).</p>

<dt><a name="method_blocking(_--&#62;_Bool)_is_rw"
>method blocking( --&#62; Bool) is rw</a></dt>

<dd>
<p>This allows the user to control whether this object should do a blocking wait or immediately return in the case of not having data available.</p>

<dt><a name="uri"
>uri</a></dt>

<dd>
<pre><code>method uri(Str $uri --&#62; IO::Streamable) {...}</code></pre>

<p>This should be callable on the class, and act like a kind of &#34;new()&#34; function. When given a URI, it returns an <code>IO::Streamable</code> of the appropriate type, and throws an error when an inappropriate type is passed in. For example, calling <code>IO::File.uri(&#39;http://....&#39;)</code> will throw an error (but will suggest using just uri(&#39;http://...&#39;) instead).</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Encoded"
>IO::Encoded</a></h2>

<p>This is a generic role for encoded data streams.</p>

<dl>
<dt><a name="method_encoding(_--&#62;_Str)_is_rw"
>method encoding( --&#62; Str) is rw</a></dt>

<dd>
<dt><a name="method_locale(_--&#62;_Str)_is_rw"
>method locale( --&#62; Str) is rw</a></dt>

<dd>
<p>Encoding and locale are required for sane conversions.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Readable::Encoded"
>IO::Readable::Encoded</a></h2>

<p>This role provides encoded access to a readable data stream, implies <code>IO::Encoded</code>. Might imply <code>IO::Buffered</code>, but that&#39;s not a requirement.</p>

<dl>
<dt><a name="uri"
>uri <!--
	INDEX: uri
--><!--
	INDEX: ftp
--><!--
	INDEX: http
--></a></dt>

<dd>
<pre><code>method uri(Str $uri --&#62; IO::Streamable);
sub uri(Str $uri --&#62; IO::Streamable);</code></pre>

<p>Returns an appropriate <code>IO::Streamable</code> descendant, with the type depending on the uri passed in. Here are some example mappings:</p>

<pre><code>URI type IO type
======== =======
file:    IO::Path
ftp:     IO::Socket::INET (data channel)
http:    IO::Socket::INET</code></pre>

<p>These can naturally be overridden or added to by other modules.</p>

<dt><a name="%*PROTOCOLS_dynamic_variable"
>%*PROTOCOLS dynamic variable</a></dt>

<dd>
<p>For each protocol, stores a type name that should be instantiated by calling the <code>uri</code> constructor on that type, and passing in the appropriate uri.</p>
</dd>
</dl>

<!-- end doc -->

</body></html>
