<!DOCTYPE html>
<html lang="ja">
<head>
<title>IO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Sep 27 10:05:35 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Functions'>Functions</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#print()'>print() </a>
    <li class='indexItem indexItem2'><a href='#say()'>say() </a>
    <li class='indexItem indexItem2'><a href='#note()'>note() </a>
    <li class='indexItem indexItem2'><a href='#dd()'>dd() </a>
    <li class='indexItem indexItem2'><a href='#prompt()'>prompt() </a>
    <li class='indexItem indexItem2'><a href='#open()'>open() </a>
    <li class='indexItem indexItem2'><a href='#dir()'>dir() </a>
    <li class='indexItem indexItem2'><a href='#slurp()'>slurp() </a>
    <li class='indexItem indexItem2'><a href='#spurt()'>spurt() </a>
    <li class='indexItem indexItem2'><a href='#mkdir()'>mkdir() </a>
    <li class='indexItem indexItem2'><a href='#rmdir()'>rmdir() </a>
    <li class='indexItem indexItem2'><a href='#chdir()'>chdir() </a>
    <li class='indexItem indexItem2'><a href='#copy()'>copy() </a>
    <li class='indexItem indexItem2'><a href='#rename()'>rename() </a>
    <li class='indexItem indexItem2'><a href='#move()'>move() </a>
    <li class='indexItem indexItem2'><a href='#unlink()'>unlink() </a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#chmod()'>chmod() </a>
    </ul>
    <li class='indexItem indexItem2'><a href='#link()'>link() </a>
    <li class='indexItem indexItem2'><a href='#symlink()'>symlink() </a>
  </ul>
  <li class='indexItem indexItem1'><a href='#IO_Types'>IO Types</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#IO'>IO</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3ASpec'>IO::Spec</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#.select'>.select </a>
    </ul>
    <li class='indexItem indexItem2'><a href='#IO%3A%3ASpec_subclasses'>IO::Spec subclasses</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#.abs2rel'>.abs2rel </a>
      <li class='indexItem indexItem3'><a href='#.canonpath'>.canonpath </a>
      <li class='indexItem indexItem3'><a href='#.catdir'>.catdir </a>
      <li class='indexItem indexItem3'><a href='#.catpath'>.catpath </a>
      <li class='indexItem indexItem3'><a href='#.curdir'>.curdir </a>
      <li class='indexItem indexItem3'><a href='#curupdir'>curupdir</a>
      <li class='indexItem indexItem3'><a href='#.devnull'>.devnull </a>
      <li class='indexItem indexItem3'><a href='#.extension'>.extension </a>
      <li class='indexItem indexItem3'><a href='#.is-absolute'>.is-absolute </a>
      <li class='indexItem indexItem3'><a href='#.join'>.join </a>
      <li class='indexItem indexItem3'><a href='#.PATH'>.PATH </a>
      <li class='indexItem indexItem3'><a href='#.rel2abs'>.rel2abs </a>
      <li class='indexItem indexItem3'><a href='#.rootdir'>.rootdir </a>
      <li class='indexItem indexItem3'><a href='#.split'>.split </a>
      <li class='indexItem indexItem3'><a href='#.splitdir'>.splitdir </a>
      <li class='indexItem indexItem3'><a href='#.splitpath'>.splitpath </a>
      <li class='indexItem indexItem3'><a href='#.tmpdir'>.tmpdir </a>
      <li class='indexItem indexItem3'><a href='#.updir'>.updir </a>
      <li class='indexItem indexItem3'><a href='#Comparison_of_.splitpath_and_.split'>Comparison of .splitpath and .split</a>
      <li class='indexItem indexItem3'><a href='#Comparison_of_.catpath_and_.join'>Comparison of .catpath and .join</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#IO%3A%3APath'>IO::Path</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#File_test_methods'>File test methods</a>
      <li class='indexItem indexItem3'><a href='#.absolute'>.absolute </a>
      <li class='indexItem indexItem3'><a href='#.accessed'>.accessed </a>
      <li class='indexItem indexItem3'><a href='#.basename'>.basename </a>
      <li class='indexItem indexItem3'><a href='#.changed'>.changed </a>
      <li class='indexItem indexItem3'><a href='#.chdir'>.chdir </a>
      <li class='indexItem indexItem3'><a href='#.child'>.child </a>
      <li class='indexItem indexItem3'><a href='#.chmod'>.chmod </a>
      <li class='indexItem indexItem3'><a href='#.copy'>.copy </a>
      <li class='indexItem indexItem3'><a href='#.dir'>.dir </a>
      <li class='indexItem indexItem3'><a href='#.directory'>.directory </a>
      <li class='indexItem indexItem3'><a href='#.extension'>.extension </a>
      <li class='indexItem indexItem3'><a href='#.IO'>.IO </a>
      <li class='indexItem indexItem3'><a href='#.is-absolute'>.is-absolute </a>
      <li class='indexItem indexItem3'><a href='#.is-relative'>.is-relative </a>
      <li class='indexItem indexItem3'><a href='#.lines'>.lines </a>
      <li class='indexItem indexItem3'><a href='#.mkdir'>.mkdir </a>
      <li class='indexItem indexItem3'><a href='#.modified'>.modified </a>
      <li class='indexItem indexItem3'><a href='#.move'>.move </a>
      <li class='indexItem indexItem3'><a href='#.open'>.open </a>
      <li class='indexItem indexItem3'><a href='#.parent'>.parent </a>
      <li class='indexItem indexItem3'><a href='#.pred'>.pred </a>
      <li class='indexItem indexItem3'><a href='#.relative'>.relative </a>
      <li class='indexItem indexItem3'><a href='#.rename'>.rename </a>
      <li class='indexItem indexItem3'><a href='#.resolve'>.resolve </a>
      <li class='indexItem indexItem3'><a href='#.rmdir'>.rmdir</a>
      <li class='indexItem indexItem3'><a href='#.slurp'>.slurp </a>
      <li class='indexItem indexItem3'><a href='#.SPEC'>.SPEC </a>
      <li class='indexItem indexItem3'><a href='#.spurt'>.spurt </a>
      <li class='indexItem indexItem3'><a href='#.succ'>.succ </a>
      <li class='indexItem indexItem3'><a href='#.unlink'>.unlink</a>
      <li class='indexItem indexItem3'><a href='#.volume'>.volume </a>
      <li class='indexItem indexItem3'><a href='#.words'>.words </a>
    </ul>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AHandle'>IO::Handle</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Methods_handled_by_.path'>Methods handled by .path</a>
      <li class='indexItem indexItem3'><a href='#.close'>.close </a>
      <li class='indexItem indexItem3'><a href='#.encoding'>.encoding </a>
      <li class='indexItem indexItem3'><a href='#.eof'>.eof </a>
      <li class='indexItem indexItem3'><a href='#.fileno'>.fileno </a>
      <li class='indexItem indexItem3'><a href='#.flush'>.flush </a>
      <li class='indexItem indexItem3'><a href='#.get'>.get </a>
      <li class='indexItem indexItem3'><a href='#.getc'>.getc </a>
      <li class='indexItem indexItem3'><a href='#.ins'>.ins </a>
      <li class='indexItem indexItem3'><a href='#.opened'>.opened </a>
      <li class='indexItem indexItem3'><a href='#.p'>.p </a>
      <li class='indexItem indexItem3'><a href='#.print'>.print </a>
      <li class='indexItem indexItem3'><a href='#.read'>.read </a>
      <li class='indexItem indexItem3'><a href='#.say'>.say </a>
      <li class='indexItem indexItem3'><a href='#.seek'>.seek </a>
      <li class='indexItem indexItem3'><a href='#.t'>.t </a>
      <li class='indexItem indexItem3'><a href='#.tell'>.tell </a>
      <li class='indexItem indexItem3'><a href='#.write'>.write </a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#Here_Be_Dragons'>Here Be Dragons</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#IO%3A%3ASocket'>IO::Socket</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3ASocket%3A%3AINET'>IO::Socket::INET</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Conjectural_Stuff'>Conjectural Stuff</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AACL'>IO::ACL</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3APipe'>IO::Pipe</a>
    <li class='indexItem indexItem2'><a href='#OS-specific_classes'>OS-specific classes</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Unix'>Unix</a>
      <li class='indexItem indexItem3'><a href='#Path%3A%3AUnix'>Path::Unix</a>
      <li class='indexItem indexItem3'><a href='#IO%3A%3ASocket%3A%3AUnix'>IO::Socket::Unix</a>
      <li class='indexItem indexItem3'><a href='#IO%3A%3APOSIX'>IO::POSIX</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#Unfilled'>Unfilled</a>
  <li class='indexItem indexItem1'><a href='#Removed_functions'>Removed functions</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#IO%3A%3ABuffered'>IO::Buffered</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AStreamable'>IO::Streamable</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AEncoded'>IO::Encoded</a>
    <li class='indexItem indexItem2'><a href='#IO%3A%3AReadable%3A%3AEncoded'>IO::Readable::Encoded</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#POD_ERRORS'>POD ERRORS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 32: Setting Library - IO</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>The authors of the related Perl 5 docs
Rod Adams &#60;rod@rodadams.net&#62;
Larry Wall &#60;larry@wall.org&#62;
Aaron Sherman &#60;ajs@ajs.com&#62;
Mark Stosberg &#60;mark@summersault.com&#62;
Carl M&#228;sak &#60;cmasak@gmail.com&#62;
Moritz Lenz &#60;moritz@faui2k3.org&#62;
Tim Nelson &#60;wayland@wayland.id.au&#62;
Daniel Ruoso &#60;daniel@ruoso.com&#62;
Lyle Hopkins &#60;webmaster@cosmicperl.com&#62;
Brent Laabs &#60;bslaabs@gmail.com&#62;
Tobias Leich &#60;email@froggs.de&#62;
Elizabeth Mattijsen &#60;liz@dijkmat.nl&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 19 Feb 2009

Last Modified: 23 Sep 2014
Version: 24</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis describes in depth the subroutines and methods that were described broadly in S16. Please note that any implementation is free to use multi-method dispatch on both subroutines as well as methods should this increase the performance or maintainability.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Functions"
>Functions</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="print()"
>print() <!--
	INDEX: print()
--></a></h2>

<pre><code>sub print(*@text --&#62; Bool) is export</code></pre>

<p>Print the given text on $*OUT.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="say()"
>say() <!--
	INDEX: say()
--></a></h2>

<pre><code>sub say(*@text --&#62; Bool) is export</code></pre>

<p>Print the given text, followed by a new line <code>&#34;\n&#34;</code> on <code>$*OUT</code>. Before printing, call the <code>.gist</code> method on any non-<code>Str</code> objects.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="note()"
>note() <!--
	INDEX: note()
--></a></h2>

<pre><code>sub note(*@text --&#62; Bool) is export</code></pre>

<p>Print the given text, followed by a new line <code>&#34;\n&#34;</code> on <code>$*ERR</code>. Before printing, call the <code>.gist</code> method on any non-<code>Str</code> objects.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="dd()"
>dd() <!--
	INDEX: dd()
--></a></h2>

<pre><code>sub dd(@vars --&#62; Bool) is export</code></pre>

<p>Tiny Data Dumper. Takes the <code>variables</code> specified and <code>note</code>s them (on <code>$*ERR</code>) in an easy to read format, along with the <code>name</code> of the variable. So:</p>

<pre><code>  my $a = 42;
  dd($a);   # notes &#34;$a = 42&#34;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="prompt()"
>prompt() <!--
	INDEX: prompt()
--></a></h2>

<pre><code>sub prompt($msg --&#62; Bool) is export</code></pre>

<p>Simple Prompter. Print message on <code>$*OUT</code> and obtains a single line of input from <code>$*IN</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="open()"
>open() <!--
	INDEX: open()
--></a></h2>

<pre><code>sub open ($name as IO,
  # mode
    Bool :$r  = True,
    Bool :$w  = False,
    Bool :$rw = False,
    Bool :$a  = False,
  # encoding
    Bool :$bin = False,
    Str  :$enc = &#34;Unicode&#34;,  # utf-8 unless otherwise
  # newlines
    Any  :$nl    = &#34;EOL&#34;,
    Bool :$chomp = True,
    --&#62; IO::Handle ) is export</code></pre>

<p>A convenience function for opening normal files as text (by default) as specified by its (first) parameter. It returns an instantiated <a href="#IO%3A%3AHandle" class="podlinkpod"
>&#34;IO::Handle&#34;</a> object. The following named parameters may also be specified:</p>

<dl>
<dt><a name=":r"
>:r</a></dt>

<dd>
<p>Open file for reading. Default is <code>True</code>.</p>

<dt><a name=":w"
>:w</a></dt>

<dd>
<p>Open file for writing by creating an empty file with the given name. The original contents of an existing file with that name, will be <b>lost</b>. Default is <code>False</code>.</p>

<dt><a name=":rw"
>:rw</a></dt>

<dd>
<p>Open file for reading and writing with the given name. The original contents of an existing file with that name, will be <b>lost</b>. Default is <code>False</code>.</p>

<dt><a name=":a"
>:a</a></dt>

<dd>
<p>Open file for appending, create one if it didn&#39;t exist yet. This may or may not inhibit overwriting the original contents when moving the file pointer. Default is <code>False</code>.</p>

<dt><a name=":bin"
>:bin</a></dt>

<dd>
<p>Open file in binary mode (byte mode). A file opened with <code>:bin</code> may still be processed line-by-line, but IO will be in terms of <code>Buf</code> rather than <code>Str</code> types. Default is <code>False</code>, implying text semantics.</p>

<dt><a name=":enc"
>:enc</a></dt>

<dd>
<p>Encoding to use if opened in text mode. Defaults to &#34;Unicode&#34;, which implies figuring out which actual UTF is in use, either from a BOM or other heuristics. If heuristics are inconclusive, UTF-8 will be assumed. (No 8-bit encoding will ever be picked implicitly.)</p>

<dt><a name=":nl"
>:nl</a></dt>

<dd>
<p>The marker used to indicate the end of a line of text. Only used in text mode. Defaults to &#34;EOL&#34;, which implies accepting any combination of <code>&#34;\n&#34;</code>, <code>&#34;\r\n&#34;</code> or <code>&#34;\r&#34;</code> or any other Unicode character that has the <code>ZI</code> (Seperator, Line) property.</p>

<dt><a name=":chomp"
>:chomp</a></dt>

<dd>
<p>Whether or not to remove new line characters from text obtained with <code>.lines</code> and <code>.get</code>. Defaults to <code>True</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="dir()"
>dir() <!--
	INDEX: dir()
--></a></h2>

<pre><code>sub dir($directory as Str = $*CWD,
    Mu       :$test = $*SPEC.curupdir,
    Bool     :$absolute = False,
    IO::Path :$CWD = $*CWD,
    --&#62; List[Str] ) is export</code></pre>

<p>Returns a lazy list of (relative) path names in the <code>$directory</code> as strings, by default from the directory pointed to by <code>$*CWD</code>. If dir() fails, it returns an <a href="http://search.cpan.org/perldoc?S32%3A%3AException#X%3A%3AIO%3A%3ADir" class="podlinkpod"
>X::IO::Dir</a> failure. The following named parameters are optional:</p>

<dl>
<dt><a name=":test"
>:test</a></dt>

<dd>
<p>Expression against which to smart-match for inclusion in result list. By default excludes <code>curdir</code> (usually &#34;.&#34;) and <code>updir</code> (usually &#34;..&#34;) only.</p>

<dt><a name=":absolute"
>:absolute</a></dt>

<dd>
<p>Boolean indicating to return absolute path names, rather than relative ones. False by default.</p>

<dt><a name=":CWD"
>:CWD</a></dt>

<dd>
<p>Only important if <code>:absolute</code> is specified with a True value. The directory to pre-pend to the relative file paths. Defaults to <code>$*CWD</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="slurp()"
>slurp() <!--
	INDEX: slurp()
--></a></h2>

<pre><code>sub slurp ($what = $*ARGFILES,
    Bool :$bin = False,
    Str  :$enc = &#34;Unicode&#34;,
    --&#62; Str|Buf ) is export</code></pre>

<p>Slurps the contents of the entire file into a <code>Str</code> (or <code>Buf</code> if <code>:bin</code>). Accepts <code>:bin</code> and <code>:enc</code> optional named parameters, with the same meaning as <a href="#open()" class="podlinkpod"
>&#34;open()&#34;</a>. The routine will <code>fail</code> if the file does not exist, or is a directory.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="spurt()"
>spurt() <!--
	INDEX: spurt()
--></a></h2>

<pre><code>sub spurt ($where, $what,
    Str  :$enc        = $*ENC,
    Bool :append      = False,
    Bool :$createonly = False,
    --&#62; Bool ) is export</code></pre>

<p>Writes the indicated contents (2nd positional parameter) to the location indicated by the first positional parameter (which can either be a string, an <code>IO::Path</code> object, or an already opened <code>IO::Handle</code> object).</p>

<p>If a file needs to be opened for writing, it will also be <code>close</code>d. Returns True on success, or the appropriate <code>Failure</code> if something went wrong.</p>

<p>These named parameters are optional and only have meaning if the first positional parameter was <b>not</b> an <code>IO::Handle</code>:</p>

<dl>
<dt><a name=":enc"
>:enc</a></dt>

<dd>
<p>The encoding with which the contents will be written. [conjectural]</p>

<dt><a name=":append"
>:append</a></dt>

<dd>
<p>Boolean indicating whether to append to a (potentially) existing file. If the file did not exist yet, it will be created. Defaults to <code>False</code>.</p>

<dt><a name=":createonly"
>:createonly</a></dt>

<dd>
<p>Boolean indicating whether to fail if the file already exists. Defaults to <code>False</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mkdir()"
>mkdir() <!--
	INDEX: mkdir()
--></a></h2>

<pre><code>sub mkdir($dir as IO --&#62; Bool) is export</code></pre>

<p>Creates the directory as indicated by the positional parameter. Returns <code>True</code> on success or an appropriate <code>Failure</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rmdir()"
>rmdir() <!--
	INDEX: rmdir()
--></a></h2>

<pre><code>sub rmdir($dir as IO --&#62; Bool) is export</code></pre>

<p>Removes the (empty) directory as indicated by the positional parameter. Returns <code>True</code> on success or an appropriate <code>Failure</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="chdir()"
>chdir() <!--
	INDEX: chdir()
--></a></h2>

<pre><code>sub chdir($dir as IO, $CWD = $*CWD,
    :$test = &#60;d r&#62;
    --&#62; Bool) is export</code></pre>

<p>Changes the current working directory to the given directory, for the scope in which <code>$*CWD</code> is active (if no second positional parameter is given) or for the scope of the indicated localized <code>$*CWD</code>. A typical use case:</p>

<pre><code>  {
  chdir(&#34;foo&#34;, my $*CWD);
  # working directory changed to &#34;foo&#34;
  }
  # restored to what it was</code></pre>

<p>Returns <code>True</code> if succesful, or an appropriate <code>Failure</code>, e.g if the directory does not exist, or is not a directory, or is not readable.</p>

<p>Please note that this directory has <b>no</b> connection with whatever the operating system thinks is the current working directory. The value of <code>$*CWD</code> just will always be prepended to any relative paths in any file operation in Perl 6.</p>

<p>Also note that you can use <code>chdir</code> to set similar dynamic variables, like <code>$*TMPDIR</code> and <code>$*HOME</code> this way:</p>

<pre><code>  chdir(&#34;bar&#34;, my $*TMPDIR);   # set $*TMPDIR in this scope
  chdir(&#34;bar&#34;, my $*HOME);     # set $*HOME in this scope</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="copy()"
>copy() <!--
	INDEX: copy()
--></a></h2>

<pre><code>sub copy ($source as IO, $dest as IO,
    :$createonly = False,
    --&#62; Bool ) is export</code></pre>

<p>Copies a file, as indicate by the first positional paramater, to the destination specified. If :createonly is set to True, copy fails if a file already exists in the destination. Returns <code>True</code> upon success, or an appropriate <code>Failure</code> if the operation could not be completed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rename()"
>rename() <!--
	INDEX: rename()
--></a></h2>

<pre><code>sub rename ($source as IO, $dest as IO,
    :$createonly = False,
    --&#62; Bool ) is export</code></pre>

<p>Moves a file, as indicate by the first positional paramater, by renaming it to the destination specified. If :createonly is set to True, the rename fails if a file already exists in the destination. Returns <code>True</code> upon success, or an appropriate <code>Failure</code> if the operation could not be completed.</p>

<p>Please use <a href="#move" class="podlinkpod"
>&#34;move&#34;</a> if a file could not be moved by renaming (usually because the destination is on a different physical storage device).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="move()"
>move() <!--
	INDEX: move()
--></a></h2>

<pre><code>sub move ($source as IO, $dest as IO,
    :$createonly = False,
    --&#62; Bool ) is export</code></pre>

<p>Moves a file, as indicate by the first positional paramater, by copying its contents to the destination specified, and then removing the file at the original location. If :createonly is set to True, the move fails if a file already exists in the destination. Returns <code>True</code> upon success, or an appropriate <code>Failure</code> if the operation could not be completed.</p>

<p>Please use <a href="#rename" class="podlinkpod"
>&#34;rename&#34;</a> if a file can be moved by renaming (which is usually possible if the destination is on the same different physical storage device). Alternately, the <code>move()</code> function is free to try the <code>rename()</code> first, and if that (silently) fails, do it the hard way.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="unlink()"
>unlink() <!--
	INDEX: unlink()
--></a></h2>

<pre><code>sub unlink(*@files --&#62; Int) is export</code></pre>

<p>Delete all specified ordinary files, links, or symbolic links. Returns the number successfully deleted.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="chmod()"
>chmod() <!--
	INDEX: chmod()
--></a></h3>

<pre><code>sub chmod($permission, *@files --&#62; Int) is export</code></pre>

<p>Changes the permissions of a list of files. The first element of the list must be the numerical mode, which should probably be an octal number, and which definitely should <i>not</i> be a string of octal digits: <code>0o644</code> is okay, <code>0644</code> is not. Returns the number of files successfully changed.</p>

<pre><code>$count = chmod 0o755, &#39;foo&#39;, &#39;bar&#39;;
chmod 0o755, @executables;
$mode =  &#39;0644&#39;; chmod $mode, &#39;foo&#39;;  # BAD!!! sets mode to --w----r-T
$mode = &#39;0o644&#39;; chmod $mode, &#39;foo&#39;;  # this is better
$mode =  0o644 ; chmod $mode, &#39;foo&#39;;  # this is best</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="link()"
>link() <!--
	INDEX: link()
--></a></h2>

<pre><code>sub link($target, $source --&#62; Bool) is export</code></pre>

<p>Create a hard link between the target from the given source path. Returns <code>True</code> if successful, or an appropriate <code>Failure</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="symlink()"
>symlink() <!--
	INDEX: symlink()
--></a></h2>

<pre><code>sub symlink($target, $source --&#62; Bool) is export</code></pre>

<p>Create a symbolic link between the target from the given source path. Returns <code>True</code> if successful, or an appropriate <code>Failure</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IO_Types"
>IO Types</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO"
>IO</a></h2>

<pre><code>role IO { };</code></pre>

<p>The base role only tags that this is an <code>IO</code> object for more generic purposes. It doesn&#39;t specify any methods or attributes.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Spec"
>IO::Spec</a></h2>

<p>This class is a collection of methods dealing with file specifications (commonly known as file names, though it can include the entire directory path). Most of the methods allow access to lower-level operations on file path strings.</p>

<p>These operations are significantly different on some operating systems, so the actual work is being done by subclasses such as <code>IO::Spec::Unix</code>, <code>IO::Spec::Win32</code> and <code>IO::Spec::Cygwin</code>.</p>

<p>The correct <code>IO::Spec</code> class for your system, is available in the <code>$*SPEC</code> dynamic variable. So typically, you would call methods on that:</p>

<pre><code>  my $cleanpath = $*SPEC.canonpath(&#34;a/.//b/&#34;)  # gives &#34;a/b&#34;</code></pre>

<p>This set of modules was inspired by Perl5&#39;s <code>File::Spec</code>. An implementation may choose to inherit from <code>IO::Spec</code>, or any of its subclasses, if that helps in avoiding code duplication.</p>

<p>The <code>select</code> method is the only method provided by <code>IO::Spec</code> itself.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".select"
>.select <!--
	INDEX: .select
--></a></h3>

<pre><code>method select(IO::Spec:U: $name = $*DISTRO.name as Str --&#62; IO::Spec:U)</code></pre>

<p>The <code>.select</code> method takes an optional argument: a string indicating the type of system for which to perform file specification operations. By default, it takes <code>$*DISTRO.name</code>.</p>

<p>At startup, <code>$*SPEC</code> is initialized to <code>IO::Spec.select</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Spec_subclasses"
>IO::Spec subclasses</a></h2>

<p>The following methods should be provided by the <code>IO::Spec</code> subclasses, or may be inherited from another class. They will never check anything with an actual file system. In alphabetical order:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".abs2rel"
>.abs2rel <!--
	INDEX: .abs2rel
--></a></h3>

<pre><code>method abs2rel($path as Str, $base = $*CWD --&#62; Str)</code></pre>

<p>Takes a path and an optional base path (default <code>$*CWD) and returns a relative path from the base path to the destination path. If the base path is relative, then it will first be transformed to an absolute path with <a href="#.rel2abs" class="podlinkpod"
>&#34;.rel2abs&#34;</a>, relative to <code>$*CWD</code>.</code></p>

<p>On systems with the concept of volume, if <code>$path</code> and <code>$base</code> appear to be on two different volumes, it will not attempt to resolve the two paths, and will instead simply return <code>$path</code>.</p>

<p>On systems that have a grammar that indicates filenames, this ignores the <code>$base</code> filename as well. Otherwise all path components are assumed to be directories.</p>

<p>If <code>$path</code> is relative, it is first converted to absolute form using <a href="#.rel2abs" class="podlinkpod"
>&#34;.rel2abs&#34;</a>. This means that it is taken to be relative to <code>$*CWD</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".canonpath"
>.canonpath <!--
	INDEX: .canonpath
--></a></h3>

<pre><code>method canonpath($path as Str --&#62; Str)</code></pre>

<p>Perform a logical cleanup of a path and returns that. Note that this does *not* collapse <em>x/../y</em> sections into <em>y</em>. This is by design. If <em>/foo</em> on your system is a symlink to <em>/bar/baz</em>, then <em>/foo/../quux</em> is actually <em>/bar/quux</em>, not <em>/quux</em> as a naive <em>../</em>-removal would give you. If you want to do this kind of processing, you probably want <a href="#IO%3A%3APath" class="podlinkpod"
>&#34;IO::Path&#34;</a>&#39;s <a href="#.resolve" class="podlinkpod"
>&#34;.resolve&#34;</a> method to actually traverse the filesystem cleaning up paths like this.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".catdir"
>.catdir <!--
	INDEX: .catdir
--></a></h3>

<pre><code>method catdir(*@dir as Array[Str] --&#62; Str)</code></pre>

<p>Concatenate two or more directory names to form a complete path ending with a directory. Removes any trailing slashes from the resulting string, unless the result is the <a href="#.rootdir" class="podlinkpod"
>&#34;.rootdir&#34;</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".catpath"
>.catpath <!--
	INDEX: .catpath
--></a></h3>

<pre><code>method catpath($volume, $dir, $file --&#62; Str)</code></pre>

<p>Takes volume, directory and file portions and returns an entire path string. Under Unix, <code>$volume</code> is ignored, and directory and file are concatenated. On other OSes, <code>$volume</code> is significant. Directory separators like slashes are inserted if need be.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".curdir"
>.curdir <!--
	INDEX: .curdir
--></a></h3>

<pre><code>method curdir(--&#62; Str)</code></pre>

<p>Returns a string representation of the current directory (Usually <code>&#34;.&#34;</code>).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="curupdir"
>curupdir</a></h3>

<p>Returns a test as to whether a given path is identical to the current directory (as indicated by <a href="#.curdir" class="podlinkpod"
>&#34;.curdir&#34;</a>) or the parent directory (as indicated by <a href="#.updir" class="podlinkpod"
>&#34;.updir&#34;</a>. This is usually <code>none(&#60;. ..&#62;)</code>. It is the default for the <code>:test</code> parameter to <code>/dir()</code> and <a href="#IO%3A%3APath" class="podlinkpod"
>&#34;IO::Path&#34;</a>&#39;s <a href="#.contents" class="podlinkpod"
>&#34;.contents&#34;</a> method. It can also be used to extend <code>dir()</code> through its <code>:test</code> named parameter:</p>

<pre><code>  dir &#34;my/directory&#34;, test =&#62; all($*SPEC.curupdir, /^ &#39;.&#39; /);</code></pre>

<p>This example would return all files beginning with a period that are not <code>&#34;.&#34;</code> or <code>&#34;..&#34;</code> directories.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".devnull"
>.devnull <!--
	INDEX: .devnull
--></a></h3>

<pre><code>method devnull(--&#62; Str)</code></pre>

<p>Returns a string representation of the null device (e.g. <code>&#34;/dev/null&#34;</code> on Unix-like systems).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".extension"
>.extension <!--
	INDEX: .extension
--></a></h3>

<pre><code>method extension($path as Str --&#62; Str)</code></pre>

<p>Returns the extension (if any) of the given path.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".is-absolute"
>.is-absolute <!--
	INDEX: .is-absolute
--></a></h3>

<pre><code>method is-absolute($path as Str --&#62; Bool)</code></pre>

<p>Takes as its argument a path, and returns <code>True</code> if it is an absolute path, <code>False</code> otherwise. For <a href="#IO%3A%3ASpec%3A%3AWin32" class="podlinkpod"
>&#34;IO::Spec::Win32&#34;</a>, it returns 1 if it&#39;s an absolute path without a volume, and 2 if it&#39;s absolute with a volume.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".join"
>.join <!--
	INDEX: .join
--></a></h3>

<pre><code>method join(:$volume, $dir, $file --&#62; Str)</code></pre>

<p>A close relative of <a href="#.catpath" class="podlinkpod"
>&#34;.catpath&#34;</a>, this method takes volume, directory and basename portions and returns an entire path string. If a directory is <b>&#34;.&#34;</b>, it is removed from the (relative) path output, because this function inverts the functionality of dirname and basename.</p>

<p>Directory separators are inserted if necessary. Under Unix, $volume is ignored, and only directory and basename are concatenated. On other OSes, $volume is significant.</p>

<p>This method is the inverse of <a href="#.split" class="podlinkpod"
>&#34;.split&#34;</a>; the results can be passed to it to get the volume, dirname, and basename portions back.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".PATH"
>.PATH <!--
	INDEX: .PATH
--></a></h3>

<pre><code>method PATH($PATH = %*ENV&#60;PATH&#62; --&#62; List[Str])</code></pre>

<p>Convert a string formatted like a system&#39;s <code>PATH</code> specification, and returns it as a list of strings. Takes <code>%*ENPATH</code> by default.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".rel2abs"
>.rel2abs <!--
	INDEX: .rel2abs
--></a></h3>

<pre><code>method rel2abs($path as Str, $base = $*CWD as Str --&#62; Str)</code></pre>

<p>Converts a relative path to an absolute path, using an optional base directory. If the base directory is not specified, <code>$*CWD</code> will be assumed.</p>

<p>If <code>$base</code> is relative, then it is first converted to absolute form, relative to <code>$*CWD</code>.</p>

<p>On systems with the concept of volume, if <code>$path</code> and <code>$base</code> appear to be on two different volumes, t will not attempt to resolve the two paths, and will instead simply return <code>$path</code>.</p>

<p>On systems that have a grammar that indicates filenames (like VMS), this ignores the <code>$base</code> specification as well. Otherwise all path components are assumed to be directories.</p>

<p>If <code>$path</code> is absolute, it is cleaned up and returned using <a href="#.canonpath" class="podlinkpod"
>&#34;.canonpath&#34;</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".rootdir"
>.rootdir <!--
	INDEX: .rootdir
--></a></h3>

<pre><code>method rootdir(--&#62; Str)</code></pre>

<p>Returns a string representation of the root directory (usually <code>&#34;/&#34;</code>).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".split"
>.split <!--
	INDEX: .split
--></a></h3>

<pre><code>method split($path as Str --&#62; Hash[Str])</code></pre>

<p>A close relative of <a href="#.splitdir" class="podlinkpod"
>&#34;.splitdir&#34;</a>, this function also splits a path into volume, directory, and basename portions. Unlike <a href="#.splitdir" class="podlinkpod"
>&#34;.splitdir&#34;</a>, split returns paths compatible with dirname and basename <i>and</i> returns it arguments as a hash of <code>volume</code>, <code>directory</code>, and <code>basename</code>.</p>

<p>This means that trailing slashes will be eliminated from the directory and basename components, in Win32 and Unix-like environments. The basename component will always contain the last part of the path, even if it is a directory, <code>&#39;.&#39;</code>, or <code>&#39;..&#39;</code>. If a relative path&#39;s directory portion would otherwise be empty, the directory is set to whatever <code>curdir</code> is.</p>

<p>On systems with no concept of volume, returns <code>&#39;&#39;</code> (the empty string) for volume. The results can be passed to <a href="#.join" class="podlinkpod"
>&#34;.join&#34;</a> to get back a path equivalent to (but not necessarily identical to) the original path. If you want to keep all of the characters involved, use <a href="#.splitdir" class="podlinkpod"
>&#34;.splitdir&#34;</a> instead.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".splitdir"
>.splitdir <!--
	INDEX: .splitdir
--></a></h3>

<pre><code>method splitdir($directories as Str --&#62; List[Str])</code></pre>

<p>The opposite of <a href="#catdir" class="podlinkpod"
>&#34;catdir&#34;</a>. <code>$directories</code> must be only the directory portion of the path on systems that have the concept of a volume or that have path syntax that differentiates files from directories.</p>

<p>Unlike just splitting the directories on the separator, empty directory names (<code>&#39;&#39;</code>) can be returned, because these are significant on some OSes.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".splitpath"
>.splitpath <!--
	INDEX: .splitpath
--></a></h3>

<pre><code>method splitpath( $path, $nofile = False )</code></pre>

<p>Splits a path in to volume, directory, and filename portions and returns these as a List. On systems with no concept of volume, returns &#39;&#39; for volume.</p>

<pre><code>my ($volume,$directories,$file) = IO::Spec.splitpath( $path );
my ($volume,$directories,$file) = IO::Spec.splitpath( $path, $no_file );</code></pre>

<p>For systems with no syntax differentiating filenames from directories, assumes that the last file is a path unless <code>$no_file</code> is <code>True</code> or a trailing separator or <em>/.</em> or <em>/..</em> is present. On Unix, this means that <code>$no_file</code> true makes this return ( &#39;&#39;, $path, &#39;&#39; ).</p>

<p>The directory portion may or may not be returned with a trailing &#39;/&#39;.</p>

<p>The results can be passed to <a href="#.catpath" class="podlinkpod"
>&#34;.catpath&#34;</a> to get back a path equivalent to (but not necessarily identical to) the original path.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".tmpdir"
>.tmpdir <!--
	INDEX: .tmpdir
--></a></h3>

<pre><code>method tmpdir(--&#62; IO::Path)</code></pre>

<p>Returns an <a href="#IO%3A%3APath" class="podlinkpod"
>&#34;IO::Path&#34;</a> representation of the first writable directory from an implicit list of possible temporary directories. Returns the current directory if no writable temporary directories are found. The list of directories checked depends on the platform.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".updir"
>.updir <!--
	INDEX: .updir
--></a></h3>

<pre><code>method updir(--&#62; Str)</code></pre>

<p>Returns a string representation of the parent directory (usually <code>&#34;..&#34;</code>).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Comparison_of_.splitpath_and_.split"
>Comparison of .splitpath and .split</a></h3>

<pre><code>OS      Path       splitpath               split
Unix    /a/b/c     (&#34;&#34;, &#34;/a/b/&#34;, &#34;c&#34;)      (&#34;&#34;, &#34;/a/b&#34;, &#34;c&#34;)
Unix    /a/b//c/   (&#34;&#34;, &#34;/a/b//c/&#34;, &#34;&#34;)    (&#34;&#34;, &#34;/a/b&#34;, &#34;c&#34;)
Unix    /a/b/.     (&#34;&#34;, &#34;/a/b/.&#34;, &#34;&#34;)      (&#34;&#34;, &#34;/a/b&#34;, &#34;.&#34;)
Win32   C:\a\b\    (&#34;C:&#34;, &#34;\\a\\b\\&#34;, &#34;&#34;)  (&#34;C:&#34;, &#34;\\a&#34;, &#34;b&#34;)
VMS     A:[b.c]    (&#34;A:&#34;, &#34;[b.c]&#34;, &#34;&#34;)     (&#34;A:&#34;, &#34;[b]&#34;, &#34;[c]&#34;)</code></pre>

<p>* The VMS section is still speculative, and not yet supported.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Comparison_of_.catpath_and_.join"
>Comparison of .catpath and .join</a></h3>

<pre><code>OS     Components            catpath        join
Unix   (&#34;&#34;, &#34;/a/b&#34;, &#34;c&#34;)     /a/b/c         /a/b/c
Unix   (&#34;&#34;, &#34;.&#34;, &#34;foo&#34;)      ./foo          foo
Unix   (&#34;&#34;, &#34;/&#34;, &#34;/&#34;)        //             /
Win32  (&#34;C:&#34;, &#34;\a&#34;, &#34;b&#34;)     C:\a\b         C:\a\b
VMS    (&#34;A:&#34;, &#34;[b]&#34;, &#34;[c]&#34;)  A:[b][c]       A:[b.c]</code></pre>

<p>* The VMS section is still speculative, and not yet supported.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Path"
>IO::Path</a></h2>

<pre><code>class IO::Path is Cool { }</code></pre>

<p>Holds a path of a file or directory. The path is generally divided into three parts, the <i>volume</i>, <i>directory</i> and <i>base name</i>.</p>

<p>On Windows, the volume is a drive letter like <code>C:</code>, or a UNC network volume like <code>\\share\</code>. On UNIX-based systems, the volume part is empty.</p>

<p>The basename is name of the file or directory that the <code>IO::Path</code> object represents, and the directory is the part of the path leading up to the basename.</p>

<pre><code>path              volume         directory  basename
/usr/bin/gvim                    /usr/bin   gvim
/usr/bin/                        /usr       bin
foo/bar.txt                      foo        bar.txt
C:\temp\f.txt     C:             \temp      f.txt
\\server\share\a  \\server\share \          a</code></pre>

<p>By default, <code>IO::Path</code> uses the <code>IO::Spec</code> setting as found in <code>$*SPEC</code> when the object is created. If you want to work paths as if you were using another OS, you can specify another <code>IO::Spec</code> subclass with the optional <code>:SPEC</code> named parameter.</p>

<p>There are several ways of creating an <code>IO::Path</code>. The easiest way is to use <code>.IO</code> coercer:</p>

<pre><code>  my $io = &#34;foo/bar&#34;.IO;</code></pre>

<p>Of course, you can always call the <code>.new</code> method as well:</p>

<pre><code>  my $io = IO::Path.new( $full-path );
  my $io = IO::Path.new( :$volume, :$directory, :$basename);</code></pre>

<p>Whenever a new <code>IO::Path</code> is created, an internal absolute and cleaned version of the specified path is stored, using the implicitely or explicitely specified values for <code>$*SPEC</code> and <code>$*CWD</code>:</p>

<pre><code>  my $io = IO::Path.new( &#34;foo&#34;, :SPEC&#60;win32&#62;, :CWD&#60;/usr/local/src&#62; );</code></pre>

<p>would create an <code>IO::Path</code> object with <code>IO::Spec::Win32</code> semantics, with an absolute path of <code>/usr/local/src/foo</code>. Yes, that would be strange, but it <b>is</b> possible. A shorter way would be:</p>

<pre><code>  my $io = &#34;foo&#34;.IO( :SPEC&#60;win32&#62;, :CWD&#60;/usr/local/src&#62; );</code></pre>

<p>The (implicit) value of <code>:CWD</code> is only used for creating the absolute path at instantiation time. The (implicit) value of <code>:SPEC</code> is actually saved in the object to be able to perform path operations with the correct semantics at a later time.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="File_test_methods"
>File test methods</a></h3>

<p>The following (single letter) methods can be used on the <code>IO::Path</code> object:</p>

<pre><code>M  Test performed                              Returns
=  ==============                              =======
r  Path is readable by effective uid/gid.      Bool
w  Path is writable by effective uid/gid.      Bool
x  Path is executable by effective uid/gid.    Bool
o  Path is owned by effective uid.             Bool

R  Path is readable by real uid/gid.           Bool
W  Path is writable by real uid/gid.           Bool
X  Path is executable by real uid/gid.         Bool
O  Path is owned by real uid.                  Bool

e  Path exists.                                Bool
s  Size of the path in bytes.                  Int
z  Path has zero size (an empty file).         Bool

f  Path is a plain file.                       Bool
d  Path is a directory.                        Bool
l  Path is a symbolic link.                    Bool
L  Actual path of symbolic link (readlink)     Str
p  Path is a named pipe (FIFO)                 Bool
S  Path is a socket.                           Bool
b  Path is a block special file.               Bool
c  Path is a character special file.           Bool

u  Path has setuid bit set.                    Bool
g  Path has setgid bit set.                    Bool
k  Path has sticky bit set.                    Bool</code></pre>

<p>To allow for easy chaining of file tests, there is an <code>.all</code> method that can be fed the tests to be tried as a <code>Parcel</code> of strings. The value returned will be the first non-True value, or the final True value.</p>

<pre><code>  say &#34;rwx&#34; if $io.all: &#60;r w x&#62;;

  if $io.all(&#60;f r w x s&#62;) -&#62; $size {
  say &#34;plain file with rwx of $size bytes&#34;;
  }</code></pre>

<p>Other methods are listed here in alphabetical order:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".absolute"
>.absolute <!--
	INDEX: .absolute
--></a></h3>

<pre><code>method absolute(--&#62; Str)</code></pre>

<p>The absolute path of the path. Same as the stringification.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".accessed"
>.accessed <!--
	INDEX: .accessed
--></a></h3>

<pre><code>method accessed(--&#62; Instant)</code></pre>

<p>Returns the <code>Instant</code> when the file was last accessed, or <code>Failure</code> if this could not be determined.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".basename"
>.basename <!--
	INDEX: .basename
--></a></h3>

<pre><code>method basename(--&#62; Str)</code></pre>

<p>Returns the base name part of the path -- that is, the last portion. Functions equivalently to the <code>basename</code> shell program on Unix-like systems.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".changed"
>.changed <!--
	INDEX: .changed
--></a></h3>

<pre><code>method changed(--&#62; Instant)</code></pre>

<p>Returns the <code>Instant</code> when the metadata of the file was last changed, or <code>Failure</code> if this could not be determined.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".chdir"
>.chdir <!--
	INDEX: .chdir
--></a></h3>

<pre><code>method chdir(:$CWD = $*CWD --&#62; Bool)</code></pre>

<p>Like <a href="#chdir()" class="podlinkpod"
>&#34;chdir()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the first parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".child"
>.child <!--
	INDEX: .child
--></a></h3>

<pre><code>method child($childname --&#62; IO::Path)</code></pre>

<p>Appends <code>$childname</code> to the end of the path, adding path separators where needed and returns the result as a new <code>IO::Path</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".chmod"
>.chmod <!--
	INDEX: .chmod
--></a></h3>

<pre><code>method chmod($permissions --&#62; Bool)</code></pre>

<p>Like <a href="#chmod()" class="podlinkpod"
>&#34;chmod()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the second parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".copy"
>.copy <!--
	INDEX: .copy
--></a></h3>

<pre><code>method copy($dest, :$createonly --&#62; Bool)</code></pre>

<p>Like <a href="#copy()" class="podlinkpod"
>&#34;copy()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the first parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".dir"
>.dir <!--
	INDEX: .dir
--></a></h3>

<pre><code>method dir(:$test, :$absolute, :$CWD --&#62; List[Str])</code></pre>

<p>Like <a href="#dir()" class="podlinkpod"
>&#34;dir()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the first parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".directory"
>.directory <!--
	INDEX: .directory
--></a></h3>

<pre><code>method directory(--&#62;Str)</code></pre>

<p>Returns the directory part of the path, not including the last item. Functions equivalently to the <code>dirname</code> shell program on Unix-like systems.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".extension"
>.extension <!--
	INDEX: .extension
--></a></h3>

<pre><code>method extension(--&#62; Str)</code></pre>

<p>Returns the extension of the path, if any.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".IO"
>.IO <!--
	INDEX: .IO
--></a></h3>

<pre><code>method IO(--&#62; IO::Path)</code></pre>

<p>Returns itself.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".is-absolute"
>.is-absolute <!--
	INDEX: .is-absolute
--></a></h3>

<pre><code>method is-absolute(--&#62; Bool)</code></pre>

<p>Always returns <code>True</code> since internally the path is always stored as an absolute path.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".is-relative"
>.is-relative <!--
	INDEX: .is-relative
--></a></h3>

<pre><code>method is-relative(--&#62; Bool)</code></pre>

<p>Always returns <code>False</code> since internally the path is always stored as an absolute path.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".lines"
>.lines <!--
	INDEX: .lines
--></a></h3>

<pre><code>method lines($limit = Inf,
    :$nl    = &#34;EOL&#34;,
    :$eager = (context),
    --&#62; List[Str] )

method lines($limit = Inf, :count --&#62; Int)</code></pre>

<p>Returns a (lazy) list of lines of which the file consists, or a <code>Failure</code> if something went wrong. Optionally limits to the number given. Also takes the following optional named parameters:</p>

<dl>
<dt><a name=":nl"
>:nl</a></dt>

<dd>
<p>The delimiter between what are to be considered lines. By default assumes <code>&#34;EOL&#34;</code>, which indicates any combination of <code>&#34;\n&#34;</code>, <code>&#34;\r\n&#34;</code>, <code>&#34;\r&#34;</code> or any other Unicode that has the <code>ZI</code> (Seperator, Line) property.</p>

<dt><a name=":eager"
>:eager</a></dt>

<dd>
<p>If specified with a <code>True</code> value, will generate the list of lines eagerly, which may provide a performance benefit. By default, it takes its cue from the context in which the method executes.</p>

<dt><a name=":count"
>:count</a></dt>

<dd>
<p>If specified with a <code>True</code> value, will return a count of the number of lines, rather than the lines themselves. By default, lines will be returned.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".mkdir"
>.mkdir <!--
	INDEX: .mkdir
--></a></h3>

<pre><code>method mkdir(--&#62; Bool)</code></pre>

<p>Like <a href="#mkdir()" class="podlinkpod"
>&#34;mkdir()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the first parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".modified"
>.modified <!--
	INDEX: .modified
--></a></h3>

<pre><code>method modified(--&#62; Instant)</code></pre>

<p>Returns the <code>Instant</code> when the contents of the file were last modified, or <code>Failure</code> if this could not be determined.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".move"
>.move <!--
	INDEX: .move
--></a></h3>

<pre><code>method move($dest as IO, :$createonly --&#62; Bool)</code></pre>

<p>Like <a href="#move()" class="podlinkpod"
>&#34;move()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the first parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".open"
>.open <!--
	INDEX: .open
--></a></h3>

<pre><code>method open(... --&#62; IO::Handle)</code></pre>

<p>Like <a href="#open()" class="podlinkpod"
>&#34;open()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the first parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".parent"
>.parent <!--
	INDEX: .parent
--></a></h3>

<pre><code>method parent(--&#62; IO::Path)</code></pre>

<p>Removes last portion of the path and returns the result as a new <code>IO::Path</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".pred"
>.pred <!--
	INDEX: .pred
--></a></h3>

<pre><code>method pred(--&#62; IO::Path)</code></pre>

<p>Create previous logical path and return the result as a new <code>IO::Path</code> or returns <code>Failure</code> if that is not possible.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".relative"
>.relative <!--
	INDEX: .relative
--></a></h3>

<pre><code>method relative ($base as Str = $*CWD --&#62; IO::Path)</code></pre>

<p>Transforms the path into an relative form, and returns the result as a new <code>IO::Path</code>. If <code>$base</code> is supplied, transforms it relative to that base directory, otherwise the <code>$*CWD</code>is used. Paths that are already relative are returned unchanged.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".rename"
>.rename <!--
	INDEX: .rename
--></a></h3>

<pre><code>method rename($dest as IO, :$createonly --&#62; Bool)</code></pre>

<p>Like <a href="#rename()" class="podlinkpod"
>&#34;rename()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the first parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".resolve"
>.resolve <!--
	INDEX: .resolve
--></a></h3>

<pre><code>method resolve(--&#62; IO::Path)</code></pre>

<p>Returns a new IO::Path object with all symbolic links and references to the parent directory (<code>..</code>) are physically resolved. This means that the filesystem is examined for each directory in the path, and any symlinks found are followed.</p>

<pre><code>  # bar is a symlink pointing to &#34;/baz&#34;
  my $io = &#34;foo/./bar/..&#34;.IO.resolve;  # now &#34;/&#34; (the parent of &#34;/baz&#34;)</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".rmdir"
>.rmdir</a></h3>

<pre><code>method rmdir(--&#62; Bool)</code></pre>

<p>Removes (deletes) the directory represented by the <code>IO::Path</code>. Returns <code>True</code> if successful, or a <code>Failure</code> of some kind if not. Typically fails if the path is not a directory or the directory is not empty.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".slurp"
>.slurp <!--
	INDEX: .slurp
--></a></h3>

<pre><code>method slurp(:$bin, :$enc  --&#62; Str|Buf)</code></pre>

<p>Like <a href="#slurp()" class="podlinkpod"
>&#34;slurp()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the first parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".SPEC"
>.SPEC <!--
	INDEX: .SPEC
--></a></h3>

<pre><code>method SPEC(--&#62; IO::Spec)</code></pre>

<p>Returns the <a href="#IO%3A%3ASpec" class="podlinkpod"
>&#34;IO::Spec&#34;</a> object that was (implicitely) specified at object creation time.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".spurt"
>.spurt <!--
	INDEX: .spurt
--></a></h3>

<pre><code>method spurt(:$enc, :$append, :$createonly  --&#62; Str|Buf)</code></pre>

<p>Like <a href="#spurt()" class="podlinkpod"
>&#34;spurt()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the first parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".succ"
>.succ <!--
	INDEX: .succ
--></a></h3>

<pre><code>method succ(--&#62; IO::Path)</code></pre>

<p>Create next logical path and return the result as a new <code>IO::Path</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".unlink"
>.unlink</a></h3>

<pre><code>method unlink(--&#62; Bool)</code></pre>

<p>Like <a href="#unlink()" class="podlinkpod"
>&#34;unlink()&#34;</a>, but with <a href="#.absolute" class="podlinkpod"
>&#34;.absolute&#34;</a> as the first parameter. Returns <code>True</code> on success or an appropriate <code>Failure</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".volume"
>.volume <!--
	INDEX: .volume
--></a></h3>

<pre><code>method volume(--&#62;Str)</code></pre>

<p>Returns the volume part of the path. On Unix-like OSes or systems without a concept of volume in the path, returns the empty string.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".words"
>.words <!--
	INDEX: .words
--></a></h3>

<pre><code>method words($limit = Inf,
    :$nw    = &#34;WS&#34;,
    :$eager = (context),
    --&#62; List[Str] )

method words($limit = Inf, :count --&#62; Int)</code></pre>

<p>Returns a (lazy) list of words of which the file consists, or a <code>Failure</code> if something went wrong. Optionally limits to the number given. Also takes the following optional named parameters:</p>

<dl>
<dt><a name=":nw"
>:nw</a></dt>

<dd>
<p>The delimiter between what are to be considered words. By default assumes <code>&#34;WS&#34;</code>, which indicates any whitespace character.</p>

<dt><a name=":eager"
>:eager</a></dt>

<dd>
<p>If specified with a <code>True</code> value, will generate the list of words eagerly, which may provide a performance benefit. By default, it takes its cue from the context in which the method executes.</p>

<dt><a name=":count"
>:count</a></dt>

<dd>
<p>If specified with a <code>True</code> value, will return a count of the number of words, rather than words themselves. By default, words will be returned.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Handle"
>IO::Handle</a></h2>

<pre><code>class IO::Handle does IO { ... }</code></pre>

<p>A handle of a file, pipe or anything else that supports reading or writing like a file.</p>

<p>The <code>IO::Handle</code> object is usually <b>not</b> directly instantiated, but with <a href="#open()" class="podlinkpod"
>&#34;open()&#34;</a> or <a href="#IO%3A%3APath" class="podlinkpod"
>&#34;IO::Path&#34;</a>&#39;s<a href="#.open" class="podlinkpod"
>&#34;.open&#34;</a>. Nonetheless, you <b>can</b> create an <code>IO::Handle</code> object with just a path:</p>

<pre><code>  my $handle = IO::Handle.new($filename as Str);
  my $handle = IO::Handle.new($filename as Str, :SPEC(*$SPEC));
  my $handle = IO::Handle.new($filename as Str, :SPEC(*$SPEC), :CWD($*CWD));</code></pre>

<p>This does not interact with anything at all and will appear as if the file has been <code>.close</code>d. From then on, the <code>.path</code> method will return the <code>IO::Path</code> object that was created</p>

<p>The <code>.open</code> method <b>does</b> interact with the file system:</p>

<pre><code>  $handle.open;  # same as $handle = $filename.IO.open</code></pre>

<p>It has the same optional named parameters as <a href="#open()" class="podlinkpod"
>&#34;open()&#34;</a> and either returns <b>itself</b> (for historical reasons), or a <code>Failure</code> with additional information.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Methods_handled_by_.path"
>Methods handled by .path</a></h3>

<p>The filename specified with <code>.new</code> is internally stored as an <a href="#IO%3A%3APath" class="podlinkpod"
>&#34;IO::Path&#34;</a> object, obtainable with the <code>.path</code> method. The following methods are handled by <code>.path</code> and work exactly the same:</p>

<pre><code>  absolute       the absolute, canonical path
  accessed       last access time (if available)
  basename       the basename of the path
  changed        last (metadata) changed time
  chmod          change attributes of path
  directory      the directory part of the absolute path
  extension      the extension of the file
  is-absolute    is the (original) path absolute
  is-relative    is the (original) path relative
  modified       last modified time
  relative       the relative path against CWD
  SPEC           the :SPEC at instantiation time
  volume         the volume of the path (if any)</code></pre>

<p>The following methods also work the same as with <code>IO::Path</code>, but it may be less logical to use these on an <code>IO::Handle</code> object as these return new <code>IO::Path</code> objects.</p>

<pre><code>  child          append basename to path
  IO             same as .path
  parent         remove last portion of path
  pred           previous logical path
  resolve        follow symlinks to the real path
  succ           next logical path</code></pre>

<p>These <code>IO::Path</code> methods seem to only make sense if the <code>IO::Handle</code> object is closed. But there may be some uses for this, but it seems more like extra rope for shooting yourself in the foot.</p>

<pre><code>  copy           create a copy of file
  mkdir          create directory
  move           move (rename) to other storage
  rename         rename (move) to other name
  rmdir          remove directory if empty directory
  unlink         remove file</code></pre>

<p>[Conjecture: perhaps the above methods should fail on IO::Handle]</p>

<p>Contrary to the <code>IO::Path</code> methods with the same name, these methods operate only from the current file position. If the file was just opened, it&#39;s identical as with the <code>IO::Path</code> version. But if you have done anything to the handle that moved the file pointer, you will get a different result.</p>

<pre><code>  lines          contents of file as lines
  slurp          obtain the contents of the file
  spurt          write / append contents to file
  words          contents of file as words</code></pre>

<p>The other methods of <code>IO::Handle</code> are:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".close"
>.close <!--
	INDEX: .close
--></a></h3>

<pre><code>method close(--&#62; Bool)</code></pre>

<p>Closes the handle and returns <code>True</code>, or a <code>Failure</code> if something went wrong.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".encoding"
>.encoding <!--
	INDEX: .encoding
--></a></h3>

<pre><code>method encoding(--&#62; Str)

method encoding($encoding --&#62; Str)</code></pre>

<p>Without arguments, simply returns the current encoding used on the handle. If supplied with a string identifying a valid encoding, change the handle to read with that encoding from then on. Options include <code>binary</code>, <code>utf8</code>, and other text encodings. An invalid encoding causes the method to return a <code>Failure</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".eof"
>.eof <!--
	INDEX: .eof
--></a></h3>

<pre><code>method eof(--&#62; Bool)</code></pre>

<p>Returns <code>True</code> if the handle is exhausted, <code>False</code> otherwise.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".fileno"
>.fileno <!--
	INDEX: .fileno
--></a></h3>

<pre><code>method fileno(--&#62; int)</code></pre>

<p>Returns the file descriptor, which is always a native integer, conforming to C89.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".flush"
>.flush <!--
	INDEX: /flush
--></a></h3>

<pre><code>method flush(--&#62; Bool)</code></pre>

<p>Attempts to flush any buffered data, returns <code>True</code> if successful, an appropriate <code>Failure</code> otherwise.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".get"
>.get <!--
	INDEX: .get
--></a></h3>

<pre><code>method get(--&#62; Str)</code></pre>

<p>Reads the next line and returns it. Uses the (implicit) specification of <code>:nl</code> with <a href="#open" class="podlinkpod"
>&#34;open&#34;</a> to determine where a line ends. Returns a <code>Str</code> type object if no more lines to be read.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".getc"
>.getc <!--
	INDEX: .getc
--></a></h3>

<pre><code>method getc(Int $chars = 1 --&#62; Str)</code></pre>

<p>Tries to read <code>$chars</code> characters and return them concatenated as a string. Returns a <code>Str</code> type object if no more lines to be read.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".ins"
>.ins <!--
	INDEX: .ins
--></a></h3>

<pre><code>method ins(--&#62; Int)</code></pre>

<p>Returns the number of lines that have been read with <a href="#.get" class="podlinkpod"
>&#34;.get&#34;</a> or <a href="#.lines" class="podlinkpod"
>&#34;.lines&#34;</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".opened"
>.opened <!--
	INDEX: .opened
--></a></h3>

<pre><code>method opened(--&#62; Bool)</code></pre>

<p>Return whether the file is opened.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".p"
>.p <!--
	INDEX: .p
--></a></h3>

<pre><code>method p(--&#62; Bool)</code></pre>

<p>Returns whether the handle is opened to a pipe.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".print"
>.print <!--
	INDEX: .print
--></a></h3>

<pre><code>method print (*@text --&#62; Bool)</code></pre>

<p>Stringifies each element, concatenates those strings, and writes the result to the file. Returns <code>True</code> if successful, a <code>Failure</code> otherwise.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".read"
>.read <!--
	INDEX: .read
--></a></h3>

<pre><code>method read(Int $bytes --&#62; Buf)</code></pre>

<p>Reads and returns <code>$bytes</code> bytes from the handle, or as many as are possible.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".say"
>.say <!--
	INDEX: .say
--></a></h3>

<pre><code>method say (*@text --&#62; Bool)</code></pre>

<p>This is identical to <a href="#.print" class="podlinkpod"
>&#34;.print&#34;</a> except that it stringifies its arguments by calling <code>.gist</code> on them and auto-appends a newline after the final argument.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".seek"
>.seek <!--
	INDEX: .seek
--></a></h3>

<pre><code>method seek(Int $position, MoveMethod $whence --&#62; Bool)</code></pre>

<p>Move the file pointer to <code>$position</code>. The meaning of this position is always in &#34;bytes&#34;, so you better know what you&#39;re doing in a text-file.</p>

<p>The <code>$whence</code> value should be a <code>MoveMethod</code> value, which is one of:</p>

<pre><code>name        value
=========== =====
FromStart     0
FromCurrent   1
FromEnd       2</code></pre>

<p>These numerical values will also be accepted. Returns <code>True</code> on success, or a <code>Failure</code> if something went wrong (e.g. when using <code>$*IN</code> on a terminal input).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".t"
>.t <!--
	INDEX: .t
--></a></h3>

<pre><code>method t(--&#62; Bool)</code></pre>

<p>Returns <code>True</code> if the handle is opened to a tty, aka there might actually be a person watching.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".tell"
>.tell <!--
	INDEX: .tell
--></a></h3>

<pre><code>method tell(--&#62; Int)</code></pre>

<p>Returns the position of the file pointer in number of &#34;octets&#34;.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=".write"
>.write <!--
	INDEX: .write
--></a></h3>

<pre><code>method write(Buf $buf --&#62; Int)</code></pre>

<p>Tries to write <code>$buf</code> to the file. The actual number of bytes written is returned, or a <code>Failure</code> if something went wrong.</p>

<p>This is &#34;raw&#34; write. <code>$buf</code> contains plain bytes. If you want to <code>write</code> a <code>Str</code>, you should <code>.encode</code> it first, or use <a href="#.print" class="podlinkpod"
>&#34;.print&#34;</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Here_Be_Dragons"
>Here Be Dragons</a></h1>

<p>Everything below this point hasn&#39;t been reviewed properly</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Socket"
>IO::Socket</a></h2>

<pre><code>role IO::Socket {
    has %.options;
    has Bool $.Listener;
    ...
}</code></pre>

<p>Accessing the <code>%.options</code> would on Unix be done with <i>getsockopt(2)</i>/<i>setsockopt(2)</i>.</p>

<p>The $.Listener attribute indicates whether the socket will be a listening socket when opened, rather than indicating whether it is currently listening.</p>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code>method new(
    :$Listener, # initializes $.Listener
)</code></pre>

<p>The initial value of the $.Listener attribute is defined according to the following rules:</p>

<pre><code> * If $Listener is passed to .new(), then that value is used
 * If neither a local address nor a remote address are passed in, throw an exception
 * If no remote address is passed, then $.Listener is set to SOMAXCONN
 * If no local address is used, then $Listener is set to 0
 * If both local and remote addresses are used, throw an exception that asks people to
   specify $Listener</code></pre>

<dt><a name="open"
>open</a></dt>

<dd>
<pre><code>method open()</code></pre>

<p>If $.Listener is true, does a <i>bind(2)</i> and a <i>listen(2)</i>, otherwise does a <i>connect(2)</i>.</p>

<p>It&#39;s end-user use case is intended for the case where NoOpen is passed to .new(). .new() itself will presumably also call it.</p>

<dt><a name="close"
>close</a></dt>

<dd>
<pre><code>method close()</code></pre>

<p>Implements the close() function from IO::Closeable by doing a shutdown on the connection (see below) with @how set to (&#39;Readable&#39;, &#39;Writeable&#39;).</p>

<dt><a name="shutdown"
>shutdown</a></dt>

<dd>
<pre><code>method shutdown(Str @how)</code></pre>

<p>Does a <i>shutdown(2)</i> on the connection. See also IO::Readable.isReadable and IO::Writeable.isWriteable.</p>

<p>$how can contain 1 or more of the strings &#39;Readable&#39; and &#39;Writeable&#39;.</p>

<dt><a name="accept"
>accept</a></dt>

<dd>
<pre><code>method accept( --&#62; IO::Socket)</code></pre>

<dt><a name="method_read(Int_$bytes_--&#62;_Buf)"
>method read(Int $bytes --&#62; Buf)</a></dt>

<dd>
<p>Reads and returns <code>$bytes</code> bytes from the handle</p>

<dt><a name="method_write(Buf_$buf_--&#62;_Int)"
>method write(Buf $buf --&#62; Int)</a></dt>

<dd>
<p>Implements the IO::Writeable interface by doing a <i>send(2)</i>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Socket::INET"
>IO::Socket::INET</a></h2>

<pre><code>class IO::Socket::INET does IO::Socket {
    has Str $.proto = &#39;TCP&#39;;
    has Str $.host;
    has Int $.port;
    has Str $.localhost;
    has Int $.localport;
    ...
}</code></pre>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code>multi method new(:$host!, :$port, *%attributes) { ... }
multi method new(:$localhost!, :$localport, :$listen! *%attributes) { ... }</code></pre>

<p>Creates a new socket and opens it.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Conjectural_Stuff"
>Conjectural Stuff</a></h1>

<p>Everything below this point should be considered as mere ideas for future evolution, not as things that a compiler write should implement unquestioningly.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::ACL"
>IO::ACL</a></h2>

<p>This is a basic abstraction; for better control, use the operating-system specific interfaces, over which this is a thin veneer.</p>

<pre><code>class IO::ACL {
    has Str $.type; # &#34;User&#34;, &#34;Group&#34;, &#34;Everyone&#34;, ???
    has Str $.id; # username or groupname; unused for $type eq &#34;Everyone&#34;
    has %.permissions;
            # Unsupported values may (or may not) throw
            # UnsupportedPermission when set or read
    has Path $.owningObject;
    ...
}</code></pre>

<p>The permissions used in <code>%permissions</code> are:</p>

<dl>
<dt><a name="Readable"
>Readable</a></dt>

<dd>
<p>Should be supported by all filesystems as an item to read from the hash for the group &#34;Everyone&#34;.</p>

<dt><a name="Writeable"
>Writeable</a></dt>

<dd>
<p>Should be supported by all filesystems as an item to read from the hash for the group &#34;Everyone&#34;.</p>

<dt><a name="Executable"
>Executable</a></dt>

<dd>
<p>Supported on most Unix systems, anyway. Windows should be able to guess when this is read, and throw an exception if written to.</p>

<dt><a name="Default"
>Default</a></dt>

<dd>
<p>An ACL of User,fred,Default sets the user &#34;fred&#34; to be the owner of the file. This can be done with groups too. Works on Unix, at least.</p>
</dd>
</dl>

<p>The <code>$.owningObject</code> attribute of <code>ACL</code> shows what the ACL is set on. On a Windows system, this can be a parent directory, as permissions are inherited.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Pipe"
>IO::Pipe</a></h2>

<pre><code>class IO::Pipe does IO::Streamable does IO::Readable does IO::Writable {
    ...
}</code></pre>

<p>Will need to set IO::Readable.isReadable and IO::Writable.isWriteable depending on opening method.</p>

<dl>
<dt><a name="close()"
>close()</a></dt>

<dd>
<p>If the file handle came from a piped open, <code>close</code> will additionally return <code>Failure</code> (aliased to <code>$!</code>) if one of the other system calls involved fails, or if the program exits with non-zero status. The exception object will contain any pertinent information. Closing a pipe also waits for the process executing on the pipe to complete, in case you want to look at the output of the pipe afterwards, and implicitly puts the exit status value into the <code>Failure</code> object if necessary.</p>

<dt><a name="IO::Pipe.to"
>IO::Pipe.to</a></dt>

<dd>
<pre><code>method to(Str $command, *%opts --&#62; Bool)
method to(Str *@command, *%opts --&#62; Bool)</code></pre>

<p>Opens a one-way pipe writing to <code>$command</code>. <code>IO</code> redirection for stderr is specified with <code>:err(IO)</code> or <code>:err&#60;Str&#62;</code>. Other <code>IO</code> redirection is done with feed operators. XXX how to specify &#34;2&#62;&#38;1&#34;?</p>

<dt><a name="IO::Pipe.from"
>IO::Pipe.from</a></dt>

<dd>
<pre><code>method from(Str $command, *%opts --&#62; Bool)
method from(Str *@command, *%opts --&#62; Bool)</code></pre>

<p>Opens a one-way pipe reading from $command. <code>IO</code> redirection for stderr is specified with <code>:err(IO)</code> or <code>:err&#60;Str&#62;</code>. Other <code>IO</code> redirection is done with feed operators. XXX how to specify &#34;2&#62;&#38;1&#34;?</p>

<dt><a name="IO::Pipe.pair"
>IO::Pipe.pair</a></dt>

<dd>
<pre><code>method pair(--&#62; List of IO::Pipe)</code></pre>

<p>A wrapper for <i>pipe(2)</i>, returns a pair of <code>IO</code> objects representing the reader and writer ends of the pipe.</p>

<pre><code>   ($r, $w) = IO::Pipe.pair;</code></pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="OS-specific_classes"
>OS-specific classes</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Unix"
>Unix</a></h3>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Path::Unix"
>Path::Unix</a></h3>

<dl>
<dt><a name="chown"
>chown</a></dt>

<dd>
<pre><code>multi chown ($uid = -1, $gid = -1, *@files --&#62; Int)</code></pre>

<p>Changes the owner (and group) of a list of files. The first two elements of the list must be the numeric uid and gid, in that order. A value of -1 in either position is interpreted by most systems to leave that value unchanged. Returns the number of files successfully changed.</p>

<pre><code>$count = chown $uid, $gid, &#39;foo&#39;, &#39;bar&#39;;
chown $uid, $gid, @filenames;</code></pre>

<p>On systems that support <code>fchown</code>, you might pass file handles among the files. On systems that don&#39;t support <code>fchown</code>, passing file handles produces a fatal error at run time.</p>

<p>Here&#39;s an example that looks up nonnumeric uids in the passwd file:</p>

<pre><code>   $user = prompt &#34;User: &#34;;
   $pattern = prompt &#34;Files: &#34;;

   ($login,$pass,$uid,$gid) = getpwnam($user)
   or die &#34;$user not in passwd file&#34;;

   @ary = glob($pattern);      # expand filenames
   chown $uid, $gid, @ary;</code></pre>

<p>On most systems, you are not allowed to change the ownership of the file unless you&#39;re the superuser, although you should be able to change the group to any of your secondary groups. On insecure systems, these restrictions may be relaxed, but this is not a portable assumption. On POSIX systems, you can detect this condition this way:</p>

<pre><code>use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);
$can-chown-giveaway = not sysconf(_PC_CHOWN_RESTRICTED);</code></pre>

<dt><a name="stat"
>stat</a></dt>

<dd>
<dt><a name="IO.stat"
>IO.stat</a></dt>

<dd>
<pre><code>$node.stat(Bool :$link); # :link does an lstat instead</code></pre>

<p>Returns a stat buffer. If the lstat succeeds, the stat buffer evaluates to true, and additional file tests may be performed on the value. If the stat fails, all subsequent tests on the stat buffer also evaluate to false.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="IO::Socket::Unix"
>IO::Socket::Unix</a></h3>

<pre><code>role IO::Socket::Unix does IO::Socket {
    has Str $.RemoteAddr, # Remote Address
    has Str $.LocalAddr,  # Local Address
}</code></pre>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code>method new(
    Str  :$RemoteAddr,
    Str  :$LocalAddr,

    Bool :$Listener,   # Passed to IO::Socket.new()

    Bool :$Blocking,   # Passed to IO::Streamable.new()
    Bool :$NoOpen,     # Passed to IO::Streamable.new()

    --&#62; IO::Socket::Unix
) {...}</code></pre>

<dt><a name="pair"
>pair</a></dt>

<dd>
<pre><code>method pair(Int $domain, Int $type, Int $protocol --&#62; List of IO)</code></pre>

<p>A wrapper for <i>socketpair(2)</i>, returns a pair of <code>IO</code> objects representing the reader and writer ends of the socket.</p>

<pre><code>   use IO::Socket;
   ($r, $w) = IO::Socket::Unix.pair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);</code></pre>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="IO::POSIX"
>IO::POSIX</a></h3>

<p>Indicates that this object can perform standard posix <code>IO</code> operations. It implies <code>IO::Readable</code> and <code>IO::Writeable</code>.</p>

<dl>
<dt><a name="method_dup(_--&#62;_IO)"
>method dup( --&#62; IO)</a></dt>

<dd>
<dt><a name="has_Bool_$.blocking_is_rw"
>has Bool $.blocking is rw</a></dt>

<dd>
<dt><a name="method_flock(:$r,:$w_--&#62;_Bool)"
>method flock(:$r,:$w --&#62; Bool)</a></dt>

<dd>
<dt><a name="method_funlock(_--&#62;_Bool)"
>method funlock( --&#62; Bool)</a></dt>

<dd>
<dt><a name="..."
>...</a></dt>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Unfilled"
>Unfilled</a></h1>

<dl>
<dt><a name="IO.ioctl"
>IO.ioctl</a></dt>

<dd>
<p>Available only as a handle method.</p>

<dt><a name="alarm"
>alarm</a></dt>

<dd>
<dt><a name="prompt"
>prompt</a></dt>

<dd>
<pre><code>multi prompt (Str $prompt --&#62; Str)</code></pre>

<p>Should there be an IO::Interactive role?</p>

<dt><a name="Str.readpipe"
>Str.readpipe</a></dt>

<dd>
<dt><a name="sysopen"
>sysopen</a></dt>

<dd>
<dt><a name="IO.sysseek"
>IO.sysseek</a></dt>

<dd>
<dt><a name="umask"
>umask</a></dt>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Removed_functions"
>Removed functions</a></h1>

<dl>
<dt><a name="IO.eof"
>IO.eof</a></dt>

<dd>
<p>Gone, see eoi <code>IO::Seekable</code>.</p>

<dt><a name="IO.fileno"
>IO.fileno</a></dt>

<dd>
<p>See <code>IO::Handle</code>.</p>

<dt><a name="/(get|set)(host|net|proto|serv|sock).*/"
>/(get|set)(host|net|proto|serv|sock).*/</a></dt>

<dd>
<p>Should be implemented by an external library.</p>

<dt><a name="lstat"
>lstat</a></dt>

<dd>
<p>Use <code>stat</code> with the <code>:link</code> option.</p>

<dt><a name="IO.name"
>IO.name</a></dt>

<dd>
<p>Changed to <code>.path</code>, but we haven&#39;t gotten around to specifying this on all of them.</p>

<p>The <code>.name</code> method returns the name of the file/socket/uri the handle was opened with, if known. Returns Nil otherwise. There is no corresponding <code>name()</code> function.</p>

<dt><a name="pipe"
>pipe</a></dt>

<dd>
<p>Gone, see Pipe.pair</p>

<dt><a name="select(both)"
>select(both)</a></dt>

<dd>
<p>Gone. (Note: for sub-second sleep, just use sleep with a fractional argument.)</p>

<dt><a name="IO.shutdown()"
>IO.shutdown()</a></dt>

<dd>
<p>Gone, see <code>IO::Socket.close()</code>, <code>$IO::Readable.isReadable</code>, and <code>$IO::Writeable.isWriteable</code></p>

<dt><a name="socketpair"
>socketpair</a></dt>

<dd>
<p>Gone, see Socket.pair</p>

<dt><a name="IO.sysread"
>IO.sysread</a></dt>

<dd>
<p>Gone, see <code>IO::Readable.read()</code>.</p>

<dt><a name="IO.syswrite"
>IO.syswrite</a></dt>

<dd>
<p>Gone, see <code>IO::Writeable.read()</code>.</p>

<dt><a name="utime"
>utime</a></dt>

<dd>
<p>Gone, see <code>Path.times</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Buffered"
>IO::Buffered</a></h2>

<p>Indicates that this object performs buffering. The management of the buffer is completely implementation specific.</p>

<dl>
<dt><a name="method_autoflush(_--&#62;_Bool)_is_rw"
>method autoflush( --&#62; Bool) is rw</a></dt>

<dd>
<p>Forces this object to keep its buffers empty</p>

<p>If set to nonzero, forces a flush right away and after every write or print on the currently selected output channel. Default is 0 (regardless of whether the channel is really buffered by the system or not; <code>$OUT_FH.autoflush</code> tells you only whether you&#39;ve asked Perl explicitly to flush after each write). <code>$*OUT</code> will typically be line buffered if output is to the terminal and block buffered otherwise. Setting this variable is useful primarily when you are outputting to a pipe or socket, such as when you are running a Perl program under rsh and want to see the output as it&#39;s happening. This has no effect on input buffering.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Streamable"
>IO::Streamable</a></h2>

<p>This role represents objects that depend on some external resource, which means that data might not be available at request.</p>

<pre><code>role IO::Streamable does IO {...}</code></pre>

<dl>
<dt><a name="new()"
>new()</a></dt>

<dd>
<pre><code>method new(
    Bool :$NoOpen,
    Bool :$Blocking,
    --&#62; IO::Streamable
) {...}</code></pre>

<p>Unless the NoOpen option is passed, an open will be done on the <code>IO</code> object when it is created.</p>

<p>If blocking is passed in, .blocking() is called (see below).</p>

<dt><a name="method_blocking(_--&#62;_Bool)_is_rw"
>method blocking( --&#62; Bool) is rw</a></dt>

<dd>
<p>This allows the user to control whether this object should do a blocking wait or immediately return in the case of not having data available.</p>

<dt><a name="uri"
>uri</a></dt>

<dd>
<pre><code>method uri(Str $uri --&#62; IO::Streamable) {...}</code></pre>

<p>This should be callable on the class, and act like a kind of &#34;new()&#34; function. When given a URI, it returns an <code>IO::Streamable</code> of the appropriate type, and throws an error when an inappropriate type is passed in. For example, calling <code>IO::File.uri(&#39;http://....&#39;)</code> will throw an error (but will suggest using just uri(&#39;http://...&#39;) instead).</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Encoded"
>IO::Encoded</a></h2>

<p>This is a generic role for encoded data streams.</p>

<dl>
<dt><a name="method_encoding(_--&#62;_Str)_is_rw"
>method encoding( --&#62; Str) is rw</a></dt>

<dd>
<dt><a name="method_locale(_--&#62;_Str)_is_rw"
>method locale( --&#62; Str) is rw</a></dt>

<dd>
<p>Encoding and locale are required for sane conversions.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="IO::Readable::Encoded"
>IO::Readable::Encoded</a></h2>

<p>This role provides encoded access to a readable data stream, implies <code>IO::Encoded</code>. Might imply <code>IO::Buffered</code>, but that&#39;s not a requirement.</p>

<dl>
<dt><a name="uri"
>uri <!--
	INDEX: uri
--><!--
	INDEX: ftp
--><!--
	INDEX: http
--></a></dt>

<dd>
<pre><code>method uri(Str $uri --&#62; IO::Streamable);
sub uri(Str $uri --&#62; IO::Streamable);</code></pre>

<p>Returns an appropriate <code>IO::Streamable</code> descendant, with the type depending on the uri passed in. Here are some example mappings:</p>

<pre><code>URI type IO type
======== =======
file:    IO::Path
ftp:     IO::Socket::INET (data channel)
http:    IO::Socket::INET</code></pre>

<p>These can naturally be overridden or added to by other modules.</p>

<dt><a name="%*PROTOCOLS_dynamic_variable"
>%*PROTOCOLS dynamic variable</a></dt>

<dd>
<p>For each protocol, stores a type name that should be instantiated by calling the <code>uri</code> constructor on that type, and passing in the appropriate uri.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="POD_ERRORS"
>POD ERRORS</a></h1>

<p>Hey! <b>The above document had some coding errors, which are explained below:</b></p>

<dl>
<dt><a name="Around_line_422:"
>Around line 422:</a></dt>

<dd>
<p>Unterminated C&#60;...&#62; sequence</p>

<dt><a name="Around_line_536:"
>Around line 536:</a></dt>

<dd>
<p>Deleting unknown formatting code V&#60;&#62;</p>

<dt><a name="Around_line_1290:"
>Around line 1290:</a></dt>

<dd>
<p>=back without =over</p>
</dd>
</dl>

<!-- end doc -->

</body></html>
