<!DOCTYPE html>
<html lang="ja">
<head>
<title>S08-capture</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Sep 27 10:05:33 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Introduction'>Introduction</a>
  <li class='indexItem indexItem1'><a href='#Capture_or_Parcel'>Capture or Parcel</a>
  <li class='indexItem indexItem1'><a href='#Multidimensionality'>Multidimensionality</a>
  <li class='indexItem indexItem1'><a href='#Context_deferral'>Context deferral</a>
  <li class='indexItem indexItem1'><a href='#Additions'>Additions</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 8: Capture and Parcel</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Daniel Ruoso &#60;daniel@ruoso.com&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 20 Sep 2009

Last Modified: 23 Jan 2010
Version: 2</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Introduction"
>Introduction</a></h1>

<p>Unlike most programming languages, the data structure that is used to send the parameters into a routine invocation (be it a method or a sub) is exposed to the language as a built-in type like any other. This represents a very important aspect of the Perl 6 runtime requirements.</p>

<p>Additionally to the fact that this data structure is visible in the language type system, it is not assumed that the capture is a native type, which means that the internal representation of the data is subject to change. The only thing the runtime can assume is the API described here.</p>

<p>Of course the runtime can cheat whenever it knows the capture is implemented by its own internal data structure for optimization purposes, but it should allow the use of foreign types when invoking a routine, as long as the object says true to <code>.^does(Capture)</code>.</p>

<p>Captures and Parcels are also the basis for the multidimensionality of lists in Perl 6. Unlike Perl 5, no flattening happens unless it&#39;s explicitly required by the user, which is done by enforcing the list context. If you use the item context the dimensionality should be preserved.</p>

<p>In addition to the list and item context, there&#39;s also a special context, which is, in a simplified way, called &#34;Capture context&#34;, but it actually means &#34;deferred context&#34;, in a way that the Capture or Parcel is kept as-is while they are manipulated in the code. This is useful to avoid unwanted flattening as well as avoiding the DWIMmy features that might change the capture&#39;s behavior.</p>

<p>This is the main point of why Capture and Parcel replace Perl 5 references, they allow you to send data untouched from one place to another. The second reason is that as in Perl 6 everything is an object, there isn&#39;t really &#34;pass-by-value&#34; anymore, you&#39;re always sending a reference, Captures and Parcels simply carry other objects without enforcing any context on them.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Capture_or_Parcel"
>Capture or Parcel</a></h1>

<p>While a <code>Capture</code> is the object that holds the parameters sent to a routine (positional and named), a <code>Parcel</code> is a more fundamental data structure that doesn&#39;t really differentiate named arguments from positional arguments (but it still lets you access the named ones by their name).</p>

<p>The basic underlying concept is that a Parcel behaves much like a list, but it doesn&#39;t enforce any context, in a way that no flattening or coercion is done. When you use the <code>Positional</code> API on a Parcel, it will include all the listed items, whether they look like named arguments or positional arguments. For example:</p>

<pre><code>  1, 2, :a&#60;b&#62;</code></pre>

<p>The Parcel represented here has 3 positional items and allows you to access the element &#39;a&#39; through the <code>Associative</code> interface. A Parcel might be statically converted to a Capture if it&#39;s clear to the parser that it&#39;s being used as the arguments to a routine call.</p>

<p>A Capture, on the other hand, is not required to keep the positional information for the named arguments, for example:</p>

<pre><code>  foo(1,:a&#60;b&#62;,2)</code></pre>

<p>In the call to the routine foo, there are only two positional arguments and one named argument, and you won&#39;t be able to find &#34;b&#34; from the <code>Positional</code> interface, but only from the Associative.</p>

<p>The differentiation from Parcel and Capture is important to keep the regular use of inline declarations consistent, let&#39;s say you do the following:</p>

<pre><code>  my $a = (0, :a&#60;b&#62;, 2);
  say $a[2];</code></pre>

<p>If we had Capture and Parcel as the same data structure, you wouldn&#39;t get <code>2</code> as the result of the above code, because there are only two positional arguments, not three. Using the same example:</p>

<pre><code>  sub foo($p1, $p2, :$a) {...}
  foo(|$a);</code></pre>

<p>In that case, the Parcel is converted into a Capture, and therefore the pair <code>:a&#60;b&#62;</code> is no longer visible as a positional argument, only as named.</p>

<p>Note that once you convert a Parcel into a Capture, you won&#39;t be able to get the original Parcel again, because a Capture doesn&#39;t hold the information about the position of named arguments.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Multidimensionality"
>Multidimensionality</a></h1>

<p>Probably the most important task of Parcels and Captures is to implement the multidimensionality of lists in Perl 6, this means that the barrier used to detect the dimensionality of the data structures by the operators is whatever the item inside it implements Parcel or Capture. For instance:</p>

<pre><code>  my $a = (1, (2, (3, 4)));
  say $a[1];</code></pre>

<p>In that case, you&#39;ll get <code>2, (3, 4)</code> (or whatever is implemented in the .Str method of that specific Parcel).</p>

<p>[Update: The above (and much of what follows below) doesn&#39;t conform to the latest discussion on parcels; parcels flatten under item assignment. See <a href="http://irclog.perlgeek.de/perl6/2009-09-23#i_1532822" class="podlinkurl"
>http://irclog.perlgeek.de/perl6/2009-09-23#i_1532822</a>.]</p>

<p>But, you should be able to:</p>

<pre><code>  say $a[1;0];</code></pre>

<p>Which is going to return <code>2</code>, which is almost the same as:</p>

<pre><code>  say $a[1][0];</code></pre>

<p>But the first provides a more convenient and optimizeable way of asking for it. If you want to get the value <code>4</code> from that data structure you need to:</p>

<pre><code>  say $a[1;1;1];</code></pre>

<p>Note that if you assign that parcel to an array, it will be flattened, so:</p>

<pre><code>  my @a = 1, (2, (3, 4));
  say @a[3];</code></pre>

<p>Would print <code>4</code>, at the same time that trying to ask for multidimensionality information from that list would result in a failure:</p>

<pre><code>  say @a[1;1;1];</code></pre>

<p>As the element 1 of the array <code>@a</code> is not a Capture or a Parcel, it is not possible for the <code>.[]</code> operator to traverse it.</p>

<p>[Conjecture: It is still not clear if the multidimensional access should be able to get into regular arrays, i.e.: <code>[1,[2,[3,[4]]]] ]</code></p>

<p>It is important to realize that it&#39;s not the parens that are creating the Parcel, but the <code>infix:&#60;,&#62;</code>. The parens are only required in order to define a sub-parcel.</p>

<p>On the other hand, if you bind a parcel to a variable, it doesn&#39;t really matter which sigil it uses:</p>

<pre><code>  my @a := (1, (2, (3, 4)));
  say @a[1;1;1]; # &#34;4&#34;
  say @a[3]; # failure</code></pre>

<p>Captures and Parcels are seen the same way regarding multidimensionality, for instance:</p>

<pre><code>  my $a = ((map { $_ * 2 }, 1..5),(map { $_ / 2 }, 1..5));
  say $a[0;0]; # 2
  say $a[1;0]; # 0.5</code></pre>

<p>The same way, if each map closure returns more than one item inside its capture:</p>

<pre><code>  my $a = ((map { $_ * 2, $_ / 2 }, 1..5),(map { $_ / 2, $_ * 2 }, 1..5));
  say $a[0;0;0]; # 2
  say $a[0;0;1]; # 0.5
  say $a[1;0;0]; # 0.5
  say $a[1;0;0]; # 2</code></pre>

<p>The flattening process will traverse into Parcels and Captures, so:</p>

<pre><code>  1, (2, (3, 4))</code></pre>

<p>will result in:</p>

<pre><code>  1, 2, 3, 4</code></pre>

<p>after flattening, while:</p>

<pre><code>  1, [2, [3, 4]]</code></pre>

<p>Would remain as-is.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Context_deferral"
>Context deferral</a></h1>

<p>Also known as &#34;Capture Context&#34;, defines how you can defer the context coercion for a given value. That is a fundamental feature because something as simple as assigning to a scalar might imply context coercion that would get you a modified value.</p>

<p>Both the Parcel and the Capture are able to preserve the values as-is, in a way that you can later apply any context and have the same result as if the context was applied immediately.</p>

<p>Context deferral is actually the reason why Perl 6 no longer supports the &#34;wantarray&#34; operator, nor does it provide any substitute. The way you should implement wantarray-like behavior is by properly overriding the coercion for each context. The Contextual::Return module is an implementation of that concept in Perl 5.</p>

<p>[ The capture sigil does not exist, though left in this document for the time being pending a suitable replacement mechanism to handle context deferral.]</p>

<p>In order to use the context deferral in your code, you need to use the &#34;capture sigil&#34;, which can be presented in two forms:</p>

<pre><code>  my &#162;a = (1, (2, (3, 4)));</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Additions"
>Additions</a></h1>

<p>Please post errors and feedback to perl6-language. If you are making a general laundry list, please separate messages by topic.</p>

<!-- end doc -->

</body></html>
