<!DOCTYPE html>
<html lang="ja">
<head>
<title>S04-control</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Aug 30 10:16:49 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#The_Relationship_of_Lexical_and_Dynamic_Scopes'>The Relationship of Lexical and Dynamic Scopes</a>
  <li class='indexItem indexItem1'><a href='#The_Relationship_of_Blocks_and_Declarations'>The Relationship of Blocks and Declarations</a>
  <li class='indexItem indexItem1'><a href='#The_Relationship_of_Blocks_and_Statements'>The Relationship of Blocks and Statements</a>
  <li class='indexItem indexItem1'><a href='#Statement-ending_blocks'>Statement-ending blocks</a>
  <li class='indexItem indexItem1'><a href='#Conditional_statements'>Conditional statements </a>
  <li class='indexItem indexItem1'><a href='#Loop_statements'>Loop statements</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#The_while_and_until_statements'>The while and until statements </a>
    <li class='indexItem indexItem2'><a href='#The_repeat_statement'>The repeat statement </a>
    <li class='indexItem indexItem2'><a href='#The_general_loop_statement'>The general loop statement </a>
    <li class='indexItem indexItem2'><a href='#The_for_statement'>The for statement </a>
    <li class='indexItem indexItem2'><a href='#The_do-once_loop'>The do-once loop</a>
    <li class='indexItem indexItem2'><a href='#Loops_at_the_statementlist_level_vs_the_statement_level'>Loops at the statementlist level vs the statement level</a>
    <li class='indexItem indexItem2'><a href='#Statement-level_bare_blocks'>Statement-level bare blocks</a>
    <li class='indexItem indexItem2'><a href='#The_gather_statement_prefix'>The gather statement prefix </a>
    <li class='indexItem indexItem2'><a href='#Other_do-like_forms'>Other do-like forms </a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Switch_statements'>Switch statements </a>
  <li class='indexItem indexItem1'><a href='#Exception_handlers'>Exception handlers </a>
  <li class='indexItem indexItem1'><a href='#Control_Exceptions'>Control Exceptions</a>
  <li class='indexItem indexItem1'><a href='#The_goto_statement'>The goto statement </a>
  <li class='indexItem indexItem1'><a href='#Exceptions'>Exceptions</a>
  <li class='indexItem indexItem1'><a href='#Phasers'>Phasers</a>
  <li class='indexItem indexItem1'><a href='#Statement_parsing'>Statement parsing</a>
  <li class='indexItem indexItem1'><a href='#Definition_of_Success'>Definition of Success</a>
  <li class='indexItem indexItem1'><a href='#When_is_a_closure_not_a_closure'>When is a closure not a closure</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 4: Blocks and Statements</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Larry Wall &#60;larry@wall.org&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 19 Aug 2004

Last Modified: 18 Aug 2014
Version: 135</code></pre>

<p>This document summarizes Apocalypse 4, which covers the block and statement syntax of Perl.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="The_Relationship_of_Lexical_and_Dynamic_Scopes"
>The Relationship of Lexical and Dynamic Scopes</a></h1>

<p>Control flow is a dynamic feature of all computer programming languages, but languages differ in the extent to which control flow is attached to declarative features of the language, which are often known as &#34;static&#34; or &#34;lexical&#34;. We use the phrase &#34;lexical scoping&#34; in its industry-standard meaning to indicate those blocks that surround the current textual location. More abstractly, any declarations associated with those textual blocks are also considered to be part of the lexical scope, and this is where the term earns the &#34;lexical&#34; part of its name, in the sense that lexical scoping actually does define the &#34;lexicon&#34; for the current chunk of code, insofar as the definitions of variables and routines create a local domain-specific language.</p>

<p>We also use the term &#34;dynamic scoping&#34; in the standard fashion to indicate the nested call frames that are created and destroyed every time a function or method is called. In most interesting programs the dynamic scopes are nested quite differently from the lexical scopes, so it&#39;s important to distinguish carefully which kind of scoping we&#39;re talking about.</p>

<p>Further compounding the difficulty is that every dynamic scope&#39;s outer call frame is associated with a lexical scope somewhere, so you can&#39;t just consider one kind of scoping or the other in isolation. Many constructs define a particular interplay of lexical and dynamic features. For instance, unlike normal lexically scope variables, dynamic variables search up the dynamic call stack for a variable of a particular name, but at each &#34;stop&#34; along the way, they are actually looking in the lexical &#34;pad&#34; associated with that particular dynamic scope&#39;s call frame.</p>

<p>In Perl 6, control flow is designed to do what the user expects most of the time, but this implies that we must consider the declarative nature of labels and blocks and combine those with the dynamic nature of the call stack. For instance, a <code>return</code> statement always returns from the lexically scoped subroutine that surrounds it. But to do that, it may eventually have to peel back any number of layers of dynamic call frames internal to the subroutine&#39;s current call frame. The lexical scope supplies the declared target for the dynamic operation. There does not seem to be a prevailing term in the industry for this, so we&#39;ve coined the term <i>lexotic</i> to refer to these strange operations that perform a dynamic operation with a lexical target in mind. Lexotic operators in Perl 6 include:</p>

<pre><code>return
next
last
redo
goto</code></pre>

<p>Some of these operators also fall back to a purely dynamic interpretation if the lexotic interpretation doesn&#39;t work. For instance, <code>next</code> with a label will prefer to exit a loop lexotically, but if there is no loop with an appropriate label in the lexical context, it will then scan upward dynamically through the call frames for any loop with the appropriate label, even though that loop will not be lexically visible. (<code>next</code> without a label is purely dynamic.) Lexotic and dynamic control flow is implemented by a system of control exceptions. For the lexotic return of <code>next</code>, the control exception will contain the identity of the loop scope to be exited (since the label was already &#34;used up&#34; to discover that identity), but for the dynamic fallback, the exception will contain only the loop label to be matched dynamically. See <a href="#Control_Exceptions" class="podlinkpod"
>&#34;Control Exceptions&#34;</a> below.</p>

<p>The <code>redo</code> operator, as a variant of <code>goto</code>, directly transfers control to the first statement of the lexotically enclosed loop. Essentially, the compiler turns it into a <code>goto</code> with an implicitly generated (secret) label on that first statement. In order to know when that implicit label must be generated, we restrict <code>redo</code> to the current outer lexical scope. It may not be used dynamically. (If you find yourself wanting the dynamic variant, please use <code>goto</code> with an explicit label instead, so the compiler can know to pessimize any unrolling of that loop.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="The_Relationship_of_Blocks_and_Declarations"
>The Relationship of Blocks and Declarations</a></h1>

<p>Every block is a closure. (That is, in the abstract, they&#39;re all anonymous subroutines that take a snapshot of their lexical environment.) How a block is invoked and how its results are used are matters of context, but closures all work the same on the inside.</p>

<p>Blocks are delimited by curlies, or by the beginning and end of the current compilation unit (either the current file or the current <code>EVAL</code> string). Unlike in Perl 5, there are (by policy) no implicit blocks around standard control structures. (You could write a macro that violates this, but resist the urge.) Variables that mediate between an outer statement and an inner block (such as loop variables) should generally be declared as formal parameters to that block. There are three ways to declare formal parameters to a closure.</p>

<pre><code>$func = sub ($a, $b) { .print if $a eq $b };  # standard sub declaration
$func = -&#62; $a, $b { .print if $a eq $b };     # a &#34;pointy&#34; block
$func = { .print if $^a eq $^b }              # placeholder arguments</code></pre>

<p>A bare closure (except the block associated with a conditional statement) without placeholder arguments that uses <code>$_</code> (either explicitly or implicitly) is treated as though <code>$_</code> were a formal parameter:</p>

<pre><code>$func = { .print if $_ };   # Same as: $func = &#60;-&#62; $_ { .print if $_ };
$func(&#34;printme&#34;);</code></pre>

<p>In any case, all formal parameters are the equivalent of <code>my</code> variables within the block. See S06 for more on function parameters.</p>

<p>Except for such formal parameter declarations, all lexically scoped declarations are visible from the point of declaration to the end of the enclosing block. Period. Lexicals may not &#34;leak&#34; from a block to any other external scope (at least, not without some explicit aliasing action on the part of the block, such as exportation of a symbol from a module). The &#34;point of declaration&#34; is the moment the compiler sees &#34;<code>my $foo</code>&#34;, not the end of the statement as in Perl 5, so</p>

<pre><code>my $x = $x;</code></pre>

<p>will no longer see the value of the outer <code>$x</code>; you&#39;ll need to say either</p>

<pre><code>my $x = $OUTER::x;</code></pre>

<p>or</p>

<pre><code>my $x = OUTER::&#60;$x&#62;;</code></pre>

<p>instead.</p>

<p>If you declare a lexical twice in the same scope, it is the same lexical:</p>

<pre><code>my $x;
my $x;</code></pre>

<p>By default the second declaration will get a compiler warning. You may suppress this by modifying the first declaration with <code>proto</code>:</p>

<pre><code>my proto $x;
...
while my $x = @x.shift {...}              # no warning
while my $x = @x.shift {...}              # no warning</code></pre>

<p>If you&#39;ve referred to <code>$x</code> prior to the first declaration, and the compiler tentatively bound it to <code>$OUTER::x</code>, then it&#39;s an error to declare it, and the compiler is required to complain at that point. If such use can&#39;t be detected because it is hidden in an <code>EVAL</code>, then it is erroneous, since the <code>EVAL()</code> compiler might bind to either <code>$OUTER::x</code> or the subsequently declared &#34;<code>my $x</code>&#34;.</p>

<p>As in Perl 5, &#34;<code>our $foo</code>&#34; introduces a lexically scoped alias for a variable in the current package.</p>

<p>The new <code>constant</code> declarator introduces a compile-time constant, either a variable or named value, which may be initialized with a pseudo-assignment:</p>

<pre><code>constant $pi of Int = 3;
my Num constant &#960; = atan2(2,2) * 4;</code></pre>

<p>The initializing expression is evaluated at <code>BEGIN</code> time. Constants (and enums) default to <code>our</code> scoping so they can be accessed from outside the package.</p>

<p>There is a new <code>state</code> declarator that introduces a lexically scoped variable like <code>my</code> does, but with a lifetime that persists for the life of the closure, so that it keeps its value from the end of one call to the beginning of the next. Separate clones of the closure get separate state variables. However, recursive calls to the same clone use the same state variable.</p>

<p>Perl 5&#39;s &#34;<code>local</code>&#34; function has been renamed to <code>temp</code> to better reflect what it does. There is also a <code>let</code> prefix operator that sets a hypothetical value. It works exactly like <code>temp</code>, except that the value will be restored only if the current block exits unsuccessfully. (See Definition of Success below for more.) <code>temp</code> and <code>let</code> temporize or hypotheticalize the value or the variable depending on whether you do assignment or binding. One other difference from Perl 5 is that the default is not to undefine a variable. So</p>

<pre><code>temp $x;</code></pre>

<p>causes <code>$x</code> to start with its current value. Use</p>

<pre><code>undefine temp $x;</code></pre>

<p>to get the Perl 5 behavior.</p>

<p>Note that temporizations that are undone upon scope exit must be prepared to be redone if a continuation within that scope is taken.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="The_Relationship_of_Blocks_and_Statements"
>The Relationship of Blocks and Statements</a></h1>

<p>In the absence of explicit control flow terminating the block early, the return value of a block is the value of its final statement. This is defined as the textually last statement of its top-level list of statements; any statements embedded within those top-level statements are in their own lower-level list of statements and, while they may be a final statement in their subscope, they&#39;re not considered the final statement of the outer block in question.</p>

<p>This is subtly different from Perl 5&#39;s behavior, which was to return the value of the last expression evaluated, even if that expression was just a conditional. Unlike in Perl 5, if a final statement in Perl 6 is a conditional that does not execute any of its branches, it doesn&#39;t matter what the value of the conditional is, the value of that conditional statement is always <code>()</code>. If there are no statements in the block at all, the result is also <code>()</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Statement-ending_blocks"
>Statement-ending blocks</a></h1>

<p>A line ending with a closing brace &#34;<code>}</code>&#34;, followed by nothing but whitespace or comments, will terminate a statement if an end of statement can occur there. That is, these two statements are equivalent:</p>

<pre><code>my $x = sub { 3 }
my $x = sub { 3 };</code></pre>

<p>Since bracketed expressions consider their insides to be statements, this works out consistently even where you might expect problems:</p>

<pre><code>my $x = [
    sub { 3 },  # this comma is not optional
    sub { 3 }   # the statement inside [] terminates here
];

my $hash = {
    1 =&#62; { 2 =&#62; 3, 4 =&#62; 5 },  # OK
    2 =&#62; { 6 =&#62; 7, 8 =&#62; 9 }   # OK, terminates inner statement
};</code></pre>

<p>Because subroutine declarations are expressions, not statements, this is now invalid:</p>

<pre><code>sub f { 3 } sub g { 3 }     # two terms occur in a row</code></pre>

<p>But these two are valid:</p>

<pre><code>sub f { 3 }; sub g { 3 };
sub f { 3 }; sub g { 3 }    # the trailing semicolon is optional</code></pre>

<p>Though certain control statements could conceivably be parsed in a self-contained way, for visual consistency all statement-terminating blocks that end in the middle of a line <i>must</i> be terminated by semicolon unless they are naturally terminated by some other statement terminator:</p>

<pre><code>while yin() { yang() }  say &#34;done&#34;;      # ILLEGAL
while yin() { yang() }; say &#34;done&#34;;      # okay, explicit semicolon
@yy := [ while yin() { yang() } ];       # okay within outer [...]
while yin() { yang() } ==&#62; sort          # okay, ==&#62; separates statements</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Conditional_statements"
>Conditional statements <!--
	INDEX: if
--><!--
	INDEX: unless
--></a></h1>

<p>The <code>if</code> and <code>unless</code> statements work much as they do in Perl 5. However, you may omit the parentheses on the conditional:</p>

<pre><code>if $foo == 123 {
    ...
}
elsif $foo == 321 {
    ...
}
else {
    ...
}</code></pre>

<p>The result of a conditional statement is the result of the block chosen to execute. If the conditional does not execute any branch, the return value is <code>()</code>.</p>

<p>The <code>unless</code> statement does not allow an <code>elsif</code> or <code>else</code> in Perl 6.</p>

<p>The value of the conditional expression may be optionally bound to a closure parameter:</p>

<pre><code>if    testa() -&#62; $a { say $a }
elsif testb() -&#62; $b { say $b }
else          -&#62; $b { say $b }</code></pre>

<p>Note that the value being evaluated for truth and subsequently bound is not necessarily a value of type <code>Bool</code>. (All normal types in Perl may be evaluated for truth. In fact, this construct would be relatively useless if you could bind only boolean values as parameters, since within the closure you already know whether it evaluated to true or false.) Binding within an <code>else</code> automatically binds the value tested by the previous <code>if</code> or <code>elsif</code>, which, while known to be false, might nevertheless be an <i>interesting</i> value of false. (By similar reasoning, an <code>unless</code> allows binding of a false parameter.)</p>

<p>An explicit placeholder may also be used:</p>

<pre><code>if blahblah() { return $^it }</code></pre>

<p>However, use of <code>$_</code> with a conditional or conditionally repeating statement&#39;s block is <i>not</i> considered sufficiently explicit to turn a 0-ary block into a 1-ary function, so all these methods use the same invocant:</p>

<pre><code>if .haste { .waste }
while .haste { .waste }</code></pre>

<p>(Contrast with a non-conditional statement such as:</p>

<pre><code>for .haste { .waste }</code></pre>

<p>where each call to the block would bind a new invocant for the <code>.waste</code> method, each of which is likely different from the original invocant to the <code>.haste</code> method.)</p>

<p>Conditional statement modifiers work as in Perl 5. So do the implicit conditionals implied by short-circuit operators. Note though that the contents of parens or brackets is parsed as a statement, so you can say:</p>

<pre><code>@x = 41, (42 if $answer), 43;</code></pre>

<p>and that is equivalent to:</p>

<pre><code>@x = 41, ($answer ?? 42 !! ()), 43</code></pre>

<p>(Only a single statement is allowed inside parens or brackets; otherwise it will be interpreted as a LoL composer. See <a href="http://search.cpan.org/perldoc?S02#Multidimensional_slices_and_parcels" class="podlinkpod"
>&#34;Multidimensional slices and parcels&#34; in S02</a>.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Loop_statements"
>Loop statements</a></h1>

<p>Looping statement modifiers are the same as in Perl 5 except that, for ease of writing list comprehensions, a looping statement modifier is allowed to contain a single conditional statement modifier:</p>

<pre><code>@evens = ($_ * 2 if .odd for 0..100);</code></pre>

<p>Loop modifiers <code>next</code>, <code>last</code>, and <code>redo</code> also work much as in Perl 5. However, the labeled forms can use method call syntax: <code>LABEL.next</code>, etc. The <code>.next</code> and <code>.last</code> methods take an optional argument giving the final value of that loop iteration. So the old <code>next LINE</code> syntax is still allowed but really does something like <code>LINE.next(())</code> underneath. Any block object can be used, not just labels, so to return a value from this iteration of the current block you can say:</p>

<pre><code>&#38;?BLOCK.next($retval);</code></pre>

<p>[Conjecture: a bare <code>next($retval)</code> function could be taught to do the same, as long as <code>$retval</code> isn&#39;t a loop label. Presumably multiple dispatch could sort this out.]</p>

<p>With a target object or label, loop modifiers search lexotically for the scope to modify. Without a target, however, they are purely dynamic, and choose the innermost dynamic loop, which may well be a <code>map</code> or other implicitly looping function, including user-defined functions.</p>

<p>There is no longer a <code>continue</code> block. Instead, use a <code>NEXT</code> block within the body of the loop. See below.</p>

<p>The value of a loop statement is the list of values from each iteration. Each iteration&#39;s value is returned as a single &#34;argument&#34; object. See <a href="http://search.cpan.org/perldoc?S02" class="podlinkpod"
>S02</a> for a long definition of argument, but in short, it&#39;s either an ordinary object or a parcel containing multiple values.</p>

<p>Normal flat list context ignores parcel boundaries and flattens the list. Slice context turns any parcel objects into <code>Seq</code> objects.</p>

<p>Iterations that return <code>()</code> (such as by calling <code>next</code> with no extra return arguments) return that <code>()</code> as the next value, which will therefore disappear when interpolated in flat context, but will interpolate an empty <code>Parcel</code> into slice context.</p>

<p>For finer-grained control of which iterations return values, use <code>gather</code> and <code>take</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_while_and_until_statements"
>The <code>while</code> and <code>until</code> statements <!--
	INDEX: while
--><!--
	INDEX: until
--></a></h2>

<p>The <code>while</code> and <code>until</code> statements work as in Perl 5, except that you may leave out the parentheses around the conditional:</p>

<pre><code>while $bar &#60; 100 {
    ...
}</code></pre>

<p>As with conditionals, you may optionally bind the result of the conditional expression to a parameter of the block:</p>

<pre><code>while something() -&#62; $thing {
    ...
}

while something() { ... $^thing ... }</code></pre>

<p>Nothing is ever bound implicitly, however, and many conditionals would simply bind <code>True</code> or <code>False</code> in an uninteresting fashion. This mechanism is really only good for objects that know how to return a boolean value and still remain themselves. In general, for most iterated solutions you should consider using a <code>for</code> loop instead (see below). In particular, we now generally use <code>for</code> to iterate filehandles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_repeat_statement"
>The <code>repeat</code> statement <!--
	INDEX: repeat
--><!--
	INDEX: while
--><!--
	INDEX: next
--><!--
	INDEX: last
--><!--
	INDEX: redo
--></a></h2>

<p>Unlike in Perl 5, applying a statement modifier to a <code>do</code> block is specifically disallowed:</p>

<pre><code>do {
    ...
} while $x &#60; 10;    # ILLEGAL</code></pre>

<p>Instead, you should write the more Pascal-like <code>repeat</code> loop:</p>

<pre><code>repeat {
    ...
} while $x &#60; 10;</code></pre>

<p>or equivalently:</p>

<pre><code>repeat {
    ...
} until $x &#62;= 10;</code></pre>

<p>Unlike Perl 5&#39;s <code>do-while</code> loop, this is a real loop block now, so <code>next</code>, <code>last</code>, and <code>redo</code> work as expected. The loop conditional on a <code>repeat</code> block is required, so it will be recognized even if you put it on a line by its own:</p>

<pre><code>repeat
{
    ...
}
while $x &#60; 10;</code></pre>

<p>However, that&#39;s likely to be visually confused with a following <code>while</code> loop at the best of times, so it&#39;s also allowed to put the loop conditional at the front, with the same meaning. (The <code>repeat</code> keyword forces the conditional to be evaluated at the end of the loop, so it&#39;s still C&#39;s <code>do-while</code> semantics.) Therefore, even under GNU style rules, the previous example may be rewritten into a very clear:</p>

<pre><code>repeat while $x &#60; 10
  {
    ...
  }</code></pre>

<p>or equivalently:</p>

<pre><code>repeat until $x &#62;= 10
  {
    ...
  }</code></pre>

<p>As with an ordinary <code>while</code>, you may optionally bind the result of the conditional expression to a parameter of the block:</p>

<pre><code>repeat -&#62; $thing {
    ...
} while something();</code></pre>

<p>or</p>

<pre><code>repeat while something() -&#62; $thing {
    ...
}</code></pre>

<p>Since the loop executes once before evaluating the condition, the bound parameter will be undefined that first time through the loop.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_general_loop_statement"
>The general loop statement <!--
	INDEX: loop
--></a></h2>

<p>The <code>loop</code> statement is the C-style <code>for</code> loop in disguise:</p>

<pre><code>loop ($i = 0; $i &#60; 10; $i++) {
    ...
}</code></pre>

<p>As in C, the parentheses are required if you supply the 3-part spec; however, the 3-part loop spec may be entirely omitted to write an infinite loop. That is,</p>

<pre><code>loop {...}</code></pre>

<p>is equivalent to the Cish idiom:</p>

<pre><code>loop (;;) {...}</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_for_statement"
>The <code>for</code> statement <!--
	INDEX: for
--><!--
	INDEX: zip
--><!--
	INDEX: Z
--><!--
	INDEX: STDIN
--><!--
	INDEX: $*IN
--><!--
	INDEX: lines
--></a></h2>

<p>There is no <code>foreach</code> statement any more. It&#39;s always spelled <code>for</code> in Perl 6, so it always takes a list as an argument:</p>

<pre><code>for @foo { .print }</code></pre>

<p>As mentioned earlier, the loop variable is named by passing a parameter to the closure:</p>

<pre><code>for @foo -&#62; $item { print $item }</code></pre>

<p>Multiple parameters may be passed, in which case the list is traversed more than one element at a time:</p>

<pre><code>for %hash.kv -&#62; $key, $value { print &#34;$key =&#62; $value\n&#34; }</code></pre>

<p>To process two arrays in parallel use the <code>zip</code> function to generate a list that can be bound to the corresponding number of parameters:</p>

<pre><code>for zip(@a;@b) -&#62; $a, $b { print &#34;[$a, $b]\n&#34; }
for @a Z @b -&#62; $a, $b { print &#34;[$a, $b]\n&#34; }        # same thing</code></pre>

<p>The list is evaluated lazily by default, so instead of using a <code>while</code> to read a file a line at a time as you would in Perl 5:</p>

<pre><code>while (my $line = &#60;STDIN&#62;) {...}</code></pre>

<p>in Perl 6 you should use a <code>for</code> instead:</p>

<pre><code>for $*IN.lines -&#62; $line {...}</code></pre>

<p>This has the added benefit of limiting the scope of the <code>$line</code> parameter to the block it&#39;s bound to. (The <code>while</code>&#39;s declaration of <code>$line</code> continues to be visible past the end of the block. Remember, no implicit block scopes.) It is also possible to write</p>

<pre><code>while $*IN.get -&#62; $line {...}</code></pre>

<p>However, this is likely to fail on autochomped filehandles, so use the <code>for</code> loop instead.</p>

<p>Note also that Perl 5&#39;s special rule causing</p>

<pre><code>while (&#60;&#62;) {...}</code></pre>

<p>to automatically assign to <code>$_</code> is not carried over to Perl 6. That should now be written:</p>

<pre><code>for lines() {...}</code></pre>

<p>which is short for</p>

<pre><code>for lines($*ARGFILES) {...}</code></pre>

<p>Arguments bound to the formal parameters of a pointy block are by default readonly within the block. You can declare a parameter read/write by including the &#34;<code>is rw</code>&#34; trait. The following treats every other value in <code>@values</code> as modifiable:</p>

<pre><code>for @values -&#62; $even is rw, $odd { ... }</code></pre>

<p>In the case where you want all your parameters to default to <code>rw</code>, you may use the visually suggestive double-ended arrow to indicate that values flow both ways:</p>

<pre><code>for @values &#60;-&#62; $even, $odd { ... }</code></pre>

<p>This is equivalent to</p>

<pre><code>for @values -&#62; $even is rw, $odd is rw { ... }</code></pre>

<p>If you rely on <code>$_</code> as the implicit parameter to a block, then <code>$_</code> is considered read/write by default. That is, the construct:</p>

<pre><code>for @foo {...}</code></pre>

<p>is actually short for:</p>

<pre><code>for @foo &#60;-&#62; $_ {...}</code></pre>

<p>so you can modify the current list element in that case.</p>

<p>When used as statement modifiers on implicit blocks (thunks), <code>for</code> and <code>given</code> privately temporize the current value of <code>$_</code> for the left side of the statement and restore the original value at loop exit:</p>

<pre><code>$_ = 42;
.say             # 42
.say for 1,2,3;  # 1,2,3
.say;            # 42</code></pre>

<p>The previous value of <code>$_</code> is not available within the loop. If you want it to be available, you must rewrite it as an explicit block using curlies:</p>

<pre><code>{ say OUTER::&#60;$_&#62;, $_ } for 1,2,3;  # 421,422,423</code></pre>

<p>No temporization is necessary with the explicit form since <code>$_</code> is a formal parameter to the block. Likewise, temporization is never needed for <code>statement_control:&#60;for&#62;</code> because it always calls a closure.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_do-once_loop"
>The do-once loop</a></h2>

<p>In Perl 5, a bare block is deemed to be a do-once loop. In Perl 6, the bare block is not a do-once. Instead <code>do {...}</code> is the do-once loop (which is another reason you can&#39;t put a statement modifier on it; use <code>repeat</code> for a test-at-the-end loop).</p>

<p>For any statement, prefixing with a <code>do</code> allows you to return the value of that statement and use it in an expression:</p>

<pre><code>$x = do if $a { $b } else { $c };</code></pre>

<p>This construct only allows you to attach a single statement to the end of an expression. If you want to continue the expression after the statement, or if you want to attach multiple statements, you must either use the curly form or surround the entire expression in brackets of some sort:</p>

<pre><code>@primesquares = (do $_ if .is-prime for 1..100) &#187;**&#187; 2;</code></pre>

<p>Since a bare expression may be used as a statement, you may use <code>do</code> on an expression, but its only effect is to function as an unmatched left parenthesis, much like the <code>$</code> operator in Haskell. That is, precedence decisions do not cross a <code>do</code> boundary, and the missing &#34;right paren&#34; is assumed at the next statement terminator or unmatched bracket. A <code>do</code> is unnecessary immediately after any opening bracket as the syntax inside brackets expects a statements, so the above can in fact be written:</p>

<pre><code>@primesquares = ($_ if .is-prime for 1..100) &#187;**&#187; 2;</code></pre>

<p>This basically gives us list comprehensions as rvalue expressions:</p>

<pre><code>(for 1..100 { $_ if .is-prime }).say</code></pre>

<p>Another consequence of this is that any block just inside a left parenthesis is immediately called like a bare block, so a multidimensional list comprehension may be written using a block with multiple parameters fed by a <code>for</code> modifier:</p>

<pre><code>@names = (-&#62; $name, $num { &#34;$name.$num&#34; } for &#39;a&#39;..&#39;zzz&#39; X 1..100);</code></pre>

<p>or equivalently, using placeholders:</p>

<pre><code>@names = ({ &#34;$^name.$^num&#34; } for &#39;a&#39;..&#39;zzz&#39; X 1..100);</code></pre>

<p>Since <code>do</code> is defined as going in front of a statement, it follows that it can always be followed by a statement label. This is particularly useful for the do-once block, since it is officially a loop and can take therefore loop control statements.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Loops_at_the_statementlist_level_vs_the_statement_level"
>Loops at the statementlist level vs the statement level</a></h2>

<p>In any sequence of statements, only the value of the final statement is returned, so all prior statements are evaluated in sink context, which is automatically eager, to force the evaluation of side effects. (Side effects are the only reason to execute such statements in the first place, and Perl will, in fact, warn you if you do something that is &#34;useless&#34; in sink context.) A loop in sink context not only evaluates itself eagerly, but can optimize away the production of any values from the loop.</p>

<p>The final statement of a statement list is not a sink context, and can return any value including a lazy list. However, to support the expectations of imperative programmers (the vast majority of us, it turns out), any explicit loop found as the final statement of a statement list is automatically forced to use sink semantics so that the loop executes to completion before returning from the block.</p>

<p>This forced sink context is applied to loops <i>only</i> at the statement list level, that is, at the top level of a compilation unit, or directly inside a block. Constructs that parse a single statement or semilist as an argument are presumed to want the results of that statement, so such constructs remain lazy even when that statement is a loop. Assuming each of the following statements is the final statement in a block, &#34;sunk&#34; loops such as these may be indicated:</p>

<pre><code>for LIST { ... }
... if COND for LIST 
loop { ... }
... while COND
while COND { ... }
repeat until COND { ... }</code></pre>

<p>but lazy loops can be indicated by putting the loop in parens or brackets:</p>

<pre><code>(... if COND for LIST)      # lazy list comprehension
[for LIST { ... }] 
(loop { ... })</code></pre>

<p>or by use of either a statement prefix or a phaser in statement form:</p>

<pre><code>lazy for LIST { ... }
ENTER for LIST { ... }</code></pre>

<p>Note that the corresponding block forms put the loop into a statement list, so these loops are evaluated in sink context:</p>

<pre><code>lazy { for LIST { ... } }   # useless use of &#39;lazy&#39; here
ENTER { for LIST { ... } }</code></pre>

<p>It doesn&#39;t matter that there is only one statement there; what matters is that a sequence of statements is expected there by the grammar.</p>

<p>An eager loop may likewise be indicated by using the <code>eager</code> statement prefix:</p>

<pre><code>eager for LIST { ... }
eager ... if COND for LIST 
eager loop { ... }
eager ... while COND
eager while COND { ... }
eager repeat until COND { ... }</code></pre>

<p>It is erroneous to write an eager loop without a loop exit, since that will chew up all your memory.</p>

<p>Note that since <code>do</code> is considered a one-time loop, it is always evaluated eagerly, despite being a statement prefix. This is no great hardship; the <code>lazy</code> prefix is better documentation in any case. And surely the verb &#34;do&#34; ought to imply some degree of getting it done eagerly.</p>

<p>The <code>given</code> construct is not considered a loop, and just returns normally.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Statement-level_bare_blocks"
>Statement-level bare blocks</a></h2>

<p>Although a bare block occurring as a single statement is no longer a do-once loop, as with loops when used in a statement list, it still executes immediately as in Perl 5, as if it were immediately dereferenced with a <code>.()</code> postfix, so within such a block <code>CALLER::</code> refers to the dynamic scope associated with the lexical scope surrounding the block.</p>

<p>If you wish to return a closure from a function, you must use an explicit prefix such as <code>return</code> or <code>sub</code> or <code>-&#62;</code>.</p>

<pre><code>sub f1
{
    # lots of stuff ...
    { say &#34;I&#39;m a closure.&#34; }
}

my $x1= f1;  # fall-off return is result of the say, not the closure.

sub f2
{
    # lots of stuff ...
    return { say &#34;I&#39;m a closure.&#34; }
}

my $x2= f2;  # returns a Block object.</code></pre>

<p>Use of a placeholder parameter in statement-level blocks triggers a syntax error, because the parameter is not out front where it can be seen. However, it&#39;s not an error when prefixed by a <code>do</code>, or when followed by a statement modifier:</p>

<pre><code># Syntax error: Statement-level placeholder block
{ say $^x };

# Not a syntax error, though $x doesn&#39;t get the argument it wants
do { say $^x };

# Not an error: Equivalent to &#34;for 1..10 -&#62; $x { say $x }&#34;
{ say $^x } for 1..10;

# Not an error: Equivalent to &#34;if foo() -&#62; $x { say $x }&#34;
{ say $^x } if foo();</code></pre>

<p>It&#39;s not an error to pass parameters to such a block either:</p>

<pre><code>{ say $^x + $^x }(5);</code></pre>

<p>But as always, you must use them all:</p>

<pre><code># Syntax error: Too many positional parameters passed
{ say $^x + $^x }(5,6);</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_gather_statement_prefix"
>The <code>gather</code> statement prefix <!--
	INDEX: gather
--><!--
	INDEX: take
--></a></h2>

<p>A variant of <code>do</code> is <code>gather</code>. Like <code>do</code>, it is followed by a statement or block, and executes it once. Unlike <code>do</code>, it evaluates the statement or block in sink (void) context; its return value is instead specified by calling the <code>take</code> list prefix operator one or more times within the scope (either lexical or dynamic) of the <code>gather</code>. The <code>take</code> function&#39;s signature is like that of <code>return</code>; while having the syntax of a list operator, it merely returns a single item or &#34;argument&#34; (see <a href="http://search.cpan.org/perldoc?S02" class="podlinkpod"
>S02</a> for definition).</p>

<p>The <code>take</code> function is lexotic if there is a visible outer <code>gather</code>, but falls back to purely dynamic if not. Well, it doesn&#39;t really fall back, since a <code>take</code> knows at compile time whether it is being used lexically or dynamically. Less obviously, so does a <code>gather</code>; if a <code>gather</code> lexically contains any <code>take</code> calls, it is marked as lexotic-only, and it will be invisible to a dynamic <code>take</code>. If the <code>gather</code> contains no <code>take</code> lexically, it by definition cannot be the lexotic target of any <code>take</code>, so it can only harvest dynamic <code>take</code> calls. The only remaining difficulty arises if both the user and a library writer attempt to use dynamic gather with user-defined callbacks that contain <code>take</code>. So we will say that it is erroneous for a library writer to mix dynamic gather with callbacks unless those callbacks are somehow &#34;ungathered&#34; to the outer dynamic scope. [Conjecture: there should either be an <code>callergather</code> primitive that does this, or we should allow labeled <code>gather</code>/<code>take</code> for such a situation, and dynamic <code>take</code> must match the <code>gather</code>&#39;s label (or lack thereof) exactly. (Using the term &#34;label&#34; loosely, to include other solutions besides the label syntax, such as .gather and .take methods on some identity object.)]</p>

<p>If you take multiple items in a comma list (since it is, after all, a list operator), they will be wrapped up in a <code>Parcel</code> object for return as the next argument. No additional context is applied by the <code>take</code> operator, since all context is lazy in Perl 6. The flattening or slicing of any such returned parcel will be dependent on how the <code>gather</code>&#39;s return iterator is iterated (with <code>.get</code> vs <code>.getarg</code>).</p>

<p>The value returned by the <code>take</code> to the <code>take</code>&#39;s own context is that same returned argument (which is ignored when the <code>take</code> is in sink context). Regardless of the <code>take</code>&#39;s immediate context, the object returned is also added to the list of values being gathered, which is returned by the <code>gather</code> as a lazy list (that is, an iterator, really), with each argument element of that list corresponding to one <code>take</code>.</p>

<p>Any parcels in the returned list are normally flattened when bound into flat context. When bound into a lol context, however, the parcel objects become real <code>List</code> objects that keep their identity as discrete sublists. The eventual binding context thus determines whether to throw away or keep the groupings resulting from each individual <code>take</code> call. Most list contexts are flat rather than sliced, so the boundaries between individual <code>take</code> calls usually disappear. (FLAT is an acronym meaning Flat Lists Are Typical. :)</p>

<p>Because <code>gather</code> evaluates its block or statement in sink context, this typically causes the <code>take</code> function to be evaluated in sink context. However, a <code>take</code> function that is not in sink context gathers its return objects <i>en passant</i> and also returns them unchanged. This makes it easy to keep track of what you last &#34;took&#34;:</p>

<pre><code>my @uniq = gather for @list {
    state $previous = take $_;
    next if $_ === $previous;
    $previous = take $_;
}</code></pre>

<p>The <code>take</code> function essentially has two contexts simultaneously, the context in which the <code>gather</code> is operating, and the context in which the <code>take</code> is operating. These need not be identical contexts, since they may bind or coerce the resulting parcels differently:</p>

<pre><code>my @y;
my @x = gather for 1..2 {            # flat context for list of parcels
    my ($y) := \(take $_, $_ * 10);  # binding forces item context
    push @y, $y;
}
# @x contains 4 Ints:    1,10,2,20 flattened by list assignment to @x
# @y contains 2 Parcels: $(1,10),$(2,20) sliced by binding to positional $y</code></pre>

<p>Likewise, we can just remember the gather&#39;s result parcel by binding and later coercing it:</p>

<pre><code>my ($c) := \(gather for 1..2 {
    take $_, $_ * 10;
});
# $c.flat produces 1,10,2,20 -- flatten fully into a list of Ints.
# $c.lol produces LoL.new($(1,10),$(2,20)) -- list of Parcels, a 2-D list.
# $c.item produces ($(1,10),$(2,20)).list.item -- a list of Parcels, as an item.</code></pre>

<p>Note that the <code>take</code> itself is in sink context in this example because the <code>for</code> loop is in the sink context provided inside the gather.</p>

<p>A <code>gather</code> is not considered a loop, but it is easy to combine with a loop statement as in the examples above.</p>

<p>The <code>take</code> operation may be defined internally using resumable control exceptions, or dynamic variables, or pigeons carrying clay tablets. The choice any particular implementation makes is specifically <i>not</i> part of the definition of Perl 6, and you should not rely on it in portable code.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Other_do-like_forms"
>Other <code>do</code>-like forms <!--
	INDEX: do
--></a></h2>

<p>Other similar forms, where a keyword is followed by code to be controlled by it, may also take bare statements, including <code>try</code>, <code>once</code>, <code>quietly</code>, <code>start</code>, <code>lazy</code>, and <code>sink</code>. These constructs establish a dynamic scope without necessarily establishing a lexical scope. (You can always establish a lexical scope explicitly by using the block form of argument.) As statement introducers, all these keywords must be followed by whitespace. (You can say something like <code>try({...})</code>, but then you are calling the <code>try()</code> function using function call syntax instead, and since Perl does not supply such a function, it will be assumed to be a user-defined function.) For purposes of flow control, none of these forms are considered loops, but they may easily be applied to a normal loop.</p>

<p>Note that any construct in the statement_prefix category defines special syntax. If followed by a block it does not parse as a list operator or even as a prefix unary; it will never look for any additional expression following the block. In particular,</p>

<pre><code>foo( try {...}, 2, 3 )</code></pre>

<p>calls the <code>foo</code> function with three arguments. And</p>

<pre><code>do {...} + 1</code></pre>

<p>add 1 to the result of the do block. On the other hand, if a statement_prefix is followed by a non-block statement, all nested blockless statement_prefixes will terminate at the same statement ending:</p>

<pre><code>do do do foo(); bar 43;</code></pre>

<p>is parsed as:</p>

<pre><code>do { do { do { foo(); }}}; bar(43);</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Switch_statements"
>Switch statements <!--
	INDEX: given
--><!--
	INDEX: when
--><!--
	INDEX: switch
--><!--
	INDEX: case
--><!--
	INDEX: default
--></a></h1>

<p>A switch statement is a means of topicalizing, so the switch keyword is the English topicalizer, <code>given</code>. The keyword for individual cases is <code>when</code>:</p>

<pre><code>given EXPR {
    when EXPR { ... }
    when EXPR { ... }
    default { ... }
}</code></pre>

<p>The current topic is always aliased to the special variable <code>$_</code>. The <code>given</code> block is just one way to set the current topic, but a switch statement can be any block that sets <code>$_</code>, including a <code>for</code> loop (assuming one of its loop variables is bound to <code>$_</code>) or the body of a method (if you have declared the invocant as <code>$_</code>). So switching behavior is actually caused by the <code>when</code> statements in the block, not by the nature of the block itself. A <code>when</code> statement implicitly does a &#34;smart match&#34; between the current topic (<code>$_</code>) and the argument of the <code>when</code>. If the smart match succeeds, <code>when</code>&#39;s associated block is executed, and the innermost surrounding block that has <code>$_</code> as one of its formal parameters (either explicit or implicit) is automatically broken out of. (If that is not the block you wish to leave, you must use the <code>LABEL.leave</code> method (or some other control exception such as <code>return</code> or <code>next</code>) to be more specific, since the compiler may find it difficult to guess which surrounding construct was intended as the actual topicalizer.) The value of the inner block is returned as the value of the outer block.</p>

<p>If the smart match fails, control proceeds the next statement normally, which may or may not be a <code>when</code> statement. Since <code>when</code> statements are presumed to be executed in order like normal statements, it&#39;s not required that all the statements in a switch block be <code>when</code> statements (though it helps the optimizer to have a sequence of contiguous <code>when</code> statements, because then it can arrange to jump directly to the first appropriate test that might possibly match.)</p>

<p>The default case:</p>

<pre><code>default {...}</code></pre>

<p>is exactly equivalent to</p>

<pre><code>when * {...}</code></pre>

<p>Because <code>when</code> statements are executed in order, the default must come last. You don&#39;t have to use an explicit default--you can just fall off the last <code>when</code> into ordinary code. But use of a <code>default</code> block is good documentation.</p>

<p>If you use a <code>for</code> loop with a parameter named <code>$_</code> (either explicitly or implicitly), that parameter can function as the topic of any <code>when</code> statements within the loop.</p>

<p>You can explicitly break out of a <code>when</code> block (and its surrounding topicalizer block) early using the <code>succeed</code> verb. More precisely, it first scans outward (lexically) for the innermost containing <code>when</code> block. From there it continues to scan outward to find the innermost block outside the <code>when</code> that defines <code>$_</code>, either explicitly or implicitly. (Note that both of these scans are done at compile time; if the scans fail, it&#39;s a compile-time semantic error.) Typically, such an outer block will be the block of a <code>given</code> or a <code>for</code> statement, but any block that sets the topic can be broken out of. At run time, <code>succeed</code> uses a control exception to scan up the dynamic chain to find the call frame belonging to that same outer block, and when it has found that frame, it does a <code>.leave</code> on it to unwind the call frames. If any arguments are supplied to the <code>succeed</code> function, they are passed out via the <code>leave</code> method. Since leaving a block is considered a successful return, breaking out of one with <code>succeed</code> is also considered a successful return for the purposes of <code>KEEP</code> and <code>UNDO</code>.</p>

<p>The implicit break of a normal <code>when</code> block works the same way, returning the value of the entire block (normally from its last statement) via an implicit <code>succeed</code>.</p>

<p>You can explicitly leave a <code>when</code> block and go to the next statement following the <code>when</code> by using <code>proceed</code>. (Note that, unlike C&#39;s idea of &#34;falling through&#34;, subsequent <code>when</code> conditions are evaluated. To jump into the next <code>when</code> block without testing its condition, you must use a <code>goto</code>. But generally that means you should refactor instead.)</p>

<p>If you have a switch that is the main block of a <code>for</code> loop that uses <code>$_</code> as its loop variable, and you break out of the switch either implicitly or explicitly (that is, the switch &#34;succeeds&#34;), control merely goes to the end of that block, and thence on to the next iteration of the loop. You must use <code>last</code> (or some more violent control exception such as <code>return</code>) to break out of the entire loop early. Of course, an explicit <code>next</code> might be clearer than a <code>succeed</code> if you really want to go directly to the next iteration. On the other hand, <code>succeed</code> can take an optional argument giving the value for that iteration of the loop. As with the <code>.leave</code> method, there is also a <code>.succeed</code> method to break from a labelled block functioning as a switch:</p>

<pre><code>OUTER.succeed($retval)</code></pre>

<p>There is a <code>when</code> statement modifier, but it does not have any breakout semantics; it is merely a smartmatch against the current topic. That is,</p>

<pre><code>doit() when 42;</code></pre>

<p>is exactly equivalent to</p>

<pre><code>doit() if $_ ~~ 42;</code></pre>

<p>This is particularly useful for list comprehensions:</p>

<pre><code>@lucky = ($_ when /7/ for 1..100);</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Exception_handlers"
>Exception handlers <!--
	INDEX: CATCH
--></a></h1>

<p>Unlike many other languages, Perl 6 specifies exception handlers by placing a <code>CATCH</code> block <i>within</i> that block that is having its exceptions handled.</p>

<p>The Perl 6 equivalent to Perl 5&#39;s <code>eval {...}</code> is <code>try {...}</code>. (Perl 6&#39;s <code>EVAL</code> function only evaluates strings, not blocks, and does not catch exceptions.) A <code>try</code> block by default has a <code>CATCH</code> block that handles all fatal exceptions by ignoring them. If you define a <code>CATCH</code> block within the <code>try</code>, it replaces the default <code>CATCH</code>. It also makes the <code>try</code> keyword redundant, because any block can function as a <code>try</code> block if you put a <code>CATCH</code> block within it. To prevent lazy lists for leaking out unexpectedly, the inside of a <code>try</code> is always considered an eager context, unless the <code>try</code> itself is in a sink context, in which case the inside of <code>try</code> is also in sink context.</p>

<p>Additionally, the <code>try</code> block or statement implicitly enforces a <code>use fatal</code> context such that failures are immediately thrown as exceptions. (See below.)</p>

<p>An exception handler is just a switch statement on an implicit topic that happens to be the current exception to be dealt with. Inside the <code>CATCH</code> block, the exception in question is bound to <code>$_</code>. Because of smart matching, ordinary <code>when</code> statements are sufficiently powerful to pattern match the current exception against classes or patterns or numbers without any special syntax for exception handlers. If none of the cases in the <code>CATCH</code> handles the exception, the exception will be rethrown. To ignore all unhandled exceptions, use an empty <code>default</code> case. (In other words, there is an implicit <code>.die</code> just inside the end of the <code>CATCH</code> block. Handled exceptions break out past this implicit rethrow.) Hence, <code>CATCH</code> is unlike all other switch statements in that it treats code inside a <code>default</code> block differently from code that&#39;s after all the <code>when</code> blocks but not in a <code>default</code> block.</p>

<p>More specifically, when you write:</p>

<pre><code>CATCH {
    when Mumble {...}
    default {...}
}</code></pre>

<p>you&#39;re really calling into a <i>catch lambda</i> that works something like this:</p>

<pre><code>-&#62; *@! {
    my @handled = ();
    my @unhandled = ();
    my @*undead = ();

    for @! {
        # note, fails current iteration, continues with loop
        SIMPLECATCH { push @*undead, $_; push @unhandled, OUTER::&#60;$_&#62;; }

        .handled = True;
        when Mumble {...}
        default {...}
        .handled = False;

        push @unhandled, $_;

        KEEP { push @handled, $_ if .handled }
    }

    push @unhandled, @*undead;

    # no point in setting their $! if we&#39;re gonna blow past
    set_outer_caller&#39;s_bang(@handled) unless @unhandled;

    @unhandled;
}</code></pre>

<p>Whenever an exception occurs during the execution of a handler, it is pushed onto the end of the <code>@*undead</code> array for later processing by an outer handler. If there are any unhandled <code>@!</code> exceptions, or if any exceptions were caught by the inner SIMPLECATCH (which does nothing but runs its push code, which should not produce any exceptions), then the CATCH block returns them to the exception thrower.</p>

<p>The exception thrower looks up the call stack for a catch lambda that returns () to indicate all exceptions are handled, and then it is happy, and unwinds the stack to that point. If any exceptions are returned as not handled, the exception thrower keeps looking for a higher dynamic scope for a spot to unwind to. Note that any <code>die</code> in the catch lambda eventually rethrows outside the lambda as a new exception, but not until the current exception handler has a chance to handle all exceptions that came in via <code>@!</code>.</p>

<p>Resumable exceptions may or may not leave normally depending on the implementation. If continuations are used, the <code>.resume</code> call will simply goto the continuation in question, and the lambda&#39;s callframe is abandoned. Resumable exceptions may also be implemented by simply marking the current exception as &#34;resumed&#34;, in which case the original exception thrower simply returns to the code that threw the resumable exception, rather than unwinding before returning. This could be done by pushing the resumed exception onto the unhandled list, and then the thrower checking to see if there is only a single resumed exception in the &#34;unhandled&#34; list. The unhandled list is a dynamic variable so that it&#39;s easy for .resume to manipulate it.</p>

<p>A <code>CATCH</code> block sees the lexical scope in which it was defined, but its caller is the dynamic location that threw the exception. That is, the stack is not unwound until some exception handler chooses to unwind it by &#34;handling&#34; the exception in question. So logically, if the <code>CATCH</code> block throws its own exception, you would expect the <code>CATCH</code> block to catch its own exception recursively forever. However, a <code>CATCH</code> must not behave that way, so we say that a <code>CATCH</code> block never attempts to handle any exception thrown within its own dynamic scope. (Otherwise any <code>die</code> would cause an infinite loop.) Instead we treasure them up and rethrow them to a handler further up.</p>

<p>Unlike <code>try</code>, the presence of a <code>CATCH</code> block does not imply <code>use fatal</code> semantics for failures; you may, however, use either an explicit <code>try</code> block around the <code>CATCH</code> or an explicit <code>use fatal</code> to guarantee that failures are thrown eagerly rather than lazily.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Control_Exceptions"
>Control Exceptions</a></h1>

<p>All abnormal control flow is, in the general case, handled by the exception mechanism (which is likely to be optimized away in specific cases.) Here &#34;abnormal&#34; means any transfer of control outward that is not just falling off the end of a block. A <code>return</code>, for example, is considered a form of abnormal control flow, since it can jump out of multiple levels of closures to the end of the scope of the current subroutine definition. Loop commands like <code>next</code> are abnormal, but looping because you hit the end of the block is not. The implicit break (what <code>succeed</code> does explicitly) of a <code>when</code> block is abnormal.</p>

<p>A <code>CATCH</code> block handles only &#34;bad&#34; exceptions, and lets control exceptions pass unhindered. Control exceptions may be caught with a <code>CONTROL</code> block. Generally you don&#39;t need to worry about this unless you&#39;re defining a control construct. You may have one <code>CATCH</code> block and one <code>CONTROL</code> block, since some user-defined constructs may wish to supply an implicit <code>CONTROL</code> block to your closure, but let you define your own <code>CATCH</code> block.</p>

<p>A <code>return</code> always exits from the lexically surrounding sub or method definition (that is, from a function officially declared with the <code>sub</code>, <code>method</code>, or <code>submethod</code> keywords). Pointy blocks and bare closures are transparent to <code>return</code>, in that the <code>return</code> statement still means <code>&#38;?ROUTINE.leave</code> from the <code>Routine</code> that existed in dynamic scope when the closure was cloned.</p>

<p>It is illegal to return from the closure if that <code>Routine</code> no longer owns a call frame in the current call stack.</p>

<p>To return a value (to the dynamical caller) from any pointy block or bare closure, you either just let the block return the value of its final expression, or you can use <code>leave</code>, which comes in both function and method forms. The function (or listop) form always exits from the innermost block, returning its arguments as the final value of the block exactly as <code>return</code> does. The method form will leave any block in the dynamic scope that can be named as an object and that responds to the <code>.leave</code> method.</p>

<p>Hence, the <code>leave</code> function:</p>

<pre><code>leave(1,2,3)</code></pre>

<p>is really just short for:</p>

<pre><code>&#38;?BLOCK.leave(1,2,3)</code></pre>

<p>To return from your immediate caller, you can say:</p>

<pre><code>caller.leave(1,2,3)</code></pre>

<p>Further call frames up the caller stack may be located by use of the <code>callframe</code> function:</p>

<pre><code>callframe({ .labels.any eq &#39;LINE&#39; }).leave(1,2,3);</code></pre>

<p>By default the innermost call frame matching the selection criteria will be exited. This can be a bit cumbersome, so in the particular case of labels, the label that is already visible in the current lexical scope is considered a kind of pseudo object specifying a potential dynamic context. If instead of the above you say:</p>

<pre><code>LINE.leave(1,2,3)</code></pre>

<p>it was always exit from your lexically scoped <code>LINE</code> loop, even if some inner dynamic scope you can&#39;t see happens to also have that label. (In other words, it&#39;s lexotic.) If the <code>LINE</code> label is visible but you aren&#39;t actually in a dynamic scope controlled by that label, an exception is thrown. (If the <code>LINE</code> is not visible, it would have been caught earlier at compile time since <code>LINE</code> would likely be a bareword.)</p>

<p>In theory, any user-defined control construct can catch any control exception it likes. However, there have to be some culturally enforced standards on which constructs capture which exceptions. Much like <code>return</code> may only return from an &#34;official&#34; subroutine or method, a loop exit like <code>next</code> should be caught by the construct the user expects it to be caught by. (Always assuming the user expects the right thing, of course...) In particular, if the user labels a loop with a specific label, and calls a loop control from within the lexical scope of that loop, and if that call mentions the outer loop&#39;s label, then that outer loop is the one that must be controlled. In other words, it first tries this form:</p>

<pre><code>LINE.leave(1,2,3)</code></pre>

<p>If there is no such lexically scoped outer loop in the current subroutine, then a fallback search is made outward through the dynamic scopes in the same way Perl 5 does. (The difference between Perl 5 and Perl 6 in this respect arises only because Perl 5 didn&#39;t have user-defined control structures, hence the sub&#39;s lexical scope was <i>always</i> the innermost dynamic scope, so the preference to the lexical scope in the current sub was implicit. For Perl 6 we have to make this preference for lexotic behavior explicit.)</p>

<p>Warnings are produced in Perl 6 by throwing a resumable control exception to the outermost scope, which by default prints the warning and resumes the exception by extracting a resume continuation from the exception, which must be supplied by the <code>warn()</code> function (or equivalent). Exceptions are not resumable in Perl 6 unless the exception object does the <code>Resumable</code> role. (Note that fatal exception types can do the <code>Resumable</code> role even if thrown via <code>fail()</code>--when uncaught they just hit the outermost fatal handler instead of the outermost warning handler, so some inner scope has to explicitly treat them as warnings and resume them.)</p>

<p>Since warnings are processed using the standard control exception mechanism, they may be intercepted and either suppressed or fatalized anywhere within the dynamic scope by supplying a suitable <code>CONTROL</code> block. This dynamic control is orthogonal to any lexically scoped warning controls, which merely decide whether to call <code>warn()</code> in the first place.</p>

<p>As with calls to <code>return</code>, the warning control exception is an abstraction that the compiler is free to optimize away (along with the associated continuation) when the compiler or runtime can determine that the semantics would be preserved by merely printing out the error and going on. Since all exception handlers run in the dynamic scope of the throw, that reduces to simply returning from the <code>warn</code> function most of the time. See previous section for discussion of ways to return from catch lambdas. The control lambda is logically separate from the catch lambda, though an implementation is allowed to combine them if it is careful to retain separate semantics for catch and control exceptions.</p>

<p>One additional level of control is the notion of <i>lazy warnings</i>. If, instead of throwing a warning directly, the program calls <code>fail()</code> with a resumable exception, the throwing of the warning is delayed until first use (or the caller&#39;s policy) requires it to be thrown. If the warning exception supports the <code>.resume_value</code> method, that will be the value of the failure after it has resumed. Otherwise the value will be the null string. Numeric and string conversions use these lazy warnings to allow (but not require) failsoft semantics.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="The_goto_statement"
>The goto statement <!--
	INDEX: goto
--></a></h1>

<p>In addition to <code>next</code>, <code>last</code>, and <code>redo</code>, Perl 6 also supports <code>goto</code>. As with ordinary loop controls, the label is searched for first lexically within the current subroutine, then dynamically outside of it. Unlike with loop controls, however, scanning a scope includes a scan of any lexical scopes included within the current candidate scope. As in Perl 5, it is possible to <code>goto</code> into a lexical scope, but only for lexical scopes that require no special initialization of parameters. (Initialization of ordinary variables does not count--presumably the presence of a label will prevent code-movement optimizations past the label.) So, for instance, it&#39;s always possible to <code>goto</code> into the next case of a <code>when</code> or into either the &#34;then&#34; or &#34;else&#34; branch of a conditional. You may not go into a <code>given</code> or a <code>for</code>, though, because that would bypass a formal parameter binding (not to mention list generation in the case of <code>for</code>). (Note: the implicit default binding of an outer <code>$_</code> to an inner <code>$_</code> can be emulated for a bare block, so that doesn&#39;t fall under the prohibition on bypassing formal binding.)</p>

<p>Because it is possible to go to a label that is after the operation, and because Perl 6 does one-pass parsing, any <code>goto</code> to a label that has not been yet declared (or is declared outside the outward lexical scope of the <code>goto</code>) must enclose the label in quotes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Exceptions"
>Exceptions</a></h1>

<p>As in Perl 5, many built-in functions simply return an undefined value when you ask for a value out of range, or the function fails somehow. Perl 6 has <code>Failure</code> objects, known as &#34;unthrown exceptions&#34; (though really a <code>Failure</code> merely contains an unthrown exception), which know whether they have been handled or not. <code>$!</code> is a convenient link to the last failure, and only ever contains one exception, the most recent.</p>

<p>[Conjecture: all unhandled exceptions within a routine could be stored in <code>@!</code>, with the most recent first. <code>$!</code> would then be sugar for <code>@![0]</code>. (Or we use push semantics and <code>$!</code> means <code>@![*-1]</code>.) This might be more robust than merely making <code>@!</code> a parameter to CATCH. However, the new semantics of autothrowing when sink eats a Failure means we won&#39;t have many unthrown exceptions waiting around to be handled at the end of the block anymore. We should probably at least issue warnings, though, if the GC eventually collects a failure that was never handled. We can&#39;t really rely on end-of-routine cleanup to deal with failures that are returned as normal data, unless we go with the overhead of a lexical <code>@!</code> variable.]</p>

<p>If you test a <code>Failure</code> for <code>.defined</code> or <code>.Bool</code>, the <code>Failure</code> marks itself as <i>handled</i>; the exception acts as a relatively harmless undefined value thereafter. Any other use of the <code>Failure</code> object to extract a normal value will throw its associated exception immediately. (The <code>Failure</code> may, however, be stored in any container whose type allows the <code>Failure</code> role to be mixed in.) The <code>.handled</code> method returns <code>False</code> on failures that have not been handled. It returns <code>True</code> for handled exceptions and for all non-<code>Failure</code> objects. (That is, it is a <code>Mu</code> method, not a <code>Failure</code> method. Only <code>Failure</code> objects need to store the actual status however; other types just return <code>True</code>.)</p>

<p>The <code>.handled</code> method is <code>rw</code>, so you may mark an exception as handled by assigning <code>True</code> to it. Note however that</p>

<pre><code>$!.handled = 1;</code></pre>

<p>marks only the last exception as handled. To mark them all as handled you must access them individually via the implicit loop of a CATCH block.</p>

<p>A bare <code>die</code>/<code>fail</code> takes <code>$!</code> as the default argument specifying the exception to be thrown or propagated outward to the caller&#39;s <code>$!</code>.</p>

<p>You can cause built-ins to automatically throw exceptions on failure using</p>

<pre><code>use fatal;</code></pre>

<p>The <code>fail</code> function responds to the caller&#39;s <code>use fatal</code> state. It either returns an unthrown exception, or throws the exception. Before you get too happy about this pragma, note that Perl 6 contains various parallel processing primitives that will tend to get blown up prematurely by thrown exceptions. Unthrown exceptions are meant to provide a failsoft mechanism in which failures can be treated as data and dealt with one by one, without aborting execution of what may be perfectly valid parallel computations. If you <i>don&#39;t</i> deal with the failures as data, then sink context will automatically throw any unhandled <code>Failure</code> that you try to discard.</p>

<p>In any case, the overriding design principle here is that no unhandled exception is ever dropped on the floor, but propagated outward until it is handled. If no explicit handler handles it, the implicit outermost exception handler will eventually decide to abort and print all unhandled exceptions passed in as its current <code>@!</code> list.</p>

<p>It is possible to fail with a resumable exception, such as a warning. If the failure throws its exception and the exception resumes, the thrower by default returns the null string (<code>&#39;&#39;</code>) to whatever caused the failure to throw its exception. This may be overridden by attaching a <code>.resume_value</code> to the warning. Hence numeric coercions such as <code>+&#34;42foo&#34;</code> can be forced to return <code>42</code> after issuing a warning.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Phasers"
>Phasers</a></h1>

<p>A <code>CATCH</code> block is just a trait of the closure containing it, and is automatically called at the appropriate moment. These auto-called blocks are known as <i>phasers</i>, since they generally mark the transition from one phase of computing to another. For instance, a <code>CHECK</code> block is called at the end of compiling a compilation unit. Other kinds of phasers can be installed as well; these are automatically called at various times as appropriate, and some of them respond to various control exceptions and exit values. Phasers marked with a <code>*</code> can be used for their return value.</p>

<pre><code>  BEGIN {...}*      at compile time, ASAP, only ever runs once
  CHECK {...}*      at compile time, ALAP, only ever runs once
   LINK {...}*      at link time, ALAP, only ever runs once
   INIT {...}*      at run time, ASAP, only ever runs once
    END {...}       at run time, ALAP, only ever runs once

  ENTER {...}*      at every block entry time, repeats on loop blocks.
  LEAVE {...}       at every block exit time (even stack unwinds from exceptions)
   KEEP {...}       at every successful block exit, part of LEAVE queue
   UNDO {...}       at every unsuccessful block exit, part of LEAVE queue

  FIRST {...}*      at loop initialization time, before any ENTER
   NEXT {...}       at loop continuation time, before any LEAVE
   LAST {...}       at loop termination time, after any LEAVE

    PRE {...}       assert precondition at every block entry, before ENTER
   POST {...}       assert postcondition at every block exit, after LEAVE

  CATCH {...}       catch exceptions, before LEAVE
CONTROL {...}       catch control exceptions, before LEAVE

COMPOSE {...}       when a role is composed into a class</code></pre>

<p>Some of the statement prefixes also behave a little bit like phasers, but they run in-line with the executable code, so they are spelled in lowercase. They parse the same as phasers:</p>

<pre><code>     do {...}*      run a block or statement as a term
   once {...}*      run only once, suppressing additional evaluations
 gather {...}*      start a co-routine thread
  eager {...}*      evaluate statement eagerly
   lazy {...}*      defer actual evaluation till value is fetched
   sink {...}*      evaluate eagerly but throw results away
    try {...}*      evaluate and trap exceptions (implies &#39;use fatal&#39;)
quietly {...}*      evaluate and suppress warnings
  start {...}*      start computation of a promised result</code></pre>

<p>Constructs marked with a <code>*</code> have a run-time value, and if evaluated earlier than their surrounding expression, they simply save their result for use in the expression later when the rest of the expression is evaluated:</p>

<pre><code>my $compiletime = BEGIN { now };
our $temphandle = ENTER { maketemp() };</code></pre>

<p>As with other statement prefixes, these value-producing constructs may be placed in front of either a block or a statement:</p>

<pre><code>my $compiletime = BEGIN now;
our $temphandle = ENTER maketemp();</code></pre>

<p>In fact, most of these phasers will take either a block or a thunk (known as a <i>blast</i> in the vernacular). The statement form can be particularly useful to expose a lexically scoped declaration to the surrounding lexical scope without &#34;trapping&#34; it inside a block.</p>

<p>Hence these declare the same variables with the same scope as the preceding example, but run the statements as a whole at the indicated time:</p>

<pre><code>BEGIN my $compiletime = now;
ENTER our $temphandle = maketemp();</code></pre>

<p>(Note, however, that the value of a variable calculated at compile time may not persist under run-time cloning of any surrounding closure.)</p>

<p>Most of the non-value-producing phasers may also be so used:</p>

<pre><code>END say my $accumulator;</code></pre>

<p>Note, however, that</p>

<pre><code>END say my $accumulator = 0;</code></pre>

<p>sets the variable to 0 at <code>END</code> time, since that is when the &#34;my&#34; declaration is actually executed. Only argumentless phasers may use the statement form. This means that <code>CATCH</code> and <code>CONTROL</code> always require a block, since they take an argument that sets <code>$_</code> to the current topic, so that the innards are able to behave as a switch statement. (If bare statements were allowed, the temporary binding of <code>$_</code> would leak out past the end of the <code>CATCH</code> or <code>CONTROL</code>, with unpredictable and quite possibly dire consequences. Exception handlers are supposed to reduce uncertainty, not increase it.)</p>

<p>Code that is generated at run time can still fire off <code>CHECK</code> and <code>INIT</code> phasers, though of course those phasers can&#39;t do things that would require travel back in time. You need a wormhole for that.</p>

<p>The compiler is free to ignore <code>LINK</code> phasers compiled at run time since they&#39;re too late for the application-wide linking decisions.</p>

<p>Some of these phasers also have corresponding traits that can be set on variables. These have the advantage of passing the variable in question into the closure as its topic:</p>

<pre><code>our $h will enter { .rememberit() } will undo { .forgetit() };</code></pre>

<p>Only phasers that can occur multiple times within a block are eligible for this per-variable form.</p>

<p>Apart from <code>CATCH</code> and <code>CONTROL</code>, which can only occur once, most of these can occur multiple times within the block. So they aren&#39;t really traits, exactly--they add themselves onto a list stored in the actual trait. So if you examine the <code>ENTER</code> trait of a block, you&#39;ll find that it&#39;s really a list of phasers rather than a single phaser. In general, initializing phasers execute in order declared, while finalizing phasers execute in the opposite order. When phasers are in different modules, the <code>INIT</code> and <code>END</code> phasers are treated as if declared at <code>use</code> time in the using module. (It is erroneous to depend on this order if the module is used more than once, however, since the phasers are only installed the first time they&#39;re noticed.)</p>

<p>The semantics of <code>INIT</code> and <code>once</code> are not equivalent to each other in the case of cloned closures. An <code>INIT</code> only runs once for all copies of a cloned closure. A <code>once</code> runs separately for each clone, so separate clones can keep separate state variables:</p>

<pre><code>our $i = 0;
...
$func = once { state $x { $x = $i++ }; dostuff($i) };</code></pre>

<p>But <code>state</code> automatically applies &#34;once&#34; semantics to any initializer, so this also works:</p>

<pre><code>$func = { state $x = $i++; dostuff($i) }</code></pre>

<p>Each subsequent clone gets an initial state that is one higher than the previous, and each clone maintains its own state of <code>$x</code>, because that&#39;s what <code>state</code> variables do.</p>

<p>Even in the absence of closure cloning, <code>INIT</code> runs before the mainline code, while <code>once</code> puts off the initialization till the last possible moment, then runs exactly once, and caches its value for all subsequent calls (assuming it wasn&#39;t called in sink context, in which case the <code>once</code> is evaluated once only for its side effects). In particular, this means that <code>once</code> can make use of any parameters passed in on the first call, whereas <code>INIT</code> cannot.</p>

<p>All of these phaser blocks can see any previously declared lexical variables, even if those variables have not been elaborated yet when the closure is invoked (in which case the variables evaluate to an undefined value.)</p>

<p>Note: Apocalypse 4 confused the notions of <code>PRE</code>/<code>POST</code> with <code>ENTER</code>/<code>LEAVE</code>. These are now separate notions. <code>ENTER</code> and <code>LEAVE</code> are used only for their side effects. <code>PRE</code> and <code>POST</code> return boolean values which, if false, trigger a runtime exception. <code>KEEP</code> and <code>UNDO</code> are just variants of <code>LEAVE</code>, and for execution order are treated as part of the queue of <code>LEAVE</code> phasers.</p>

<p>It is conjectured that <code>PRE</code> and <code>POST</code> submethods in a class could be made to run as if they were phasers in any public method of the class. This feature is awaiting further exploration by means of a <code>ClassHOW</code> extension.</p>

<p><code>FIRST</code>, <code>NEXT</code>, and <code>LAST</code> are meaningful only within the lexical scope of a loop, and may occur only at the top level of such a loop block. A <code>NEXT</code> executes only if the end of the loop block is reached normally, or an explicit <code>next</code> is executed. In distinction to <code>LEAVE</code> phasers, a <code>NEXT</code> phaser is not executed if the loop block is exited via any exception other than the control exception thrown by <code>next</code>. In particular, a <code>last</code> bypasses evaluation of <code>NEXT</code> phasers.</p>

<p>[Note: the name <code>FIRST</code> used to be associated with <code>state</code> declarations. Now it is associated only with loops. See the <code>once</code> above for <code>state</code> semantics.]</p>

<p>Except for <code>CATCH</code> and <code>CONTROL</code> phasers, which run while an exception is looking for a place to handle it, all block-leaving phasers wait until the call stack is actually unwound to run. Unwinding happens only after some exception handler decides to handle the exception that way. That is, just because an exception is thrown past a stack frame does not mean we have officially left the block yet, since the exception might be resumable. In any case, exception handlers are specified to run within the dynamic scope of the failing code, whether or not the exception is resumable. The stack is unwound and the phasers are called only if an exception is not resumed.</p>

<p>So <code>LEAVE</code> phasers for a given block are necessarily evaluated after any <code>CATCH</code> and <code>CONTROL</code> phasers. This includes the <code>LEAVE</code> variants, <code>KEEP</code> and <code>UNDO</code>. <code>POST</code> phasers are evaluated after everything else, to guarantee that even <code>LEAVE</code> phasers can&#39;t violate postconditions. Likewise <code>PRE</code> phasers fire off before any <code>ENTER</code> or <code>FIRST</code> (though not before <code>BEGIN</code>, <code>CHECK</code>, <code>LINK</code>, or <code>INIT</code>, since those are done at compile or process initialization time).</p>

<p>The <code>POST</code> block can be defined in one of two ways. Either the corresponding <code>POST</code> is defined as a separate phaser, in which case <code>PRE</code> and <code>POST</code> share no lexical scope. Alternately, any <code>PRE</code> phaser may define its corresponding <code>POST</code> as an embedded phaser block that closes over the lexical scope of the <code>PRE</code>.</p>

<p>If exit phasers are running as a result of a stack unwind initiated by an exception, this information needs to be made available. In any case, the information as to whether the block is being exited successfully or unsuccessfully needs to be available to decide whether to run <code>KEEP</code> or <code>UNDO</code> blocks (also see <a href="#Definition_of_Success" class="podlinkpod"
>&#34;Definition of Success&#34;</a>). How this information is made available is implementation dependent.</p>

<p>An exception thrown from an <code>ENTER</code> phaser will abort the <code>ENTER</code> queue, but one thrown from a <code>LEAVE</code> phaser will not. The exceptions thrown by failing <code>PRE</code> and <code>POST</code> phasers cannot be caught by a <code>CATCH</code> in the same block, which implies that <code>POST</code> phaser are not run if a <code>PRE</code> phaser fails.</p>

<p>If a <code>POST</code> fails or any kind of <code>LEAVE</code> block throws an exception while the stack is unwinding, the unwinding continues and collects exceptions to be handled. When the unwinding is completed all new exceptions are thrown from that point.</p>

<p>For phasers such as <code>KEEP</code> and <code>POST</code> that are run when exiting a scope normally, the return value (if any) from that scope is available as the current topic within the phaser. (It is presented as a argument, that is, either as parcel or an object that can stand alone in a list. In other words, it&#39;s exactly what <code>return</code> is sending to the outside world in raw form, so that the phaser doesn&#39;t accidentally impose context prematurely.)</p>

<p>The topic of the block outside a phaser is still available as <code>OUTER::&#60;$_&#62;</code>. Whether the return value is modifiable may be a policy of the phaser in question. In particular, the return value should not be modified within a <code>POST</code> phaser, but a <code>LEAVE</code> phaser could be more liberal.</p>

<p>Any phaser defined in the lexical scope of a method is a closure that closes over <code>self</code> as well as normal lexicals. (Or equivalently, an implementation may simply turn all such phasers into submethods whose primed invocant is the current object.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Statement_parsing"
>Statement parsing</a></h1>

<p>In this statement:</p>

<pre><code>given EXPR {
    when EXPR { ... }
    when EXPR { ... }
    ...
}</code></pre>

<p>parentheses aren&#39;t necessary around <code>EXPR</code> because the whitespace between <code>EXPR</code> and the block forces the block to be considered a block rather than a subscript, provided the block occurs where an infix operator would be expected. This works for all control structures, not just the new ones in Perl 6. A top-level bare block is always considered a statement block if there&#39;s a term and a space before it:</p>

<pre><code>if $foo { ... }
elsif $bar { ... }
else { ... }
while $more { ... }
for 1..10 { ... }</code></pre>

<p>You can still parenthesize the expression argument for old times&#39; sake, as long as there&#39;s a space between the closing paren and the opening brace. (Otherwise it will be parsed as a hash subscript.)</p>

<p>Note that the parser cannot intuit how many arguments a list operator is taking, so if you mean 0 arguments, you must parenthesize the argument list to force the block to appear after a term:</p>

<pre><code>if caller {...}    # WRONG, parsed as caller({...})
if caller() {...}  # okay
if (caller) {...}  # okay</code></pre>

<p>Note that common idioms work as expected though:</p>

<pre><code>for map { $^a + 1 }, @list { .say }</code></pre>

<p>Unless you are parsing a statement that expects a block argument, it is illegal to use a bare closure where an operator is expected because it will be considered to be two terms in row. (Remove the whitespace if you wish it to be a postcircumfix.)</p>

<p>Anywhere a term is expected, a block is taken to be a closure definition (an anonymous subroutine). If a closure has arguments, it is always taken as a normal closure. (In addition to standard formal parameters, placeholder arguments also count, as do the underscore variables. Implicit use of <code>$_</code> with <code>.method</code> also counts as an argument.)</p>

<p>However, if an argumentless closure is empty, or appears to contain nothing but a comma-separated list starting with a pair or a hash (counting a single pair or hash as a list of one element), the closure will be immediately executed as a hash composer, as if called with <code>.()</code>.</p>

<pre><code>$hash = { };
$hash = { %stuff };
$hash = { &#34;a&#34; =&#62; 1 };
$hash = { &#34;a&#34; =&#62; 1, $b, $c, %stuff, @nonsense };

$code = { %_ };                            # use of %_
$code = { &#34;a&#34; =&#62; $_ };                     # use of $_
$code = { &#34;a&#34; =&#62; 1, $b, $c, %stuff, @_ };  # use of @_
$code = { ; };
$code = { @stuff };
$code = { &#34;a&#34;, 1 };
$code = { &#34;a&#34; =&#62; 1, $b, $c ==&#62; print };</code></pre>

<p>If you wish to be less ambiguous, the <code>hash</code> list operator will explicitly evaluate a list and compose a hash of the returned value, while <code>sub</code> or <code>-&#62;</code> introduces an anonymous subroutine:</p>

<pre><code>$code = -&#62; { &#34;a&#34; =&#62; 1 };
$code = sub { &#34;a&#34; =&#62; 1 };
$hash = hash(&#34;a&#34; =&#62; 1);
$hash = hash(&#34;a&#34;, 1);</code></pre>

<p>Note that the closure in a <code>map</code> will never be interpreted as a hash, since such a closure always takes arguments, and use of placeholders (including underscore variables) is taken as evidence of arguments.</p>

<p>If a closure is the right argument of the dot operator, the closure is interpreted as a hash subscript.</p>

<pre><code>$code = {$x};       # closure because term expected
if $term{$x}        # subscript because postfix expected
if $term {$x}       # expression followed by statement block
if $term.{$x}       # valid subscript with dot
if $term\  {$x}     # valid subscript with &#34;unspace&#34;</code></pre>

<p>Similar rules apply to array subscripts:</p>

<pre><code>$array = [$x];      # array composer because term expected
if $term[$x]        # subscript because postfix expected
if $term [$x]       # syntax error (two terms in a row)
if $term.[$x]       # valid subscript with dot
if $term\  [$x]     # valid subscript with &#34;unspace&#34;</code></pre>

<p>And to the parentheses delimiting function arguments:</p>

<pre><code>$scalar = ($x);     # grouping parens because term expected
if $term($x)        # function call because operator expected
if $term ($x)       # syntax error (two terms in a row)
if $term.($x)       # valid function call with explicit dot deref
if $term\  .($x)    # valid function call with &#34;unspace&#34; and dot</code></pre>

<p>Outside of any kind of expression brackets, a final closing curly on a line (not counting whitespace or comments) always reverts to the precedence of semicolon whether or not you put a semicolon after it. (In the absence of an explicit semicolon, the current statement may continue on a subsequent line, but only with valid statement continuators such as <code>else</code> that cannot be confused with the beginning of a new statement. Anything else, such as a statement modifier (on, say, a <code>loop</code> statement) must continue on the same line, unless the newline be escaped using the &#34;unspace&#34; construct--see S02.)</p>

<p>Final blocks on statement-level constructs always imply semicolon precedence afterwards regardless of the position of the closing curly. Statement-level constructs are distinguished in the grammar by being declared in the <code>statement_control</code> category:</p>

<pre><code>macro statement_control:&#60;if&#62; ($expr, &#38;ifblock) {...}
macro statement_control:&#60;while&#62; ($expr, &#38;whileblock) {...}
macro statement_control:&#60;BEGIN&#62; (&#38;beginblock) {...}</code></pre>

<p>Statement-level constructs may start only where the parser is expecting the start of a statement. To embed a statement in an expression you must use something like <code>do {...}</code> or <code>try {...}</code>.</p>

<pre><code>$x =  do { given $foo { when 1 {2}; when 3 {4} } } + $bar;
$x = try { given $foo { when 1 {2}; when 3 {4} } } + $bar;</code></pre>

<p>The existence of a <code>statement_control:&#60;BEGIN&#62;</code> does not preclude us from also defining a <code>prefix:&#60;BEGIN&#62;</code> that <i>can</i> be used within an expression:</p>

<pre><code>macro prefix:&#60;BEGIN&#62; (&#38;beginblock) { beginblock().repr }</code></pre>

<p>Then you can say things like:</p>

<pre><code>$recompile_by = BEGIN { time } + $expiration_time;</code></pre>

<p>But <code>statement_control:&#60;BEGIN&#62;</code> hides <code>prefix:&#60;BEGIN&#62;</code> at the start of a statement. You could also conceivably define a <code>prefix:&#60;if&#62;</code>, but then you may not get what you want when you say:</p>

<pre><code>die if $foo;</code></pre>

<p>since <code>prefix:&#60;if&#62;</code> would hide <code>statement_modifier:&#60;if&#62;</code>.</p>

<p>Built-in statement-level keywords require whitespace between the keyword and the first argument, as well as before any terminating loop. In particular, a syntax error will be reported for C-isms such as these:</p>

<pre><code>if(...) {...}
while(...) {...}
for(...) {...}</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Definition_of_Success"
>Definition of Success</a></h1>

<p>Hypothetical variables are somewhat transactional--they keep their new values only on successful exit of the current block, and otherwise are rolled back to their original values.</p>

<p>It is, of course, a failure to leave the block by propagating an error exception, though returning a defined value after catching an exception is okay.</p>

<p>In the absence of error exception propagation, a successful exit is one that returns a defined value or parcel. (A defined parcel may contain undefined values.) So any Perl 6 function can say</p>

<pre><code>fail &#34;message&#34;;</code></pre>

<p>and not care about whether the function is being called in item or list context. To return an explicit scalar undef, you can always say</p>

<pre><code>return Mu;          # like &#34;return undef&#34; in Perl 5</code></pre>

<p>Then in list context, you&#39;re returning a list of length 1, which is defined (much like in Perl 5). But generally you should be using <code>fail</code> in such a case to return an exception object. In any case, returning an unthrown exception is considered failure from the standpoint of <code>let</code>. Backtracking over a closure in a regex is also considered failure of the closure, which is how hypothetical variables are managed by regexes. (And on the flip side, use of <code>fail</code> within a regex closure initiates backtracking of the regex.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="When_is_a_closure_not_a_closure"
>When is a closure not a closure</a></h1>

<p>Everything is conceptually a closure in Perl 6, but the optimizer is free to turn unreferenced closures into mere blocks of code. It is also free to turn referenced closures into mere anonymous subroutines if the block does not refer to any external lexicals that should themselves be cloned. (When we say &#34;clone&#34;, we mean the way the system takes a snapshot of the routine&#39;s lexical scope and binds it to the current instance of the routine so that if you ever use the current reference to the routine, it gets the current snapshot of its world in terms of the lexical symbols that are visible to it.)</p>

<p>All remaining blocks are conceptually cloned into closures as soon as the lexical scope containing them is entered. (This may be done lazily as long as consistent semantics are preserved, so a block that is never executed and never has a reference taken can avoid cloning altogether. Execution or reference taking forces cloning in this case--references are not allowed to be lazily cloned, since no guarantee can be made that the scope needed for cloning will remain in existence over the life of the reference.)</p>

<p>In particular, package subroutines are a special problem when embedded in a changing lexical scope (when they make reference to it). The binding of such a definition to a name within a symbol table counts as taking a reference, so at compile time there is an initial binding to the symbol table entry in question. For &#34;global&#34; bindings to symbol tables visible at compile time, this binds to the compile-time view of the lexical scopes. (At run-time, the initial run-time view of these scopes is copied from the compiler&#39;s view of them, so that initializations carry over, for instance.) At run time, when such a subroutine is cloned, an additional binding is done at clone time to the same symbol table entry that the original was bound to. (The binding is not restored on exit from the current lexical scope; this binding records the <i>last</i> cloning, not the currently in-use cloning, so any use of the global reference must take into consideration that it is functioning only as a cache of the most recent cloning, not as a surrogate for the current lexical scope.)</p>

<p>Matters are more complicated if the package in question is lexically defined. In such cases, the package must be cloned as if it were a sub on entry to the corresponding lexical scope. All runtime instances of a single package declaration share the same set of compile-time declared functions, however, the runtime instances can have different lexical environments as described in the preceding paragraph. If multiple conflicting definitions of a sub exist for the same compile-time package, an error condition exists and behavior is not specified for Perl 6.0.</p>

<p>Methods in classes behave functionally like package subroutines, and have the same binding behavior if the classes are cloned. Note that a class declaration, even an augment, is fundamentally a compile-time operation; composition only happens once and the results are recorded in the prototype class. Runtime typological manipulations are limited to reseating <code>OUTER::</code> scopes of methods.</p>

<p>Lexical names do not share this problem, since the symbol goes out of scope synchronously with its usage. Unlike global subs, they do not need a compile-time binding, but like global subs, they perform a binding to the lexical symbol at clone time (again, conceptually at the entry to the outer lexical scope, but possibly deferred.)</p>

<pre><code>sub foo {
    # conceptual cloning happens to both blocks below
    my $x = 1;
    my sub bar { print $x }         # already conceptually cloned, but can be lazily deferred
    my &#38;baz := { bar(); print $x }; # block is cloned immediately, forcing cloning of bar
    my $code = &#38;bar;                # this would also force bar to be cloned
    return &#38;baz;
}</code></pre>

<p>In particular, blocks of inline control flow need not be cloned until called. [Note: this is currently a potential problem for user-defined constructs, since you have to take references to blocks to pass them to whatever is managing the control flow. Perhaps the laziness can be deferred through <code>Capture</code>s to binding time, so a slurpy of block refs doesn&#39;t clone them all prematurely. On the other hand, this either means the <code>Capture</code> must be smart enough to keep track of the lexical scope it came from so that it can pass the info to the cloner, or it means that we need some special fat not-cloned-yet references that can carry the info lazily. Neither approach is pretty.]</p>

<p>Some closures produce <code>Block</code> objects at compile time that cannot be cloned, because they&#39;re not attached to any runtime code that can actually clone them. <code>BEGIN</code>, <code>CHECK</code>, <code>LINK</code>, <code>INIT</code>, and <code>END</code> blocks fall into this category. Therefore you can&#39;t reliably refer to run-time variables from these closures even if they appear to be in the scope. (The compile-time closure may, in fact, see some kind of permanent copy of the variable for some storage classes, but the variable is likely to be undefined when the closure is run in any case.) It&#39;s only safe to refer to package variables and file-scoped lexicals from such a routine.</p>

<p>On the other hand, it is required that <code>CATCH</code> and <code>LEAVE</code> blocks be able to see transient variables in their current lexical scope, so their cloning status depends at least on the cloning status of the block they&#39;re in.</p>

<!-- end doc -->

</body></html>
