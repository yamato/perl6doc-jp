<!DOCTYPE html>
<html lang="ja">
<head>
<title>S21-calling-foreign-code</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Aug 30 10:16:51 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Calling_foreign_code'>Calling foreign code</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#The_is_native_trait'>The is native trait</a>
      <li class='indexItem indexItem3'><a href='#The_is_symbol_trait'>The is symbol trait</a>
      <li class='indexItem indexItem3'><a href='#The_is_nativeconv_trait'>The is nativeconv trait</a>
      <li class='indexItem indexItem3'><a href='#The_is_encoded_trait'>The is encoded trait</a>
      <li class='indexItem indexItem3'><a href='#Global_variables'>Global variables</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Marshalling_and_demarshalling_of_Perl_6_data'>Marshalling and demarshalling of Perl 6 data</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Numeric_types'>Numeric types</a>
      <li class='indexItem indexItem3'><a href='#Strings'>Strings</a>
      <li class='indexItem indexItem3'><a href='#The_OpaquePointer_class'>The OpaquePointer class</a>
      <li class='indexItem indexItem3'><a href='#The_CPointer_REPR'>The CPointer REPR</a>
      <li class='indexItem indexItem3'><a href='#The_CArray_class'>The CArray class</a>
      <li class='indexItem indexItem3'><a href='#The_CStruct_REPR'>The CStruct REPR</a>
      <li class='indexItem indexItem3'><a href='#Callable_objects'>Callable objects</a>
      <li class='indexItem indexItem3'><a href='#Complex_data_value_types'>Complex data value types</a>
      <li class='indexItem indexItem3'><a href='#Varargs_To_be_determined._This_section_is_hypothetical.'>Varargs To be determined. This section is hypothetical.</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Miscellaneous_helper_functions'>Miscellaneous helper functions</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Refreshing_outdated_objects'>Refreshing outdated objects</a>
    </ul>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>DRAFT: Synopsis 21: Calling Foreign Code</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Arne Skj&#230;rholt &#60;arnsholt@gmail.com&#62;
Jonathan Worthington &#60;jnthn@jnthn.net&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 27 Feb 2009

Last Modified: 23 Nov 2012
Version: 2</code></pre>

<p>The document is a draft. The current state of the document is largely derived from Zavolaj: NativeCall as implemented for Rakudo at <a href="https://github.com/jnthn/zavolaj/" class="podlinkurl"
>https://github.com/jnthn/zavolaj/</a>.</p>

<p>If you read the HTML version, it is generated from the Pod in the specs repository under <a href="https://github.com/perl6/specs/blob/master/S21-calling-foreign-code.pod" class="podlinkurl"
>https://github.com/perl6/specs/blob/master/S21-calling-foreign-code.pod</a> so edit it there in the git repository if you would like to make changes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre><code>use NativeCall;

sub native_function(int arg) is native(&#39;libsomething&#39;) { * }
sub short_name() is native(&#39;libsomething&#39;) is symbol(&#39;long_and_complicated_name&#39;) { * }

native_function(42);</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Perl 6 has a standard foreign function interface, NativeCall. The only libraries NativeCall is able to interface with are those written in C. Languages like Fortran and C++ require name mangling, which is compiler-specific and thus falls well beyond the scope of this specification.</p>

<p>Hypotheticals:</p>

<dl>
<dt><a 
>This is likely not an exhaustive list of showstoppers for C++/Fortran compat; also, some platforms may be tricky simply in terms of C interop as well</a></dt>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Calling_foreign_code"
>Calling foreign code</a></h2>

<p>A sub is marked as a native routine with the <code>is native</code> trait. A native sub must have an attached signature, which is used to specify the native-level argument structure of the function. If the return type of the function is <code>Mu</code> the native function returns no value, any other return type must be compatible with the types specified in the next section.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_is_native_trait"
>The <code>is native</code> trait</a></h3>

<pre><code>sub trait_mod:&#60;is&#62;(Routine $r, :$native!) is export(:DEFAULT, :traits) { ... }</code></pre>

<p>The <code>is native</code> trait is the main gateway used to access C libraries. A routine with this trait applied will not be a normal Perl 6 callable, but will call into the function with the same name in the specified library.</p>

<p>The library name passed to <code>is native</code> is passed unmodified to <a href="man:dlopen(3)" class="podlinkurl"
>man:dlopen(3)</a> or the platform&#39;s equivalent and the symbol is the looked for in the handle returned from the call to <code>dlopen</code>. If the library name is an undefined value or the empty string, the symbol will be searched for in the currently loaded libraries of the process; that is, behaviour consistent with <code>dlsym(RTLD_DEFAULT, symbol)</code> in C.</p>

<p>Hypotheticals: =for item Perl 6 allows a greater range of characters in identifiers than C. Should we look for cases where the identifier isn&#39;t legal in C?</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_is_symbol_trait"
>The <code>is symbol</code> trait</a></h3>

<pre><code>sub trait_mod:&#60;is&#62;(Routine $r, :$symbol!) is export(:DEFAULT, :traits) { ... }</code></pre>

<p>Since all symbols in a C library share a single namespace with all other libraries, it is common practice to prefix externally visible symbols with a library prefix so as not to interfere with other libraries. In Perl 6 this may be a nuisance, and the <code>is symbol</code> trait lets a user specify a different symbol name to search for than the name of the sub.</p>

<p>A native sub also adorned with <code>is symbol</code> will search for the symbol specified in the symbol trait, rather than the name of the subroutine itself.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_is_nativeconv_trait"
>The <code>is nativeconv</code> trait</a></h3>

<pre><code>sub trait_mod:&#60;is&#62;(Routine $r, :nativeconv!) is export(:DEFAULT, :traits) { ... }</code></pre>

<p>Native code typically supports several different calling conventions. If a convention different than the default one is needed, it is specified with <code>is nativeconv($convention)</code>. The conventions supported are platform-specific.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_is_encoded_trait"
>The <code>is encoded</code> trait</a></h3>

<pre><code>sub trait_mod:&#60;is&#62;(Routine $r,   :encoded!) is export(:DEFAULT, :traits) { ... }
sub trait_mod:&#60;is&#62;(Parameter $p, :encoded!) is export(:DEFAULT, :traits) { ... }</code></pre>

<p>Input arguments and return values that are strings may be returned in any of a multitude of encodings. If the value is encoded differently from UTF-8, it must be stated explicitly.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Global_variables"
>Global variables</a></h3>

<p>Caveat emptor: This whole section is conjectural (and none of it is implemented in Zavolaj).</p>

<p>Just like functions exported by a library, global variables are accessed with the <code>is native</code> trait; after all, all exported symbols are the same from the point of view of the linker: a pointer to something. The <code>is symbol</code> and <code>is encoding</code> (for strings) traits also apply to variables.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Marshalling_and_demarshalling_of_Perl_6_data"
>Marshalling and demarshalling of Perl 6 data</a></h2>

<p>The raw internal representation of most Perl 6 objects can&#39;t be expected to work sensibly with native code. To specify how to marshal and demarshal complex Perl 6 objects, representation polymorphism is most frequently used, but some classes are provided for frequent use cases.</p>

<p>For pointer types, the type object associated with the Perl 6 class represents the null pointer.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Numeric_types"
>Numeric types</a></h3>

<p>Numeric types, both native types and not, have obvious marshalling semantics (as long as they are not arbitrary-precision types). A NativeCall implementation should support the following types:</p>

<dl>
<dt><a name="int8,_uint8_signed_and_unsigned_byte"
><code>int8</code>, <code>uint8</code> signed and unsigned byte</a></dt>

<dd>
<dt><a name="int16,_uint16_signed_and_unsigned_two-byte_integer"
><code>int16</code>, <code>uint16</code> signed and unsigned two-byte integer</a></dt>

<dd>
<dt><a name="int32,_uint32_signed_and_unsigned_four-byte_integer"
><code>int32</code>, <code>uint32</code> signed and unsigned four-byte integer</a></dt>

<dd>
<dt><a name="int64,_uint64_signed_and_unsigned_eight-byte_integer"
><code>int64</code>, <code>uint64</code> signed and unsigned eight-byte integer</a></dt>

<dd>
<dt><a name="int,_uint_signed_and_unsigned_machine_word"
><code>int</code>, <code>uint</code> signed and unsigned machine word</a></dt>

<dd>
<dt><a name="Int_largest_available_integer_type"
><code>Int</code> largest available integer type</a></dt>

<dd>
<dt><a name="num32_four-byte_floating_point_number"
><code>num32</code> four-byte floating point number</a></dt>

<dd>
<dt><a name="num,_num64_eight-byte_floating_point_number"
><code>num</code>, <code>num64</code> eight-byte floating point number</a></dt>
</dl>

<p>Hypotheticals:</p>

<dl>
<dt><a 
>This is a wider range of native types than what S02 mandates. We&#39;ll either want to expand that list of natives, or find some other way of specifying sizes.</a></dt>

<dd>
<dt><a name="There_is_no_obvious_mirror_of_Int_for_largest_available_unsigned_type."
>There is no obvious mirror of <code>Int</code> for largest available <i>unsigned</i> type.</a></dt>

<dd>
<dt><a name="Should_Num_be_a_synonym_for_num/num64?"
>Should <code>Num</code> be a synonym for <code>num</code>/<code>num64</code>?</a></dt>

<dd>
<dt><a name="If_the_Int_or_Num_type_object_is_passed,_should_it_be_silently_converted_to_a_zero_value,_or_cause_an_exception?"
>If the Int or Num type object is passed, should it be silently converted to a zero value, or cause an exception?</a></dt>

<dd>
<dt><a name="How_should_overflows_be_handled?"
>How should overflows be handled?</a></dt>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Strings"
>Strings</a></h3>

<pre><code>multi explicitly-manage(Str $x is rw, :$encoding = &#39;utf8&#39;) is export(:DEFAULT, :utils) { ... }</code></pre>

<p>By default, a string passed to a native sub wil be marshalled to a <code>char *</code> appropriately encoded as specified with the <code>is encoded</code> trait. The memory allocated to the C string is freed when the function returns. If a <code>Str</code> object should have a persistent <code>char *</code> associated with it, this can be signalled by calling <code>explicitly-manage($str, $encoding)</code>. The buffer allocated will never be freed.</p>

<p>A string-valued native sub&#39;s return value will be unmarshalled according to the <code>is encoded</code> trait, and the C pointer is not freed as deciding whether the caller or callee owns the data can&#39;t be decided automatically, and freeing by default risks causing later code to access freed memory.</p>

<p>Hypotheticals:</p>

<dl>
<dt><a 
>We need better facilities for signaling when it&#39;s appropriate to free data. The current facilities have the benefit that it won&#39;t cause memory-related errors later on, but on the flip side, it will leak memory over time.</a></dt>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_OpaquePointer_class"
>The <code>OpaquePointer</code> class</a></h3>

<pre><code>class OpaquePointer is repr(&#39;CPointer&#39;) { }</code></pre>

<p>The <code>OpaquePointer</code> type is the simplest possible way to interface with C pointers, and can be seen as similar to the <code>void *</code> type in C. An <code>OpaquePointer</code> offers no way to inspect the pointer or manipulate it; it can only be passed around in the program and back to C.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_CPointer_REPR"
>The <code>CPointer</code> REPR</a></h3>

<pre><code>typedef struct _magic magic;
magic *magic_new(void);
void   magic_perform(magic *m);

class Magic is repr(&#39;CPointer&#39;) {
    my Magic sub magic_new()       is native(&#39;libmagic&#39;) { * }
    my sub magic_perform(Magic $m) is native(&#39;libmagic&#39;) { * }

    method new() { magic_new(); }
    method perform() { magic_perform(self); }
}</code></pre>

<p>The <code>CPointer</code> REPR enables types that are similar to <code>OpaquePointer</code> in that they cannot be introspected or mutated, but different in that they can have methods. This makes it easy to interface with &#34;object-oriented&#34; C code that returns an opaque pointer handle that encapsulate the resources used by the library and lets us implement this naturally using Perl 6 OO.</p>

<p>A <code>CPointer</code> object can not have attributes.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_CArray_class"
>The <code>CArray</code> class</a></h3>

<pre><code>class CArray[::Type] does Positional[Type] is export(:DEFAULT, :types) { ... }</code></pre>

<p>General Perl 6 arrays support features such as laziness, which means that they can not easily be marshalled into a C representation. Thus, NativeCall provides the CArray type which supports a set of array features compatible with marshalling to and from C. The <code>Type</code> parameter is, of course, mandatory as the exact layout of the array in memory depends on the type of the elements.</p>

<p>A <code>Carray</code> that has been marshalled from a value returned from C cannot, given how arrays work in C, know the bounds of the array. Thus, it is the <i>user&#39;s</i> responsibility to ensure that all accesses are within the bounds of the array. NativeCall will make no attempt to figure this out, and requests for array elements outside of the array is likely to result in death by segmentation fault.</p>

<p>If the <code>CArray</code> has been created in Perl 6, the bounds of the array are known, and operations can be bounds-checked and the array grown appropriately. Note, however, that growing an array may result in its C representation being moved to a different memory location. Thus, if a piece of C code has stored the location of an array and it is later on moved due to operations on the Perl side, strange bugs and segfaults are likely to ensue.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="The_CStruct_REPR"
>The <code>CStruct</code> REPR</a></h3>

<pre><code>class StructObject is repr(&#39;CStruct&#39;) { ... }</code></pre>

<p>Structs are an important part of most non-trivial C APIs; using the <code>CStruct</code> REPR, arbitrary structs can be accessed just like ordinary Perl 6 classes.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Callable_objects"
>Callable objects</a></h3>

<p>Callback arguments are, in essence, no different from normal data. They are declared as callables (typically with the <code>&#38;</code> sigil) and also have an attached signature. The signature is important as the callback handling code needs this information to get the function&#39;s arguments off the stack.</p>

<p>Callbacks returned from C are specified identically, but as return values rather than parameters (note: callbacks returned from C NYI in Zavolaj).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Complex_data_value_types"
>Complex data value types</a></h3>

<p>Caveat emptor: This section, like the one on global variables, is all conjecture. Nothing is implemented in Zavolaj.</p>

<p>In Perl 6 the distinction between value type and reference is intrinsic to the type. In C, on the other hand, any type can be used both as a value and reference type, depending on how it&#39;s used. Thus, NativeCall needs some mechanism to duplicate this. One possible source of inspiration for this is C#. C# distinguishes between value and reference types similarly to Perl 6 and also has a well-supported foreign function interface.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Varargs_To_be_determined._This_section_is_hypothetical."
>Varargs To be determined. This section is hypothetical.</a></h3>

<p>One option is an API similar to the C99 <code>stdarg.h</code> macros and explicitly get arguments off an opaque object. For example <code>my $arg = va_arg($args, Type)</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Miscellaneous_helper_functions"
>Miscellaneous helper functions</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Refreshing_outdated_objects"
>Refreshing outdated objects</a></h3>

<pre><code>multi refresh($obj) is export(:DEFAULT, :utils) { { ... }</code></pre>

<p>To avoid unmarshalling data from the C representation whenever data is accessed, an efficient implementation is going to want to cache unmarshalled data. Whenever a complex object is passed to a native subroutine, the implementation should make sure the cache data isn&#39;t out of date. However, if the C code saves a pointer passed to it and a later invocation mutates the data pointed to, NativeCall can&#39;t magically detect this. In cases like this, the user will have to use <code>refresh</code> to invalidate any outdated objects in the cache.</p>

<p>Hypotheticals:</p>

<dl>
<dt><a 
>Sometimes it will be necessary to reinterpret a pointer-valued object as a different kind of pointer. One way to provide this would be a function a la: <code>my $val = reinterpret($ptr, Type)</code>.</a></dt>
</dl>

<!-- end doc -->

</body></html>
