<!DOCTYPE html>
<html lang="ja">
<head>
<title>S06-routines</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Sep 27 10:05:33 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Subroutines_and_other_code_objects'>Subroutines and other code objects</a>
  <li class='indexItem indexItem1'><a href='#Routine_modifiers'>Routine modifiers</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Named_subroutines'>Named subroutines</a>
    <li class='indexItem indexItem2'><a href='#Anonymous_subroutines'>Anonymous subroutines</a>
    <li class='indexItem indexItem2'><a href='#Perl5ish_subroutine_declarations'>Perl5ish subroutine declarations</a>
    <li class='indexItem indexItem2'><a href='#Blocks'>Blocks</a>
    <li class='indexItem indexItem2'><a href='#%22Pointy_blocks%22'>&#34;Pointy blocks&#34;</a>
    <li class='indexItem indexItem2'><a href='#Stub_declarations'>Stub declarations</a>
    <li class='indexItem indexItem2'><a href='#Globally_scoped_subroutines'>Globally scoped subroutines</a>
    <li class='indexItem indexItem2'><a href='#Dynamically_scoped_subroutines'>Dynamically scoped subroutines</a>
    <li class='indexItem indexItem2'><a href='#Lvalue_subroutines'>Lvalue subroutines</a>
    <li class='indexItem indexItem2'><a href='#Parcel_subroutines'>Parcel subroutines</a>
    <li class='indexItem indexItem2'><a href='#Operator_overloading'>Operator overloading</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Calling_conventions'>Calling conventions</a>
  <li class='indexItem indexItem1'><a href='#Signatures'>Signatures</a>
  <li class='indexItem indexItem1'><a href='#Parameters_and_arguments'>Parameters and arguments</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Named_arguments'>Named arguments</a>
    <li class='indexItem indexItem2'><a href='#Invocant_parameters'>Invocant parameters</a>
    <li class='indexItem indexItem2'><a href='#Longname_parameters'>Longname parameters</a>
    <li class='indexItem indexItem2'><a href='#Required_parameters'>Required parameters</a>
    <li class='indexItem indexItem2'><a href='#Optional_parameters'>Optional parameters</a>
    <li class='indexItem indexItem2'><a href='#Named_parameters'>Named parameters</a>
    <li class='indexItem indexItem2'><a href='#List_parameters'>List parameters</a>
    <li class='indexItem indexItem2'><a href='#Slurpy_block'>Slurpy block</a>
    <li class='indexItem indexItem2'><a href='#Argument_list_binding'>Argument list binding</a>
    <li class='indexItem indexItem2'><a href='#Parcel_binding'>Parcel binding</a>
    <li class='indexItem indexItem2'><a href='#Flattening_argument_lists'>Flattening argument lists</a>
    <li class='indexItem indexItem2'><a href='#Multidimensional_argument_list_binding'>Multidimensional argument list binding</a>
    <li class='indexItem indexItem2'><a href='#Zero-dimensional_argument_list'>Zero-dimensional argument list</a>
    <li class='indexItem indexItem2'><a href='#Feed_operators'>Feed operators</a>
    <li class='indexItem indexItem2'><a href='#Closure_parameters'>Closure parameters</a>
    <li class='indexItem indexItem2'><a href='#En_passant_type_capture'>En passant type capture</a>
    <li class='indexItem indexItem2'><a href='#Unpacking_array_parameters'>Unpacking array parameters</a>
    <li class='indexItem indexItem2'><a href='#Unpacking_a_single_list_argument'>Unpacking a single list argument</a>
    <li class='indexItem indexItem2'><a href='#Unpacking_tree_node_parameters'>Unpacking tree node parameters</a>
    <li class='indexItem indexItem2'><a href='#Attributive_parameters'>Attributive parameters</a>
    <li class='indexItem indexItem2'><a href='#Placeholder_variables'>Placeholder variables</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Properties_and_traits'>Properties and traits</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Subroutine_traits'>Subroutine traits</a>
    <li class='indexItem indexItem2'><a href='#Parameter_traits'>Parameter traits</a>
    <li class='indexItem indexItem2'><a href='#Signature_Introspection'>Signature Introspection</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Advanced_subroutine_features'>Advanced subroutine features</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Processing_of_returned_values'>Processing of returned values</a>
    <li class='indexItem indexItem2'><a href='#The_return_function'>The return function</a>
    <li class='indexItem indexItem2'><a href='#The_callframe_and_caller_functions'>The callframe and caller functions</a>
    <li class='indexItem indexItem2'><a href='#The_want_function'>The want function</a>
    <li class='indexItem indexItem2'><a href='#The_leave_function'>The leave function</a>
    <li class='indexItem indexItem2'><a href='#Temporization'>Temporization</a>
    <li class='indexItem indexItem2'><a href='#Wrapping'>Wrapping</a>
    <li class='indexItem indexItem2'><a href='#The_%26%3FROUTINE_object'>The &#38;?ROUTINE object</a>
    <li class='indexItem indexItem2'><a href='#The_%26%3FBLOCK_object'>The &#38;?BLOCK object</a>
    <li class='indexItem indexItem2'><a href='#Priming'>Priming</a>
    <li class='indexItem indexItem2'><a href='#Macros'>Macros</a>
    <li class='indexItem indexItem2'><a href='#Quasiquoting'>Quasiquoting</a>
    <li class='indexItem indexItem2'><a href='#Splicing'>Splicing</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Other_matters'>Other matters</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Anonymous_hashes_vs_blocks'>Anonymous hashes vs blocks</a>
    <li class='indexItem indexItem2'><a href='#Pairs_as_lvalues'>Pairs as lvalues</a>
    <li class='indexItem indexItem2'><a href='#Out-of-scope_names'>Out-of-scope names</a>
    <li class='indexItem indexItem2'><a href='#Declaring_a_MAIN_subroutine'>Declaring a MAIN subroutine</a>
    <li class='indexItem indexItem2'><a href='#Relationship_of_MAIN_routine_with_lexical_setting'>Relationship of MAIN routine with lexical setting</a>
    <li class='indexItem indexItem2'><a href='#Implementation_note_on_autothreading_of_only_subs'>Implementation note on autothreading of only subs</a>
    <li class='indexItem indexItem2'><a href='#Introspection'>Introspection</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Routine'>Routine</a>
      <li class='indexItem indexItem3'><a href='#Signature'>Signature</a>
    </ul>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 6: Subroutines</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Damian Conway &#60;damian@conway.org&#62;
Allison Randal &#60;al@shadowed.net&#62;
Larry Wall &#60;larry@wall.org&#62;
Daniel Ruoso &#60;daniel@ruoso.com&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 21 Mar 2003

Last Modified: 17 Aug 2014
Version: 162</code></pre>

<p>This document summarizes Apocalypse 6, which covers subroutines and the new type system.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Subroutines_and_other_code_objects"
>Subroutines and other code objects</a></h1>

<p><code>Routine</code> is the parent type of all keyword-declared code blocks. All routines are born with undefined values of <code>$_</code>, <code>$!</code>, and <code>$/</code>, unless the routine declares them otherwise explicitly. A compilation unit, such as a module file or an <code>EVAL</code> string, is also considered a routine, or you would not be able to reference <code>$!</code> or <code>$/</code> in them.</p>

<p>Non-routine code <code>Block</code>s, declared with <code>-&#62;</code> or with bare curlies, are born only with <code>$_</code>, which is aliased to its OUTER::&#60;$_&#62; unless bound as a parameter. A block generally uses the <code>$!</code> and <code>$/</code> defined by the innermost enclosing routine, unless <code>$!</code> or <code>$/</code> is explicitly declared in the block.</p>

<p>A thunk is a piece of code that may not execute immediately, for instance because it is part of a conditional operator, or a default initialization of an attribute. It has no scope of its own, so any new variables defined in a thunk, will leak to the scope that they&#39;re in. Note however that any and all lazy constructs, whether block-based or thunk-based, such as gather or start or <code>==&#62;</code> should declare their own <code>$/</code> and <code>$!</code> so that the user&#39;s values for those variables cannot be clobbered asynchronously.</p>

<p><b>Subroutines</b> (keyword: <code>sub</code>) are non-inheritable routines with parameter lists.</p>

<p><b>Methods</b> (keyword: <code>method</code>) are inheritable routines which always have an associated object (known as their invocant) and belong to a particular kind or class.</p>

<p><b>Submethods</b> (keyword: <code>submethod</code>) are non-inheritable methods, or subroutines masquerading as methods. They have an invocant and belong to a particular kind or class.</p>

<p><b>Regexes</b> (keyword: <code>regex</code>) are methods (of a grammar) that perform pattern matching. Their associated block has a special syntax (see Synopsis 5). (We also use the term &#34;regex&#34; for anonymous patterns of the traditional form.)</p>

<p><b>Tokens</b> (keyword: <code>token</code>) are regexes that perform low-level non-backtracking (by default) pattern matching.</p>

<p><b>Rules</b> (keyword: <code>rule</code>) are regexes that perform non-backtracking (by default) pattern matching (and also enable rules to do whitespace dwimmery).</p>

<p><b>Macros</b> (keyword: <code>macro</code>) are routines whose calls execute as soon as they are parsed (i.e. at compile-time). Macros may return another source code string or a parse-tree.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Routine_modifiers"
>Routine modifiers</a></h1>

<p><b>Multis</b> (keyword: <code>multi</code>) are routines that can have multiple variants that share the same name, selected by arity, types, or some other constraints.</p>

<p><b>Prototypes</b> (keyword: <code>proto</code>) specify the commonalities (such as parameter names, fixity, and associativity) shared by all multis of that name in the scope of the <code>proto</code> declaration. A <code>proto</code> also adds an implicit <code>multi</code> to all routines of the same short name within its scope, unless they have an explicit modifier. (This is particularly useful when adding to rule sets or when attempting to compose conflicting methods from roles.) Abstractly, the <code>proto</code> is a generic wrapper around the dispatch to the <code>multi</code>s. Each <code>proto</code> is instantiated into an actual dispatcher for each scope that needs a different candidate list.</p>

<p><b>Only</b> (keyword: <code>only</code>) routines do not share their short names with other routines. This is the default modifier for all routines, unless a <code>proto</code> of the same name was already in scope. (For subs, the governing <code>proto</code> must have been declared in the same file, so <code>proto</code> declarations from the setting or other modules don&#39;t have this effect unless explicitly imported.)</p>

<p>A modifier keyword may occur before the routine keyword in a named routine:</p>

<pre><code>only sub foo {...}
proto sub foo {...}
dispatch sub foo {...}      # internal
multi sub foo {...}

only method bar {...}
proto method bar {...}
dispatch method bar {...}   # internal
multi method bar {...}</code></pre>

<p>If the routine keyword is omitted, it defaults to <code>sub</code>.</p>

<p>Modifier keywords cannot apply to anonymous routines.</p>

<p>A <code>proto</code> is a generic dispatcher, which any given scope with a unique candidate list will instantiate into a <code>dispatch</code> routine. Hence a <code>proto</code> is never called directly, much like a <code>role</code> can&#39;t be used as an instantiated object.</p>

<p>When you call any routine (or method, or rule) that may have multiple candidates, the basic dispatcher is really only calling an &#34;only&#34; sub or method--but if there are multiple candidates, the &#34;only&#34; that will be found is really a dispatcher. This instantiated <code>dispatch</code> is always called first (at least in the abstract--this can often be optimized away). In essence, a <code>dispatch</code> is dispatched exactly like an <code>only</code> sub, but the <code>dispatch</code> itself may delegate to any of the candidates it is &#34;managing&#34;.</p>

<p>It is the <code>dispatch</code>&#39;s responsibility to first vet the arguments for all the candidates; any call that does not successfully bind the <code>dispatch</code>&#39;s signature fails outright. (Its signature is a copy of one belonging to the <code>proto</code> from which it was instantiated.) The <code>dispatch</code> does not necessarily send the original capture to its candidates, however. Named arguments that bind to positionals in the <code>dispatch</code> sig will become positionals for all subsequent calls to its managed multis.</p>

<p>The dispatch then considers its list of managed candidates from the viewpoint of the caller or object, sorts them into some order, and dispatches them according to the rules of multiple dispatch as defined for each of the various dispatchers. In the case of multi subs, the candidate list is known at compile time. In the case of multi methods, it may be necessary to generate (or regenerate) the candidate list at run time, depending on what is known when about the inheritance tree.</p>

<p>This default dispatch behavior is symbolized within the original <code>proto</code> by a block containing of a single <code>*</code> (that is, a &#34;whatever&#34;). Hence the typical <code>proto</code> will simply have a body of <code>{*}</code>.</p>

<pre><code>proto method bar {*}</code></pre>

<p>(We don&#39;t use <code>...</code> for that because it would fail at run time, and the proto&#39;s instantiated <code>dispatch</code> blocks are not stubs, but are intended to be executed.)</p>

<p>Other statements may be inserted before and after the <code>{*}</code> statement to capture control before or after the multi dispatch:</p>

<pre><code>proto foo ($a,$b) { say &#34;Called with $a $b&#34;; {*}; say &#34;Returning&#34;; }</code></pre>

<p>(That <code>proto</code> is only good for <code>multi</code>s with side effects and no return value, since it returns the result of <code>say</code>, which might not be what you want. See below for how to fix that.)</p>

<p>The syntactic form <code>&#38;foo</code> (without a modifying signature) can never refer to a <code>multi</code> candidate or a generic <code>proto</code>. It may only refer to the single <code>only</code> or <code>dispatch</code> routine that would first be called by <code>foo()</code>. Individual <code>multi</code>s may be named by appending a signature to the noun form: <code>&#38;foo:($,$,*@)</code>.</p>

<p>We used the term &#34;managed&#34; loosely above to indicate the set of <code>multi</code>s in question; the &#34;managed set&#34; is more accurately defined as the intersection of all the <code>multi</code>s in the <code>proto</code>&#39;s downward scope with all the <code>multi</code>s that are visible to the caller&#39;s upward-looking scope. For ordinary routines this means looking down lexical scopes and looking up lexical scopes. [This is more or less how <code>multi</code>s already behave.]</p>

<p>For methods this means looking down or up the inheritance tree; &#34;managed set&#34; in this case translates to the intersection of all methods in the <code>proto</code>&#39;s class or its subclasses with all <code>multi</code> methods visible to the object in its parent classes, that is, the parent classes of the object&#39;s actual type on whose behalf the method was called. [Note, this is a change from prior multi method semantics, which restricted multimethods to a single class; the old semantics is equivalent to defining a <code>proto</code> in every class that has multimethods. The new way gives the user the ability to intermix <code>multi</code>s at different inheritance levels].</p>

<p>Also, the old semantics of <code>proto</code> providing the most-default <code>multi</code> body is hereby deprecated. Default <code>multi</code>s should be marked with &#34;<code>is default</code>&#34;.</p>

<p>It is still possible to provide default behavior in the <code>proto</code>, however, by using it as a wrapper:</p>

<pre><code>my proto sub foo (@args) {
    do-something-before(@args);
    {*}       # call into the managed set, then come back
    do-something-after(@args);
}</code></pre>

<p>Note that this returns the value of do-something-after(), not the <code>multi</code>. There are two ways to get around that. Here&#39;s one way:</p>

<pre><code>my proto sub foo (@args) {
    ENTER do-something-before(@args);
    {*}
    LEAVE do-something-after(@args);
}</code></pre>

<p>Alternately, you can spell out what <code>{*}</code> is actually sugar for, which would be some dispatcher macro such as:</p>

<pre><code>my proto sub foo (|cap (@args)) {
    do-something-before(@args);
    my \retcap = MULTI-DISPATCH-CALLWITH(&#38;?ROUTINE, cap);
    do-something-after(@args);
    return retcap;
}</code></pre>

<p>which optimizes (we hope) to an inlined multidispatcher to locate all the candidates for these arguments (hopefully memoized), create the dynamic scope of a dispatch, start the dispatch, manage <code>callnext</code> and <code>lastcall</code> semantics, and return the result of whichever <code>multi</code> succeeded, if any.</p>

<p>Which is why we have <code>{*}</code> instead.</p>

<p>Another common variant would be to propagate control to the outer/higher routine that would have been found if this one didn&#39;t exist:</p>

<pre><code>my proto method foo { {*}; UNDO nextsame; }  # failover to super foo</code></pre>

<p>Note that, in addition to making <code>multi</code>s work similarly to each other, the new <code>proto</code> semantics greatly simplify top-level dispatchers, which never have to worry about <code>multi</code>s, because <code>multi</code>s are always in the second half of the double dispatch (again, just in the abstract, since the first dispatch can often be optimized away, as if the <code>proto</code> were inlined). So in the abstract, <code>foo()</code> only ever calls a single <code>only</code>/<code>proto</code> routine, and we know which one it is at compile time.</p>

<p>This is less of a shift for method dispatch, which already assumed that there is something like a single proto in each class that redispatches inside the class. Here the change is that multi-method dispatcher needs to look more widely for its candidates than the current class. But note that our semantics were inconsistent before, insofar as regex methods already had to look for this larger managed set in order to do transitive LTM correctly. Now the semantics of normal method <code>proto</code>s and regex <code>proto</code>s are nearly identical, apart from the fact that regex candidate lists naturally have fancier tiebreaking rules involving longest token matching.</p>

<p>A <code>dispatch</code> must be generated for every scope that contains one or more <code>multi</code> declaration. This is done by searching backwards and outwards (or up the inheritance chain for methods) for a <code>proto</code> to instantiate. If no such <code>proto</code> is found, a &#34;most generic&#34; <code>proto</code> will be generated, something like:</p>

<pre><code>proto sub foo (*@, *%) {*}
proto method foo (*@, *%) {*}</code></pre>

<p>Obviously, no named-to-positional remapping can be done in this case.</p>

<p>[Conjecture: we could instead autogen a more specific signature for each such autogenerated <code>dispatch</code> once we know its exact candidate set, such that consistent use of positional parameter names is rewarded with positional names in the generated signature, which could remap named parameters.]</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Named_subroutines"
>Named subroutines</a></h2>

<p>The general syntax for named subroutines is any of:</p>

<pre><code> my RETTYPE sub NAME ( PARAMS ) TRAITS {...}    # lexical only
            sub NAME ( PARAMS ) TRAITS {...}    # same as &#34;my&#34;
our RETTYPE sub NAME ( PARAMS ) TRAITS {...}    # package-scoped</code></pre>

<p>The return type may also be put inside the parentheses:</p>

<pre><code>sub NAME (PARAMS --&#62; RETTYPE) {...}</code></pre>

<p>Unlike in Perl 5, named subroutines are considered expressions, so this is valid Perl 6:</p>

<pre><code>my @subs = (sub foo { ... }, sub bar { ... });</code></pre>

<p>Another difference is that subroutines default to <code>my</code> scope rather than <code>our</code> scope. However, subroutine dispatch searches lexical scopes outward, and subroutines are also allowed to be <i>postdeclared</i> after their use, so you won&#39;t notice this much. A subroutine that is not declared yet may be called using parentheses around the arguments, in the absence of parentheses, the subroutine call is assumed to take multiple arguments in the form of a list operator.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Anonymous_subroutines"
>Anonymous subroutines</a></h2>

<p>The general syntax for anonymous subroutines is:</p>

<pre><code>sub ( PARAMS ) TRAITS {...}</code></pre>

<p>But one can also use the <code>anon</code> scope modifier to introduce the return type first:</p>

<pre><code>anon RETTYPE sub ( PARAMS ) TRAITS {...}</code></pre>

<p>When an anonymous subroutine will be assigned to a scalar variable, the variable can be declared with the signature of the routines that will be assigned to it:</p>

<pre><code>my $grammar_factory:(Str, int, int --&#62; Grammar);
$grammar_factory = sub (Str $name, int $n, int $x --&#62; Grammar) { ... }; </code></pre>

<p>Covariance allows a routine (that has a more derived return type than what is defined in the scalar&#39;s signature) to be assigned to that scalar. Contravariance allows a routine (with parameter types that are less derived than those in the scalar&#39;s signature) to be assigned to that scalar. The compiler may choose to enforce (by type-checking) such assignments at compile-time, if possible. Such type annotations are intended to help the compiler optimize code to the extent such annotations are included and/or to the extent they aid in type inference.</p>

<p>The same signature can be used to mark the type of a closure parameter to another subroutine:</p>

<pre><code>sub (int $n, &#38;g_fact:(Str, int, int --&#62; Grammar) --&#62; Str) { ... }</code></pre>

<p><b>Trait</b> is the name for a compile-time (<code>is</code>) property. See <a href="#Properties_and_traits" class="podlinkpod"
>&#34;Properties and traits&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Perl5ish_subroutine_declarations"
>Perl5ish subroutine declarations</a></h2>

<p>You can declare a sub without parameter list, as in Perl 5:</p>

<pre><code>sub foo {...}</code></pre>

<p>This is equivalent to one of:</p>

<pre><code>sub foo () {...}
sub foo (*@_) {...}
sub foo (*%_) {...}
sub foo (*@_, *%_) {...}</code></pre>

<p>depending on whether either or both of those variables are used in the body of the routine.</p>

<p>Positional arguments implicitly come in via the <code>@_</code> array, but unlike in Perl 5 they are <code>readonly</code> aliases to actual arguments:</p>

<pre><code>sub say { print qq{&#34;@_[]&#34;\n}; }   # args appear in @_

sub cap { $_ = uc $_ for @_ }   # Error: elements of @_ are read-only</code></pre>

<p>Also unlike in Perl 5, Perl 6 has true named arguments, which come in via <code>%_</code> instead of <code>@_</code>. (To construct pseudo-named arguments that come in via <code>@_</code> as in Perl 5, the p5-to-p6 translator will define and use the ugly <code>p5=&#62;</code> operator instead of Perl 6&#39;s <code>=&#62;</code> Pair constructor.)</p>

<p>If you need to modify the elements of <code>@_</code> or <code>%_</code>, declare the array or hash explicitly with the <code>is rw</code> trait:</p>

<pre><code>sub swap (*@_ is rw, *%_ is rw) { @_[0,1] = @_[1,0]; %_&#60;status&#62; = &#34;Q:S&#34;; }</code></pre>

<p>Note: the <code>rw</code> container trait is automatically distributed to the individual elements by the slurpy star even though there is no actual array or hash passed in. More precisely, the slurpy star means the declared formal parameter is <i>not</i> considered readonly; only its elements are. See <a href="#Parameters_and_arguments" class="podlinkpod"
>&#34;Parameters and arguments&#34;</a> below.</p>

<p>Note also that if the sub&#39;s block contains placeholder variables (such as <code>$^foo</code> or <code>$:bar</code>), those are considered to be formal parameters already, so in that case <code>@_</code> or <code>%_</code> fill the role of sopping up unmatched arguments. That is, if those containers are explicitly mentioned within the body, they are added as slurpy parameters. This allows you to easily customize your error message on unrecognized parameters. If they are not mentioned in the body, they are not added to the signature, and normal dispatch rules will simply fail if the signature cannot be bound.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Blocks"
>Blocks</a></h2>

<p>Raw blocks are also executable code structures in Perl 6.</p>

<p>Every block defines an object of type <code>Block</code> (which <code>does Callable</code>), which may either be executed immediately or passed on as a <code>Block</code> object. How a block is parsed is context dependent.</p>

<p>A bare block where an operator is expected terminates the current expression and will presumably be parsed as a block by the current statement-level construct, such as an <code>if</code> or <code>while</code>. (If no statement construct is looking for a block there, it&#39;s a syntax error.) This form of bare block requires leading whitespace because a bare block where a postfix is expected is treated as a hash subscript.</p>

<p>A bare block where a term is expected merely produces a <code>Block</code> object. If the term bare block occurs in a list, it is considered the final element of that list unless followed immediately by a comma or colon (intervening <code>\h*</code> or &#34;unspace&#34; is allowed).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="&#34;Pointy_blocks&#34;"
>&#34;Pointy blocks&#34;</a></h2>

<p>Semantically the arrow operator <code>-&#62;</code> is almost a synonym for the <code>sub</code> keyword as used to declare an anonymous subroutine, insofar as it allows you to declare a signature for a block of code. However, the parameter list of a pointy block does not require parentheses, and a pointy block may not be given traits. In most respects, though, a pointy block is treated more like a bare block than like an official subroutine. Syntactically, a pointy block may be used anywhere a bare block could be used:</p>

<pre><code>my $sq = -&#62; $val { $val**2 };
say $sq(10); # 100

my @list = 1..3;
for @list -&#62; $elem {
    say $elem; # prints &#34;1\n2\n3\n&#34;
}</code></pre>

<p>It also behaves like a block with respect to control exceptions. If you <code>return</code> from within a pointy block, the block is transparent to the return; it will return from the innermost enclosing <code>sub</code> or <code>method</code> (et al.), not from the block itself. It is referenced by <code>&#38;?BLOCK</code>, not <code>&#38;?ROUTINE</code>.</p>

<p>A normal pointy block&#39;s parameters default to <code>readonly</code>, just like parameters to a normal sub declaration. However, the double-pointy variant defaults parameters to <code>rw</code>:</p>

<pre><code>for @list &#60;-&#62; $elem {
    $elem++;
}</code></pre>

<p>This form applies <code>rw</code> to all the arguments:</p>

<pre><code>for @kv &#60;-&#62; $key, $value {
    $key ~= &#34;.jpg&#34;;
    $value *= 2 if $key ~~ :e;
}</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Stub_declarations"
>Stub declarations</a></h2>

<p>To predeclare a subroutine without actually defining it, use a &#34;stub block&#34;:</p>

<pre><code>sub foo {...}     # Yes, those three dots are part of the actual syntax</code></pre>

<p>The old Perl 5 form:</p>

<pre><code>sub foo;</code></pre>

<p>is a compile-time error in Perl 6 (because it would imply that the body of the subroutine extends from that statement to the end of the file, as <code>class</code> and <code>module</code> declarations do). The only allowed use of the semicolon form is to declare a <code>MAIN</code> sub--see <a href="#Declaring_a_MAIN_subroutine" class="podlinkpod"
>&#34;Declaring a MAIN subroutine&#34;</a> below.</p>

<p>Redefining a stub subroutine does not produce an error, but redefining an already-defined subroutine does. If you wish to redefine a defined sub, you must explicitly use the &#34;<code>supersede</code>&#34; declarator. (The compiler may refuse to do this if it has already committed to the previous definition.)</p>

<p>The <code>...</code> is the &#34;yadayadayada&#34; operator, which is executable but returns a failure. You can also use <code>???</code> to fail with a warning (a lazy one, to be issued only if the value is actually used), or <code>!!!</code> to always die. These also officially define stub blocks. Any of these yada operators will be taken as a stub if used as the main operator of the first statement in the block. (Statement modifiers are allowed on that statement.) The yada operators differ from their respective named functions in that they all default to a message such as: &#34;Unimplemented stub of sub foo was executed&#34;.</p>

<p>It has been argued that <code>...</code> as literal syntax is confusing when you might also want to use it for metasyntax within a document. Generally this is not an issue in context; it&#39;s never an issue in the program itself, and the few places where it could be an issue in the documentation, a comment will serve to clarify the intent, as above. The rest of the time, it doesn&#39;t really matter whether the reader takes <code>...</code> as literal or not, since the purpose of <code>...</code> is to indicate that something is missing whichever way you take it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Globally_scoped_subroutines"
>Globally scoped subroutines</a></h2>

<p>Subroutines and variables can be declared in the global namespace (or any package in the global namespace), and are thereafter visible everywhere in the program via the GLOBAL package (or one of its subpackages). They may be made directly visible by importation, but may not otherwise be called with a bare identifier, since subroutine dispatch only looks in lexical scopes.</p>

<p>Global subroutines and variables are normally referred to by prefixing their identifiers with the <code>*</code> twigil, to allow dynamically scoped overrides.</p>

<pre><code>GLOBAL::&#60;$next_id&#62; = 0;
sub GLOBAL::saith($text)  { say &#34;Yea verily, $text&#34; }

module A {
    my $next_id = 2;     # hides any global or package $next_id
    &#38;*saith($next_id);   # print the lexical $next_id;
    &#38;*saith($*next_id);  # print the dynamic $next_id;
}</code></pre>

<p>To disallow dynamic overrides, you must access the globals directly:</p>

<pre><code>GLOBAL::saith($GLOBAL::next_id);</code></pre>

<p>The fact that this is verbose is construed to be a feature. Alternately, you may play aliasing tricks like this:</p>

<pre><code>module B {
    import GLOBAL &#60;&#38;saith $next_id&#62;;
    saith($next_id);    # Unambiguously the global definitions
}</code></pre>

<p>Despite the fact that subroutine dispatch only looks in lexical scopes, you can always call a package subroutine directly if there&#39;s a lexical alias to it, as the <code>our</code> declarator does:</p>

<pre><code>module C;
our sub saith($text)  { say &#34;Yea verily, $text&#34; }
saith(&#34;I do!&#34;)      # okay
C::saith(&#34;I do!&#34;)   # also okay</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Dynamically_scoped_subroutines"
>Dynamically scoped subroutines</a></h2>

<p>Similarly, you may define dynamically scoped subroutines:</p>

<pre><code>my sub myfunc ($x) is dynamic { ... }
my sub &#38;*myfunc ($x) { ... }        # same thing</code></pre>

<p>This may then be invoked via the syntax for dynamic variables:</p>

<pre><code>&#38;*myfunc(42);</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Lvalue_subroutines"
>Lvalue subroutines</a></h2>

<p>Lvalue subroutines return a &#34;proxy&#34; object that can be assigned to. It&#39;s known as a proxy because the object usually represents the purpose or outcome of the subroutine call.</p>

<p>Subroutines are specified as being lvalue using the <code>is rw</code> trait.</p>

<p>An lvalue subroutine may return a variable:</p>

<pre><code>my $lastval;
sub lastval () is rw { return $lastval }</code></pre>

<p>or the result of some nested call to an lvalue subroutine:</p>

<pre><code>sub prevval () is rw { return lastval() }</code></pre>

<p>or a specially tied proxy object, with suitably programmed <code>FETCH</code> and <code>STORE</code> methods:</p>

<pre><code>sub checklastval ($passwd) is rw {
    return Proxy.new:
            FETCH =&#62; method {
                        return lastval();
                     },
            STORE =&#62; method ($val) {
                        die unless check($passwd);
                        lastval() = $val;
                     };
}</code></pre>

<p>Other methods may be defined for specialized purposes such as temporizing the value of the proxy.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parcel_subroutines"
>Parcel subroutines</a></h2>

<p>If the subroutine doesn&#39;t care whether the returned value is a container or not, it may declare this with <code>is parcel</code>, to indicate that the return value should be returned raw, without attempting any decontainerization. This can be useful for routines that wish to process mixed containers and non-containers without distinction.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Operator_overloading"
>Operator overloading</a></h2>

<p>Operators are just subroutines with special names and scoping. An operator name consists of a grammatical category name followed by a single colon followed by an operator name specified as if it were one or more strings. So any of these indicates the same binary addition operator:</p>

<pre><code>infix:&#60;+&#62;
infix:&#171;+&#187;
infix:&#60;&#60;+&#62;&#62;
infix:[&#39;+&#39;]
infix:[&#34;+&#34;]</code></pre>

<p>Use the <code>&#38;</code> sigil just as you would on ordinary subs.</p>

<p>Unary operators are defined as <code>prefix</code> or <code>postfix</code>:</p>

<pre><code>sub prefix:&#60;OPNAME&#62;  ($operand) {...}
sub postfix:&#60;OPNAME&#62; ($operand) {...}</code></pre>

<p>Binary operators are defined as <code>infix</code>:</p>

<pre><code>sub infix:&#60;OPNAME&#62; ($leftop, $rightop) {...}</code></pre>

<p>Bracketing operators are defined as <code>circumfix</code> where a term is expected or <code>postcircumfix</code> where a postfix is expected. A two-element slice containing the leading and trailing delimiters is the name of the operator.</p>

<pre><code>sub circumfix:&#60;LEFTDELIM RIGHTDELIM&#62; ($contents) {...}
sub circumfix:[&#39;LEFTDELIM&#39;,&#39;RIGHTDELIM&#39;] ($contents) {...}</code></pre>

<p>Contrary to Apocalypse 6, there is no longer any rule about splitting an even number of characters. You must use a two-element slice. Such names are canonicalized to a single form within the symbol table, so you must use the canonical name if you wish to subscript the symbol table directly (as in <code>PKG::{&#39;infix:&#60;+&#62;&#39;}</code>). Otherwise any form will do. (Symbolic references do not count as direct subscripts since they go through a parsing process.) The canonical form always uses angle brackets and a single space between slice elements. The elements are escaped on brackets, so <code>PKG::circumfix:[&#39;&#60;&#39;,&#39;&#62;&#39;]</code> is canonicalized to <code>PKG::{&#39;circumfix:&#60;\&#60; \&#62;&#62;&#39;}</code>, and decanonicalizing may always be done left-to-right.</p>

<p>Operator names can be any sequence of non-whitespace characters including Unicode characters. For example:</p>

<pre><code>sub infix:&#60;(c)&#62; ($text, $owner) { return $text but Copyright($owner) }
method prefix:&#60;&#177;&#62; (Num $x --&#62; Num) { return +$x | -$x }
multi sub postfix:&#60;!&#62; (Int $n) { $n &#60; 2 ?? 1 !! $n*($n-1)! }
macro circumfix:&#171;&#60;!-- --&#62;&#187; ($text) is parsed / .*? / { &#34;&#34; }

my $document = $text (c) $me;

my $tolerance = &#177;7!;

&#60;!-- This is now a comment --&#62;</code></pre>

<p>Whitespace may never be part of the name (except as separator within a <code>&#60;...&#62;</code> or <code>&#171;...&#187;</code> slice subscript, as in the example above).</p>

<p>A null operator name does not define a null or whitespace operator, but a default matching subrule for that syntactic category, which is useful when there is no fixed string that can be recognized, such as tokens beginning with digits. Such an operator <i>must</i> supply an <code>is parsed</code> trait. The Perl grammar uses a default subrule for the <code>:1st</code>, <code>:2nd</code>, <code>:3rd</code>, etc. regex modifiers, something like this:</p>

<pre><code>sub regex_mod_external:&#60;&#62; ($x) is parsed(token { \d+[st|nd|rd|th] }) {...}</code></pre>

<p>Such default rules are attempted in the order declared. (They always follow any rules with a known prefix, by the longest-token-first rule.)</p>

<p>Although the name of an operator can be installed into any package or lexical namespace, the syntactic effects of an operator declaration are always lexically scoped. Operators other than the standard ones should not be installed into the <code>GLOBAL::</code> namespace. Always use exportation to make non-standard syntax available to other scopes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Calling_conventions"
>Calling conventions</a></h1>

<p>In Perl 6 culture, we distinguish the terms <i>parameter</i> and <i>argument</i>; a parameter is the formal name that will attach to an incoming argument during the course of execution, while an argument is the actual value that will be bound to the formal parameter. The process of attaching these values (arguments) to their temporary names (parameters) is known as <i>binding</i>. (Some C.S. literature uses the terms &#34;formal argument&#34; and &#34;actual argument&#34; for these two concepts, but here we try to avoid using the term &#34;argument&#34; for formal parameters.)</p>

<p>Various Perl 6 code objects (either routines or blocks) may be declared with parameter lists, either explicitly by use of a signature declaration, or implicitly by use of placeholder variables within the body of code. (Use of both for the same code block is not allowed.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Signatures"
>Signatures</a></h1>

<p>A signature consists of a list of zero or more parameter declarations, separated by commas. (These are described below.) Signatures are usually found inside parentheses (within routine declarations), or after an arrow <code>-&#62;</code> (within block declarations), but other forms are possible for specialized cases. A signature may also indicate what the code returns, either generally or specifically. This is indicated by placing the return specification after a <code>--&#62;</code> token. If the return specification names a type (that is, an indefinite object), then a successful call to the code must always return a value of that type. If the return specification returns a definite object, then that value is always returned from a successful call. (For this purpose the <code>Nil</code> value is treated as definite.) An unsuccessful call may always call <code>fail</code> to return a <code>Failure</code> object regardless of the return specification.</p>

<p>Ordinarily, if the return is specified as a type (or is unspecified), the final statement of the block will be evaluated for its return value, and this will be the return value of the code block as a whole. (It must conform to the return type specification, if provided.) An explicit <code>return</code> may be used instead to evaluate the <code>return</code>&#39;s arguments as the code block&#39;s return value, and leave the code block immediately, short-circuiting the rest of the block&#39;s execution.</p>

<p>If the return specification is a definite immutable value (or <code>Nil</code>) rather than a type, then all top-level statements in the code block are evaluated only for their side effects; in other words, all of the statements are evaluated in sink context, including the final statement. An explicit <code>return</code> statement is allowed, but only in argumentless form, to indicate that execution is to be short-circuited and the <i>declared</i> return value is to be returned. No other value may be returned in its place.</p>

<p>If the return specification is definite but not an immutable value, then it must be a mutable container (variable) of some sort. The container variable is declared as any other parameter would be, but no incoming argument will ever be bound to it. It is permitted to supply a default value, in which case the return variable will always be initialized with that default value. As with value return, all top-level statements are evaluated in sink context, and only argumentless <code>return</code> is allowed, indicating that the current contents of the return value should be returned.</p>

<p>Note that the default return policy assumes functional semantics, with the result that a loop as the final statement would be evaluated as a map, which may surprise some people. An implementation is allowed to warn when it finds such a loop; this warning may be suppressed by supplying a return specification, which will also determine whether the final loop statement is evaluated in sink context.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Parameters_and_arguments"
>Parameters and arguments</a></h1>

<p>By default, all parameters are readonly aliases to their corresponding arguments--the parameter is just another name for the original argument, but the argument can&#39;t be modified through it. This is vacuously true for value arguments, since they may not be modified in any case. However, the default forces any container argument to also be treated as an immutable value. This extends down only one level; an immutable container may always return an element that is mutable if it so chooses. (For this purpose a scalar variable is not considered a container of its singular object, though, so the top-level object within a scalar variable is considered immutable by default. Perl 6 does not have references in the same sense that Perl 5 does.)</p>

<p>To allow modification, use the <code>is rw</code> trait. This requires a mutable object or container as an argument (or some kind of type object that can be converted to a mutable object, such as might be returned by an array or hash that knows how to autovivify new elements). Otherwise the signature fails to bind, and this candidate routine cannot be considered for servicing this particular call. (Other multi candidates, if any, may succeed if they don&#39;t require <code>rw</code> for this parameter.) In any case, failure to bind does not by itself cause an exception to be thrown; that is completely up to the dispatcher.</p>

<p>To pass-by-copy, use the <code>is copy</code> trait. An object container will be cloned whether or not the original is mutable, while an (immutable) value will be copied into a suitably mutable container. The parameter may bind to any argument that meets the other typological constraints of the parameter.</p>

<p>If you have a readonly parameter <code>$ro</code>, it may never be passed on to a <code>rw</code> parameter of a subcall, whether or not <code>$ro</code> is currently bound to a mutable object. It may only be rebound to readonly or copy parameters. It may also be rebound to a parcel parameter (see &#34;<code>is parcel</code>&#34; below), but modification will fail as in the case where an immutable value is bound to a <code>parcel</code> parameter.</p>

<p>Aliases of <code>$ro</code> are also readonly, whether generated explicitly with <code>:=</code> or implicitly within a <code>Capture</code> object (which are themselves immutable).</p>

<p>Also, <code>$ro</code> may not be returned from an lvalue subroutine or method.</p>

<p>Parameters may be required or optional. They may be passed by position, or by name. Individual parameters may confer an item or list context on their corresponding arguments, but unlike in Perl 5, this is decided lazily at parameter binding time.</p>

<p>Arguments destined for required positional parameters must come before those bound to optional positional parameters. Arguments destined for named parameters may come before and/or after the positional parameters. (To avoid confusion it is highly recommended that all positional parameters be kept contiguous in the call syntax, but this is not enforced, and custom arg list processors are certainly possible on those arguments that are bound to a final slurpy or arglist variable.)</p>

<p>A signature containing a name collision is considered a compile time error. A name collision can occur between positional parameters, between named parameters, or between a positional parameter and a named one. The sigil is not considered in such a comparison, except in the case of two positional parameters -- in other words, a signature in which two or more parameters are identical except for the sigil is still OK (but you won&#39;t be able to pass values by that name).</p>

<pre><code>:($a, $a)       # wrong, two $a
:($a, @a)       # OK (but don&#39;t do that)
:($a, :a($b))   # wrong, one $a from positional, one $a from named parameter
:($a, :a(@b))   # wrong, same 
:(:$a, :@a)     # wrong, can only have one named parameter &#34;a&#34;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Named_arguments"
>Named arguments</a></h2>

<p>Named arguments are recognized syntactically at the &#34;comma&#34; level. Since parameters are identified using identifiers, the recognized syntaxes are those where the identifier in question is obvious. You may use either the adverbial form, <code>:name($value)</code>, or the autoquoted arrow form, <code>name =&#62; $value</code>. These must occur at the top &#34;comma&#34; level, and no other forms are taken as named pairs by default. Pairs intended as positional arguments rather than named arguments may be indicated by extra parens or by explicitly quoting the key to suppress autoquoting:</p>

<pre><code>doit :when&#60;now&#62;,1,2,3;      # always a named arg
doit (:when&#60;now&#62;),1,2,3;    # always a positional arg

doit when =&#62; &#39;now&#39;,1,2,3;   # always a named arg
doit (when =&#62; &#39;now&#39;),1,2,3; # always a positional arg
doit &#39;when&#39; =&#62; &#39;now&#39;,1,2,3; # always a positional arg</code></pre>

<p>Only bare keys with valid identifier names are recognized as named arguments:</p>

<pre><code>doit when =&#62; &#39;now&#39;;         # always a named arg
doit &#39;when&#39; =&#62; &#39;now&#39;;       # always a positional arg
doit 123  =&#62; &#39;now&#39;;         # always a positional arg
doit :123&#60;now&#62;;             # always a positional arg</code></pre>

<p>Going the other way, pairs intended as named arguments that don&#39;t look like pairs must be introduced with the <code>|</code> prefix operator:</p>

<pre><code>$pair = :when&#60;now&#62;;
doit $pair,1,2,3;                # always a positional arg
doit |$pair,1,2,3;               # always a named arg
doit |get_pair(),1,2,3;          # always a named arg
doit |(&#39;when&#39; =&#62; &#39;now&#39;),1,2,3;   # always a named arg</code></pre>

<p>Note the parens are necessary on the last one due to precedence.</p>

<p>Likewise, if you wish to pass a hash and have its entries treated as named arguments, you must dereference it with a <code>|</code>:</p>

<pre><code>%pairs = (:when&#60;now&#62;, :what&#60;any&#62;);
doit %pairs,1,2,3;               # always a positional arg
doit |%pairs,1,2,3;              # always named args
doit |%(get_pair()),1,2,3;       # always a named arg
doit |%(&#39;when&#39; =&#62; &#39;now&#39;),1,2,3;  # always a named arg</code></pre>

<p>Variables with a <code>:</code> prefix in rvalue context autogenerate pairs, so you can also say this:</p>

<pre><code>$when = &#39;now&#39;;
doit $when,1,2,3;   # always a positional arg of &#39;now&#39;
doit :$when,1,2,3;  # always a named arg of :when&#60;now&#62;</code></pre>

<p>In other words <code>:$when</code> is shorthand for <code>:when($when)</code>. This works for any sigil:</p>

<pre><code>:$what      :what($what)
:@what      :what(@what)
:%what      :what(%what)
:&#38;what      :what(&#38;what)</code></pre>

<p>Ordinary hash notation will just pass the value of the hash entry as a positional argument regardless of whether it is a pair or not. To pass both key and value out of hash as a positional pair, use <code>:p</code> instead:</p>

<pre><code>doit %hash&#60;a&#62;:p,1,2,3;
doit %hash{&#39;b&#39;}:p,1,2,3;</code></pre>

<p>The <code>:p</code> stands for &#34;pairs&#34;, not &#34;positional&#34;--the <code>:p</code> adverb may be placed on any <code>Associative</code> access subscript to make it mean &#34;pairs&#34; instead of &#34;values&#34;. If you want the pair (or pairs) to be interpreted as named arguments, you may do so by prefixing with the <code>prefix:&#60;|&#62;</code> operator:</p>

<pre><code>doit |(%hash&#60;a&#62;:p),1,2,3;
doit |(%hash{&#39;b&#39;}:p),1,2,3;</code></pre>

<p>(The parens are required to keep the <code>:p</code> adverb from attaching to <code>prefix:&#60;|&#62;</code> operator.)</p>

<p><code>Pair</code> constructors are recognized syntactically at the call level and put into the named slot of the <code>Capture</code> structure. Hence they may be bound to positionals only by name, not as ordinary positional <code>Pair</code> objects. Leftover named arguments can be slurped into a slurpy hash.</p>

<p>Because named and positional arguments can be freely mixed, the programmer always needs to disambiguate pairs literals from named arguments with parentheses or quotes:</p>

<pre><code># Named argument &#34;a&#34;
push @array, 1, 2, :a&#60;b&#62;;

# Pair object (a=&#62;&#39;b&#39;)
push @array, 1, 2, (:a&#60;b&#62;);
push @array, 1, 2, &#39;a&#39; =&#62; &#39;b&#39;;</code></pre>

<p>Perl 6 allows multiple same-named arguments, and records the relative order of arguments with the same name. When there are more than one argument, the <code>@</code> sigil in the parameter list causes the arguments to be concatenated:</p>

<pre><code>sub fun (Int :@x) { ... }
fun( x =&#62; 1, x =&#62; 2 );              # @x := (1, 2)
fun( x =&#62; (1, 2), x =&#62; (3, 4) );    # @x := (1, 2, 3, 4)</code></pre>

<p>Other sigils bind only to the <i>last</i> argument with that name:</p>

<pre><code>sub fun (Int :$x) { ... }
fun( x =&#62; 1, x =&#62; 2 );              # $x := 2
fun( x =&#62; (1, 2), x =&#62; (3, 4) );    # $x := (3, 4)</code></pre>

<p>This means a hash holding default values must come <i>before</i> known named parameters, similar to how hash constructors work:</p>

<pre><code># Allow &#34;x&#34; and &#34;y&#34; in %defaults to be overridden
f( |%defaults, x =&#62; 1, y =&#62; 2 );</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Invocant_parameters"
>Invocant parameters</a></h2>

<p>A method invocant may be specified as the first parameter in the parameter list, with a colon (rather than a comma) immediately after it:</p>

<pre><code>method get_name ($self:) {...}
method set_name ($_: $newname) {...}</code></pre>

<p>The corresponding argument (the invocant) is evaluated in item context and is passed as the left operand of the method call operator:</p>

<pre><code>print $obj.get_name();
$obj.set_name(&#34;Sam&#34;);</code></pre>

<p>The invocant is actually stored as the first positional argument of a <code>Capture</code> object. It is special only to the dispatcher, otherwise it&#39;s just a normal positional argument.</p>

<p>Single-dispatch semantics may also be requested by using the indirect object syntax, with a colon after the invocant argument. The colon is just a special form of the comma, and has the same precedence:</p>

<pre><code>set_name $obj: &#34;Sam&#34;;
$obj.set_name(&#34;Sam&#34;);   # same as the above</code></pre>

<p>An invocant is the topic of the corresponding method if that formal parameter is declared with the name <code>$_</code>. A method&#39;s invocant always has the alias <code>self</code>. Other styles of self can be declared with the <code>self</code> pragma.</p>

<p>If you have a call of the form:</p>

<pre><code>foo(|$capture)</code></pre>

<p>the compiler must defer the decision on whether to treat it as a method or function dispatch based on whether the supplied <code>Capture</code>&#39;s first argument is marked as an invocant. For ordinary calls this can always be determined at compile time, however.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Longname_parameters"
>Longname parameters</a></h2>

<p>A routine marked with <code>multi</code> can mark part of its parameters to be considered in the multi dispatch. These are called <i>longnames</i>; see S12 for more about the semantics of multiple dispatch.</p>

<p>You can choose part of a <code>multi</code>&#39;s parameters to be its longname, by putting a double semicolon after the last one:</p>

<pre><code>multi sub handle_event ($window, $event;; $mode) {...}
multi method set_name ($self: $name;; $nick) {...}</code></pre>

<p>A parameter list may have at most one double semicolon; parameters after it are never considered for multiple dispatch (except of course that they can still &#34;veto&#34; if their number or types mismatch).</p>

<p>[Conjecture: It might be possible for a routine to advertise multiple long names, delimited by single semicolons. See S12 for details.]</p>

<p>If the parameter list for a <code>multi</code> contains no semicolons to delimit the list of important parameters, then all positional parameters are considered important. If it&#39;s a <code>multi method</code> or <code>multi submethod</code>, an additional implicit unnamed <code>self</code> invocant is added to the signature list unless the first parameter is explicitly marked with a colon.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Required_parameters"
>Required parameters</a></h2>

<p>Required parameters are specified at the start of a subroutine&#39;s parameter list:</p>

<pre><code>sub numcmp ($x, $y) { return $x &#60;=&#62; $y }</code></pre>

<p>Required parameters may optionally be declared with a trailing <code>!</code>, though that&#39;s already the default for positional parameters:</p>

<pre><code>sub numcmp ($x!, $y!) { return $x &#60;=&#62; $y }</code></pre>

<p>Not passing all of the required arguments to a normal subroutine is a fatal error. Passing a named argument that cannot be bound to a normal subroutine is also a fatal error. (Methods are different.)</p>

<p>The number of required parameters a subroutine has can be determined by calling its <code>.arity</code> method:</p>

<pre><code>$args_required = &#38;foo.arity;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Optional_parameters"
>Optional parameters</a></h2>

<p>Optional positional parameters are specified after all the required parameters and each is marked with a <code>?</code> after the parameter:</p>

<pre><code>sub my_substr ($str, $from?, $len?) {...}</code></pre>

<p>Alternately, optional fields may be marked by supplying a default value. The <code>=</code> sign introduces a default value:</p>

<pre><code>sub my_substr ($str, $from = 0, $len = Inf) {...}</code></pre>

<p>Default values can be calculated at run-time. They may even use the values of preceding parameters:</p>

<pre><code>sub xml_tag ($tag, $endtag = matching_tag($tag) ) {...}</code></pre>

<p>Arguments that correspond to optional parameters are evaluated in item context. They can be omitted, passed positionally, or passed by name:</p>

<pre><code>my_substr(&#34;foobar&#34;);            # $from is 0, $len is infinite
my_substr(&#34;foobar&#34;,1);          # $from is 1, $len is infinite
my_substr(&#34;foobar&#34;,1,3);        # $from is 1, $len is 3
my_substr(&#34;foobar&#34;,len=&#62;3);     # $from is 0, $len is 3</code></pre>

<p>Missing optional arguments default to their default values, or to an undefined value if they have no default. (A supplied argument that is undefined is not considered to be missing, and hence does not trigger the default. Use <code>//=</code> within the body for that.)</p>

<p>You may check whether an optional parameter was bound to anything by calling <code>VAR($param).defined</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Named_parameters"
>Named parameters</a></h2>

<p>Named-only parameters follow any required or optional parameters in the signature. They are marked by a prefix <code>:</code>:</p>

<pre><code>sub formalize($text, :$case, :$justify) {...}</code></pre>

<p>This is actually shorthand for:</p>

<pre><code>sub formalize($text, :case($case), :justify($justify)) {...}</code></pre>

<p>If the longhand form is used, the label name and variable name can be different:</p>

<pre><code>sub formalize($text, :case($required_case), :justify($justification)) {...}</code></pre>

<p>so that you can use more descriptive internal parameter names without imposing inconveniently long external labels on named arguments. Multiple name wrappings may be given; this allows you to give both a short and a long external name:</p>

<pre><code>sub globalize (:g(:global($gl))) {...}</code></pre>

<p>Or equivalently:</p>

<pre><code>sub globalize (:g(:$global)) {...}</code></pre>

<p>Arguments that correspond to named parameters are evaluated in item context. They can only be passed by name, so it doesn&#39;t matter what order you pass them in:</p>

<pre><code>$formal = formalize($title, case=&#62;&#39;upper&#39;);
$formal = formalize($title, justify=&#62;&#39;left&#39;);
$formal = formalize($title, :justify&#60;right&#62;, :case&#60;title&#62;);</code></pre>

<p>See S02 for the correspondence between adverbial form and arrow notation.</p>

<p>While named and position arguments may be intermixed, it is suggested that you keep all the positionals in one place for clarity unless you have a good reason not to. This is likely bad style:</p>

<pre><code>$formal = formalize(:justify&#60;right&#62;, $title, :case&#60;title&#62;, $date);</code></pre>

<p>Named parameters are optional unless marked with a following <code>!</code>. Default values for optional named parameters are defined in the same way as for positional parameters, but may depend only on existing values, including the values of parameters that have already been bound. Named optional parameters default to <code>Nil</code> (that is, they set the default of the container) if they have no default. Named required parameters fail unless an argument pair of that name is supplied.</p>

<p>Bindings logically happen in declaration order, not call order, so any default may reliably depend on formal parameters to its left in the signature.</p>

<p>Another benefit of this policy is that, for routines that allow it, named arguments may be bound to positional parameters. (This is allowed only on routines that are <i>explicitly</i> declared with either the <code>proto</code> or the <code>only</code> declarator.) If the first positional parameter is named <code>$a</code>, for example, it will bind to a <code>:a()</code> argument in preference to the first positional argument.</p>

<p>The restriction to explicit <code>proto</code> and <code>only</code> declarations is motivated by the desire for both API purity and efficiency. Normal <code>multi</code> or <code>sub</code> declarations and normal method declarations do not attempt to look for named bindings to positionals. At most there is one such binding for any dispatch, when it initially calls the <code>proto</code> (or explicit <code>only</code>). The <code>proto</code> binder (for either sub or method) must automatically remap such named parameters to positionals before calling its internal multi dispatcher (the one represented by <code>{*}</code>). In the case of a <code>proto</code> sub, this mapping can be done at the point of the call, since there can only be one possible set of positional names, and the proto to be called can be known at compile time (in the absence of CANDO declarations in the outer scopes). So after</p>

<pre><code>proto foo ($x, $y, :$bar, :$baz) {*}
multi foo ($a, $b, :$bar, :$baz) {...}
multi foo ($n, $m, :$bar, :$baz) {...}

foo :y(2), :x(1);   # can turn into foo(1,2)</code></pre>

<p>the call to <code>foo</code> can be turned into a pure positional call to the <code>proto</code> (which can in turn be inlined because it&#39;s using the standard <code>{*}</code> dispatcher--and likewise for methods, when the class containing the <code>proto</code> is known to be finalizable). Note also that multi definitions are never required to use the same parameter names for positional parameters, since after the <code>proto</code> binding is done, the names (if any) are never used again for positionals.</p>

<p>The <code>$x</code> and <code>$y</code> names above are part of the public API only because they are named in the <code>proto</code>. Positional parameter names are never part of the advertised API unless explicitly enabled. An explicit <code>proto</code> may easily refrain from advertising names by declaring positionals with bare sigils:</p>

<pre><code>proto foo ($, $, :$bar, :$baz) {*}
multi foo ($x, $y, :$bar, :$baz) {...}

foo :x(1), :y(2);   # illegal</code></pre>

<p>(And an <code>only</code> routine may control the positional API simply by using <code>sub</code> instead, or by defining a <code>proto</code> with a single <code>multi</code> if finer control is desired.)</p>

<p>It follows from all this that an intuited proto never has to worry about supplying the API names of positional parameters. And no proto ever has to worry about conflicting names in the positionals of the multis they dispatch to, since any remapping is handled before that.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="List_parameters"
>List parameters</a></h2>

<p>List parameters capture a variable length list of data. They&#39;re used in subroutines like <code>print</code>, where the number of arguments needs to be flexible. They&#39;re also called &#34;variadic parameters&#34;, because they take a <i>variable</i> number of arguments. But generally we call them &#34;slurpy&#34; parameters because they slurp up arguments.</p>

<p>Slurpy parameters follow any required or optional parameters. They are marked by a <code>*</code> before the parameter:</p>

<pre><code>sub duplicate($n, *%flag, *@data) {...}</code></pre>

<p>Named arguments are bound to the slurpy hash (<code>*%flag</code> in the above example). Such arguments are evaluated in item context. Any remaining variadic arguments at the end of the argument list are bound to the slurpy array (<code>*@data</code> above) and are evaluated in list context.</p>

<p>For example:</p>

<pre><code>duplicate(3, reverse =&#62; 1, collate =&#62; 0, 2, 3, 5, 7, 11, 14);
duplicate(3, :reverse, :!collate, 2, 3, 5, 7, 11, 14);  # same

# The @data parameter receives [2, 3, 5, 7, 11, 14]
# The %flag parameter receives { reverse =&#62; 1, collate =&#62; 0 }</code></pre>

<p>Slurpy scalar parameters capture what would otherwise be the first elements of the variadic array:</p>

<pre><code>sub head(*$head, *@tail)         { return $head }
sub neck(*$head, *$neck, *@tail) { return $neck }
sub tail(*$head, *@tail)         { return @tail }

head(1, 2, 3, 4, 5);        # $head parameter receives 1
                            # @tail parameter receives [2, 3, 4, 5]

neck(1, 2, 3, 4, 5);        # $head parameter receives 1
                            # $neck parameter receives 2
                            # @tail parameter receives [3, 4, 5]</code></pre>

<p>Slurpy scalars still impose list context on their arguments.</p>

<p>Single slurpy parameters are treated lazily -- the list is only flattened into an array when individual elements are actually accessed:</p>

<pre><code>@fromtwo = tail(1..Inf);        # @fromtwo contains a lazy [2..Inf]</code></pre>

<p>[Conjecture: However, if you use two or more slurpy arrays in a signature, the list is instead evaluated in hyper context, and will be asked to split itself into the number of lists corresponding to the number of slurpies so declared. A non-hyperable list will return failure for this splitting operation, so the signature should only bind on parallelizable list operations. Likewise a list that is &#34;too short to split&#34; fails to bind, so a separate signature may match empty lists, and perhaps singletons, if we define &#34;too short&#34; that way.]</p>

<p>You can&#39;t bind to the name of a slurpy parameter: the name is just there so you can refer to it within the body.</p>

<pre><code>sub foo(*%flag, *@data) {...}

foo(:flag{ a =&#62; 1 }, :data[ 1, 2, 3 ]);
    # %flag has elements (flag =&#62; (a =&#62; 1)) and (data =&#62; [1,2,3])
    # @data has nothing</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Slurpy_block"
>Slurpy block</a></h2>

<p>It&#39;s also possible to declare a slurpy block: <code>*&#38;block</code>. It slurps up any nameless block, specified by <code>{...}</code>, at either the current positional location or the end of the syntactic list. Put it first if you want the option of putting a block either first or last in the arguments. Put it last if you want to force it to come in as the last argument.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Argument_list_binding"
>Argument list binding</a></h2>

<p>The underlying <code>Capture</code> object may be bound to a single name marked with a <code>|</code>.</p>

<pre><code>sub bar ($a,$b,$c,:$mice) { say $mice }
sub foo (|args) { say args.perl; &#38;bar.callwith(|args); }</code></pre>

<p>This prints:</p>

<pre><code>foo 1,2,3,:mice&#60;blind&#62;;     # says &#34;\(1,2,3,:mice&#60;blind&#62;)&#34; then &#34;blind&#34;</code></pre>

<p>As demonstrated above, the capture may be interpolated into another call&#39;s arguments. (The <code>|</code> prefix is described below.) Use of <code>callwith</code> allows the routine to be called without introducing an official <code>CALLER</code> frame. For more see &#34;Wrapping&#34; below.</p>

<p>The <code>|</code> parameter takes a snapshot of the current binding state, but does not consume any arguments from it. It is allowed to have more parameters within the signature:</p>

<pre><code>sub compare (|args, Num $x, Num $y --&#62; Bool) { ... }</code></pre>

<p>For all normal declarative purposes (invocants and multiple dispatch types, for instance), capture parameters are ignored.</p>

<pre><code>method addto (|args, $self: @x) { trace(args); $self += [+] @x }</code></pre>

<p>The extra signature is not required for non-<code>multi</code>s since there can only be one candidate, but for multiple dispatch the extra signature is required at least for its types, or the declaration would not know what signature to match against.</p>

<pre><code>multi foo (|args, Int, Bool?, *@, *%)) { reallyintfoo(args) }
multi foo (|args, Str, Bool?, *@, *%)) { reallystrfoo(args) }</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parcel_binding"
>Parcel binding</a></h2>

<p>When you bind an argument to a sigiled variable, it enforces the contract of that sigil, but sometimes you don&#39;t want that. It is possible to bind an argument to a simple name instead, which represents that argument in its rawest form, which is what we call a parcel. (It might actually be a <code>Parcel</code> object, or any item that can function as a parcel.) In any case, it&#39;s a raw reference to whatever was passed, with no commitment to structure or mutability.</p>

<pre><code>sub foo (\x, \y) { x = y; }    # might or might not succeed</code></pre>

<p>A <code>\</code> parameter effectively declares a new term in the language for the rest of the current scope, so when you use that term, it is not parsed as a list operator, so it will not look for any subsequent arguments.</p>

<pre><code>sub foo (\x) { x 42; }    # syntax error; two terms in a row</code></pre>

<p>Parcel parameters make it relatively easy to program in a &#34;sigilless&#34; style, if you desire:</p>

<pre><code>sub say-sins (\angles) {
    for angles -&#62; \&#120579; { say sin &#120579; }
}</code></pre>

<p>or</p>

<pre><code>my \&#119894; = some-integer; say &#119894; + 2;</code></pre>

<p>Note how <code>&#119894;</code> would be misinterpreted if it treated <code>+ 2</code> as an argument, but since it&#39;s a simple term, it doesn&#39;t.</p>

<p>The term does act like a function call in one way, however. Since it returns a parcel, the value will flatten in a list context, but itemize in an item context. You can use <code>prefix:&#60;|&#62;</code> to force flattening into an outer argument list, if needed.</p>

<p>It is possible to alias to a non-identifier by using the <code>term</code> syntactic category:</p>

<pre><code>my \term:&#60;&#8734;&#62; = Inf;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Flattening_argument_lists"
>Flattening argument lists</a></h2>

<p>The unary <code>|</code> operator casts its argument to a <code>Capture</code> object, then splices that capture into the argument list it occurs in. To get the same effect on multiple arguments you can use the <code>|&#171;</code> hyperoperator.</p>

<p><code>Pair</code> and <code>Hash</code> become named arguments:</p>

<pre><code>|(x=&#62;1);          # Pair, becomes \(x=&#62;1)
|{x=&#62;1, y=&#62;2};    # Hash, becomes \(x=&#62;1, y=&#62;2)</code></pre>

<p>Anything else that is <code>Iterable</code> is simply turned into positional arguments:</p>

<pre><code>|(1,2,3);         # Parcel, becomes \(1,2,3)
|(1..3);          # Range, becomes \(1,2,3)
|(1..2, 3);       # Parcel, becomes \(1,2,3)
|([x=&#62;1, x=&#62;2]);  # List (from an Array), becomes \((x=&#62;1), (x=&#62;2))</code></pre>

<p>For example:</p>

<pre><code>sub foo($x, $y, $z) {...}    # expects three scalars
@onetothree = 1..3;          # array stores three scalars

foo(1,2,3);                  # okay:  three args found
foo(@onetothree);            # error: only one arg
foo(|@onetothree);           # okay:  @onetothree flattened to three args</code></pre>

<p>The <code>|</code> operator flattens lazily -- the array is flattened only if flattening is actually required within the subroutine. To flatten before the list is even passed into the subroutine, use the <code>flat</code> list operator:</p>

<pre><code>foo(|flat 1,2,3 Z 4,5,6);    # zip list flattened before interpolation
foo |(1,2,3 Z 4,5,6).flat    # same thing</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multidimensional_argument_list_binding"
>Multidimensional argument list binding</a></h2>

<p>Some functions take more than one list of positional and/or named arguments, that they wish not to be flattened into one list. For instance, <code>zip()</code> wants to iterate several lists in parallel, while array and hash subscripts want to process a multidimensional slice. The set of underlying argument lists may be bound to a single array parameter declared with a double <code>**</code> marker:</p>

<pre><code>sub foo (**@slice) { ... }</code></pre>

<p>Note that this is different from</p>

<pre><code>sub foo (|slice) { ... }</code></pre>

<p>insofar as <code>|slice</code> is bound to a single argument-list object that makes no commitment to processing its structure (and maybe doesn&#39;t even know its own structure yet), while <code>**@slice</code> has to create an array that binds the incoming dimensional lists to the array&#39;s dimensions, and make that commitment visible to the rest of the scope via the sigil so that constructs expecting multidimensional lists know that multidimensionality is the intention.</p>

<p>It is allowed to specify a return type:</p>

<pre><code>sub foo (**@slice --&#62; Num) { ... }</code></pre>

<p>The invocant does not participate in multi-dimensional argument lists, so <code>self</code> is not present in the <code>**@slice</code> below:</p>

<pre><code>method foo (**@slice) { ... }</code></pre>

<p>The <code>**</code> marker is just a variant of the <code>*</code> marker that ends up requesting parcels when binding (underlyingly calling <code>.getarg</code>) rather than requesting individual elements as the flattening <code>*</code> does (underlyingly calling <code>.get</code>).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Zero-dimensional_argument_list"
>Zero-dimensional argument list</a></h2>

<p>If you call a function without parens and supply no arguments, the argument list becomes a zero-dimensional slice. It differs from <code>\()</code> in several ways:</p>

<pre><code>sub foo (**@slice) {...}
foo;        # +@slice == 0
foo();      # +@slice == 1

sub bar (|args = \(1,2,3)) {...}
bar;        # $args === \(1,2,3)
bar();      # $args === \()</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Feed_operators"
>Feed operators</a></h2>

<p>The variadic list of a subroutine call can be passed in separately from the normal argument list, by using either of the <i>feed</i> operators: <code>&#60;==</code> or <code>==&#62;</code>. Syntactically, feed operators expect to find a statement on either end. Any statement can occur on the source end; however not all statements are suitable for use on the sink end of a feed.</p>

<p>Each operator expects to find a call to a variadic receiver on its &#34;sharp&#34; end, and a list of values on its &#34;blunt&#34; end:</p>

<pre><code>grep { $_ % 2 } &#60;== @data;

@data ==&#62; grep { $_ % 2 };</code></pre>

<p>It binds the (potentially lazy) list from the blunt end to the slurpy parameter(s) of the receiver on the sharp end. In the case of a receiver that is a variadic function, the feed is received as part of its slurpy list. So both of the calls above are equivalent to:</p>

<pre><code>grep { $_ % 2 }, @data;</code></pre>

<p>Note that all such feeds (and indeed all lazy argument lists) supply an implicit promise that the code producing the lists may execute in parallel with the code receiving the lists. (Feeds, hyperops, and junctions all have this promise of parallelizability in common, but differ in interface. Code which violates these promises is erroneous, and will produce undefined results when parallelized.)</p>

<p>However, feeds go a bit further than ordinary lazy lists in enforcing the parallel discipline: they explicitly treat the blunt end as a cloned closure that starts a subthread (presumably cooperative). The only variables shared by the inner scope with the outer scope are those lexical variables declared in the outer scope that are visible at the time the closure is cloned and the subthread spawned. Use of such shared variables will automatically be subject to transactional protection (and associated overhead). Package variables are not cloned unless predeclared as lexical names with <code>our</code>. Variables declared within the blunt end are not visible outside, and in fact it is illegal to declare a lexical on the blunt end that is not enclosed in curlies somehow.</p>

<p>Because feeds are defined as lazy pipes, a chain of feeds may not begin and end with the same array without some kind of eager sequence point. That is, this isn&#39;t guaranteed to work:</p>

<pre><code>@data &#60;== grep { $_ % 2 } &#60;== @data;</code></pre>

<p>either of these do:</p>

<pre><code>@data &#60;== grep { $_ % 2 } &#60;== eager @data;
@data &#60;== eager grep { $_ % 2 } &#60;== @data;</code></pre>

<p>Conjecture: if the cloning process eagerly duplicates <code>@data</code>, it could be forced to work. Not clear if this is desirable, since ordinary clones just clone the container, not the value.</p>

<p>Leftward feeds are a convenient way of explicitly indicating the typical right-to-left flow of data through a chain of operations:</p>

<pre><code>@oddsquares = map { $_**2 }, sort grep { $_ % 2 }, @nums;

# perhaps more clearly written as...

@oddsquares = do {
    map { $_**2 } &#60;== sort &#60;== grep { $_ % 2 } &#60;== @nums;
}</code></pre>

<p>Rightward feeds are a convenient way of reversing the normal data flow in a chain of operations, to make it read left-to-right:</p>

<pre><code>@oddsquares = do {
    @nums ==&#62; grep { $_ % 2 } ==&#62; sort ==&#62; map { $_**2 };
}</code></pre>

<p>Note that something like the <code>do</code> is necessary because feeds operate at the statement level. Parens would also work, since a statement is expected inside:</p>

<pre><code>@oddsquares = (
    @nums ==&#62; grep { $_ % 2 } ==&#62; sort ==&#62; map { $_**2 };
);</code></pre>

<p>But as described below, you can also just write:</p>

<pre><code>@nums ==&#62; grep { $_ % 2 } ==&#62; sort ==&#62; map { $_**2 } ==&#62; @oddsquares;</code></pre>

<p>If the operand on the sharp end of a feed is not a call to a variadic operation, it must be something else that can be interpreted as a list receiver, or a scalar expression that can be evaluated to produce an object that does the <code>KitchenSink</code> role, such as an <code>IO</code> object. Such an object provides <code>.clear</code> and <code>.push</code> methods that will be called as appropriate to send data. (Note that an <code>IO</code> object used as a sink will force eager evaluation on its pipeline, so the next statement is guaranteed not to run till the file is closed. In contrast, an <code>Array</code> object used as a sink turns into a lazy array.)</p>

<p>Any non-variadic object (such as an <code>Array</code> or <code>IO</code> object) used as a filter between two feeds is treated specially as a <i>tap</i> that merely captures data <i>en passant</i>. You can safely install such a tap in an extended pipeline without changing the semantics. An <code>IO</code> object used as a tap does not force eager evaluation since the eagerness is controlled instead by the downstream feed.</p>

<p>Any prefix list operator is considered a variadic operation, so ordinarily a list operator adds any feed input to the end of its list. But sometimes you want to interpolate elsewhere, so any contextualizer with <code>*</code> as an argument may be used to indicate the target of a feed without the use of a temporary array:</p>

<pre><code>foo() ==&#62; say @(*), &#34; is what I meant&#34;;
bar() ==&#62; @(*).baz();</code></pre>

<p>Likewise, an <code>Array</code> used as a tap may be distinguished from an <code>Array</code> used as a translation function:</p>

<pre><code>numbers() ==&#62; @array ==&#62; bar()          # tap
numbers() ==&#62; @array[@(*)] ==&#62; bar()    # translation</code></pre>

<p>To append multiple sources to the next sink, double the angle:</p>

<pre><code>my $sink;
0..*       ==&#62;  $sink;
&#39;a&#39;..*     ==&#62;&#62; $sink;
pidigits() ==&#62;&#62; $sink;

# outputs &#34;(0, &#39;a&#39;, 3)\n&#34;...
for $sink.zip { .perl.say }</code></pre>

<p>Each such append adds another slice element (that is, a parcel), to the sink. (The original feed also created a parcel.)</p>

<p>You may use a variable (or variable declaration) as a receiver, in which case the list value is bound as the &#34;todo&#34; of the variable. (The append form binds addition todos to the receiver&#39;s todo list.) Do not think of it as an assignment, nor as an ordinary binding. Think of it as iterator creation. In the case of a scalar variable, that variable contains the newly created iterator itself. In the case of an array, the new iterator is installed as the method for extending the array. As with assignment, the old todo list is clobbered; use the append form to avoid that and get push semantics. In any case, feeding an array always flattens. You must use the scalar form to preserve slice information.</p>

<p>In general you can simply think of a receiver array as representing the results of the chain, so you can equivalently write any of:</p>

<pre><code>my @oddsquares &#60;== map { $_**2 } &#60;== sort &#60;== grep { $_ % 2 } &#60;== @nums;

my @oddsquares
    &#60;== map { $_**2 }
    &#60;== sort
    &#60;== grep { $_ % 2 }
    &#60;== @nums;

@nums ==&#62; grep { $_ % 2 } ==&#62; sort ==&#62; map { $_**2 } ==&#62; my @oddsquares;

@nums
==&#62; grep { $_ % 2 }
==&#62; sort
==&#62; map { $_**2 }
==&#62; my @oddsquares;</code></pre>

<p>Since the feed iterator is bound into the final variable, the variable can be just as lazy as the feed that is producing the values.</p>

<p>When feeds are bound to arrays with &#34;push&#34; semantics, you can have a receiver for multiple feeds:</p>

<pre><code>my @foo;
0..2       ==&#62;  @foo;
&#39;a&#39;..&#39;c&#39;   ==&#62;&#62; @foo;
say @foo;   # 0,1,2,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;</code></pre>

<p>Note how the feeds are concatenated in <code>@foo</code> so that <code>@foo</code> is a list of 6 elements. This is the default behavior. However, sometimes you want to capture the outputs as a list of two iterators, namely the two iterators that represent the two input feeds. You can get at those two iterators by using a scalar instead, which will preserve the slice structure, which can be fed to any operation that knows how to deal with a list of parcels as a slice, such as <code>zip</code>:</p>

<pre><code>0..*       ==&#62;  $foo;
&#39;a&#39;..*     ==&#62;&#62; $foo;
pidigits() ==&#62;&#62; $foo;

for $foo.zip { .say }

    [0,&#39;a&#39;,3]
    [1,&#39;b&#39;,1]
    [2,&#39;c&#39;,4]
    [3,&#39;d&#39;,1]
    [4,&#39;e&#39;,5]
    [5,&#39;f&#39;,9]
    ...</code></pre>

<p>Here <code>$foo</code> is a list of three parcels, so</p>

<pre><code>$foo.zip</code></pre>

<p>is equivalent to</p>

<pre><code>my (@a,@b,@c) := |$foo;
zip(@a; @b; @c)</code></pre>

<p>A named receiver array is useful when you wish to feed into an expression that is not an ordinary list operator, and you wish to be clear where the feed&#39;s destination is supposed to be:</p>

<pre><code>picklist() ==&#62; my @baz;
my @foo = @bar[@baz];</code></pre>

<p>Various contexts may or may not be expecting multi-dimensional slices or feeds. By default, ordinary arrays are flattened in slurpy context, that is, they have &#34;list&#34; semantics. If you say</p>

<pre><code>zip(0..2; &#39;a&#39;..&#39;c&#39;) ==&#62; my @tmp;
for @tmp { .say }</code></pre>

<p>then you get 0,1,2,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;. If you have a multidimensional array, you can ask for flattening semantics explicitly with <code>flat</code>:</p>

<pre><code>zip(0..2; &#39;a&#39;..&#39;c&#39;) ==&#62; my $tmp;
for $tmp.flat { .say }</code></pre>

<p>As we saw earlier, &#34;zip&#34; produces an interleaved result by taking one element from each list in turn, so</p>

<pre><code>zip(0..2; &#39;a&#39;..&#39;c&#39;) ==&#62; my $tmp;
for $tmp.zip { .say }</code></pre>

<p>produces 0,&#39;a&#39;,1,&#39;b&#39;,2,&#39;c&#39;.</p>

<p>If you want the zip&#39;s result as a list of subarrays, then you need to put the zip itself into a &#34;chunky&#34; <code>LoL</code> context instead:</p>

<pre><code>zip(0..2; &#39;a&#39;..&#39;c&#39;) ==&#62; my $tmp;
for $tmp.zip.lol { .say }</code></pre>

<p>This produces two values on each line. But usually you want the flat form so you can just bind it directly to a signature:</p>

<pre><code>for $tmp.zip -&#62; $i, $a { say &#34;$i: $a&#34; }</code></pre>

<p>Otherwise you&#39;d have to say this:</p>

<pre><code>for $tmp.zip.lol -&#62; [$i, $a] { say &#34;$i: $a&#34; }</code></pre>

<p>Note that with the current definition, the order of feeds is preserved left to right in general regardless of the position of the receiver.</p>

<p>So</p>

<pre><code>(&#39;a&#39;..*; 0..*) ==&#62; $feed;
 for $feed.zip &#60;== @foo) -&#62; $a, $i, $x { ... }</code></pre>

<p>is the same as</p>

<pre><code>&#39;a&#39;..* ==&#62; $feed;
 0..*  ==&#62;&#62; $feed;
 for $feed.zip &#60;== @foo) -&#62; $a, $i, $x { ... }</code></pre>

<p>which is the same as</p>

<pre><code>for zip(&#39;a&#39;..*; 0..*; @foo) -&#62; $a, $i, $x { ... }</code></pre>

<p>Also note that these come out to be identical for ordinary arrays:</p>

<pre><code>@foo.zip
@foo.cat</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Closure_parameters"
>Closure parameters</a></h2>

<p>Parameters declared with the <code>&#38;</code> sigil take blocks, closures, or subroutines as their arguments. Closure parameters can be required, optional, named, or slurpy.</p>

<pre><code>sub limited_grep (Int $count, &#38;block, *@list) {...}

# and later...

@first_three = limited_grep 3, {$_&#60;10}, @data;</code></pre>

<p>(The comma is required after the closure.)</p>

<p>Within the subroutine, the closure parameter can be used like any other lexically scoped subroutine:</p>

<pre><code>sub limited_grep (Int $count, &#38;block, *@list) {
    ...
    if block($nextelem) {...}
    ...
}</code></pre>

<p>The closure parameter can have its own signature in a type specification written with <code>:(...)</code>:</p>

<pre><code>sub limited_Dog_grep ($count, &#38;block:(Dog), Dog *@list) {...}</code></pre>

<p>and even a return type:</p>

<pre><code>sub limited_Dog_grep ($count, &#38;block:(Dog --&#62; Bool), Dog *@list) {...}</code></pre>

<p>When an argument is passed to a closure parameter that has this kind of signature, the argument must be a <code>Code</code> object with a compatible parameter list and return type.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="En_passant_type_capture"
>En passant type capture</a></h2>

<p>Unlike normal parameters, type parameters often come in piggybacked on the actual value as &#34;kind&#34;, and you&#39;d like a way to capture both the value and its kind at once. (A &#34;kind&#34; is a storage type, that is, a class or type that an object is allowed to be. An object is not officially allowed to take on a constrained or contravariant type.) A type variable can be used anywhere a type name can, but instead of asserting that the value must conform to a particular type, it captures the actual &#34;kind&#34; of the object and also declares a package/type name by which you can refer to that kind later in the signature or body. In addition, it captures the nominal typing of any associated nominal type. For instance, if you wanted to match any two Dogs as long as they were of the same kind, you can say:</p>

<pre><code>sub matchedset (Dog ::T $fido, T $spot) {...}</code></pre>

<p>This actually turns into something more like</p>

<pre><code>sub matchedset (Dog ::T $fido, Dog $spot where T) {...}</code></pre>

<p>Note that <code>::T</code> is not required to contain <code>Dog</code>, only a type that is compatible with <code>Dog</code>. Note also that the nominal type, <code>Dog</code>, is also included in the meaning of <code>T</code>, along with the notion that the actual type must match the storage type of <code>$fido</code>.</p>

<p>The <code>::</code> quasi-sigil is short for &#34;subset&#34; in much the same way that <code>&#38;</code> is short for &#34;sub&#34;. Just as <code>&#38;</code> can be used to name any kind of code, so too <code>::</code> can be used to name any kind of type. Both of them insert a bare identifier into the symbol table, though they fill different syntactic spots.</p>

<p>Note that it is not required to capture the object associated with the class unless you want it. The sub above could be written as</p>

<pre><code>sub matchedset (Dog ::T, T) {...}</code></pre>

<p>if we&#39;re not interested in <code>$fido</code> or <code>$spot</code>. Or just</p>

<pre><code>sub matchedset (::T, T) {...}</code></pre>

<p>if we don&#39;t care about anything but the matching. Note here that the second parameter may be more derived than the first. If you need them to be identical, you must say something like</p>

<pre><code>sub matchedset (::T, $ where { $_.WHAT === T }</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unpacking_array_parameters"
>Unpacking array parameters</a></h2>

<p>Instead of specifying an array parameter as an array:</p>

<pre><code>sub quicksort (@data, $reverse?, $inplace?) {
    my $pivot := shift @data;
    ...
}</code></pre>

<p>it may be broken up into components in the signature, by specifying the parameter as if it were an anonymous array of parameters:</p>

<pre><code>sub quicksort ([$pivot, *@data], $reverse?, $inplace?) {
    ...
}</code></pre>

<p>This subroutine still expects an array as its first argument, just like the first version.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unpacking_a_single_list_argument"
>Unpacking a single list argument</a></h2>

<p>To match the first element of the slurpy list, use a &#34;slurpy&#34; scalar:</p>

<pre><code>sub quicksort (:$reverse, :$inplace, *$pivot, *@data)</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unpacking_tree_node_parameters"
>Unpacking tree node parameters</a></h2>

<p>You can unpack hash values and tree nodes in various dwimmy ways by enclosing the bindings of child nodes and attributes in parentheses following the declaration of the node itself:</p>

<pre><code>sub traverse ( BinTree $top ( $left, $right ) ) {
    traverse($left);
    traverse($right);
}</code></pre>

<p>In this, <code>$left</code> and <code>$right</code> are automatically bound to the left and right nodes of the tree. If <code>$top</code> is an ordinary object, it binds the <code>$top.left</code> and <code>$top.right</code> attributes. If it&#39;s a hash, it binds <code>$top&#60;left&#62;</code> and <code>$top&#60;right&#62;</code>. If <code>BinTree</code> is a signature type and $top is a <code>Capture</code> (argument list) object, the child types of the signature are applied to the actual arguments in the argument list object. (Signature types have the benefit that you can view them inside-out as constructors with positional arguments, such that the transformations can be reversible.)</p>

<p>However, the full power of signatures can be applied to pattern match just about any argument or set of arguments, even though in some cases the reverse transformation is not derivable. For instance, to bind to an array of children named <code>.kids</code> or <code>.&#60;kids&#62;</code>, use something like:</p>

<pre><code>proto traverse ($) {*}
multi traverse ( NAry $top ( :kids [$eldest, *@siblings] ) ) {
    traverse($eldest);
    traverse(:kids(@siblings));  # (binds @siblings to $top)
}
multi traverse ( $leaf ) {...}</code></pre>

<p>The second candidate is called only if the parameter cannot be bound to both <code>$top</code> and to the &#34;kids&#34; parsing subparameter.</p>

<p>Likewise, to bind to a hash element of the node and then bind to keys in that hash by name:</p>

<pre><code>sub traverse ( AttrNode $top ( :%attr{ :$vocalic, :$tense } ) ) {
    say &#34;Has {+%attr} attributes, of which&#34;;
    say &#34;vocalic = $vocalic&#34;;
    say &#34;tense = $tense&#34;;
}</code></pre>

<p>You may omit the top variable if you prefix the parentheses with a colon to indicate a signature. Otherwise you must at least put the sigil of the variable, or we can&#39;t correctly differentiate:</p>

<pre><code>my Dog ($fido, $spot)   := twodogs();       # list of two dogs
my Dog $ ($fido, $spot) := twodogs();       # one twodog object
my Dog :($fido, $spot)  := twodogs();       # one twodog object</code></pre>

<p>Sub signatures can be matched directly within regexes by using <code>:(...)</code> notation.</p>

<pre><code>push @a, &#34;foo&#34;;
push @a, \(1,2,3);
push @a, &#34;bar&#34;;
...
my ($i, $j, $k);
@a ~~ rx/
        &#60;,&#62;                         # match initial elem boundary
        :(Int $i,Int $j,Int? $k)    # match lists with 2 or 3 ints
        &#60;,&#62;                         # match final elem boundary
      /;
say &#34;i = $&#60;i&#62;&#34;;
say &#34;j = $&#60;j&#62;&#34;;
say &#34;k = $&#60;k&#62;&#34; if defined $&#60;k&#62;;</code></pre>

<p>If you want a parameter bound into <code>$/</code>, you have to say <code>$&#60;i&#62;</code> within the signature. Otherwise it will try to bind an external <code>$i</code> instead, and fail if no such variable is declared.</p>

<p>Note that unlike a sub declaration, a regex-embedded signature has no associated &#34;returns&#34; syntactic slot, so you have to use <code>--&#62;</code> within the signature to specify the <code>of</code> type of the signature, or match as an arglist:</p>

<pre><code>:(Num, Num --&#62; Coord)
:(\Coord(Num, Num))</code></pre>

<p>A consequence of the latter form is that you can match the type of an object with <code>:(\Dog)</code> without actually breaking it into its components. Note, however, that it&#39;s not equivalent to say</p>

<pre><code>:(--&#62; Dog)</code></pre>

<p>which would be equivalent to</p>

<pre><code>:(\Dog())</code></pre>

<p>that is, match a nullary function of type <code>Dog</code>. Nor is it equivalent to</p>

<pre><code>:(Dog)</code></pre>

<p>which would be equivalent to</p>

<pre><code>:(\Any(Dog))</code></pre>

<p>and match a function taking a single parameter of type Dog.</p>

<p>Note also that bare <code>\(1,2,3)</code> is never legal in a regex since the first (escaped) paren would try to match literally.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Attributive_parameters"
>Attributive parameters</a></h2>

<p>If a submethod&#39;s parameter is declared with a <code>.</code> or <code>!</code> after the sigil (like an attribute):</p>

<pre><code>submethod initialize($.name, $!age) {}</code></pre>

<p>then the argument is bound directly to the object&#39;s attribute of the same name. This avoids the frequent need to write code like:</p>

<pre><code>submethod initialize($name, $age) {
    $.name = $name;
    $!age  = $age;
}</code></pre>

<p>The initialization of attributes requires special care to preserve encapsulation; therefore the default for attributive parameters is value semantics, that is, as if specified with <code>is copy</code>. Hence, the submethod above is really more like:</p>

<pre><code>submethod initialize($name is copy, $age is copy) {
    $.name := $name;      # or maybe = here, since it&#39;s a parent&#39;s attr
    $!age  := $age;       # or maybe only $! parameters work really
}</code></pre>

<p>If you wish to allow the user to initialize an attribute by reference, you may either write your own initializer submethod explicitly, or simply mark the attributes you want to work that way with <code>is parcel</code>:</p>

<pre><code>has $!age is parcel;   # BUILD will automatically use binding, not copy</code></pre>

<p>To rename an attribute parameter you can use the explicit pair form:</p>

<pre><code>submethod initialize(:moniker($.name), :youth($!age)) {}</code></pre>

<p>The <code>:$name</code> shortcut may be combined with the <code>$.name</code> shortcut, but the twigil is ignored for the parameter name, so</p>

<pre><code>submethod initialize(:$.name, :$!age) {}</code></pre>

<p>is the same as:</p>

<pre><code>submethod initialize(:name($.name), :age($!age)) {}</code></pre>

<p>Note that <code>$!age</code> actually refers to the private &#34;<code>has</code>&#34; variable that can be referred to as either <code>$age</code> or <code>$!age</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Placeholder_variables"
>Placeholder variables</a></h2>

<p>Even though every bare block is a closure, bare blocks can&#39;t have explicit parameter lists. Instead, they use &#34;placeholder&#34; variables, marked by a caret (<code>^</code>) or a colon (<code>:</code>) after their sigils. The caret marks positional placeholders, while the colon marks named placeholders.</p>

<p>Using placeholders in a block defines an implicit parameter list. The signature is the list of distinct positional placeholder names, sorted in Unicode order, following by the named placeholder names in any order. So:</p>

<pre><code>{ say &#34;woof&#34; if $:dog; $^y &#60; $^z &#38;&#38; $^x != 2 }</code></pre>

<p>is a shorthand for:</p>

<pre><code>-&#62; $x,$y,$z,:$dog { say &#34;woof&#34; if $dog; $y &#60; $z &#38;&#38; $x != 2 }</code></pre>

<p>Note that placeholder variables syntactically cannot have type constraints. Also, it is illegal to use placeholder variables in a block that already has a signature, because the autogenerated signature would conflict with that. Positional placeholder names consisting of a single uppercase letter are disallowed, not because we&#39;re mean, but because it helps us catch references to obsolete Perl 5 variables such as <code>$^O</code>.</p>

<p>The <code>$_</code> variable functions as a placeholder in a block without any other placeholders or signature. Any bare block without placeholders really has a parameter like this:</p>

<pre><code>-&#62; $_ is parcel = OUTER::&#60;$_&#62; { .mumble }</code></pre>

<p>(However, statement control <code>if</code> notices this and passes no argument, so <code>$_</code> ends up being bound to the outer <code>$_</code> anyway.)</p>

<p>A block may also refer to either <code>@_</code> or <code>%_</code> or both, each of which will be added to generated signature as a normal readonly slurpy parameter:</p>

<pre><code>{ say $:what; warn &#34;bad option: $_\n&#34; for keys %_; }</code></pre>

<p>turns into</p>

<pre><code>-&#62; :$what, *%_ { say $what; warn &#34;bad option: $_\n&#34; for keys %_; }</code></pre>

<p>If not used, they are not added, and a dispatch with mispatched parameters will fail.</p>

<p>The use of a P5ish <code>@_</code> in a signatureless sub falls naturally out of this:</p>

<pre><code>sub sayall { .say for @_ }</code></pre>

<p>Note that in this case, <code>$_</code> is not treated as a placeholder because there is already the <code>@_</code> placeholder. And <code>@_</code> is a placeholder only because the sub has no official signature. Otherwise it would be illegal (unless explicitly declared).</p>

<p>Placeholders may also be used in method bodies that have no formal signature. The invocant is always removed first, so the first placeholder argument always refers to the first non-invocant argument. <code>@_</code> will never contain the invocant. The invocant is always available via <code>self</code>, of course.</p>

<p>Since the placeholder declares a parameter variable without the twigil, the twigil is needed only on the first occurrence of the variable within the block. Subsequent mentions of that variable may omit the twigil. Within an internal nested block the twigil <i>must</i> be omitted, since it would wrongly attach to the inner block.</p>

<p>Note that, unlike in Perl 5, <code>@_</code> may not be used within an inner block to refer to the outer block&#39;s arguments:</p>

<pre><code>sub say-or-print {
    if $SAYIT {
        say @_;     # WRONG
    }
    else {
        print @_;   # WRONG
    }
}</code></pre>

<p>because this desugars to:</p>

<pre><code>sub say-or-print {
    if $SAYIT -&#62; *@_ {
        say @_;
    }
    else -&#62; *@_ {
        print @_;
    }
}</code></pre>

<p>Translators of Perl 5 will need to bear this in mind.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Properties_and_traits"
>Properties and traits</a></h1>

<p>Compile-time properties are called &#34;traits&#34;. The <code>is <i>NAME</i> (<i>DATA</i>)</code> syntax defines traits on containers and subroutines, as part of their declaration:</p>

<pre><code>constant $pi is Approximated = 3;   # variable $pi has Approximated trait

my $key is Persistent(:file&#60;.key&#62;);

sub fib is cached {...}</code></pre>

<p>The <code>will <i>NAME</i> <i>BLOCK</i></code> syntax is a synonym for <code>is <i>NAME</i> (<i>BLOCK</i>)</code>:</p>

<pre><code>my $fh will undo { close $fh };    # Same as: my $fh is undo({ close $fh });</code></pre>

<p>The <code>but <i>NAME</i> (<i>DATA</i>)</code> syntax specifies run-time properties on values:</p>

<pre><code>constant $pi = 3 but Inexact;       # value 3 has Inexact property

sub system {
    ...
    return $error but False if $error;
    return 0 but True;
}</code></pre>

<p>Properties are predeclared as roles and implemented as mixins--see S12.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subroutine_traits"
>Subroutine traits</a></h2>

<p>These traits may be declared on the subroutine as a whole (individual parameters take other traits). Trait syntax depends on the particular auxiliary you use, but for <code>is</code>, the subsequent syntax is identical to adverbial syntax, except that that colon may be omitted or doubled depending on the degree of ambiguity desired:</p>

<pre><code>sub x() is ::Foo[...]       # definitely a parameterized typename
sub x() is :Foo[...]        # definitely a pair with a list
sub x() is Foo[...]         # depends on whether Foo is predeclared as type</code></pre>

<dl>
<dt><a name="is_signature"
><code>is signature</code></a></dt>

<dd>
<p>The signature of a subroutine. Normally declared implicitly, by providing a parameter list and/or return type.</p>

<dt><a name="as/is_as"
><code>as</code>/<code>is as</code></a></dt>

<dd>
<p>The <code>inner</code> type constraint that a routine imposes on its return value.</p>

<dt><a name="of/is_of"
><code>of</code>/<code>is of</code></a></dt>

<dd>
<p>The <code>of</code> type that is the official return type of the routine. Or you can think of &#34;of&#34; as outer/formal. If there is no inner type, the outer type also serves as the inner type to constrain the return value.</p>

<dt><a name="will_do"
><code>will do</code></a></dt>

<dd>
<p>The block of code executed when the subroutine is called. Normally declared implicitly, by providing a block after the subroutine&#39;s signature definition.</p>

<dt><a name="is_rw"
><code>is rw</code></a></dt>

<dd>
<p>Marks a subroutine as returning an lvalue.</p>

<dt><a name="is_parcel"
><code>is parcel</code></a></dt>

<dd>
<p>Marks a subroutine as returning a parcel.</p>

<dt><a name="is_parsed"
><code>is parsed</code></a></dt>

<dd>
<p>Specifies the subrule by which a macro call is parsed. The parse always starts after the macro&#39;s initial token. If the operator has two parts (circumfix or postcircumfix), the final token is also automatically matched, and should not be matched by the supplied regex.</p>

<dt><a name="is_reparsed"
><code>is reparsed</code></a></dt>

<dd>
<p>Also specifies the subrule by which a macro call is parsed, but restarts the parse before the macro&#39;s initial token, usually because you want to parse using an existing rule that expects to traverse the initial token. If the operator has two parts (circumfix or postcircumfix), the final token must also be explicitly matched by the supplied regex.</p>

<dt><a name="is_cached"
><code>is cached</code></a></dt>

<dd>
<p>Marks a subroutine as being memoized, or at least memoizable. In the abstract, this cache is just a hash where incoming argument <code>Capture</code>s are mapped to return values. If the <code>Capture</code> is found in the hash, the return value need not be recalculated. If you use this trait, the compiler will assume two things:</p>

<ul>
<li>A given <code>Capture</code> would always calculate the same return value. That is, there is no state hidden within the dynamic scope of the call.</li>

<li>The cache lookup is likely to be more efficient than recalculating the value in at least some cases, because either most uncached calls would be slower (and reduce throughput), or you&#39;re trying to avoid a significant number of pathological cases that are unacceptably slow (and increase latency).</li>
</ul>

<p>This trait is a suggestion to the compiler that caching is okay. The compiler is free to choose any kind of caching algorithm (including non-expiring, random, lru, pseudo-lru, or adaptive algorithms, or even no caching algorithm at all). The run-time system is free to choose any kind of maximum cache size depending on the availability of memory and trends in usage patterns. You may suggest a particular cache size by passing a numeric argument (representing the maximum number of unique <code>Capture</code> values allowed), and some of the possible algorithms may pay attention to it. You may also pass <code>*</code> for the size to request a non-expiring cache (complete memoization). The compiler is free to ignore this too.</p>

<p>The intent of this trait is to specify performance hints without mandating any exact behavior. Proper use of this trait should not change semantics of the program; it functions as a kind of &#34;pragma&#34;. This trait will not be extended to reinvent other existing ways of achieving the same effect. To gain more control, write your own trait handler to allow the use of a more specific trait, such as &#34;<code>is lru(42)</code>&#34;. Alternately, just use a state hash keyed on the sub&#39;s argument capture to write your own memoization with complete control from within the subroutine itself, or from within a wrapper around your subroutine.</p>

<dt><a name="is_tighter/is_looser/is_equiv"
><code>is tighter</code>/<code>is looser</code>/<code>is equiv</code></a></dt>

<dd>
<p>Specifies the precedence of an operator relative to an existing operator. <code>tighter</code> and <code>looser</code> precedence levels default to being left associative. They define a new precedence level slightly tighter or looser than the precedence level on which they&#39;re based. Both <code>tighter</code> and <code>looser</code> may be specified, in which case the new precedence level is generated midway between the specified levels.</p>

<p>Two different declarations using the same precedence derivation end up at the same precedence level, as if <code>equiv</code> was specified instead of <code>tighter</code>/<code>looser</code>, and the second will clone the associativity of the first. If the second explicitly specifies an associativity that differs from the first, unexpected parsing conflicts may result. (See S03.)</p>

<p>In addition to cloning the precedence level, <code>equiv</code> also clones other traits, so it specifies the default associativity to be the same as the operator to which the new operator is equivalent. The following are the default equivalents for various syntactic categories if neither <code>equiv</code> nor <code>assoc</code> is specified. (Many of these have no need of precedence or associativity because they are parsed specially. Nevertheless, <code>equiv</code> may be useful for cloning other traits of these operators.)</p>

<pre><code>category:&#60;prefix&#62;
circumfix:&#60;( )&#62;
dotty:&#60;.&#62;
infix:&#60;+&#62;
infix_circumfix_meta_operator:[&#39;&#187;&#39;,&#39;&#171;&#39;]
infix_postfix_meta_operator:&#60;=&#62;
infix_prefix_meta_operator:&#60;!&#62;
package_declarator:&#60;class&#62;
postcircumfix:&#60;( )&#62;
postfix:&#60;++&#62;
postfix_prefix_meta_operator:[&#39;&#187;&#39;]
prefix:&#60;++&#62;
prefix_circumfix_meta_operator:[&#39;[&#39;,&#39;]&#39;]
prefix_postfix_meta_operator:[&#39;&#171;&#39;]
q_backslash:&#60;\\&#62;
qq_backslash:&#60;n&#62;
quote_mod:&#60;c&#62;
quote:&#60;q&#62;
regex_assertion:&#60;?&#62;
regex_backslash:&#60;w&#62;
regex_metachar:&#60;.&#62;
regex_mod_internal:&#60;i&#62;
routine_declarator:&#60;sub&#62;
scope_declarator:&#60;my&#62;
sigil:&#60;$&#62;
special_variable:&#60;$!&#62;
statement_control:&#60;if&#62;
statement_mod_cond:&#60;if&#62;
statement_mod_loop:&#60;while&#62;
statement_prefix:&#60;do&#62;
term:&#60;*&#62;
trait_mod:&#60;is&#62;
trait_verb:&#60;of&#62;
twigil:&#60;?&#62;
type_declarator:&#60;subset&#62;
version:&#60;v&#62;</code></pre>

<p>The existing operator may be specified either as a function object or as a string argument equivalent to the one that would be used in the complete function name. In string form the syntactic category will be assumed to be the same as the new declaration. Therefore these all have the same effect:</p>

<pre><code>sub postfix:&#60;!&#62; ($x) is equiv(&#38;postfix:&#60;++&#62;) {...}
sub postfix:&#60;!&#62; ($x) is equiv&#60;++&#62; {...}
sub postfix:&#60;!&#62; ($x) {...}      # since equiv&#60;++&#62; is the default</code></pre>

<p>Prefix operators that are identifiers are handled specially. The form with one argument defaults to named unary precedence instead of autoincrement precedence:</p>

<pre><code>sub prefix:&#60;foo&#62; ($x) {...}
foo 1, 2, 3;        # means foo(1), 2, 3</code></pre>

<p>Likewise postfix operators that look like method calls are forced to default to the precedence of method calls. Any prefix operator that requires multiple arguments defaults to listop precedence, even if it is not an identifier:</p>

<pre><code>sub prefix:&#60;&#9742;&#62; ($x,$y) {...}
&#9742; 1;                # ERROR, too few arguments
&#9742; 1, 2;             # okay
&#9742; 1, 2, 3;          # ERROR, too many arguments</code></pre>

<p>You must use the <code>prefix:&#60;foo&#62;</code> form in order to mutate the grammar to parse as a named unary operator. Normal function definitions never change the grammar, and when called always parse as listops, even if defined with a single argument:</p>

<pre><code>sub foo ($x) {...}  # a listop
foo(1), 2, 3;       # okay
(foo 1), 2, 3;      # okay
foo 1, 2, 3;        # ERROR, too many arguments</code></pre>

<p>Likewise 0-ary functions parse as listops. Use <code>term:&#60;foo&#62;</code> (or a constant or enum declaration) to declare a term that expects no arguments.</p>

<p>Because these traits have an immediate declarative effect, it is illegal to apply them to a <code>multi</code>, or to any post-declared function. More generally, any such language-bending declaration must follow the same lexical scoping rules that a macro does.</p>

<dt><a name="is_assoc"
><code>is assoc</code></a></dt>

<dd>
<p>Specifies the associativity of an operator explicitly. Valid values are:</p>

<pre><code>Tag         Examples        Meaning of $a op $b op $c       Default equiv
===         ========        =========================       =============
left        + - * / x       ($a op $b) op $c                +
right       ** =            $a op ($b op $c)                **
non         cmp &#60;=&#62; ..      ILLEGAL                         cmp
chain       == eq ~~        ($a op $b) and ($b op $c)       eqv
list        | &#38; ^ Z         op($a; $b; $c)                  |</code></pre>

<p>Note that operators &#34;<code>equiv</code>&#34; to relationals are automatically considered chaining operators. When creating a new precedence level, the chaining is determined by the presence or absence of &#34;<code>is assoc&#60;chain&#62;</code>&#34;, and other operators defined at that level are required to be the same.</p>

<p>Specifying an <code>assoc</code> without an explicit <code>equiv</code> substitutes a default <code>equiv</code> consistent with the associativity, as shown in the final column above.</p>

<p>Because this trait has an immediate declarative effect, it is illegal to apply it to a <code>multi</code>, or to any post-declared function.</p>

<dt><a name="PRE/POST"
><code>PRE</code>/<code>POST</code></a></dt>

<dd>
<p>These phasers declare statements or blocks that are to be unconditionally executed before/after the subroutine&#39;s <code>do</code> block. They must return a true value, otherwise an exception is thrown.</p>

<p>When applied to a method, the semantics provide support for the &#34;Design by Contract&#34; style of OO programming: a precondition of a particular method is met if all the <code>PRE</code> phasers associated with that method return true. Otherwise, the precondition is met if <code>all</code> of the parent classes&#39; preconditions are met (which may include the preconditions of <i>their</i> parent classes if they fail, and so on recursively.)</p>

<p>In contrast, a method&#39;s postcondition is met if all the method&#39;s <code>POST</code> phasers return true <i>and</i> all its parents&#39; postconditions are also met recursively.</p>

<p><code>POST</code> phasers (and &#34;<code>will post</code>&#34; phaser traits) declared within a <code>PRE</code> or <code>ENTER</code> block are automatically hoisted outward to be called at the same time as other <code>POST</code> phasers. This conveniently gives &#34;circum&#34; semantics by virtue of wrapping the post lexical scope within the pre lexical scope. That is, the <code>POST</code> closes over its outer scope, even if that scope is gone by the time the <code>POST</code> is run.</p>

<pre><code>method push ($new_item) {
    ENTER {
        my $old_height = self.height;
        POST { self.height == $old_height + 1 }
    }

    $new_item ==&#62; push @.items;
}

method pop () {
    ENTER {
        my $old_height = self.height;
        POST { self.height == $old_height - 1 }
    }

    return pop @.items;
}</code></pre>

<p>Note that <code>self</code> is available in phasers defined within methods.</p>

<p>Class invariants are declared with <code>PRE</code>/<code>POST</code> submethods instead of phasers.</p>

<p>Module invariants are declared with <code>PRE</code>/<code>POST</code> subs or protos.</p>

<p>[Conjecture: class and module invariants can applied more selectively by marking <code>PRE</code>/<code>POST</code> declarations with a <code>selective</code> trait that stops it from running on internal calls (which might allow temporary violations of invariants), but enforces the invariants when any routine of this module is called from &#34;outside&#34; the current module or type, however that&#39;s defined. There could be arguments to this trait that could refine the concept of what is foreign.]</p>

<dt><a name="ENTER/LEAVE/KEEP/UNDO/etc."
><code>ENTER</code>/<code>LEAVE</code>/<code>KEEP</code>/<code>UNDO</code>/etc.</a></dt>

<dd>
<p>These phasers supply code that is to be conditionally executed before or after the subroutine&#39;s <code>do</code> block (only if used at the outermost level within the subroutine; technically, these are added to the block traits on the <code>do</code> block, not the subroutine object). These phasers are generally used only for their side effects, since most return values will be ignored. (Phasers that run before normal execution may be used for their values, however.)</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parameter_traits"
>Parameter traits</a></h2>

<p>The following traits can be applied to many types of parameters.</p>

<dl>
<dt><a name="is_readonly"
><code>is readonly</code></a></dt>

<dd>
<p>Specifies that the parameter cannot be modified (e.g. assigned to, incremented). It is the default for parameters. On arguments which are already immutable values it is a no-op at run time; on mutable containers it may need to create an immutable alias to the mutable object if the constraint cannot be enforced entirely at compile time. Binding to a readonly parameter never triggers autovivification.</p>

<dt><a name="is_rw"
><code>is rw</code></a></dt>

<dd>
<p>Specifies that the parameter can be modified (assigned to, incremented, etc). Requires that the corresponding argument is an lvalue or can be converted to one. Since this option forces an argument to be required, it cannot coexist with the <code>?</code> mark to make an argument optional. (It may, however, be used with <code>=</code> indicating a default, but only if the default expression represents something that is nameable at compile time and that can bind as an lvalue, such as <code>CALLER::&#60;$/&#62;</code> or <code>OUTER::&#60;$_&#62;</code>.)</p>

<p>When applied to a variadic parameter, the <code>rw</code> trait applies to each element of the list:</p>

<pre><code>sub incr (*@vars is rw) { $_++ for @vars }</code></pre>

<p>(The variadic array as a whole is always modifiable, but such modifications have no effect on the original argument list.)</p>

<dt><a name="is_parcel"
><code>is parcel</code></a></dt>

<dd>
<p>Specifies that the parameter is passed as a &#34;parcel&#34;, that is, as a raw reference to a &#34;parenthetical cell&#34; or &#34;parse list&#34;, an argument object that has not yet had a context imposed. (It may or may not actually be of the <code>Parcel</code> type, since a <code>Parcel</code> containing only one object automatically unwraps itself to be that object directly.) In other words, this provides for lazy contextualization even through function calls. This is important if you wish to pass the parameter onward to something else that will determine its context later.</p>

<p>You may modify the argument, but only if argument is already a suitable lvalue since, unlike <code>rw</code>, no attempt at autovivification is made, so unsuitable lvalues will throw an exception if you try to modify them within the body of the routine. That is, if autovivification happens, it happens at the point of use, not at the point of binding.</p>

<p>For better visual distinction, such a parameter is declared by prefixing with a backslash rather than by using <code>is parcel</code> directly. The backslash is also more succinct; the trait is there primarily for introspection.</p>

<dt><a name="is_copy"
><code>is copy</code></a></dt>

<dd>
<p>Specifies that the parameter receives a distinct, read-writable copy of the original argument. This is commonly known as &#34;pass-by-value&#34;.</p>

<pre><code>sub reprint ($text, $count is copy) {
    print $text while $count-- &#62; 0;
}</code></pre>

<p>Binding to a copy parameter never triggers autovivification.</p>

<dt><a name="is_dynamic"
><code>is dynamic</code></a></dt>

<dd>
<p>Specifies that the parameter is to be treated as an &#34;environmental&#34; variable, that is, a lexical that is accessible from the dynamic scope (see S02).</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Signature_Introspection"
>Signature Introspection</a></h2>

<p>A <code>Signature</code> object can be introspected to find out the details of the parameters it is defined as expected. The <code>.params</code> method will return a <code>Parcel</code> of <code>Parameter</code> objects, which have the following readonly properties:</p>

<pre><code>  name           The name of the lexical variable to bind to, if any
  type           The main type (the one multi-dispatch sorts by)
  constraints    Any further type constraints
  type_captures  List of names the argument type is captured into
  readonly       True if the parameter has C&#60;is readonly&#62; trait
  rw             True if the parameter has C&#60;is rw&#62; trait
  copy           True if the parameter has C&#60;is copy&#62; trait
  named          True if the parameter is to be passed named
  named_names    List of names a named parameter can be passed as
  capture        True if the parameter binds the caller&#39;s Capture
  parcel         True if the parameter is too lazy to contextualize
  slurpy         True if the parameter is slurpy
  optional       True if the parameter is optional
  default        A closure returning the default value
  invocant       True if the parameter is a method invocant
  multi_invocant True if the parameter is a multi invocant
  signature      A nested signature to bind the argument against</code></pre>

<p>Note that <code>constraints</code> will be something that can be smart-matched against if it is defined; if there are many constraints it may be a <code>Junction</code> of some sort, but if there is just one it may be simply that one thing.</p>

<p>Further, various things that appear in an original written signature will have been deconstructed a bit. For example, a signature like:</p>

<pre><code>  :(1)</code></pre>

<p>Will introspect the same way as:</p>

<pre><code>  :(Int $ where 1)</code></pre>

<p>And if we have:</p>

<pre><code>  subset Odd of Int where { $^n % 2 };
  sub foo(Odd $x) { ... }</code></pre>

<p>Then the signature of foo will be equivalent to something like:</p>

<pre><code>  :(Int $x where { $^n % 2 })</code></pre>

<p>That is, the refinement type will have been deconstructed into the part that nominal type that multiple dispatch uses for sorting the candidates and an additional constraint.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Advanced_subroutine_features"
>Advanced subroutine features</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Processing_of_returned_values"
>Processing of returned values</a></h2>

<p>It is a general policy that lvalues should only be returned up the dynamic call stack if specifically requested. Therefore, by default the returned arguments are processed to enforce this, both for the implicit return from the last statement of any block, as well as the explicit return done by operators such as:</p>

<pre><code>return
leave
take</code></pre>

<p>Specifically, this processing involves examining the returned parcel&#39;s arguments and dereferencing any container that could be used as an lvalue, replacing it with the container&#39;s value.</p>

<p>To override this processing for a routine, it must be declared <code>rw</code>, or the form <code>return-rw</code> must be used.</p>

<p>To override for a <code>gather</code>, use <code>gather-rw</code> instead, or <code>take-rw</code> on the individual take.</p>

<p>Since blocks don&#39;t generally have traits, you must use <code>leave-rw</code> to pass an lvalue out of a block.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_return_function"
>The <code>return</code> function</a></h2>

<p>The <code>return</code> function notionally throws a control exception that is caught by the current lexically enclosing <code>Routine</code> to force a return through the control logic code of any intermediate block constructs. (That is, it must unwind the stack of dynamic scopes to the proper lexical scope belonging to this routine.) With normal blocks (those that are autoexecuted in place because they&#39;re known to the compiler) this unwinding can likely be optimized away to a &#34;goto&#34;. All <code>Routine</code> declarations have an explicit declarator such as <code>sub</code> or <code>method</code>; bare blocks and &#34;pointy&#34; blocks are never considered to be routines in that sense. To return from a block, use <code>leave</code> instead--see below.</p>

<p>The <code>return</code> function preserves its argument list as a <code>Capture</code> object, and responds to the left-hand <code>Signature</code> in a binding. This allows named return values if the caller expects one:</p>

<pre><code>sub f () { return :x&#60;1&#62; }
sub g ($x) { print $x }

my $x := |(f);  # binds 1 to $x, via a named argument
g(|(f));        # prints 1, via a named argument</code></pre>

<p>To return a literal <code>Pair</code> object, always put it in an additional set of parentheses:</p>

<pre><code>return( (:x&#60;1&#62;), (:y&#60;2&#62;) ); # two positional Pair objects</code></pre>

<p>Note that the postfix parentheses on the function call don&#39;t count as being &#34;additional&#34;. However, as with any function, whitespace after the <code>return</code> keyword prevents that interpretation and turns it instead into a list operator:</p>

<pre><code>return :x&#60;1&#62;, :y&#60;2&#62;; # two named arguments (if caller uses |)
return ( :x&#60;1&#62;, :y&#60;2&#62; ); # two positional Pair objects</code></pre>

<p>If the function ends with an expression without an explicit <code>return</code>, that expression is also taken to be a <code>Capture</code>, just as if the expression were the argument to a <code>return</code> list operator (with whitespace):</p>

<pre><code>sub f { :x&#60;1&#62; } # named-argument binding (if caller uses |)
sub f { (:x&#60;1&#62;) } # always just one positional Pair object</code></pre>

<p>On the caller&#39;s end, the <code>Capture</code> is interpolated into any new argument list much like an array would be, that is, as an item in item context, and as a list in list context. This is the default behavior, but the caller may use <code>prefix:&#60;|&#62;</code> to inline the returned values as part of the new argument list. The caller may also bind the returned <code>Capture</code> directly.</p>

<p>A function is called only once at the time the <code>Capture</code> object is generated, not when it is later bound (which could happen more than once).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_callframe_and_caller_functions"
>The <code>callframe</code> and <code>caller</code> functions</a></h2>

<p>The <code>callframe</code> function takes a list of matchers and interprets them as a navigation path from the current call frame to a location in the call stack, either the current call frame itself or some frame from which the current frame was called. It returns an object that describes that particular call frame, or a false value if there is no such scope. Numeric arguments are interpreted as number of frames to skip, while non-numeric arguments scan outward for a frame matching the argument as a smartmatch.</p>

<p>The current frame is accessed with a null argument list.</p>

<pre><code>say &#34; file &#34;, callframe().file,
    &#34; line &#34;, callframe().line;</code></pre>

<p>which is equivalent to:</p>

<pre><code>say &#34; file &#34;, DYNAMIC::&#60;$?FILE&#62;,
    &#34; line &#34;, DYNAMIC::&#60;$?LINE&#62;;</code></pre>

<p>The immediate caller of this frame is accessed by skipping one level:</p>

<pre><code>say &#34; file &#34;, callframe(1).file,
    &#34; line &#34;, callframe(1).line;</code></pre>

<p>You might think that that must be the current function&#39;s caller, but that&#39;s not necessarily so. This might return an outer block in our own routine, or even some function elsewhere that implements a control operator on behalf of our block. To get outside your current routine, see <code>caller</code> below.</p>

<p>The <code>callframe</code> function may be given arguments telling it which higher scope to look for. Each argument is processed in order, left to right. Note that <code>Any</code> and <code>0</code> are no-ops:</p>

<pre><code>$ctx = callframe();        # currently running frame for &#38;?BLOCK
$ctx = callframe(Any);     # currently running frame for &#38;?BLOCK
$ctx = callframe(Any,Any); # currently running frame for &#38;?BLOCK
$ctx = callframe(1);       # my frame&#39;s caller
$ctx = callframe(2);       # my frame&#39;s caller&#39;s caller
$ctx = callframe(3);       # my frame&#39;s caller&#39;s caller&#39;s caller
$ctx = callframe(1,0,1,1); # my frame&#39;s caller&#39;s caller&#39;s caller
$ctx = callframe($i);      # $i&#39;th caller</code></pre>

<p>Note also that negative numbers are allowed as long as you stay within the existing call stack:</p>

<pre><code>$ctx = callframe(4,-1);    # my frame&#39;s caller&#39;s caller&#39;s caller</code></pre>

<p>Repeating any smartmatch just matches the same frame again unless you intersperse a 1 to skip the current level:</p>

<pre><code>$ctx = callframe(Method);              # nearest frame that is method
$ctx = callframe(Method,Method);       # nearest frame that is method
$ctx = callframe(Method,1,Method);     # 2nd nearest method frame
$ctx = callframe(Method,1,Method,1)    # caller of that 2nd nearest method
$ctx = callframe(1,Block);             # nearest outer frame that is block
$ctx = callframe(Sub,1,Sub,1,Sub);     # 3rd nearest sub frame
$ctx = callframe({ .labels.any eq &#39;Foo&#39; }); # nearest frame labeled &#39;Foo&#39;</code></pre>

<p>Note that this last potentially differs from the answer returned by</p>

<pre><code>Foo.callframe</code></pre>

<p>which returns the frame of the innermost <code>Foo</code> block in the lexical scope rather than the dynamic scope. A call frame also responds to the <code>.callframe</code> method, so a given frame may be used as the basis for further navigation:</p>

<pre><code>$ctx = callframe(Method,1,Method);
$ctx = callframe(Method).callframe(1).callframe(Method);     # same</code></pre>

<p>You must supply args to get anywhere else, since <code>.callframe</code> is the identity operator when called on something that is already a <code>Context</code>:</p>

<pre><code>$ctx = callframe;
$ctx = callframe.callframe.callframe.callframe;                # same</code></pre>

<p>The <code>caller</code> function is special-cased to go outward just far enough to escape from the current routine scope, after first ignoring any inner blocks that are embedded, or are otherwise pretending to be &#34;inline&#34;:</p>

<pre><code>&#38;caller ::= &#38;callframe.assuming({ !.inline }, 1);</code></pre>

<p>Note that this is usually the same as <code>callframe(&#38;?ROUTINE,1)</code>, but not always. A call to a returned closure might not even have <code>&#38;?ROUTINE</code> in its dynamic scope anymore, but it still has a caller.</p>

<p>So to find where the current routine was called you can say:</p>

<pre><code>say &#34; file &#34;, caller.file,
    &#34; line &#34;, caller.line;</code></pre>

<p>which is equivalent to:</p>

<pre><code>say &#34; file &#34;, CALLER::&#60;$?FILE&#62;,
    &#34; line &#34;, CALLER::&#60;$?LINE&#62;;</code></pre>

<p>Additional arguments to <code>caller</code> are treated as navigational from the calling frame. One frame out from your current routine is <i>not</i> guaranteed to be a <code>Routine</code> frame. You must say <code>caller(Routine)</code> to get to the next-most-inner routine.</p>

<p>Note that <code>caller(Routine).line</code> is not necessarily going to give you the line number that your current routine was called from; you&#39;re rather likely to get the line number of the topmost block that is executing within that outer routine, where that block contains the call to your routine.</p>

<p>For either <code>callframe</code> or <code>caller</code>, the returned CallFrame object supports at least the following methods:</p>

<pre><code>.callframe
.caller
.leave
.inline
.package
.file
.line
.my
.hints
.args</code></pre>

<p>The <code>.callframe</code> and <code>.caller</code> methods work the same as the functions except that they are relative to the frame supplied as invocant. The <code>.leave</code> method can force an immediate return from the specified call frame.</p>

<p>The <code>.inline</code> method says whether this block was entered implicitly by some surrounding control structure. Any time you invoke a block or routine explicitly with <code>.()</code> this is false. However, it is defined to be true for any block entered using dispatcher-level primitives such as <code>.callwith</code>, <code>.callsame</code>, <code>.nextwith</code>, or <code>.nextsame</code>.</p>

<p>The <code>.my</code> method provides access to the lexical namespace associated with the given call frame&#39;s current position. It may be used to look up ordinary lexical variables in that lexical scope. It must not be used to change any lexical variable that is marked as readonly.</p>

<p>The <code>.hints</code> method gives access to a snapshot of compiler symbols in effect at the point of the call when the call was originally compiled. (For instance, <code>caller.hints(&#39;&#38;?ROUTINE&#39;)</code> will give you the caller&#39;s routine object.) Such values are always read-only, though in the case of some (like the caller&#39;s routine above) may return a fixed object that is nevertheless mutable.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_want_function"
>The <code>want</code> function</a></h2>

<p>The <code>want</code> function is gone. If you want context specific behavior, return an object instead that responds accordingly to the various contextual methods.</p>

<p>(Conjecture: in future we might want to provide some syntactic sugar that makes it easier to create such objects. Or maybe a type that takes values or code references for the various contexts, so that you can write</p>

<pre><code>   return ContextProxy.new:
    Int   =&#62; 3,
    item  =&#62; { @.list.join(&#39;, &#39;) },
    list  =&#62; { ...               },
    ;</code></pre>

<p>or something similar.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_leave_function"
>The <code>leave</code> function</a></h2>

<p>As mentioned above, a <code>return</code> call causes the innermost surrounding subroutine, method, rule, token, regex (as a keyword) or macro to return. Only declarations with an explicit declarator keyword (<code>sub</code>, <code>submethod</code>, <code>method</code>, <code>macro</code>, <code>regex</code>, <code>token</code>, and <code>rule</code>) may be returned from. Statement prefixes such a <code>do</code> and <code>try</code> do not fall into that category. You cannot use <code>return</code> to escape directly into the surrounding context from loops, bare blocks, pointy blocks, or quotelike operators such as <code>rx//</code>; a <code>return</code> within one of those constructs will continue searching outward for a &#34;proper&#34; routine to return from. Nor may you return from property blocks such as <code>BEGIN</code> or <code>CATCH</code> (though blocks executing within the lexical and dynamic scope of a routine can of course return from that outer routine, which means you can always return from a <code>CATCH</code> or a <code>FIRST</code>, but never from a <code>BEGIN</code> or <code>INIT</code>.)</p>

<p>To return from blocks that aren&#39;t routines, the <code>leave</code> method is used instead. (It can be taken to mean either &#34;go away from&#34; or &#34;bequeath to your successor&#34; as appropriate.) The object specifies the scope to exit, and the method&#39;s arguments specify the return value. If the object is omitted (by use of the function or listop forms), the innermost block is exited. Otherwise you must use something like <code>callframe</code> or <code>&#38;?BLOCK</code> or a dynamic variable to specify the scope you want to exit. A label (such as a loop label) previously seen in the lexical scope also works as a kind of singleton dynamic object: it names a statement that is serving both as an outer lexical scope and as a frame in the current dynamic scope.</p>

<p>As with <code>return</code>, the arguments are taken to be a <code>Capture</code> holding the return values.</p>

<pre><code>leave;                      # return from innermost block of any kind
callframe(Method).leave;    # return from innermost calling method
&#38;?ROUTINE.leave(1,2,3);     # Return from current sub. Same as: return 1,2,3
&#38;?ROUTINE.leave &#60;== 1,2,3;  # same thing, force return as feed
OUTER.leave;                # Return from OUTER label in lexical scope
&#38;foo.leave: 1,2,3;          # Return from innermost surrounding call to &#38;foo</code></pre>

<p>Note that these are equivalent in terms of control flow:</p>

<pre><code>COUNT.leave;
last COUNT;</code></pre>

<p>However, the first form explicitly sets the return value for the entire loop, while the second implicitly returns all the previous successful loop iteration values as a list comprehension. (It may, in fact, be too late to set a return value for the loop if it is being evaluated lazily!) A <code>leave</code> from the inner loop block, however, merely specifies the return value for that iteration:</p>

<pre><code>for 1..10 { leave $_ * 2 }   # 2..20</code></pre>

<p>Note that this:</p>

<pre><code>leave COUNT;</code></pre>

<p>will always be taken as the function, not the method, so it returns the <code>COUNT</code> object from the innermost block. The indirect object form of the method always requires a colon:</p>

<pre><code>leave COUNT: ;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Temporization"
>Temporization</a></h2>

<p>The <code>temp</code> macro temporarily replaces the value of an existing variable, subroutine, context of a function call, or other object in a given scope:</p>

<pre><code>{
   temp $*foo = &#39;foo&#39;;      # Temporarily replace global $foo
   temp &#38;bar := sub {...};  # Temporarily replace sub &#38;bar
   ...
} # Old values of $*foo and &#38;bar reinstated at this point</code></pre>

<p><code>temp</code> invokes its argument&#39;s <code>.TEMP</code> method. The method is expected to return a <code>Callable</code> object that can later restore the current value of the object. At the end of the lexical scope in which the <code>temp</code> was applied, the subroutine returned by the <code>.TEMP</code> method is executed.</p>

<p>The default <code>.TEMP</code> method for variables simply creates a closure that assigns the variable&#39;s pre-<code>temp</code> value back to the variable.</p>

<p>New kinds of temporization can be created by writing storage classes with their own <code>.TEMP</code> methods:</p>

<pre><code>class LoudArray is Array {
    method TEMP {
        print &#34;Replacing $.WHICH() at {caller.location}\n&#34;;
        my $restorer = callsame;
        return {
            print &#34;Restoring $.WHICH() at {caller.location}\n&#34;;
            $restorer();
        };
    }
}</code></pre>

<p>You can also modify the behaviour of temporized code structures, by giving them a <code>TEMP</code> block. As with <code>.TEMP</code> methods, this block is expected to return a closure, which will be executed at the end of the temporizing scope to restore the subroutine to its pre-<code>temp</code> state:</p>

<pre><code>my $next = 0;
sub next {
    my $curr = $next++;
    TEMP {{ $next = $curr }}  # TEMP block returns the closure { $next = $curr }
    return $curr;
}

# and later...

say next();     # prints 0; $next == 1
say next();     # prints 1; $next == 2
say next();     # prints 2; $next == 3
if ($hiccough) {
    say temp next();  # prints 3; closes $curr at 3; $next == 4
    say next();       # prints 4; $next == 5
    say next();       # prints 5; $next == 6
}                     # $next = 3
say next();     # prints 3; $next == 4
say next();     # prints 4; $next == 5</code></pre>

<p>Note that <code>temp</code> must be a macro rather than a function because the temporization must be arranged before the function causes any state changes, and if it were a normal argument to a normal function, the state change would be happen before <code>temp</code> got control.</p>

<p>Hypothetical variables use the same mechanism, except that the restoring closure is called only on failure.</p>

<p>Note that dynamic variables may be a better solution than temporized globals in the face of multithreading.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Wrapping"
>Wrapping</a></h2>

<p>Every <code>Routine</code> object has a <code>.wrap</code> method. This method expects a single <code>Callable</code> argument. Within the code, the special <code>callsame</code>, <code>callwith</code>, <code>nextsame</code> and <code>nextwith</code> functions will invoke the original routine, but do not introduce an official <code>CALLER</code> frame:</p>

<pre><code>sub thermo ($t) {...}   # set temperature in Celsius, returns old value

# Add a wrapper to convert from Fahrenheit...
$handle = &#38;thermo.wrap( { callwith( ($^t-32)/1.8 ) } );</code></pre>

<p>The <code>callwith</code> function lets you pass your own arguments to the wrapped function. The <code>callsame</code> function takes no argument; it implicitly passes the original argument list through unchanged. The <code>callsame</code> and <code>nextsame</code> functions are really short for:</p>

<pre><code>callwith( |callframe(Routine).args )
nextwith( |callframe(Routine).args )</code></pre>

<p>The call to <code>.wrap</code> replaces the original <code>Routine</code>&#39;s <code>do</code> property with the <code>Callable</code> argument, and arranges that any call to <code>callsame</code>, <code>callwith</code>, <code>nextsame</code> or <code>nextwith</code> invokes the previous version of the routine. In other words, the call to <code>.wrap</code> has more or less the same effect as:</p>

<pre><code>my &#38;old_thermo := &#38;thermo;
&#38;thermo = sub ($t) { old_thermo( ($t-32)/1.8 ) }</code></pre>

<p>Note that <code>&#38;thermo.WHICH</code> stays the same after the <code>.wrap</code>, as it does with the equivalent assignment shown since assignment to a <code>Routine</code> works like a container, changing the contained <code>do</code> property but not the container itself.</p>

<p>The call to <code>.wrap</code> returns a unique handle that has a <code>restore</code> method that will undo the wrapping:</p>

<pre><code>$handle.restore;</code></pre>

<p>This does not affect any other wrappings placed to the routine.</p>

<p>A wrapping can also be restricted to a particular dynamic scope with temporization:</p>

<pre><code># Add a wrapper to convert from Kelvin
# wrapper self-unwraps at end of current scope
temp &#38;thermo.wrap( { callwith($^t + 273.16) } );</code></pre>

<p>The entire argument list may be captured by binding to a <code>Capture</code> parameter. It can then be passed to <code>callwith</code> using that name:</p>

<pre><code># Double the return value for &#38;thermo
&#38;thermo.wrap( -&#62; |args { callwith(|args) * 2 } );</code></pre>

<p>In this case only the return value is changed.</p>

<p>The wrapper is not required to call the original routine; it can call another <code>Callable</code> object by passing the <code>Capture</code> to its <code>callwith</code> method:</p>

<pre><code># Transparently redirect all calls to &#38;thermo to &#38;other_thermo
&#38;thermo.wrap( sub (|args) { &#38;other_thermo.callwith(|args) } );</code></pre>

<p>or more briefly:</p>

<pre><code>&#38;thermo.wrap( { &#38;other_thermo.callsame } );</code></pre>

<p>Since the method versions of <code>callsame</code>, <code>callwith</code>, <code>nextsame</code>, and <code>nextwith</code> specify an explicit destination, their semantics do not change outside of wrappers. However, the corresponding functions have no explicit destination, so instead they implicitly call the next-most-likely method or multi-sub; see S12 for details.</p>

<p>As with any return value, you may capture the returned <code>Capture</code> of <code>call</code> by binding:</p>

<pre><code>my |retval := callwith(|args);
... # postprocessing
return |retval;</code></pre>

<p>Alternately, you may prevent any return at all by using the variants <code>nextsame</code> and <code>nextwith</code>. Arguments are passed just as with <code>callsame</code> and <code>callwith</code>, but a tail call is explicitly enforced; any code following the call will be unreached, as if a return had been executed there before calling into the destination routine.</p>

<p>Within an ordinary method dispatch these functions treat the rest of the dispatcher&#39;s candidate list as the wrapped function, which generally works out to calling the same method in one of our parent (or older sibling) classes. Likewise within a multiple dispatch the current routine may defer to candidates further down the candidate list. Although not necessarily related by a class hierarchy, such later candidates are considered more generic and hence likelier to be able to handle various unforeseen conditions (perhaps).</p>

<p>Note that all routines are (by default) considered to be candidates for inlining and constant folding. The optimizer is allowed to start making these optimizations after the main program&#39;s <code>LINK</code> time, but not before. After any routine is &#34;hard&#34; inlined or constant folded, it is explicitly retyped as immutable; any attempt to wrap an immutable routine will result in failure of the wrap call. An immutable routine is so marked by recasting to type <code>HardRoutine</code>, a subclass of <code>Routine</code>.</p>

<p>On the other hand, it is also possible to explicitly mark a routine as mutable, and then the ability to wrap it must be preserved even after <code>LINK</code> time. This is done by recasting to <code>SoftRoutine</code>. Explicitly marking a routine as either mutable or immutable should be considered permanent. It is still possible to inline soft routines, but only if the possibility of indirection is detected inline as well, and provision made (either inline or via external rewriting) for dealing with any wrappers.</p>

<p>Hence, any routine marked as soft before <code>LINK</code> time is exempt from hard inlining or folding. There are several methods of marking a routine as soft, however no method is provided for marking routines as hard, since that is the job of the optimizer. A routine may be marked as soft:</p>

<ul>
<li>if it is declared using &#34;our&#34; explicitly</li>

<li>if it is mentioned in the argument list of a <code>use soft</code> pragma,</li>

<li>if its name matches any wildcard pattern (TBD) in a <code>use soft</code>,</li>

<li>if the module or class in which it is defined is mentioned in a <code>use soft</code>,</li>

<li>or if there is a general <code>use soft *;</code> declaration, which basically turns on AOP for everything at run time. Be aware that this may turn your optimizer into more of a &#34;pessimizer&#34;.</li>
</ul>

<p>For any normal standalone application, any <code>use soft</code> pragma applies to the entire program in which it participates, provided it is performed before <code>LINK</code> time. The optimizer may then harden anything that was not requested to remain soft.</p>

<p>A plug-in system, such as for a web server, may choose either to allow individual plug-ins to behave as independent programs by letting the optimizer harden individual plug-ins independently, or treat all plug-ins as a part of the same program by softening all plug-ins. (Similar considerations apply to optimizing classes to closed/final.)</p>

<p>Note that installing a wrapper before <code>LINK</code> time is specifically <i>not</i> one of the ways to mark a routine as soft. Such a routine may still be hardened at <code>LINK</code> time despite being wrapped during compile time.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_&#38;?ROUTINE_object"
>The <code>&#38;?ROUTINE</code> object</a></h2>

<p><code>&#38;?ROUTINE</code> is always an alias for the lexically innermost <code>Routine</code> (which may be a <code>Sub</code>, <code>Method</code>, or <code>Submethod</code>), so you can specify recursion on an anonymous sub:</p>

<pre><code>my $anonfactorial = sub (Int $n) {
                        return 1 if $n&#60;2;
                        return $n * &#38;?ROUTINE($n-1);
                    };</code></pre>

<p>You can get the current routine name by calling <code>&#38;?ROUTINE.name</code>. Outside of any sub declaration, this call returns failure.</p>

<p>Note that <code>&#38;?ROUTINE</code> refers to the current single sub, even if it is declared <code>multi</code>. To redispatch to the entire suite under a given short name, just use the named form to call the <code>proto</code>, since there are no anonymous <code>multi</code>s.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_&#38;?BLOCK_object"
>The <code>&#38;?BLOCK</code> object</a></h2>

<p><code>&#38;?BLOCK</code> is always an alias for the current block, so you can specify recursion on an anonymous block:</p>

<pre><code>my $anonfactorial = -&#62; Int $n { $n &#60; 2
                                    ?? 1
                                    !! $n * &#38;?BLOCK($n-1)
                              };</code></pre>

<p><code>&#38;?BLOCK.labels</code> contains a list of all labels of the current block. This is typically matched by saying</p>

<pre><code>if &#38;?BLOCK.labels.any eq &#39;Foo&#39; {...}</code></pre>

<p>If the innermost lexical block happens to be the main block of a <code>Routine</code>, then <code>&#38;?BLOCK</code> just returns the <code>Block</code> object, not the <code>Routine</code> object that contains it.</p>

<p>[Note: to refer to any <code>$?</code> or <code>&#38;?</code> variable at the time the sub or block is being compiled, use the <code>COMPILING::</code> pseudopackage.]</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Priming"
>Priming</a></h2>

<p>Every <code>Callable</code> object has a <code>.assuming</code> method, which does partial function application, aka <i>priming</i>. This method does a partial binding of a set of arguments to a signature and returns a new function that takes only the remaining arguments.</p>

<pre><code>&#38;textfrom := &#38;substr.assuming(str=&#62;$text, len=&#62;Inf);</code></pre>

<p>or equivalently:</p>

<pre><code>&#38;textfrom := &#38;substr.assuming(:str($text) :len(Inf));</code></pre>

<p>or even:</p>

<pre><code>&#38;textfrom := &#38;substr.assuming :str($text):len(Inf);</code></pre>

<p>It returns a <code>Callable</code> object that implements the same behaviour as the original subroutine, but has the values passed to <code>.assuming</code> already bound to the corresponding parameters:</p>

<pre><code>$all  = textfrom(0);   # same as: $all  = substr($text,0,Inf);
$some = textfrom(50);  # same as: $some = substr($text,50,Inf);
$last = textfrom(-1);  # same as: $last = substr($text,-1,Inf);</code></pre>

<p>Position parameters may also be primed. To skip a position argument, pass a <code>*</code>, which is handled specially by <code>.assuming</code>. Passing a <code>Nil</code> causes priming with the default argument supplied with the parameter at that position in the signature, or the (presumably undefined) default value for the container associated with the parameter if the parameter in question has no default. <code>Nil</code> may also be passed to a named argument to force priming to the default.</p>

<p>The result of a <code>use</code> statement is a (compile-time) object that also has a <code>.assuming</code> method, allowing the user to bind parameters in all the module&#39;s subroutines/methods/etc. simultaneously:</p>

<pre><code>(use IO::Logging).assuming(logfile =&#62; &#34;.log&#34;);</code></pre>

<p>This special form should generally be restricted to named parameters.</p>

<p>To prime a particular <code>multi</code> variant, it may be necessary to specify the type for one or more of its parameters to pick out a single function:</p>

<pre><code>&#38;woof ::= &#38;bark:(Dog).assuming :pitch&#60;low&#62;;
&#38;pine ::= &#38;bark:(Tree).assuming :pitch&#60;yes&#62;;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Macros"
>Macros</a></h2>

<p>Macros are functions or operators that are called by the compiler as soon as their arguments are parsed (if not sooner). The syntactic effect of a macro declaration or importation is always lexically scoped, even if the name of the macro is visible elsewhere. As with ordinary operators, macros may be classified by their grammatical category. For a given grammatical category, a default parsing rule or set of rules is used, but those rules that have not yet been &#34;used&#34; by the time the macro keyword or token is seen can be replaced by use of &#34;is parsed&#34; trait. (This means, for instance, that an infix operator can change the parse rules for its right operand but not its left operand.)</p>

<p>In the absence of a signature to the contrary, a macro is called as if it were a method on the current match object returned from the grammar rule being reduced; that is, all the current parse information is available by treating <code>self</code> as if it were a <code>$/</code> object. [Conjecture: alternate representations may be available if arguments are declared with particular AST types.]</p>

<p>Macros may return either a string to be reparsed, or a syntax tree that needs no further parsing. The textual form is handy, but the syntax tree form is generally preferred because it allows the parser and debugger to give better error messages. Textual substitution on the other hand tends to yield error messages that are opaque to the user. Syntax trees are also better in general because they are reversible, so things like syntax highlighters can get back to the original language and know which parts of the derived program come from which parts of the user&#39;s view of the program. Nevertheless, it&#39;s difficult to return a syntax tree for an unbalanced construct, and in such cases a textual macro may be a clearer expression of the evil thing you&#39;re trying to do.</p>

<p>If you call a macro at runtime, the result of the macro is automatically evaluated again, so the two calls below print the same thing:</p>

<pre><code>macro f { &#39;1 + 1&#39; }
say f();    # compile-time call to &#38;f
say &#38;f();   # runtime call to &#38;f</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Quasiquoting"
>Quasiquoting</a></h2>

<p>In aid of returning syntax tree, Perl provides a &#34;quasiquoting&#34; mechanism using the quote <code>quasi</code>, followed by a block intended to represent an AST:</p>

<pre><code>return quasi { say &#34;foo&#34; };</code></pre>

<p>Modifiers to the <code>quasi</code> can modify the operation:</p>

<pre><code>:ast(MyAst)         # Default :ast(AST)
:lang(Ruby)         # Default :lang($?PARSER)
:unquote&#60;[: :]&#62;     # Default &#34;triple rule&#34;</code></pre>

<p>Within a quasiquote, variable and function names resolve according to the lexical scope of the macro definition. Unrecognized symbols raise errors when the macro is being compiled, <i>not</i> when it&#39;s being used.</p>

<p>Use of a macro argument in a quasiquote without unquoting should provide a warning, as this is very likely to be an error.</p>

<pre><code># Oops; size of the AST of the argument
macro mouse ($arg) { quasi { $arg.elems } }</code></pre>

<p>To make a symbol resolve to the (partially compiled) scope of the macro call, use the <code>COMPILING::</code> pseudo-package:</p>

<pre><code>macro moose () { quasi { $COMPILING::x } }

moose(); # macro-call-time error
my $x;
moose(); # resolves to &#39;my $x&#39;</code></pre>

<p>If you want to mention symbols from the scope of the macro call, use the import syntax as modifiers to <code>quasi</code>:</p>

<pre><code>:COMPILING&#60;$x&#62;      # $x always refers to $x in caller&#39;s scope
:COMPILING          # All free variables fallback to caller&#39;s scope</code></pre>

<p>If those symbols do not exist in the scope of the compiling scope, a compile-time exception is thrown at macro call time.</p>

<p>Similarly, in the macro body you may either refer to the <code>$x</code> declared in the scope of the macro call as <code>$COMPILING::x</code>, or bind to them explicitly:</p>

<pre><code>my $x := $COMPILING::x;</code></pre>

<p>You may also use an import list to bind multiple symbols into the macro&#39;s lexical scope:</p>

<pre><code>require COMPILING &#60;$x $y $z&#62;;</code></pre>

<p>Note that you need to use the run-time <code>require</code> form, not <code>use</code>, because the macro caller&#39;s compile-time is the macro&#39;s runtime.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Splicing"
>Splicing</a></h2>

<p>Bare AST variables (such as the arguments to the macro) may not be spliced directly into a quasiquote because they would be taken as normal bindings. Likewise, program text strings to be inserted need to be specially marked or they will be bound normally. To insert an &#34;unquoted&#34; expression of either type within a quasiquote, use the quasiquote delimiter tripled, typically a bracketing quote of some sort:</p>

<pre><code>return quasi { say $a + {{{ $ast }}} }
return quasi [ say $a + [[[ $ast ]]] ]
return quasi &#60; say $a + &#60;&#60;&#60; $ast &#62;&#62;&#62; &#62;
return quasi ( say $a + ((( $ast ))) )</code></pre>

<p>The delimiters don&#39;t have to be bracketing quotes, but the following is probably to be construed as Bad Style:</p>

<pre><code>return quasi / say $a + /// $ast /// /</code></pre>

<p>(Note to implementors: this must not be implemented by finding the final closing delimiter and preprocessing, or we&#39;ll violate our one-pass parsing rule. Perl 6 parsing rules are parameterized to know their closing delimiter, so adding the opening delimiter should not be a hardship. Alternately the opening delimiter can be deduced from the closing delimiter. Writing a rule that looks for three opening delimiters in a row should not be a problem. It has to be a special grammar rule, though, not a fixed token, since we need to be able to nest code blocks with different delimiters. Likewise when parsing the inner expression, the inner parser subrule is parameterized to know that <code>}}}</code> or whatever is its closing delimiter.)</p>

<p>Unquoted expressions are inserted appropriately depending on the type of the variable, which may be either a syntax tree or a string. (Again, syntax tree is preferred.) The case is similar to that of a macro called from within the quasiquote, insofar as reparsing only happens with the string version of interpolation, except that such a reparse happens at macro call time rather than macro definition time, so its result cannot change the parser&#39;s expectations about what follows the interpolated variable.</p>

<p>Hence, while the quasiquote itself is being parsed, the syntactic interpolation of a unquoted expression into the quasiquote always results in the expectation of an operator following the unquote. (You must use a call to a submacro if you want to expect something else.) Of course, the macro definition as a whole can expect whatever it likes afterwards, according to its syntactic category. (Generally, a term expects a following postfix or infix operator, and an operator expects a following term or prefix operator. This does not matter for textual macros, however, since the reparse of the text determines subsequent expectations.)</p>

<p>Quasiquotes default to hygienic lexical scoping, just like closures. The visibility of lexical variables is limited to the quasi expression by default. A variable declaration can be made externally visible using the <code>COMPILING::</code> pseudo-package. Individual variables can be made visible, or all top-level variable declarations can be exposed using the <code>quasi :COMPILING</code> form.</p>

<p>Both examples below will add <code>$new_variable</code> to the lexical scope of the macro call:</p>

<pre><code>  quasi {  my $COMPILING::new_variable;   my $private_var; ... }
  quasi :COMPILING { my $new_variable; { my $private_var; ... } }</code></pre>

<p>(Note that <code>:COMPILING</code> has additional effects described in <a href="#Macros" class="podlinkpod"
>&#34;Macros&#34;</a>.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Other_matters"
>Other matters</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Anonymous_hashes_vs_blocks"
>Anonymous hashes vs blocks</a></h2>

<p><code>{...}</code> is always a block. However, if it is completely empty or consists of a single list, the first element of which is either a hash or a pair, it is executed immediately to compose a <code>Hash</code> object.</p>

<p>The standard <code>pair</code> list operator is equivalent to:</p>

<pre><code>sub pair (*@LIST) {
    my @pairs;
    for @LIST -&#62; $key, $val {
        push @pairs, $key =&#62; $val;
    }
    return @pairs;
}</code></pre>

<p>or more succinctly (and lazily):</p>

<pre><code>sub pair (*@LIST) {
    gather for @LIST -&#62; $key, $val {
        take $key =&#62; $val;
    }
}</code></pre>

<p>The standard <code>hash</code> list operator is equivalent to:</p>

<pre><code>sub hash (*@LIST) {
    return { pair @LIST };
}</code></pre>

<p>So you may use <code>sub</code> or <code>hash</code> or <code>pair</code> to disambiguate:</p>

<pre><code>$obj =  sub { 1, 2, 3, 4, 5, 6 };   # Anonymous sub returning list
$obj =      { 1, 2, 3, 4, 5, 6 };   # Anonymous sub returning list
$obj =      { 1=&#62;2, 3=&#62;4, 5=&#62;6 };   # Anonymous hash
$obj =      { 1=&#62;2, 3, 4, 5, 6 };   # Anonymous hash
$obj =  hash( 1, 2, 3, 4, 5, 6 );   # Anonymous hash
$obj =  hash  1, 2, 3, 4, 5, 6  ;   # Anonymous hash
$obj = { pair 1, 2, 3, 4, 5, 6 };   # Anonymous hash</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Pairs_as_lvalues"
>Pairs as lvalues</a></h2>

<p>Since they are immutable, Pair objects may not be directly assigned:</p>

<pre><code>(key =&#62; $var) = &#34;value&#34;;    # ERROR</code></pre>

<p>However, when binding pairs, names can be used to &#34;match up&#34; lvalues and rvalues, provided you write the left side as a signature using <code>:(...)</code> notation:</p>

<pre><code>:(:who($name), :why($reason)) := (why =&#62; $because, who =&#62; &#34;me&#34;);</code></pre>

<p>(Otherwise the parser doesn&#39;t know it should parse the insides as a signature and not as an ordinary expression until it gets to the <code>:=</code>, and that would be bad. Alternately, the <code>my</code> declarator can also force treatment of its argument as a signature.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Out-of-scope_names"
>Out-of-scope names</a></h2>

<p><code>GLOBAL::&#60;$varname&#62;</code> specifies the <code>$varname</code> declared in the <code>*</code> namespace. Or maybe it&#39;s the other way around...</p>

<p><code>CALLER::&#60;$varname&#62;</code> specifies the <code>$varname</code> visible in the dynamic scope from which the current block/closure/subroutine was called, provided that variable carries the &#34;<code>dynamic</code>&#34; trait. (All variables with a <code>*</code> twigil are automatically marked with the trait. Likewise certain implicit lexicals (<code>$_</code>, <code>$/</code>, and <code>$!</code>) are so marked.)</p>

<p><code>DYNAMIC::&#60;$varname&#62;</code> specifies the <code>$varname</code> visible in the innermost dynamic scope that declares the variable with the &#34;<code>is dynamic</code>&#34; trait or with a name that has the <code>*</code> twigil.</p>

<p><code>MY::&#60;$varname&#62;</code> specifies the lexical <code>$varname</code> declared in the current lexical scope.</p>

<p><code>OUR::&#60;$varname&#62;</code> specifies the <code>$varname</code> declared in the current package&#39;s namespace.</p>

<p><code>COMPILING::&#60;$varname&#62;</code> specifies the <code>$varname</code> declared (or about to be declared) in the lexical scope currently being compiled.</p>

<p><code>OUTER::&#60;$varname&#62;</code> specifies the <code>$varname</code> declared in the lexical scope surrounding the current lexical scope (i.e. the scope in which the current block was defined).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Declaring_a_MAIN_subroutine"
>Declaring a <code>MAIN</code> subroutine</a></h2>

<p>Ordinarily a top-level Perl &#34;script&#34; just evaluates its anonymous mainline code and exits. During the mainline code, the program&#39;s arguments are available in raw form from the <code>@*ARGS</code> array. At the end of the mainline code, however, a <code>MAIN</code> subroutine will be called with whatever command-line arguments remain in <code>@*ARGS</code>. This call is performed if and only if:</p>

<dl>
<dt><a name="a)"
>a)</a></dt>

<dd>
<p>the compilation unit was directly invoked rather than by being required by another compilation unit, and</p>

<dt><a name="b)"
>b)</a></dt>

<dd>
<p>the compilation unit declares a <code>Routine</code> named &#34;<code>MAIN</code>&#34;, and</p>

<dt><a name="c)"
>c)</a></dt>

<dd>
<p>the mainline code is not terminated prematurely, such as with an explicit call to <code>exit</code>, or an uncaught exception.</p>
</dd>
</dl>

<p>The command line arguments (or what&#39;s left of them after mainline processing) is magically converted into a <code>Capture</code> and passed to <code>MAIN</code> as its arguments, so switches may be bound as named args and other arguments to the program may be bound to positional parameters or the slurpy array:</p>

<pre><code>sub MAIN ($directory, :$verbose, *%other, *@filenames) {
    for @filenames { ... }
}</code></pre>

<p>Each incoming argument is automatically passed through the <code>val()</code> function, which will attempt to intuit the types of the textual arguments such that they may be used in multimethod dispatch. If <code>MAIN</code> is declared as a set of <code>multi</code> subs, multi dispatch is performed, and the type information intuited by <code>val()</code> may be used to distinguish the different signatures:</p>

<pre><code>multi MAIN (Int $i) {...}   # foo 1
multi MAIN (Rat $i) {...}   # foo 1/2
multi MAIN (Num $i) {...}   # foo 1e6
multi MAIN ($i) {...}       # foo bar</code></pre>

<p>As with module and class declarations, a sub declaration ending in semicolon is allowed at the outermost file scope if it is the first such declaration, in which case the rest of the file is the body:</p>

<pre><code>sub MAIN ($directory, :$verbose, *%other, *@filenames);
for @filenames { ... }</code></pre>

<p>This form is allowed only for simple subs named <code>MAIN</code> that are intended to be run from the command line. A <code>proto</code> or <code>multi</code> definition may not be written in semicolon form, nor may <code>MAIN</code> subs within a module or class be written in semicolon form. (A <code>MAIN</code> routine is allowed in a module or class, but is not usually invoked unless the file is run directly (see a above). This corresponds to the &#34;unless caller&#34; idiom of Perl 5.) In general, you may have only one semicolon-style declaration that controls the whole file.</p>

<p>If an attempted dispatch to <code>MAIN</code> fails, the <code>USAGE</code> routine is called. If there is no <code>USAGE</code> routine, a default message is printed to standard error. If <code>--help</code> is passed as a command line option to the program, the usage message is printed to standard output instead.</p>

<p>This usage message is automatically generated from the signature (or signatures) of <code>MAIN</code>. This message is generated at compile time, and hence is available at any later time as <code>$?USAGE</code>.</p>

<p>Common Unix command-line conventions are mapped onto the capture as follows:</p>

<pre><code>Assuming C&#60;-n&#62; is the short name for C&#60;--name&#62;,
On command line...         $*ARGS capture gets...

# Short names
-n                         :name
-n=value                   :name&#60;value&#62;
-n=&#34;spacey value&#34;          :name&#171;&#39;spacey value&#39;&#187;
-n=&#39;spacey value&#39;          :name&#171;&#39;spacey value&#39;&#187;
-n=val1,&#39;val 2&#39;,etc        :name&#171;val1 &#39;val 2&#39; etc&#187;

# Long names
--name                     :name
--name=value               :name&#60;value&#62;

--name=&#34;spacey value&#34;      :name&#171;&#39;spacey value&#39;&#187;
--name &#34;spacey value&#34;      :name&#171;&#39;spacey value&#39;&#187;
--name=&#39;spacey value&#39;      :name&#171;&#39;spacey value&#39;&#187;
--name=val1,&#39;val 2&#39;,etc    :name&#171;val1 &#39;val 2&#39; etc&#187;
--                                          # end named argument processing

# Negation
--/name                    :!name
--/name=value              :name&#60;value&#62; but False
--/name=&#34;spacey value&#34;     :name&#171;&#39;spacey value&#39;&#187; but False
--/name=&#39;spacey value&#39;     :name&#171;&#39;spacey value&#39;&#187; but False
--/name=val1,&#39;val 2&#39;,etc   :name&#171;val1 &#39;val 2&#39; etc&#187; but False

# Native
:name                      :name
:/name                     :!name
:name=value                :name&#60;value&#62;
:name=&#34;spacey value&#34;       :name&#171;&#39;spacey value&#39;&#187;
:name=&#39;spacey value&#39;       :name&#171;&#39;spacey value&#39;&#187;
:name=val1,&#39;val 2&#39;,etc     :name&#171;val1 &#39;val 2&#39; etc&#187;</code></pre>

<p>Exact Perl 6 forms are okay if quoted from shell processing:</p>

<pre><code>&#39;:name&#60;value&#62;&#39;             :name&#60;value&#62;
&#39;:name(42)&#39;                :name(42)</code></pre>

<p>For security reasons, only constants are allowed as arguments, however.</p>

<p>The default <code>Capture</code> mapper pays attention to declaration of <code>MAIN</code>&#39;s parameters to resolve certain ambiguities. A <code>--foo</code> switch needs to know whether to treat the next word from the command line as an argument. (Allowing the spacey form gives the shell room to do various things to the argument.) The short <code>-foo</code> form never assumes a separate argument, and you must use <code>=</code>. For the <code>--foo</code> form, if there is a named parameter corresponding to the switch name, and it is of type <code>Bool</code>, then no argument is expected. Otherwise an argument is expected. If the parameter is of a non-slurpy array type, all subsequent words up to the next command-line switch (or the end of the list) are bound to that parameter.</p>

<p>As usual, switches are assumed to be first, and everything after the first non-switch, or any switches after a <code>--</code>, are treated as positionals or go into the slurpy array (even if they look like switches). Other policies may easily be introduced by calling <code>MAIN</code> explicitly. For instance, you can parse your arguments with a grammar and pass the resulting <code>Match</code> object as a <code>Capture</code> to <code>MAIN</code>:</p>

<pre><code>@*ARGS ~~ /&#60;MyGrammar::top&#62;/;
MAIN(|$/);
exit;

sub MAIN ($frompart, $topart, *@rest) {
    if $frompart&#60;foo&#62; { ... }
    if $topart&#60;bar&#62;&#60;baz&#62; { ... }
}</code></pre>

<p>This will conveniently bind top-level named matches to named parameters, but still give you access to nested matches through those parameters, just as any <code>Match</code> object would. Of course, in this example, there&#39;s no particular reason the sub has to be named <code>MAIN</code>.</p>

<p>To give both a long and a short switch name, you may use the pair notation to install several names for the same parameter. If any of the names is a single character, it will be considered a short switch name, while all other parameters names are considered as long switch name. So if the previous declaration had been:</p>

<pre><code>sub MAIN (:f(:$frompart), :t(:$topart), *@rest)</code></pre>

<p>then you could invoke the program with either <code>-f</code> or <code>--frompart</code> to specify the first parameter. Likewise you could use either <code>-t</code> or <code>--topart</code> for the second parameter.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Relationship_of_MAIN_routine_with_lexical_setting"
>Relationship of MAIN routine with lexical setting</a></h2>

<p>The preceding section describes the use of <code>MAIN</code> in the user&#39;s code. There may also be an implicit <code>MAIN</code> routine supplied by the setting of the current compilation unit. (The <code>-n</code> and <code>-p</code> command-line switches are implemented this way.) In this case the user&#39;s mainline code is not automatically executed; instead, execution is controlled by the setting&#39;s <code>MAIN</code> routine. That routine calls <code>{YOU_ARE_HERE}</code> at the point where the user&#39;s code is to be lexically inserted (in the abstract). A setting may also call <code>{YOU_ARE_HERE}</code> outside of a <code>MAIN</code> routine, in which case it functions as a normal setting, and the <code>{YOU_ARE_HERE}</code> merely indicates where the user&#39;s code goes logically. (Or from the compiler&#39;s point of view, which the lexical scope to dump a snapshot of for later use by the compiler as the setting for a different compilation unit.) In this case the execution of the user code proceeds as normal. In fact, the <code>CORE</code> setting ends with a <code>{YOU_ARE_HERE}</code> to dump the <code>CORE</code> lexical scope as the standard setting. In this sense, <code>CORE</code> functions as an ordinary prelude.</p>

<p>If a <code>MAIN</code> routine is declared both in the setting and in the user&#39;s code, the setting&#39;s <code>MAIN</code> functions as the actual mainline entry point. The user&#39;s <code>MAIN</code> functions in an embedded fashion; the setting&#39;s invocation of <code>{YOU_ARE_HERE}</code> functions as the main invocation from the point of view of the user&#39;s code, and the user&#39;s <code>MAIN</code> routine will be invoked at the end of each call to <code>{YOU_ARE_HERE}</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Implementation_note_on_autothreading_of_only_subs"
>Implementation note on autothreading of only subs</a></h2>

<p>The natural way to implement autothreading for <code>multi</code> subs is to simply have the junctional signatures (the ones that can accept <code>Mu</code> or junction as well as <code>Any</code> parameters) match more loosely than the non-autothreading versions, and let multiple dispatch find the appropriate sub based on the signature. Those generic routines then end up redispatching to the more specific ones.</p>

<p>On the other hand, the natural implementation of <code>only</code> subs is to call the sub in question directly for efficiency (and maybe even inline it in some cases). That efficiency is, after all, the main reason for not just making all subs <code>multi</code>. However, this direct call conflicts with the desire to allow autothreading. It might be tempting to simply make everything multi dispatch underneath, and then say that the <code>only</code> declaration merely means that you get an error if you redeclare. And maybe that is a valid approach if the multiple dispatch mechanism is fast enough.</p>

<p>However, a direct call still needs to bind its arguments to its parameters correctly, and it has to handle the case of failure to bind somehow. So it is also possible to implement autothreading of <code>only</code> subs based on failover from the binding failure. This could either be a one-shot failover followed by a conversion to a <code>multi</code> call, or it could failover every time you try to autothread. If we assume that junctional processing is likely to be fairly heavyweight most of the time compared to the cost of failing to bind, that tends to argue for failing over every time. This is also more conducive to inlining, since it&#39;s difficult to rewrite inlined calls. In any case, nowadays a <code>proto</code> declaration is considered to be a kind of <code>only</code> sub, and needs to handle autothreading similarly if the signature of the <code>proto</code> excludes junctions.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Introspection"
>Introspection</a></h2>

<p>This section describes the methods implemented by the routine objects that allow introspection of the inner works of that routine.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Routine"
>Routine</a></h3>

<dl>
<dt><a name=".candidates"
>.candidates</a></dt>

<dd>
<p>This method returns a (potentially lazy) list of the candidates associated with the current routine. An &#34;only&#34; routine should return a list with itself as the single item.</p>

<dt><a name=".signature"
>.signature</a></dt>

<dd>
<p>This method returns the signature of the current routine.</p>

<dt><a name=".cando($capture)"
>.cando($capture)</a></dt>

<dd>
<p>This method returns a (potentially lazy) list of the candidates that match the given capture, ordered by goodness of match, with the best match first.</p>

<dt><a name=".push($candidate)"
>.push($candidate)</a></dt>

<dd>
<p>Adds <code>$candidate</code> to the list of candidates for this <code>proto</code>, calling this method in an <code>only</code> routine should result in a failure. It is also accepted for <code>multi</code>s declared in the source code to finalize the list of candidates and also return a failure here. But <code>Proto</code>s created by calling <code>Proto.new()</code> should be able add candidates at run-time.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Signature"
>Signature</a></h3>

<p>See section <a href="#Signature_Introspection" class="podlinkpod"
>&#34;Signature Introspection&#34;</a>.</p>

<!-- end doc -->

</body></html>
