<!DOCTYPE html>
<html lang="ja">
<head>
<title>S09-data</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Sep 27 10:05:33 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Lazy_lists'>Lazy lists</a>
  <li class='indexItem indexItem1'><a href='#Sized_types'>Sized types</a>
  <li class='indexItem indexItem1'><a href='#Compact_structs'>Compact structs</a>
  <li class='indexItem indexItem1'><a href='#Standard_array_indexing'>Standard array indexing</a>
  <li class='indexItem indexItem1'><a href='#Fixed-size_arrays'>Fixed-size arrays</a>
  <li class='indexItem indexItem1'><a href='#Typed_arrays'>Typed arrays</a>
  <li class='indexItem indexItem1'><a href='#Compact_arrays'>Compact arrays</a>
  <li class='indexItem indexItem1'><a href='#Multidimensional_arrays'>Multidimensional arrays</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Autoextending_multidimensional_arrays'>Autoextending multidimensional arrays</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#User-defined_array_indexing'>User-defined array indexing</a>
  <li class='indexItem indexItem1'><a href='#Inclusive_subscripts'>Inclusive subscripts</a>
  <li class='indexItem indexItem1'><a href='#Negative_and_differential_subscripts'>Negative and differential subscripts</a>
  <li class='indexItem indexItem1'><a href='#Mixing_subscripts'>Mixing subscripts</a>
  <li class='indexItem indexItem1'><a href='#PDL_support'>PDL support</a>
  <li class='indexItem indexItem1'><a href='#Subscript_and_slice_notation'>Subscript and slice notation</a>
  <li class='indexItem indexItem1'><a href='#Cascaded_subscripting_of_multidimensional_arrays'>Cascaded subscripting of multidimensional arrays</a>
  <li class='indexItem indexItem1'><a href='#The_semicolon_operator'>The semicolon operator</a>
  <li class='indexItem indexItem1'><a href='#PDL_signatures'>PDL signatures</a>
  <li class='indexItem indexItem1'><a href='#Autothreading_types'>Autothreading types</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Junctions'>Junctions</a>
    <li class='indexItem indexItem2'><a href='#Each'>Each</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Parallelized_parameters_and_autothreading'>Parallelized parameters and autothreading</a>
  <li class='indexItem indexItem1'><a href='#Hashes'>Hashes</a>
  <li class='indexItem indexItem1'><a href='#Autosorted_hashes'>Autosorted hashes</a>
  <li class='indexItem indexItem1'><a href='#Autovivification'>Autovivification</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 9: Data Structures</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Larry Wall &#60;larry@wall.org&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 13 Sep 2004

Last Modified: 5 Mar 2012
Version: 51</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis summarizes the non-existent Apocalypse 9, which discussed in detail the design of Perl 6 data structures. It was primarily a discussion of how the existing features of Perl 6 combine to make it easier for the PDL folks to write numeric Perl.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Lazy_lists"
>Lazy lists</a></h1>

<p>All list contexts are lazy by default. They might still flatten eventually, but only when forced to. You have to use the <code>eager</code> list operator to get a non-lazy list context, and you have to use the <code>flat</code> operator to guarantee flattening. However, such context is generally provided by the eventual destination anyway, so you don&#39;t usually need to be explicit.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Sized_types"
>Sized types</a></h1>

<p>Sized low-level types are named most generally by appending the number of bits to a generic low-level type name:</p>

<pre><code>int1
int2
int4
int8
int16
int32       (aka int on 32-bit machines)
int64       (aka int on 64-bit machines)
int128      (aka int on 128-bit machines)

uint1       (aka bit)
uint2
uint4
uint8       (aka byte)
uint16
uint32
uint64
uint128

num16
num32
num64       (aka num on most architectures)
num128

complex16
complex32
complex64   (aka complex on most architectures)
complex128

rat8
rat16
rat32
rat64
rat128

buf8        aka buf, a &#34;normal&#34; byte buffer
buf16       a uint16 buffer
buf32       a uint32 buffer
buf64       a uint64 buffer</code></pre>

<p>Complex sizes indicate the size of each <code>num</code> component rather than the total. This would extend to tensor typenames as well if they&#39;re built-in types. Of course, the typical tensor structure is just reflected in the dimensions of the array--but the principle still holds that the name is based on the number of bits of the simple base type.</p>

<p>The unsized types <code>int</code> and <code>num</code> are based on the architecture&#39;s normal size for <code>int</code> and <code>double</code> in whatever version of C the run-time system is compiled in. So <code>int</code> typically means <code>int32</code> or <code>int64</code>, while <code>num</code> usually means <code>num64</code>, and <code>complex</code> means two of whatever <code>num</code> turns out to be. For symmetry around the decimal point, native <code>rat</code>s have a numerator that is twice the size of their denominator, such that a <code>rat32</code> actually has an <code>int64</code> for its numerator. Custom rational types may be created by instantiating the <code>Rational</code> role with two types; if both types used are native types, the resulting type is considered a native type.</p>

<p>You are, of course, free to use macros or type declarations to associate additional names, such as &#34;short&#34; or &#34;single&#34;. These are not provided by default. An implementation of Perl is not required to support 64-bit integer types or 128-bit floating-point types unless the underlying architecture supports them. 16-bit floating-point is also considered optional in this sense.</p>

<p>And yes, an <code>int1</code> can store only -1 or 0. I&#39;m sure someone&#39;ll think of a use for it...</p>

<p>Note that these are primarily intended to represent storage types; the compiler is generally free to keep all intermediate results in wider types in the absence of declarations or explicit casts to the contrary. Attempts to store an intermediate result in a location that cannot hold it will generally produce a warning on overflow. Underflow may also warn depending on the pragmatic context and use of explicit rounding operators. The default rounding mode from <code>Num</code> to <code>Int</code> is to truncate the fractional part without warning. (Note that warnings are by definition resumable exceptions; however, an exception handler is free to either transform such a warning into a fatal exception or ignore it completely.)</p>

<p>An explicit cast to a storage type has the same potential to throw an exception as the actual attempt to store to such a storage location would.</p>

<p>With IEEE floating-point types, we have a bias towards the use of in-band <code>+Inf</code>, <code>-Inf</code>, and <code>NaN</code> values in preference to throwing an exception, since this is construed as friendlier to vector processing and pipelining. Object types such as <code>Num</code> and <code>Int</code> may store additional information about the nature of the failure, perhaps as an unthrown exception or warning.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Compact_structs"
>Compact structs</a></h1>

<p>A class whose attributes are all low-level value types can behave as a struct. (Access from outside the class is still only through accessors, though, except when the address of a serialized version of the object is used or generated for interfacing to C-like languages.) Whether such a class is actually stored compactly is up to the implementation, but it ought to behave that way, at least to the extent that it&#39;s trivially easy (from the user&#39;s perspective) to read and write to the equivalent C structure. That is, when serialized or deserialized to the C view, it should look like the C struct, even if that&#39;s not how it&#39;s actually represented inside the class. (This is to be construed as a substitute for at least some of the current uses of <code>pack</code>/<code>unpack</code>.) Of course, a lazy implementation will probably find it easiest just to keep the object in its serialized form all the time. In particular, an array of compact structs must be stored in their serialized form (see next section).</p>

<p>For types that exist in the C programming language, the serialized mapping in memory should follow the same alignment and padding rules by default. Integers smaller than a byte are packed into a power-of-two number of bits, so a byte holds four 2-bit integers. Datum sizes that are not a power of two bits are not supported unless declared by the user with sufficient information to determine how to lay them out in memory, possibly with a pack/unpack format associated with the class, or with the strange elements of the class, or with the types under which the strange element is declared.</p>

<p>Note that a compact struct that has no mutators is itself a value type, so except for performance considerations, it doesn&#39;t matter how many representations of it there are in memory as long as those are consistent. On the other hand, structs with mutators must behave more like normal mutable objects.</p>

<p>The packing serialization is performed by coercion to an appropriate buffer type. The unpacking is performed by coercion of such a buffer type back to the type of the compact struct.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Standard_array_indexing"
>Standard array indexing</a></h1>

<p>Standard array indices are specified using square brackets. Standard indices always start at zero in each dimension of the array (see <a href="#Multidimensional_arrays" class="podlinkpod"
>&#34;Multidimensional arrays&#34;</a>), and are always contiguous:</p>

<pre><code>@dwarves[0] = &#34;Happy&#34;;           # The 1st dwarf
@dwarves[6] = &#34;Doc&#34;;             # The 7th dwarf

@seasons[0] = &#34;Spring&#34;;          # The 1st season
@seasons[2] = &#34;Autumn&#34;|&#34;Fall&#34;;   # The 3rd season</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Fixed-size_arrays"
>Fixed-size arrays</a></h1>

<p>A basic array declaration like:</p>

<pre><code>my @array;</code></pre>

<p>declares a one-dimensional array of indeterminate length. Such arrays are autoextending. For many purposes, though, it&#39;s useful to define array types of a particular size and shape that, instead of autoextending, fail if you try to access outside their declared dimensionality. Such arrays tend to be faster to allocate and access as well. (The language must, however, continue to protect you against overflow--these days, that&#39;s not just a reliability issue, but also a security issue.)</p>

<p>To declare an array of fixed size, specify its maximum number of elements in square brackets immediately after its name:</p>

<pre><code>my @dwarves[7];           # Valid indices are 0..6

my @seasons[4];           # Valid indices are 0..3</code></pre>

<p>No intervening whitespace is permitted between the name and the size specification, but &#34;unspace&#34; is allowed:</p>

<pre><code>my @values[10];           # Okay
my @keys  [10];           # Error
my @keys\ [10];           # Okay</code></pre>

<p>Note that the square brackets are a compile-time declarator, not a run-time operator, so you can&#39;t use the &#34;dotted&#34; form either:</p>

<pre><code>my @values.[10];          # An indexing, not a fixed-size declaration
my @keys\ .[10];          # Ditto</code></pre>

<p>Attempting to access an index outside an array&#39;s defined range will fail:</p>

<pre><code>@dwarves[7] = &#39;Sneaky&#39;;   # Fails with &#34;invalid index&#34; exception</code></pre>

<p>However, it is legal for a range or sequence iterator to extend beyond the end of an array as long as its min value is a valid subscript; when used as an rvalue, the range is truncated as necessary to map only valid locations. (When used as an lvalue, any non-existent subscripts generate WHENCE proxies that can receive new values and autovivify anything that needs it.)</p>

<p>It&#39;s also possible to explicitly specify a normal autoextending array:</p>

<pre><code>my @vices[*];             # Length is: &#34;whatever&#34;
                          # Valid indices are 0..*</code></pre>

<p>For subscripts containing range or sequence iterators extending beyond the end of autoextending arrays, the range is truncated to the actual current size of the array rather than the declared size of that dimension. It is allowed for such a range to start one after the end, so that</p>

<pre><code>@array[0..*]</code></pre>

<p>merely returns <code>()</code> if <code>@array</code> happens to be empty. However,</p>

<pre><code>@array[1..*]</code></pre>

<p>would fail because the range&#39;s min is too big.</p>

<p>Note that these rules mean it doesn&#39;t matter whether you say</p>

<pre><code>@array[*]
@array[0 .. *]
@array[0 .. *-1]</code></pre>

<p>because they all end up meaning the same thing.</p>

<p>There is no autotruncation on the left end. It&#39;s not that hard to write <code>0</code>, and standard indexes always start there.</p>

<p>Subscript size declarations may add a named <code>:map</code> argument supplying a closure, indicating that all index values are to be mapped through that closure. For example, a subscript may be declared as cyclical:</p>

<pre><code>my @seasons[4, :map( * % 4 )];
my @seasons[4, :map{ $_ % 4 }];  # same thing</code></pre>

<p>In this case, all numeric values are taken modulo 4, and no range truncation can ever happen. If you say</p>

<pre><code>@seasons[-4..7] = &#39;a&#39; .. &#39;l&#39;;</code></pre>

<p>then each element is written three times and the array ends up with <code>[&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;]</code>. The mapping function is allowed to return fractional values; the index will be the <code>floor</code> of that value. (It is still illegal to use a numeric index less that 0.) One could map indexes logarithmically, for instance, as long as the numbers aren&#39;t so small they produce negative indices.</p>

<p>Another use might be to map positive numbers to even slots and negative numbers to odd slots, so you get indices that are symmetric around 0 (though Perl is not going to track the max-used even and odd slots for you when the data isn&#39;t symmetric).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Typed_arrays"
>Typed arrays</a></h1>

<p>The type of value stored in each element of the array (normally <code>Any</code> for unspecified type) can be explicitly specified too, as an external <code>of</code> type:</p>

<pre><code>my num @nums;                     # Each element stores a native number
my @nums of num;                  # Same

my Book @library[1_000_000];      # Each element stores a Book object
my @library[1_000_000] of Book;   # Same</code></pre>

<p>Alternatively, the element storage type may be specified as part of the dimension specifier (much like a subroutine definition):</p>

<pre><code>my @nums[--&#62;num];

my @library[1_000_000 --&#62; Book];</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Compact_arrays"
>Compact arrays</a></h1>

<p>In declarations of the form:</p>

<pre><code>my bit @bits;
my int @ints;
my num @nums;
my int4 @nybbles;
my buf @buffers;
my complex128 @longdoublecomplex;
my Array @ragged2d;</code></pre>

<p>the presence of a low-level type tells Perl that it is free to implement the array with &#34;compact storage&#34;, that is, with a chunk of memory containing contiguous (or as contiguous as practical) elements of the specified type without any fancy object boxing that typically applies to undifferentiated scalars. (Perl tries really hard to make these elements look like objects when you treat them like objects--this is called autoboxing.)</p>

<p>Unless explicitly declared to be of fixed size, such arrays are autoextending just like ordinary Perl arrays (at the price of occasionally copying the block of data to another memory location, or using a tree structure).</p>

<p>A compact array is for most purposes interchangeable with the corresponding buffer type. For example, apart from the sigil, these are equivalent declarations:</p>

<pre><code>my uint8 @buffer;
my buf8 $buffer;</code></pre>

<p>(Note: If you actually said both of those, you&#39;d still get two different names, since the sigil is part of the name.)</p>

<p>So given <code>@buffer</code> you can say</p>

<pre><code>$piece = substr(@buffer, $beg, $end - $beg);</code></pre>

<p>and given <code>$buffer</code> you can also say</p>

<pre><code>@pieces = $buffer[$n ..^ $end];</code></pre>

<p>Note that subscripting still pulls the elements out as numbers, but <code>substr()</code> returns a buffer of the same type.</p>

<p>For types that exist in the C programming language, the mapping in memory should follow the same alignment rules, at least in the absence of any declaration to the contrary. For interfacing to C pointer types, any buffer type may be used for its memory pointer; note, however, that the buffer knows its length, while in C that length typically must be passed as a separate argument, so the C interfacing code needs to support this whenever possible, lest Perl inherit all the buffer overrun bugs bequeathed on us by C. Random C pointers should never be converted to buffers unless the length is also known. (Any call to strlen() should generally be considered a security hole.) The size of any buffer type in bytes may be found with the <code>.bytes</code> method, even if the type of the buffer elements is not <code>byte</code>. (Strings may be asked for their size in bytes only if they support a buffer type as their minimum abstraction level, hopefully with a known encoding. Otherwise you must encode them explicitly from the higher-level abstraction into some buffer type.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Multidimensional_arrays"
>Multidimensional arrays</a></h1>

<p>Perl 6 arrays are not restricted to being one-dimensional (that&#39;s simply the default). To declare a multidimensional array, you specify it with a semicolon-separated list of dimension lengths:</p>

<pre><code>my int @ints[4;2];          # Valid indices are 0..3 ; 0..1

my @calendar[12;31;24];     # Valid indices are 0..11 ; 0..30 ; 0..23</code></pre>

<p>Arrays may also be defined with a mixture of fixed and autoextending dimensions. For example, there are always 12 months in a year and 24 hours in a day, but the number of days in the month can vary:</p>

<pre><code>my @calendar[12;*;24];     # day-of-month dimension unlimited/ragged</code></pre>

<p>You can pass a slice (of any dimensionality) for the shape as well:</p>

<pre><code>@shape = 4, 2;
my int @ints[ ||@shape ];</code></pre>

<p>The <code>prefix:&#60;||&#62;</code> operator interpolates a list into a semicolon list at the semicolon level.</p>

<p>The shape in the declaration merely specifies how the array will autovivify on first use, but ends up as an attribute of the actual container object thereby. On the other hand, the shape may be also supplied entirely by an explicit constructor at run-time:</p>

<pre><code>my num @nums = Array of num.new(:shape(3;3;3));
my num @nums .=new():shape(3;3;3); # same thing</code></pre>

<p>A multidimensional array is indexed by a semicolon list (or &#34;semilist&#34;), which is really a list of lists in disguise. Each sublist is a slice of one particular dimension. So:</p>

<pre><code>@array[0..10; 42; @x]</code></pre>

<p>is really short for something like:</p>

<pre><code>@array.postcircumfix:&#60;[ ]&#62;( (0..10), (42), (@x) );</code></pre>

<p>The method&#39;s internal <code>**@slices</code> parameter turns the subscripts into three independent <code>Parcel</code> lists, which can be read lazily independently of one other. (Though a subscripter will typically use them left-to-right as it slices each dimension in turn.)</p>

<p>Note that:</p>

<pre><code>@array[@x,@y]</code></pre>

<p>is always interpreted as a one-dimensional slice in the outermost dimension, which is the same as:</p>

<pre><code>@array[@x,@y;]</code></pre>

<p>or more verbosely:</p>

<pre><code>@array.postcircumfix:&#60;[ ]&#62;( ((@x,@y)) );</code></pre>

<p>To interpolate an array at the semicolon level rather than the comma level, use the <code>prefix:&#60;||&#62;</code> operator:</p>

<pre><code>@array[||@x]</code></pre>

<p>which is equivalent to</p>

<pre><code>@array.postcircumfix:&#60;[ ]&#62;( ((@x[0]), (@x[1]), (@x[2]), etc.) );</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Autoextending_multidimensional_arrays"
>Autoextending multidimensional arrays</a></h2>

<p>Any dimension of the array may be declared as &#34;<code>*</code>&#34;, in which case that dimension will autoextend. Typically this would be used in the final dimension to make a ragged array functionally equivalent to an array of arrays:</p>

<pre><code>my int @ints[42; *];            # Second dimension unlimited/ragged
push(@ints[41], getsomeints());</code></pre>

<p>but <i>any</i> dimension of an array may be declared as autoextending:</p>

<pre><code>my @calendar[12;*;24];          # day-of-month dimension unlimited/ragged
@calendar[1;42;8] = &#39;meeting&#39;   # See you on January 42nd</code></pre>

<p>It is also possible to specify that an array has an arbitrary number of dimensions, using a &#34;hyperwhatever&#34; (<code>**</code>) at the end of the dimensional specification:</p>

<pre><code>my @grid[**];                      # Any number of dimensions
my @spacetime[*;*;*;**];           # Three or more dimensions
my @coordinates[100;100;100;**];   # Three or more dimensions</code></pre>

<p>Note that <code>**</code> is a shorthand for something that means <code>||(* xx *)</code>, so the extra dimensions are all of arbitrary size. To specify an arbitrary number of fixed-size dimensions, write:</p>

<pre><code>my @coordinates[ ||(100 xx *) ];</code></pre>

<p>This syntax is also convenient if you need to define a large number of consistently sized dimensions:</p>

<pre><code>my @string_theory[ ||(100 xx 11) ];    # 11-dimensional</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="User-defined_array_indexing"
>User-defined array indexing</a></h1>

<p>Any array may also be given a second set of user-defined indices, which need not be zero-based, monotonic, or even integers. Whereas standard array indices always start at zero, user-defined indices may start at any finite value of any enumerable type. Standard indices are always contiguous, but user-defined indices need only be distinct and in an enumerable sequence.</p>

<p>To define a set of user-defined indices, specify an explicit or enumerable list of the indices of each dimension (or the name of an enumerable type) in a set of curly braces immediately after the array name:</p>

<pre><code>my @dwarves{ 1..7 };
my @seasons{ &#60;Spring Summer Autumn Winter&#62; };

my enum Months
    &#171;:Jan(1) Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&#187;;

my @calendar{ Months; 1..31; 9..12,14..17 };    # Business hours only</code></pre>

<p>Array look-ups via user-defined indices are likewise specified in curly braces instead of square brackets:</p>

<pre><code>@dwarves{7} = &#34;Doc&#34;;             # The 7th dwarf

say @calendar{Jan;13;10};        # Jan 13th, 10am</code></pre>

<p>User-defined indices merely provide a second, non-standard &#34;view&#34; of the array; the underlying container remains the same. Each user-defined index in each dimension is mapped one-to-one back to the standard (zero- based) indices of that dimension. So, given the preceding definitions:</p>

<pre><code>             maps to
@dwarves{1}  ------&#62;  @dwarves[0]
@dwarves{2}  ------&#62;  @dwarves[1]
        :                   :
@dwarves{7}  ------&#62;  @dwarves[6]</code></pre>

<p>and:</p>

<pre><code>                    maps to
@seasons{&#39;Spring&#39;}  ------&#62;  @seasons[0]
@seasons{&#39;Summer&#39;}  ------&#62;  @seasons[1]
@seasons{&#39;Autumn&#39;}  ------&#62;  @seasons[2]
@seasons{&#39;Winter&#39;}  ------&#62;  @seasons[3]

@seasons&#60;Spring&#62;    ------&#62;  @seasons[0]
@seasons&#60;Summer&#62;    ------&#62;  @seasons[1]
@seasons&#60;Autumn&#62;    ------&#62;  @seasons[2]
@seasons&#60;Winter&#62;    ------&#62;  @seasons[3]</code></pre>

<p>and:</p>

<pre><code>                      maps to
@calendar{Jan;1;9}    ------&#62;  @calendar[0;0;0]
@calendar{Jan;1;10}   ------&#62;  @calendar[0;0;1]
        :                              :
@calendar{Jan;1;12}   ------&#62;  @calendar[0;0;3]
@calendar{Jan;1;14}   ------&#62;  @calendar[0;0;4]
        :                              :
@calendar{Feb;1;9}    ------&#62;  @calendar[1;0;0]
        :                              :
@calendar{Dec;31;17}  ------&#62;  @calendar[11;30;7]</code></pre>

<p>User-defined indices can be open-ended, but only on the upper end (i.e. just like standard indices). That is, you can specify:</p>

<pre><code>my @sins{7..*};      # Indices are: 7, 8, 9, etc.</code></pre>

<p>but not:</p>

<pre><code>my @virtue{*..6};
my @celebs{*};</code></pre>

<p>These last two are not allowed because there is no first index, and hence no way to map the infinity of negative user-defined indices back to the standard zero-based indexing scheme.</p>

<p>Declaring a set of user-defined indices implicitly declares the array&#39;s standard indices as well (which are still zero-based in each dimension). Such arrays can be accessed using either notation. The standard indices provide an easy way of referring to &#34;ordinal&#34; positions, independent of user-specified indices:</p>

<pre><code>say &#34;The first sin was @sins[0]&#34;;
# First element, no matter what @sin&#39;s user-defined indexes are</code></pre>

<p>Note that if an array is defined with fixed indices (either standard or user-defined), any attempt to use an index that wasn&#39;t specified in the definition will fail. For example:</p>

<pre><code>my @values{2,3,5,7,11};   # Also has standard indices: 0..4

say @values[-1];           # Fails (not a valid standard index)
say @values{1};            # Fails (not a valid user-defined index)

say @values{4};            # Fails (not a valid user-defined index)

say @values[5];            # Fails (not a valid standard index)
say @values{13};           # Fails (not a valid user-defined index)</code></pre>

<p>Furthermore, if an array wasn&#39;t specified with user-defined indices, <i>any</i> attempt to index it via <code>.{}</code> will fail:</p>

<pre><code>my @dwarves[7];    # No user-defined indices;

say @dwarves{1};   # Fails: can&#39;t map .{1} to a standard .[] index</code></pre>

<p>When <code>:k</code>, <code>:kv</code>, or <code>:p</code> is applied to an array slice, it returns the kind of indices that were used to produce the slice:</p>

<pre><code>@arr[0..2]:p          # 0=&#62;&#39;one&#39;, 1=&#62;&#39;two&#39;, 2=&#62;&#39;three&#39;
@arr{1,3,5}:p         # 1=&#62;&#39;one&#39;, 3=&#62;&#39;two&#39;, 5=&#62;&#39;three&#39;</code></pre>

<p>Adverbs may be applied only to operators, not to terms, so <code>:k</code>, <code>:kv</code>, and <code>:p</code> may not be applied to a full array. However, you may apply an adverb to a Zen slice, which can indicate which set of keys are desired:</p>

<pre><code>my @arr{1,3,5,7,9} = &#60;one two three four five&#62;;

say @arr[]:k;           # 0, 1, 2, 3, 4
say @arr{}:k;           # 1, 3, 5, 7, 9</code></pre>

<p>The <code>.keys</code> method also returns the keys of all existing elements. For a multidimensional array each key is a list containing one value for each dimension.</p>

<p>The <code>.shape</code> method also works on such an array; it returns a slice of the valid keys for each dimension. The component list representing an infinite dimension is necessarily represented lazily. (Note that the <code>.shape</code> method returns the possible keys, but the cartesian product of the key slice dimensions is not guaranteed to index existing elements in every case. That is, this is not intended to reflect current combinations of keys in use (use <code>:k</code> for that). Note that you have to distinguish these two forms:</p>

<pre><code>@array[].shape      # the integer indices
@array{}.shape      # the user-defined indices</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Inclusive_subscripts"
>Inclusive subscripts</a></h1>

<p>Within any array look-up (whether via <code>.[]</code> or <code>.{}</code>), the &#34;whatever star&#34; can be used to indicate &#34;all the indices&#34;. The meaning of &#34;all&#34; here depends on the definition of the array. If there are no pre-specified indices, the star means &#34;all the indices of currently allocated elements&#34;:</p>

<pre><code>my @data                      # No pre-specified indices
    = 21, 43, 9, 11;          # Four elements allocated
say @data[*];                 # So same as:  say @data[0..3]

@data[5] = 101;               # Now six elements allocated
say @data[*];                 # So same as:  say @data[0..5]</code></pre>

<p>If the array is defined with predeclared fixed indices (either standard or user-defined), the star means &#34;all the defined indices&#34;:</p>

<pre><code>my @results{1,3...99}         # Pre-specified indices
    = 42, 86, 99, 1;

say @results[*];              # Same as:  say @results[0..49]
say @results{*};              # Same as:  say @results{1,3...99}</code></pre>

<p>You can omit unallocated elements, either by using the <code>:v</code> adverb:</p>

<pre><code>say @results[*]:v;            # Same as:  say @results[0..3]
say @results{*}:v;            # Same as:  say @results{1,3,5,7}</code></pre>

<p>or by using a &#34;zen slice&#34;:</p>

<pre><code>say @results[];               # Same as:  say @results[0..3]
say @results{};               # Same as:  say @results{1,3,5,7}</code></pre>

<p>A &#34;whatever star&#34; can also be used as the starting-point of a range within a slice, in which case it means &#34;from the first index&#34;:</p>

<pre><code>say @calendar[*..5];          # Same as:  say @calendar[0..5]
say @calendar{*..Jun};        # Same as:  say @calendar{Jan..Jun}

say @data[*..3];              # Same as:  say @data[0..3]</code></pre>

<p>As the end-point of a range, a lone &#34;whatever&#34; means &#34;to the maximum specified index&#34; (if fixed indices were defined):</p>

<pre><code>say @calendar[5..*];          # Same as:  say @calendar[5..11]
say @calendar{Jun..*};        # Same as:  say @calendar{Jun..Dec}</code></pre>

<p>or &#34;to the largest allocated index&#34; (if there are no fixed indices):</p>

<pre><code>say @data[1..*];              # Same as:  say @results[1..5]</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Negative_and_differential_subscripts"
>Negative and differential subscripts</a></h1>

<p>The &#34;whatever star&#34; behaves differently than described above when it is treated as a number inside a standard index. In this case it evaluates to the length of the array. This provides a clean and consistent way to count back or forwards from the end of an array:</p>

<pre><code>@array[*-$N]      # $N-th element back from end of array
@array[*+$N]      # $N-th element at or after end of array</code></pre>

<p>More specifically:</p>

<pre><code>@array[*-2]       # Second-last element of the array
@array[*-1]       # Last element of the array
@array[+*]        # First element after the end of the array
@array[*+0]       # First element after the end of the array
@array[*+1]       # Second element after the end of the array

@array[*-3..*-1]  # Slice from third-last element to last element
@array[*-3..*]    # (Same thing via range truncation)</code></pre>

<p>(Note that, if a particular array dimension has fixed indices, any attempt to index elements after the last defined index will fail, except in the case of range truncation described earlier.)</p>

<p>Negative subscripts are never allowed for standard subscripts unless the subscript is declared modular.</p>

<p>The Perl 6 semantics avoids indexing discontinuities (a source of subtle runtime errors), and provides ordinal access in both directions at both ends of the array.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Mixing_subscripts"
>Mixing subscripts</a></h1>

<p>Occasionally it&#39;s convenient to be able to mix standard and user-defined indices in a single look-up.</p>

<p>Within a <code>.[]</code> indexing operation you can use <code>*{$idx}</code> to convert a user-defined index <code>$idx</code> to a standard index. That is:</p>

<pre><code>my @lengths{ Months } = (31,28,31,30,31,30,31,31,30,31,30,31);

@lengths[ 2 .. *{Oct} ]      # Same as:  @lengths[ 2 .. 9 ]</code></pre>

<p>Similarly, within a <code>.{}</code> indexing operation you can use <code>*[$idx]</code> to convert from standard indices to user-defined:</p>

<pre><code>@lengths{ *[2] .. Oct }      # Same as:  @lengths{ Mar .. Oct }</code></pre>

<p>In other words, when treated as an array within an indexing operation, <code>*</code> allows you to convert between standard and user-defined indices, by acting like an array of the indices of the indexed array. This is especially useful for mixing standard and user-defined indices within multidimensional array look-ups:</p>

<pre><code># First three business hours of every day in December...
@calendar{Dec; *; *[0..2]}

# Last three business hours of first three days in July...
@calendar[*{July}; 0..2; *-3..*-1]</code></pre>

<p>Extending this feature, you can use <code>**</code> within an indexing operation as if it were a multidimensional array of <i>all</i> the indices of a fixed number of dimensions of the indexed array:</p>

<pre><code># Last three business hours of first three days in July...
@calendar{ July; **[0..2; *-3..*-1] }

# Same...
@calendar[ **{July; 1..3}; *-3..*-1]</code></pre>

<p>It is also possible to stack subscript declarations of various types, including a final normal signature to specify named args and return type:</p>

<pre><code>my @array[10]{&#39;a&#39;..&#39;z&#39;}(:$sparse --&#62; MyType);</code></pre>

<p>[Note: the final signature syntax is merely reserved for now, and not expected to work until we figure out what it really means, if it means anything.]</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PDL_support"
>PDL support</a></h1>

<p>An array <code>@array</code> can be tied to a PDL at declaration time:</p>

<pre><code>my num @array[||@mytensorshape] is PDL;
my @array is PDL(:shape(2;2;2;2)) of int8;</code></pre>

<p>PDLs are allowed to assume a type of <code>num</code> by default rather than the usual simple scalar. (And in general, the type info is merely made available to the &#34;tie&#34; implementation to do with what it will. Some data structures may ignore the &#34;of&#34; type and just store everything as general scalars. Too bad...)</p>

<p>Arrays by default are one dimensional, but may be declared to have any dimensionality supported by the implementation. You may use arrays just like scalars -- the main caveat is that you have to use binding rather than assignment to set one without copying:</p>

<pre><code>@b := @a[0,2,4 ... *]</code></pre>

<p>With PDLs in particular, this might alias each of the individual elements rather than the array as a whole. So modifications to @b are likely to be reflected back into @a. (But maybe the PDLers will prefer a different notation for that.)</p>

<p>The dimensionality of an array may be declared on the variable, but the actual dimensionality of the array depends on how it was created. Reconciling these views is a job for the particular array implementation. It&#39;s not necessarily the case that the declared dimensionality must match the actual dimensionality. It&#39;s quite possible that the array variable is deliberately declared with a different dimensionality to provide a different &#34;view&#34; on the actual value:</p>

<pre><code>my int @array[2;2] is Puddle .= new(:shape(4) &#60;== 0,1,2,3);</code></pre>

<p>Again, reconciling those ideas is up to the implementation, <code>Puddle</code> in this case. The traits system is flexible enough to pass any metadata required, including ideas about sparseness, raggedness, and various forms of non-rectangleness such as triangleness. The implementation should probably carp about any metadata it doesn&#39;t recognize though. The implementation is certainly free to reject any object that doesn&#39;t conform to the variable&#39;s shape requirements.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Subscript_and_slice_notation"
>Subscript and slice notation</a></h1>

<p>A subscript indicates a &#34;slice&#34; of an array. Each dimension of an array is sliced separately, so a multidimensional slice subscript may be supplied as a semicolon-separated list of slice sublists. A three-dimensional slice might look like this:</p>

<pre><code>@x[0..10; 1,0; 1,*+2...*]</code></pre>

<p>It is up to the implementation of <code>@x</code> to decide how aggressively or lazily this subscript is evaluated, and whether the slice entails copying. (The PDL folks will generally want it to merely produce a virtual PDL where the new array aliases its values back into the old one.)</p>

<p>Of course, a single element can be selected merely by providing a single index value to each slice list:</p>

<pre><code>@x[0;1;42]</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Cascaded_subscripting_of_multidimensional_arrays"
>Cascaded subscripting of multidimensional arrays</a></h1>

<p>For all multidimensional array types, it is expected that cascaded subscripts:</p>

<pre><code>@x[0][1][42]
@x[0..10][1,0][1,*+2...*]</code></pre>

<p>will either fail or produce the same results as the equivalent semicolon subscripts:</p>

<pre><code>@x[0;1;42]
@x[0..10; 1,0; 1,*+2...*]</code></pre>

<p>Built-in array types are expected to succeed either way, even if the cascaded subscript form must be implemented inefficiently by constructing temporary slice objects for later subscripts to use. (User-defined types may choose not to support the cascaded form, but if so, they should fail rather than providing different semantics.) As a consequence, for built-in types of declared shape, the appropriate number of cascaded subscripts may always be optimized into the semicolon form.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="The_semicolon_operator"
>The semicolon operator</a></h1>

<p>At the statement level, a semicolon terminates the current expression. Within any kind of bracketing construct, semicolon notionally separates the sublists of a multidimensional slice, the interpretation of which depends on the context. Such a semicolon list puts each of its sublists into a <code>Parcel</code>, deferring the context of the sublist until it is bound somewhere. The storage of these sublists is hidden in the inner workings of the list. It does not produce a list of lists unless the list as a whole is bound into a slice context.</p>

<p>Single dimensional arrays expect simple slice subscripts, meaning they will treat a list subscript as a slice in the single dimension of the array. Multi-dimensional arrays, on the other hand, know how to handle a multidimensional slice, with one subslice for each dimension. You need not specify all the dimensions; if you don&#39;t, the unspecified dimensions are &#34;wildcarded&#34;. Supposing you have:</p>

<pre><code>my num @nums[3;3;3];</code></pre>

<p>Then</p>

<pre><code>@nums[0..2]</code></pre>

<p>is the same as</p>

<pre><code>@nums[0..2;]</code></pre>

<p>which is the same as</p>

<pre><code>@nums[0,1,2;*;*]</code></pre>

<p>But you should maybe write the last form anyway just for good documentation, unless you don&#39;t actually know how many more dimensions there are. For that case use <code>**</code>:</p>

<pre><code>@nums[0,1,2;**]</code></pre>

<p>If you wanted that <code>0..2</code> range to mean</p>

<pre><code>@nums[0;1;2]</code></pre>

<p>it is not good enough to use the <code>|</code> prefix operator, because that interpolates at the comma level, so:</p>

<pre><code>@nums[ |(0,1,2) ] </code></pre>

<p>just means</p>

<pre><code>@nums[ 0,1,2 ];</code></pre>

<p>Instead, to interpolate at the semicolon level, you need to use the <code>||</code> prefix operator:</p>

<pre><code>@nums[ ||(0..2) ]</code></pre>

<p>The zero-dimensional slice:</p>

<pre><code>@x[]</code></pre>

<p>is assumed to want everything, not nothing. It&#39;s particularly handy because Perl 6 (unlike Perl 5) won&#39;t interpolate a bare array without brackets:</p>

<pre><code>@x = (1,2,3);
say &#34;@x = @x[]&#34;;    # prints @x = 1 2 3</code></pre>

<p>Lists are lazy in Perl 6, and the slice lists are no exception. In particular, list generators are not flattened until they need to be, if ever. So a PDL implementation is free to steal the values from these generators and &#34;piddle&#34; around with them:</p>

<pre><code>@nums[$min ..^ $max]
@nums[$min, *+3 ... $max]
@nums[$min, *+3 ... *]
@nums[1,*+2...*]         # the odds
@nums[0,*+2...*]         # the evens
@nums[1,3...*]           # the odds
@nums[0,2...*]           # the evens</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PDL_signatures"
>PDL signatures</a></h1>

<p>To rewrite a Perl 5 PDL definition like this:</p>

<pre><code>   pp_def(
        &#39;inner&#39;,
        Pars =&#62; &#39;a(n); b(n); [o]c(); &#39;, # the signature, see above
        Code =&#62; &#39;double tmp = 0;
                 loop(n) %{ tmp += $a() * $b(); %}
                 $c() = tmp;&#39; );</code></pre>

<p>you might want to write a macro that parses something vaguely resembling this:</p>

<pre><code>role PDL_stuff[::TYPE] {
    PDLsub inner (@a[$n], @b[$n] --&#62; @c[]) {
        my TYPE $tmp = 0;
        for ^$n {
            $tmp += @a[$_] * @b[$_];
        }
        @c[] = tmp;
    }
}</code></pre>

<p>where that turns into something like this:</p>

<pre><code>role PDL_stuff[::TYPE] {
    multi inner (TYPE @a, TYPE @b --&#62; TYPE) {
        my $n = @a.shape[0];        # or maybe $n is just a parameter
        assert($n == @b.shape[0]);  #  and this is already checked by PDL
        my TYPE $tmp = 0;
        for ^$n {
            $tmp += @a[$_] * @b[$_];
        }
        return $tmp;
    }
}</code></pre>

<p>Then any class that <code>does PDL_stuff[num]</code> has an <code>inner()</code> function that can (hopefully) be compiled down to a form useful to the PDL threading engine. Presumably the macro also stores away the PDL signature somewhere safe, since the translated code hides that information down in procedural code. Possibly some of the <code>[n]</code> information can come back into the signature via <code>where</code> constraints on the types. This would presumably make multimethod dispatch possible on similarly typed arrays with differing constraints.</p>

<p>(The special destruction problems of Perl 5&#39;s PDL should go away with Perl 6&#39;s GC approach, as long as PDL&#39;s objects are registered with the run-time system correctly.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Autothreading_types"
>Autothreading types</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Junctions"
>Junctions</a></h2>

<p>A junction is a superposition of data values pretending to be a single data value. Junctions come in four varieties:</p>

<pre><code>list op     infix op
=======     ========
any()       |
all()       &#38;
one()       ^
none()      (no &#34;nor&#34; op defined)</code></pre>

<p>Note that the infix ops are &#34;list-associative&#34;, insofar as</p>

<pre><code>$a | $b | $c
$a &#38; $b &#38; $c
$a ^ $b ^ $c</code></pre>

<p>mean</p>

<pre><code>any($a,$b,$c)
all($a,$b,$c)
one($a,$b,$c)</code></pre>

<p>rather than</p>

<pre><code>any(any($a,$b),$c)
all(all($a,$b),$c)
one(one($a,$b),$c)</code></pre>

<p>Some contexts, such as boolean contexts, have special rules for dealing with junctions. In any item context not expecting a junction of values, a junction produces automatic parallelization of the algorithm. In particular, if a junction is used as an argument to any routine (operator, closure, method, etc.), and the scalar parameter you are attempting to bind the argument to is inconsistent with the <code>Junction</code> type, that routine is &#34;autothreaded&#34;, meaning the routine will be called automatically as many times as necessary to process the individual scalar elements of the junction in parallel. (<code>Each</code> types are also autothreaded, but are serial and lazy in nature.)</p>

<p>The results of these separate calls are then recombined into a single junction of the same species as the junctive argument. If two or more arguments are junctive, then the argument that is chosen to be &#34;autothreaded&#34; is:</p>

<ul>
<li>the left-most <i>all</i> or <i>none</i> junction (if any), or else</li>

<li>the left-most <i>one</i> or <i>any</i> junction</li>
</ul>

<p>with the tests applied in that order.</p>

<p>Each of the resulting set of calls is then recursively autothreaded until no more junctive arguments remain. That is:</p>

<pre><code>   substr(&#34;camel&#34;, 0|1, 2&#38;3)

-&#62; all( substr(&#34;camel&#34;, 0|1, 2),      # autothread the conjunctive arg
        substr(&#34;camel&#34;, 0|1, 3)
      )

-&#62; all( any( substr(&#34;camel&#34;, 0, 2),   # autothread the disjunctive arg
             substr(&#34;camel&#34;, 1, 2),
           ),
        any( substr(&#34;camel&#34;, 0, 3),   # autothread the disjunctive arg
             substr(&#34;camel&#34;, 1, 3),
           )
      )

-&#62; all( any( &#34;ca&#34;,                    # evaluate
             &#34;am&#34;,
           ),
        any( &#34;cam&#34;,
             &#34;ame&#34;,
           )

-&#62; (&#34;ca&#34;|&#34;am&#34;) &#38; (&#34;cam&#34;|&#34;ame&#34;)        # recombine results in junctions</code></pre>

<p>Junctions passed as part of a container do not cause autothreading unless individually pulled out and used as a scalar. It follows that junctions passed as members of a &#34;slurpy&#34; array or hash do not cause autothreading on that parameter. Only individually declared parameters may autothread. (Note that positional array and hash parameters are in fact scalar parameters, though, so you could pass a junction of array or hash objects.)</p>

<p>The exact semantics of autothreading with respect to control structures are subject to change over time; it is therefore erroneous to pass junctions to any control construct that is not implemented via as a normal single dispatch or function call. In particular, threading junctions through conditionals correctly could involve continuations, which are almost but not quite mandated in Perl 6.0.0. Alternately, we may decide that boolean contexts always collapse the junction by default, and the exact value that allowed the collapse to &#34;true&#34; is not available. A variant of that is to say that if you want autothreading of a control construct, you must assign or bind to a non-<code>Mu</code> container before the control construct, and that assignment or binding to any such container results in autothreading the rest of the dynamic scope. (The performance ramifications of this are not clear without further experimentation, however.) So for now, please limit use of junctions to situations where the eventual binding to a scalar formal parameter is clear.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Each"
>Each</a></h2>

<p>[This section is considered conjectural.]</p>

<p>An <code>Each</code> type autothreads like a junction, but does so serially and lazily, and is used only for its mapping capabilities. The prototypical use case is where a hyperoperator would parallelize in an unfortunate way:</p>

<pre><code>@array&#187;.say          # order not guaranteed
@array.each.say      # order guaranteed</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Parallelized_parameters_and_autothreading"
>Parallelized parameters and autothreading</a></h1>

<p>Within the scope of a <code>use autoindex</code> pragma (or equivalent, such as <code>use PDL</code> (maybe)), any closure that uses parameters as subscripts is also a candidate for autothreading. For each such parameter, the compiler supplies a default value that is a range of all possible values that subscript can take on (where &#34;possible&#34; is taken to mean the declared shape of a shaped array, or the actual shape of an autoextending array). That is, if you have a closure of the form:</p>

<pre><code>-&#62; $x, $y { @foo[$x;$y] }</code></pre>

<p>then the compiler adds defaults for you, something like:</p>

<pre><code>-&#62; $x = @foo.shape[0].range,
   $y = @foo.shape[1].range { @foo[$x;$y] }</code></pre>

<p>where each such range is autoiterated for you.</p>

<p>In the abstract (and often in the concrete), this puts an implicit loop around the block of the closure that visits all the possible subscript values for that dimension (unless the parameter is actually supplied to the closure, in which case the supplied value is used as the slice subscript instead).</p>

<p>This implicit loop is assumed to be parallelizable.</p>

<p>So to write a typical tensor multiplication:</p>

<pre><code>Cijkl = Aij * Bkl</code></pre>

<p>you can simply call a closure with no arguments, allowing the <code>autoindex</code> pragma to fill in the defaults:</p>

<pre><code>use autoindex;
-&#62; $i, $j, $k, $l { @c[$i; $j; $k; $l] = @a[$i; $j] * @b[$k; $l] }();</code></pre>

<p>or you can use the <code>do BLOCK</code> syntax (see <a href="http://search.cpan.org/perldoc?S04#The_do-once_loop" class="podlinkpod"
>&#34;The do-once loop&#34; in S04</a>) to call that closure, which also implicitly iterates:</p>

<pre><code>use autoindex;
do -&#62; $i, $j, $k, $l {
    @c[$i; $j; $k; $l] = @a[$i; $j] * @b[$k; $l]
}</code></pre>

<p>or even use placeholder variables instead of a parameter list:</p>

<pre><code>use autoindex;
do { @c[$^i; $^j; $^k; $^l] = @a[$^i; $^j] * @b[$^k; $^l] };</code></pre>

<p>That&#39;s almost pretty.</p>

<p>It is erroneous for an unbound parameter to match multiple existing array subscripts differently. (Arrays being created don&#39;t count.)</p>

<p>Note that you could pass any of $i, $j, $k or $l explicitly, or prebind them with a <code>.assuming</code> method, in which only the unbound parameters autothread.</p>

<p>If you use an unbound array parameter as a semicolon-list interpolator (via the <code>prefix:&#60;||&#62;</code> operator), it functions as a wildcard list of subscripts that must match the same everywhere that parameter is used. For example,</p>

<pre><code>do -&#62; @wild { @b[ ||@wild.reverse ] = @a[ ||@wild ] };</code></pre>

<p>produces an array with the dimensions reversed regardless of the dimensionality of <code>@a</code>.</p>

<p>The optimizer is, of course, free to optimize away any implicit loops that it can figure out how to do more efficiently without changing the semantics.</p>

<p>See RFC 207 for more ideas on how to use autothreading (though the syntax proposed there is rather different).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Hashes"
>Hashes</a></h1>

<p>Like arrays, you can specify hashes with multiple dimensions and fixed sets of keys:</p>

<pre><code>my num %hash{&#60;a b c d e f&#62;};        # Only valid keys are &#39;a&#39;..&#39;f&#39;
my num %hash{&#39;a&#39;..&#39;f&#39;};             # Same thing

my %rainfall{ Months; 1..31 }       # Keys: Jan..Dec ; 1..31</code></pre>

<p>Unlike arrays, you can also specify a hash dimension via a non- enumerated type, which then allows all values of that type as keys in that dimension:</p>

<pre><code>my num %hash{&#60;a b c d e f&#62;; Str};   # 2nd dimension key may be any string
my num %hash{&#39;a&#39;..&#39;f&#39;; Str};        # Same thing

my %rainfall{ Months; Int };        # Keys: Jan..Dec ; any integer</code></pre>

<p>To declare a hash that can take any object as a key rather than just a string or integer, say something like:</p>

<pre><code>my %hash{Any};
my %hash{*};</code></pre>

<p>A hash of indeterminate dimensionality is:</p>

<pre><code>my %hash{**};</code></pre>

<p>You can limit the keys to objects of particular types:</p>

<pre><code>my Fight %hash{Dog; Squirrel where {!.scared}};</code></pre>

<p>The standard Hash:</p>

<pre><code>my %hash;</code></pre>

<p>is really short for:</p>

<pre><code>my Mu %hash{Str(Any)};</code></pre>

<p>Note that any type used as a key must be intrinsically immutable, or it has to be able to make a copy that functions as an immutable key, or it has to have copy-on-write semantics. It is erroneous to change a key object&#39;s value within the hash except by deleting it and reinserting it.</p>

<p>The order of hash keys is implementation dependent and arbitrary. Unless <code>%hash</code> is altered in any way, successive calls to <code>.keys</code>, <code>.kv</code>, <code>.pairs</code>, <code>.values</code>, or <code>.iterator</code> will iterate over the elements in the same order.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Autosorted_hashes"
>Autosorted hashes</a></h1>

<p>The default hash iterator is a property called <code>.iterator</code> that can be user replaced. When the hash itself needs an iterator for <code>.pairs</code>, <code>.keys</code>, <code>.values</code>, or <code>.kv</code>, it calls <code>%hash.iterator()</code> to start one. In item context, <code>.iterator</code> returns an iterator object. In list context, it returns a lazy list fed by the iterator. It must be possible for a hash to be in more than one iterator at a time, as long as the iterator state is stored in a lazy list.</p>

<p>The downside to making a hash autosort via the iterator is that you&#39;d have to store all the keys in sorted order, and resort it when the hash changes. Alternately, the entire hash could be tied to an ISAM implementation (not included (XXX or should it be?)).</p>

<p>For multidimensional hashes, the key returned by any hash iterator is a list of keys, the size of which is the number of declared dimensions of the hash. [XXX but this seems to imply another lookup to find the value. Perhaps the associated value can also be bundled in somehow.]</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Autovivification"
>Autovivification</a></h1>

<p>Autovivification will only happen if the vivifiable path is bound to a read-write container. Value extraction (that is, binding to a readonly or copy container) does not autovivify.</p>

<p>Note that assignment is treated the same way as binding to a copy container, so it does not autovivify its right side either.</p>

<p>Any mention of an expression within a <code>Parcel</code> delays the autovivification decision to binding time. (Binding to a parcel parameter also defers the decision.)</p>

<p>This is as opposed to Perl 5, where autovivification could happen unintentionally, even when the code looks like a non-destructive test:</p>

<pre><code># This is Perl 5 code
my %hash;
exists $hash{foo}{bar}; # creates $hash{foo} as an empty hash reference</code></pre>

<p>In Perl 6 these read-only operations are indeed non-destructive:</p>

<pre><code>my %hash;
%hash&#60;foo&#62;&#60;bar&#62; :exists; # %hash is still empty</code></pre>

<p>But these bindings <i>do</i> autovivify:</p>

<pre><code>my %hash;
my $val := %hash&#60;foo&#62;&#60;bar&#62;;

my @array;
my $parcel = \@array[0][0]; # $parcel is a Parcel object - see S02
my :($obj) := $parcel;   # @array[0][0] created here

my @array;
foo(@array[0][0]);
sub foo ($obj is rw) {...}  # same thing, basically

my %hash;
%hash&#60;foo&#62;&#60;bar&#62; = &#34;foo&#34;; # duh</code></pre>

<p>This rule applies to <code>Array</code>, <code>Hash</code>, and any other container type that chooses to return an autovivifiable type object (see S12) rather than simply returning <code>Failure</code> when a lookup fails. Note in particular that, since autovivification is defined in terms of type objects rather than failure, it still works under &#34;use fatal&#34;.</p>

<p>This table solidifies the intuition that an operation pertaining to some data structure causes the type object to autovivify to such an object:</p>

<pre><code>operation                autovivifies to
=========                ===============
push, unshift, .[]       Array
.{}                      Hash</code></pre>

<p>In addition to the above data structures autovivifying, <code>++</code> and <code>--</code> will cause an <code>Int</code> to appear, <code>~=</code> will create a <code>Str</code> etc; but these are natural consequences of the operators working on <code>Failure</code>, qualitatively different from autovivifying containers.</p>

<p>The type of the type object returned by a non-successful lookup should be identical to the type that would be returned for a successful lookup. The only difference is whether it&#39;s officially instantiated (defined) yet. That is, you cannot distinguish them via <code>.WHAT</code> or <code>.HOW</code>, only via <code>.defined</code>.</p>

<p>Binding of an autovivifiable type object to a non-writeable container translates the type object into a similar type object without its autovivifying closure and puts that new type object into the container instead (with any pertinent historical diagnostic information carried over). There is therefore no magical method you can call on the readonly parameter that can magically autovivify the type object after the binding. The newly bound variable merely appears to be a simple uninitialized value. (The original type object retains its closure in case it is rebound elsewhere to a read-write container.)</p>

<p>Some implementation notes: Nested autovivifications work by making nested type objects that depend on each other. In the general case the containers must produce type objects any time they do not know how the container will be bound. This includes when interpolated into any capture that has delayed binding:</p>

<pre><code>\( 1, 2, %hash&#60;foo&#62;&#60;bar&#62; )          # must defer
\%hash&#60;foo&#62;&#60;bar&#62;                    # must defer</code></pre>

<p>In specific situations however, the compiler can know that a value can only be bound readonly. For instance, <code>infix:&#60;+&#62;</code> is prototyped such that this can never autovivify:</p>

<pre><code>%hash&#60;foo&#62;&#60;bar&#62; + 42</code></pre>

<p>In such a case, the container object need not go through the agony of calculating an autovivifying closure that will never be called. On the other hand:</p>

<pre><code>%hash&#60;foo&#62;&#60;bar&#62; += 42</code></pre>

<p>binds the left side to a mutable container, so it autovivifies.</p>

<p>Assignment doesn&#39;t look like binding, but consider that it&#39;s really calling some kind of underlying set method on the container, which must be mutable in order to change its contents.</p>

<!-- end doc -->

</body></html>
