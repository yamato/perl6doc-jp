<!DOCTYPE html>
<html lang="ja">
<head>
<title>S13-overloading</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Sep 27 10:05:33 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Multiple_dispatch'>Multiple dispatch</a>
  <li class='indexItem indexItem1'><a href='#Syntax'>Syntax</a>
  <li class='indexItem indexItem1'><a href='#Fallbacks'>Fallbacks</a>
  <li class='indexItem indexItem1'><a href='#Type_Casting'>Type Casting</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 13: Overloading</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Larry Wall &#60;larry@wall.org&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 2 Nov 2004

Last Modified: 17 Jan 2012
Version: 17</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis discusses those portions of Apocalypse 12 that ought to have been in Apocalypse 13.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Multiple_dispatch"
>Multiple dispatch</a></h1>

<p>The overloading mechanism of Perl 5 has been superseded by Perl 6&#39;s multiple dispatch mechanism. Nearly all internal functions are defined as <code>multi</code> subs or <code>multi</code> methods on generic types. Built-in operators are merely oddly named functions with an alternate call syntax. All you have to do to overload them is to define your own <code>multi</code> subs and methods that operate on arguments with more specific types.</p>

<p>For unary operators, this makes little effective difference, but for binary operators, multiple dispatch fixes the Perl 5 problem of paying attention only to the type of the left argument. Since both argument types are used in deciding which routine to call, there is no longer any trickery involving swapping the arguments to use the right argument&#39;s type instead of the left one. And there&#39;s no longer any need to examine a special flag to see if the arguments were reversed.</p>

<p>For much more about multiple dispatch, see S12.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Syntax"
>Syntax</a></h1>

<p>There is no longer any special <code>use overload</code> syntax separate from the declarations of the <code>multi</code> routines themselves. To overload an existing built-in sub, say something like:</p>

<pre><code>multi sub uc (TurkishStr $s) {...}</code></pre>

<p>A <code>multi</code> is automatically exported if governed by a proto that is exported. It may also be explicitly exported:</p>

<pre><code>multi sub uc (TurkishStr $s) is export {...}</code></pre>

<p>Now if you call <code>uc()</code> on any Turkish string, it will call your function rather than the built-in one.</p>

<p>If you import a multi into a UNIT scope, it is automatically re-exported.</p>

<p>The types of the parameters are included in the <i>longname</i> of any <code>multi</code> sub or method. So if you want to overload string concatenation for Arabic strings so you can handle various ligatures, you can say:</p>

<pre><code>multi sub infix:&#60;~&#62;(ArabicStr $s1, ArabicStr $s2) {...}
multi sub infix:&#60;~&#62;(Str $s1, ArabicStr $s2) {...}
multi sub infix:&#60;~&#62;(ArabicStr $s1, Str $s2) {...}</code></pre>

<p>The <code>use overload</code> syntax had one benefit over Perl 6&#39;s syntax in that it was easy to alias several different operators to the same service routine. This can easily be handled with Perl 6&#39;s aliasing:</p>

<pre><code>multi sub unimpl (MyFoo $x, MyFoo $y) { upchuck(); }
&#38;infix:&#60;+&#62; ::= &#38;unimpl;
&#38;infix:&#60;-&#62; ::= &#38;unimpl;
&#38;infix:&#60;*&#62; ::= &#38;unimpl;
&#38;infix:&#60;/&#62; ::= &#38;unimpl;</code></pre>

<p>A <code>multi</code> is in effect only within the scope in which it is defined or imported. Generally you want to put your <code>multi</code> subs into a package that will be imported wherever they are needed.</p>

<p>Conjectural: If the first parameter to a <code>multi</code> signature is followed by an invocant colon, that signature represents two signatures, one for an ordinary method definition, and one for the corresponding <code>multi</code> definition that has a comma instead of the colon. This form is legal only where the standard method definition would be legal, and only if any declared type of the first parameter is consistent with <code>$?CLASS</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Fallbacks"
>Fallbacks</a></h1>

<p>Dispatch is based on a routine&#39;s signature declaration without regard to whether the routine is defined yet. If an attempt is made to dispatch to a declared but undefined routine, Perl will redispatch to an <code>AUTODEF</code> submethod [conjectural] as appropriate to define the routine. This provides a run-time mechanism for fallbacks. By default, these declarations are taken at face value and do not specify any underlying semantics. As such, they&#39;re a &#34;shallow&#34; interpretation.</p>

<p>[Note: the following section on &#34;is deep&#34; may no longer be necessary given the way metaoperators are now constructed.]</p>

<p>However, sometimes you want to specify a &#34;deep&#34; interpretation of your operators. That is, you&#39;re specifying the abstract operation, which may be used by various shallow operators. Any deep multi declarations will be &#34;amplified&#34; into all the shallow operators that can be logically based on it. If you say:</p>

<pre><code>multi sub infix:&#60;%&#62; (Us $us, Them $them) is deep { mymod($us,$them) }</code></pre>

<p>then</p>

<pre><code>multi sub infix:&#60;%=&#62; (Us $us, Them $them) { $us = $us % $them }</code></pre>

<p>is also generated for you (unless you define it yourself). The mappings of magical names to sub definitions is controlled by the <code>%?DEEPMAGIC</code> compiler hash. Pragmas can influence the contents of this hash over a lexical scope, so you could have different policies on magical autogeneration. The default mappings correspond to the standard fallback mappings of Perl 5 overloading.</p>

<p>These deep mappings are mainly intended for infix operators that would have difficulty naming all their variants. Prefix operators tend to be simpler; note in particular that</p>

<pre><code>multi prefix:&#60;~&#62; is deep {...}</code></pre>

<p>is better written:</p>

<pre><code>method Stringy {...}</code></pre>

<p>(see below).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Type_Casting"
>Type Casting</a></h1>

<p>A class may define methods that allow it to respond as if it were a routine, array, or hash. The long forms are as follows:</p>

<pre><code>method postcircumfix:&#60;( )&#62; (|capture) {...}
method postcircumfix:&#60;[ ]&#62; (**@slice) {...}
method postcircumfix:&#60;{ }&#62; (**@slice) {...}</code></pre>

<p>Those are a bit unwieldy, so you may also use these short forms:</p>

<pre><code>method &#38;.( |capture ) {...}
method @.[ **@slice ] {...}
method %.{ **@slice } {...}</code></pre>

<p>The sigil-dot sequence in these short forms autogenerates the corresponding public operators, in exactly the same way that the sigil-dot in:</p>

<pre><code>has $.action;
has @.sequence;
has %.mapping;</code></pre>

<p>autogenerates public accessor methods.</p>

<p>And because it uses the same method-autogeneration mechanism, the specific sigil used to specify a short-form postcircumfix operator doesn&#39;t actually matter...as long as it&#39;s followed by a dot and the bracket pair containing the signature. (Though it&#39;s probably kinder to future readers of your code to stick with the &#34;natural&#34; sigil for each type of bracket.)</p>

<p>Note that the angle bracket subscripting form <code>.&#60;a b c&#62;</code> automatically translates itself into a call to <code> .{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;} </code>, so defining methods for angles is basically useless.</p>

<p>The expected semantics of <code>&#38;.()</code> is that of a type coercion which may or may not create a new object. So if you say:</p>

<pre><code>$fido = Dog.new($spot)</code></pre>

<p>it certainly creates a new <code>Dog</code> object. But if you say:</p>

<pre><code>$fido = Dog($spot)</code></pre>

<p>it might call <code>Dog.new</code>, or it might pull a <code>Dog</code> with Spot&#39;s identity from the dog cache, or it might do absolutely nothing if <code>$spot</code> already knows how to be a <code>Dog</code>. As a fallback, if no method responds to a coercion request, the class will be asked to attempt to do <code>Dog.new($spot)</code> instead.</p>

<p>It is also possible (and often preferable) to specify coercions from the other end, that is, for a class to specify how to coerce one of its values to some other class. If you define a method whose name is a declared type, it is taken as a coercion to that type:</p>

<pre><code>method Str { self.makestringval() }</code></pre>

<p>As with all methods, you can also export the corresponding <code>multi</code>:</p>

<pre><code>multi method Str is export { self.makestringval() }</code></pre>

<p>in which case you can use both calling forms:</p>

<pre><code>$x.Str
Str($x)</code></pre>

<p>If the source class and the destination class both specify a coercion routine, the ambiguity is settled by the ordinary rules of dispatch. That is, <code>$x.Str</code> will always prefer the method form and <code>Str($x)</code> will always prefer the functional form.</p>

<p>Note that, because the name of an anonymous class is unknown, coercion to an anonymous class can only be specified by the destination class:</p>

<pre><code>$someclass = generate_class();
$someclass($x);</code></pre>

<!-- end doc -->

</body></html>
