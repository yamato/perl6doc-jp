<!DOCTYPE html>
<html lang="ja">
<head>
<title>S16-io</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="../default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Sep 27 10:05:33 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#IO'>IO</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Overridable_IO_handles'>Overridable IO handles</a>
    <li class='indexItem indexItem2'><a href='#Path_Names_and_the_.IO_coercer'>Path Names and the .IO coercer</a>
    <li class='indexItem indexItem2'><a href='#%24*SPEC'>$*SPEC</a>
    <li class='indexItem indexItem2'><a href='#%24*CWD_and_chdir()'>$*CWD and chdir()</a>
    <li class='indexItem indexItem2'><a href='#%24*TMPDIR_and_chdir()'>$*TMPDIR and chdir()</a>
    <li class='indexItem indexItem2'><a href='#%24*HOME_and_chdir()'>$*HOME and chdir()</a>
    <li class='indexItem indexItem2'><a href='#System_dependent_path_semantics_and_IO%3A%3ASpec'>System dependent path semantics and IO::Spec</a>
    <li class='indexItem indexItem2'><a href='#Functions_and_Classes'>Functions and Classes</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Functions'>Functions</a>
      <li class='indexItem indexItem3'><a href='#IO%3A%3ASpec_Class'>IO::Spec Class</a>
      <li class='indexItem indexItem3'><a href='#IO%3A%3APath_Class'>IO::Path Class</a>
      <li class='indexItem indexItem3'><a href='#IO%3A%3AHandle_Class'>IO::Handle Class</a>
      <li class='indexItem indexItem3'><a href='#Interplay_between_Roles_and_Classes'>Interplay between Roles and Classes</a>
    </ul>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 16: I/O</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Largely, the authors of the related Perl 5 docs.
Larry Wall &#60;larry@wall.org&#62;
Mark Stosberg &#60;mark@summersault.com&#62;
Tim Nelson &#60;wayland@wayland.id.au&#62;
Daniel Ruoso &#60;daniel@ruoso.com&#62;
Elizabeth Mattijsen &#60;liz@dijkmat.nl&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 12 Sep 2006

Last Modified: 23 Sep 2014
Version: 25</code></pre>

<p>Many of these functions will work as in Perl 5, except we&#39;re trying to rationalize everything into roles. For now you can assume most of the important functions will automatically be in the * namespace. However, with IO operations in particular, many of them are really methods on an IO handle, and if there is a corresponding global function, it&#39;s merely an exported version of the method.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IO"
>IO</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Overridable_IO_handles"
>Overridable IO handles</a></h2>

<p>In Perl 6, there are the <i>standard</i> IO handles, and any number of overriding inner filehandles for the same symbol.</p>

<p>The <i>standard</i> handles are our old familiar friends (with new names). Standard input changed from STDIN to <code>$*IN</code>, standard output changed from STDOUT to <code>$*OUT</code>, and standard error changed from STDERR to <code>$*ERR</code>. In Perl 6 these symbols represent more of a concept than a given filehandle, since the meaning is contextually determined. The process&#39;s version of these handles live in the <code>PROCESS::</code> namespace, which is more global than the per-interpreter <code>GLOBAL::</code> namespace.</p>

<p>When no explicit filehandle is used, the standard IO operators are defined in terms of the dynamic variables. So the <code>say</code> function prints to <code>$*OUT</code>, while <code>note</code> prints to <code>$*ERR</code>. The <code>lines()</code> term inputs from <code>$*ARGFILES</code> which defaults to <code>$*IN</code> in the absence of any filenames. So any given dynamic scope (interpreter, thread, function or method call) may redefine the current meaning of any of those filehandles within the dynamic scope of itself and of its called routines.</p>

<p>So to put it another way, when you write something like</p>

<pre><code>  say &#34;Howdy, world!&#34;</code></pre>

<p>the <code>say</code> function looks for the current meaning of <code>$*OUT</code>, and takes the closest definition it can find in its callers. If none of the callers have overridden the definition, it looks in the interpreter&#39;s <code>GLOBAL</code> namespace. If the interpreter hasn&#39;t overridden the meaning, it takes the meaning from <code>PROCESS</code>. In essence, any dynamic scope in Perl 6 is allowed to do IO redirection much like a Unix shell does with its subprocesses, albeit with a different syntax:</p>

<pre><code>  {
  my $*OUT will leave *.close = open $newfile, :w;
  say &#34;Written to $newfile&#34;;
  }
  # stdout reverts to outer scope&#39;s definition, and closed the file</code></pre>

<p>In short:</p>

<pre><code>          default handle
routine   for sub form    purpose
=======   ===========     =======
print     $*OUT           string-based writing
say       $*OUT           string-based writing
get       $*ARGFILES      read a line (Str)
lines     $*ARGFILES      read all lines (Str)
words     $*ARGFILES      read all words (Str)
read                      binary reading (Buf)
write                     binary writing (Buf)</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Path_Names_and_the_.IO_coercer"
>Path Names and the .IO coercer</a></h2>

<p>Path names are just strings (<code>Str</code>). Methods that return path names, will just return strings. As soon as you need to do manipulation on the path name (e.g. to find out its <code>basename</code> or <code>extension</code>), you can create an <code>IO::Path</code> object out of the string by applying the <code>.IO</code> coercer:</p>

<pre><code>  my $path = $filename.IO;</code></pre>

<p>Then you can use any of the <code>IO::Path</code> methods, such as <code>open</code>:</p>

<pre><code>  my $handle = $newfile.IO.open(:w);</code></pre>

<p>Note that the <code>open()</code> sub, is just really syntactic sugar for the above:</p>

<pre><code>  my $handle = open $newfile, :w;</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$*SPEC"
>$*SPEC</a></h2>

<p>The current system&#39;s path semantics are encapsulated in <code>$*SPEC</code> dynamic variable. It adhers to the <code>IO::Spec</code> interface, and is automatically initialized for the current environment. But like any dynamic variable, can be overridden in a scope:</p>

<pre><code>  { # Win32 path semantics in here
  my $*SPEC = IO::Spec::Win32;
  ...  # your code
  }
  # original path semantics here again</code></pre>

<p>Please note that it does <b>not</b> need to be an instantiated object: the standard <code>IO::Spec</code> subclasses only provide class methods, and therefore do not need an instantiated object. But that could be different for a very specific third-party implementation of an <code>IO::Spec</code> class.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$*CWD_and_chdir()"
>$*CWD and chdir()</a></h2>

<p>The dynamic variable $*CWD is an <code>IO::Path</code> object of the current working directory. It is normally set with the <code>chdir()</code> function, which will check whether the specified path exists as a directory. To facilitate setting a locally scoped version of $*CWD, you can specify the variable to be set as a second parameter to <code>chdir()</code>.</p>

<pre><code>  chdir($dir);   # sets $*CWD of outer scope, usually PROCESS::&#60;$*CWD&#62;

  {
  chdir($dir, my $*CWD);  # set $*CWD in this scope
  }</code></pre>

<p>The <code>chdir()</code> function returns a <code>X::IO::Chdir</code> Failure if the path does not exist, is not accessible, or is not a directory. Otherwise it will return <code>True</code>. Any <code>Failure</code> generally will be thrown immediately if called like above.</p>

<p>Please note that the path in <code>$*CWD</code> does not have any bearing on what the underlying operating system&#39;s concept of a &#34;current directory&#34;. It is simply the path that will prepended before any implicit or explicit relative paths, and the default path that will be used when executing a sub-process.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$*TMPDIR_and_chdir()"
>$*TMPDIR and chdir()</a></h2>

<p>The dynamic variable <code>$*TMPDIR</code> is an <code>IO::Path</code> object which points to the system&#39;s temporary directory. It can be set with the <code>chdir()</code> function:</p>

<pre><code>  chdir($dir, $*TMPDIR, :test&#60;d r w x&#62;);</code></pre>

<p>which will check whether the specified path exists as a directory and is readable and writable. To facilitate setting a locally scoped version of $*TMPDIR in the same manner:</p>

<pre><code>  {
  chdir($dir, my $*TMPDIR, :test:&#60;d r w x&#62;);  # set $*TMPDIR in this scope
  }</code></pre>

<p>It will return <code>True</code> or an appropriate <code>Failure</code>.</p>

<p>The initialization of <code>$*TMPDIR</code> at startup, is delegated to the <code>.tmpdir</code> method of the <code>$*SPEC</code> setting that is set at startup.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$*HOME_and_chdir()"
>$*HOME and chdir()</a></h2>

<p>The dynamic variable <code>$*HOME</code> is an <code>IO::Path</code> object which points to the user&#39;s home directory. It can be set with the <code>chdir()</code> function:</p>

<pre><code>  chdir($dir, $*HOME, :test&#60;d r w x&#62;);</code></pre>

<p>which will check whether the specified path exists as a directory and is readable and writable. To facilitate setting a locally scoped version of $*HOME in the same manner:</p>

<pre><code>  {
  chdir($dir, my $*HOME, :test&#60;d r w x&#62;);  # set $*HOME in this scope
  }</code></pre>

<p>It will return <code>True</code> or an appropriate <code>Failure</code>.</p>

<p>The initialization of <code>$*HOME</code> at startup, is delegated to the <code>.homedir</code> method of the <code>$*SPEC</code> setting that is set at startup.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="System_dependent_path_semantics_and_IO::Spec"
>System dependent path semantics and IO::Spec</a></h2>

<p>Each time an <code>IO::Path</code> object is created, the current <code>$*SPEC</code> will be encapsulated in the object, to be used for all path related operations.</p>

<p>Of course, it is also possible to specify a specify a specific system&#39;s path semantics module when creating an <code>IO::Path</code> object with the <code>:SPEC</code> named parameter:</p>

<pre><code>  my $SPEC = IO::Spec::Win32;
  my $path = $fileonNTFS.IO(:$SPEC);</code></pre>

<p>or:</p>

<pre><code>  my $path = $fileonNTFS.IO(:SPEC&#60;Win32&#62;); # auto-expand to IO::Spec::Win32</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Functions_and_Classes"
>Functions and Classes</a></h2>

<p>The functions and classes that define most of the functionality for IO are more thoroughly defined in S32-setting-library/IO.pod. The main functions used are listed in S29 with references to S32-setting-library/IO.pod. An overview:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Functions"
>Functions</a></h3>

<pre><code>  print(@text)                  # print text on $*OUT
  say(@text)                    # print text + newline on $*OUT
  note(@text)                   # print text + newline on $*ERR
  dd($a,$b,$c)                  # tiny data dumper on $*ERR
  $line = prompt($message)      # print message on $*OUT, obtain next line

  $handle = open($path)         # open a file, return IO::Handle

  @paths = dir                  # paths (as Str) in $*CWD
  @paths = dir($dir)            # paths (as Str) in $dir

  $contents = slurp($handle)    # read all that&#39;s left of an opened filehandle
  $contents = slurp($filename)  # read all from given filename

  spurt($handle,$contents)      # write $contents to $handle
  spurt($filename,$contents)    # write $contents to $filename

  mkdir($dir)                   # create a directory
  rmdir($dir)                   # remove a directory

  chdir($dir)                   # set $*CWD
  chdir($dir, my $*CWD)         # set $*CWD for the current scope
  chdir($dir, my $*TMPDIR, :test&#60;d r w x&#62;)   # set $*TMPDIR, also be +w and +x
  chdir($dir, my $*HOME)        # set $*HOME for the current scope

  copy($from,$to)               # copy a file
  rename($from,$to)             # rename (move) a file on same physical storage
  move($from,$to)               # move (rename) a file to other storage
  unlink(*@files)               # remove one or more files
  chmod($permission,*@files)    # change permissions of one or more files

  link($target,$source)         # create a hard-link to a file
  symlink($target,$source)      # create a symbolic link to a file</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="IO::Spec_Class"
>IO::Spec Class</a></h3>

<p>The <code>IO::Spec</code> itself only has one method: <code>select</code>. It takes an OS descriptive name (usually something like what <code>$*DISTRO.name</code> gives) and returns the type object of the appropriate <code>IO::Spec</code> subclass.</p>

<pre><code>  my $*SPEC = IO::Spec.select(&#34;MSWin32&#34;);  # gives IO::Spec::Win32</code></pre>

<p>Such a subclass should provide at least the following methods (in alphabetical order):</p>

<pre><code>  abs2rel        convert an absolute path into a relative one
  canonpath      return a canonical version of the given path
  catdir         concatenate directories
  catpath        create a path from volume/directories/filename
  curdir         the path to the current directory (usually &#39;.&#39;)
  curupdir       test for matching curdir|updir
  devnull        the path to the bit bucket (on Unixy systems &#39;/dev/null&#39;)
  extension      the extension of the path
  is-absolute    whether the path is absolute
  join           create a path from hash with volume/directories/filename
  PATH           %ENV&#60;PATH&#62; interpreted as paths
  rel2abs        convert a relative path into an absolute one
  rootdir        the path to the root directory (on Unixy systems &#39;/&#39;)
  split          split a path into volume/directories/filename in hash
  splitdir       split directories
  splitpath      split a path into volume/directories/filename as Parcel
  tmpdir         path of the first writeable directory for temporary files
  updir          the path to the path directory (usually &#39;..&#39;)</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="IO::Path_Class"
>IO::Path Class</a></h3>

<pre><code>  class IO::Path is Cool { }</code></pre>

<p>The official way to create an <code>IO::Path</code> object is with the <code>new</code> method. Apart from the <code>path</code> positional, it also takes optional <code>:SPEC</code> and <code>CWD</code> named parameters. The <code>.IO</code> coercer (which takes the same parameters as <code>.new</code>) is the syntactic sugar that will most likely be used most often.</p>

<pre><code>  my $path = $filename.IO;                  # current $*SPEC/$*CWD
  my $path = $filename.IO(:SPEC(*$SPEC));   # specific IO::SPEC
  my $path = $filename.IO(:SPEC(*$SPEC), :CWD($*CWD));</code></pre>

<p>which would be the same as:</p>

<pre><code>  my $path = IO::Path.new($filename);
  my $path = IO::Path.new($filename, :SPEC(*$SPEC));
  my $path = IO::Path.new($filename, :SPEC(*$SPEC), :CWD($*CWD));</code></pre>

<p>If you only have filename components to start with, you can also create an <code>IO::Path</code> object with the <code>:volume</code>, <code>:directory</code> and <code>:basename</code> named parameters:</p>

<pre><code>  my $path = IO::Path.new( :$volume, :$directory, :$basename );</code></pre>

<p>The following file test methods are provided:</p>

<pre><code>  r          is readable by effective uid/gid
  w          is writable by effective uid/gid
  x          is executable by effective uid/gid
  o          is owned by effective uid

  R          is readable by real uid/gid
  W          is writable by real uid/gid
  X          is executable by real uid/gid
  O          is owned by real uid

  e          exists
  s          Size of the $!path of $io in bytes
  z          has zero size (an empty file)

  f          is a plain file
  d          is a directory
  l          is a symbolic link
  L          path of symbolic link (readlink)
  p          is a named pipe (FIFO)
  S          is a socket
  b          is a block special file
  c          is a character special file

  u          has setuid bit set
  g          has setgid bit set
  k          has sticky bit set</code></pre>

<p>To allow for easy chaining of file tests, there is an <code>.all</code> method that can be fed the tests to be tried as a <code>Parcel</code> of strings. The value returned will be the first non-True value, or the final True value.</p>

<pre><code>  say &#34;rwx&#34; if $path.all: &#60;r w x&#62;;

  if $path.all(&#60;f r w x s&#62;) -&#62; $size {
  say &#34;plain file with rwx of $size bytes&#34;;
  }</code></pre>

<p>These other methods are also provided (in alphabetical order):</p>

<pre><code>  absolute       the absolute, canonical path
  accessed       last access time (if available)
  basename       the basename of the path
  changed        last (metadata) changed time
  chdir          change $*CWD if directory
  child          append basename to path, return new object for that
  chmod          change attributes of path
  copy           create a copy of file
  dir            files in path (if dir)
  directory      the directory part of the absolute path
  extension      the extension of the file
  is-absolute    is the (original) path absolute
  is-relative    is the (original) path relative
  lines          contents of file as lines
  mkdir          create directory
  modified       last modified time
  move           move (rename) to other storage
  open           attempt to open file, return IO::Handle
  parent         remove last portion of path, return new object for that
  pred           previous logical path, return new object for that
  relative       the relative path against CWD
  rename         rename (move) to other name
  resolve        follow symlinks to the real path, return new object for that
  rmdir          remove directory if empty directory
  slurp          obtain the contents of the file
  SPEC           the :SPEC at instantiation time
  spurt          set the contents of the file
  succ           next logical path, return new object for that
  unlink         remove file
  volume         the volume of the path (if any)
  words          contents of file as words</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="IO::Handle_Class"
>IO::Handle Class</a></h3>

<pre><code>  class IO::Handle does IO { }</code></pre>

<p>The <code>IO::Handle</code> object is usually <b>not</b> directly instantiated, but with <code>open()</code> or <code>IO::Path.open</code>. Nonetheless, you <b>can</b> create an <code>IO::Handle</code> object with just a path:</p>

<pre><code>  my $handle = IO::Handle.new($filename);
  my $handle = IO::Handle.new($filename, :SPEC(*$SPEC));
  my $handle = IO::Handle.new($filename, :SPEC(*$SPEC), :CWD($*CWD));</code></pre>

<p>This does not interact with anything at all and will appear as if the file has been <code>.close</code>d. The <code>.open</code> method does interact with the file system:</p>

<pre><code>  $handle.open;  # same as $handle = $filename.IO.open</code></pre>

<p>It either returns True, or a <code>Failure</code> with additional information.</p>

<p>The other methods of the <code>IO::Handle</code> class are only valid <b>after</b> the <code>.open</code> has been called succesfully:</p>

<pre><code>  close          close file handle, flush buffers
  encoding       set/return encoding of file handle
  eof            file pointer reached end of file
  fileno         file descriptor (usually a native integer)
  flush          flush buffers
  get            get next line from file
  getc           get next character from file
  ins            number of lines read
  IO             return new IO::Path of path of file
  lines          return rest of contents of file as lines
  opened         is the file open?
  p              the handle is a pipe
  path           the IO::Path of path of file, handles file tests
  print          write characters to file
  read           read bytes from file
  say            write characters + newline to file
  seek           move file pointer to given position
  slurp          return rest of contents of file
  spurt          write / append contents to file
  t              is the file a TTY (as a person looking?)
  tell           return position of file pointer
  words          return rest of contents of file as words
  write          write bytes to file</code></pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Interplay_between_Roles_and_Classes"
>Interplay between Roles and Classes</a></h3>

<p>These classes and roles may cache and share pertinent information for better performance.</p>

<!-- end doc -->

</body></html>
