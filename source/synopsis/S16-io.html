<!DOCTYPE html>
<html lang="ja">
<head>
<title>S16-io</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css">
<link rel="stylesheet" href="default.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.configure( { languages: ['perl'] } ); hljs.initHighlightingOnLoad();</script>
</head>
<body class='pod'>
<!--
  generated by My::Pod v,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sat Aug 30 10:16:51 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to My::Pod, and/or subclassing My::Pod,
   then reconverting this document from the Pod source.
   When in doubt, email the author of My::Pod for advice.
   See 'perldoc My::Pod' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#IO'>IO</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Overridable_IO_handles'>Overridable IO handles</a>
    <li class='indexItem indexItem2'><a href='#Roles_and_Classes'>Roles and Classes</a>
    <li class='indexItem indexItem2'><a href='#Special_Quoting_Syntax'>Special Quoting Syntax</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Default_constraints'>Default constraints</a>
      <li class='indexItem indexItem3'><a href='#%3Aposix_constraints'>:posix constraints</a>
      <li class='indexItem indexItem3'><a href='#%3Aportable'>:portable</a>
      <li class='indexItem indexItem3'><a href='#%3Alocal'>:local</a>
      <li class='indexItem indexItem3'><a href='#%3Amodern_constraints'>:modern constraints</a>
      <li class='indexItem indexItem3'><a href='#%3Awin_constraints'>:win constraints</a>
      <li class='indexItem indexItem3'><a href='#%3Aunix_constraints'>:unix constraints</a>
      <li class='indexItem indexItem3'><a href='#%3Abin_constraints_(no_constraints_at_all)'>:bin constraints (no constraints at all)</a>
      <li class='indexItem indexItem3'><a href='#Other_constraints'>Other constraints</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#%24*CWD'>$*CWD</a>
    <li class='indexItem indexItem2'><a href='#%24*TMPDIR'>$*TMPDIR</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Name_Services'>Name Services</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#User_role'>User role</a>
    <li class='indexItem indexItem2'><a href='#OS%3A%3AUnix%3A%3AUser_role'>OS::Unix::User role</a>
    <li class='indexItem indexItem2'><a href='#Group_role'>Group role</a>
    <li class='indexItem indexItem2'><a href='#OS%3A%3AUnix%3A%3ANameServices_role'>OS::Unix::NameServices role</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Additions'>Additions</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>DRAFT: Synopsis 16: IO / Name Services</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre><code>Largely, the authors of the related Perl 5 docs.
Larry Wall &#60;larry@wall.org&#62;
Mark Stosberg &#60;mark@summersault.com&#62;
Tim Nelson &#60;wayland@wayland.id.au&#62;
Daniel Ruoso &#60;daniel@ruoso.com&#62;</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre><code>Created: 12 Sep 2006

Last Modified: 19 Nov 2009
Version: 23</code></pre>

<p>This is a draft document. Many of these functions will work as in Perl 5, except we&#39;re trying to rationalize everything into roles. For now you can assume most of the important functions will automatically be in the * namespace. However, with IO operations in particular, many of them are really methods on an IO handle, and if there is a corresponding global function, it&#39;s merely an exported version of the method.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IO"
>IO</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Overridable_IO_handles"
>Overridable IO handles</a></h2>

<p>In Perl 6, there are the <i>standard</i> IO handles, and any number of overriding inner filehandles for the same symbol.</p>

<p>The <i>standard</i> handles are our old familiar friends (with new names). Standard input changed from STDIN to <code>$*IN</code>, standard output changed from STDOUT to <code>$*OUT</code>, and standard error changed from STDERR to <code>$*ERR</code>. In Perl 6 these symbols represent more of a concept than a given filehandle, since the meaning is contextually determined. The process&#39;s version of these handles live in the <code>PROCESS::</code> namespace, which is more global than the per-interpreter <code>GLOBAL::</code> namespace.</p>

<p>When no explicit filehandle is used, the standard IO operators are defined in terms of the dynamic variables. So the <code>print</code> function prints to <code>$*OUT</code>, while <code>warn</code> warns to <code>$*ERR</code>. The <code>lines()</code> term inputs from <code>$*ARGFILES</code> which defaults to <code>$*IN</code> in the absence of any filenames. So any given dynamic scope (interpreter, thread, function or method call) may redefine the current meaning of any of those filehandles within the dynamic scope of itself and of its called routines.</p>

<p>So to put it another way, when you write something like</p>

<pre><code>say &#34;Howdy, world!&#34;</code></pre>

<p>the <code>say</code> function looks for the current meaning of <code>$*OUT</code>, and takes the closest definition it can find in its callers. If none of the callers have overridden the definition, it looks in the interpreter&#39;s <code>GLOBAL</code> namespace. If the interpreter hasn&#39;t overridden the meaning, it takes the meaning from <code>PROCESS</code>. In essence, any dynamic scope in Perl 6 is allowed to do IO redirection much like a Unix shell does with its subprocesses, albeit with a different syntax:</p>

<pre><code>{
    temp $*OUT = open $newfile, :w;
    foo() # all stdout goes to $newfile
}
# stdout reverts to outer scope&#39;s definition</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Roles_and_Classes"
>Roles and Classes</a></h2>

<p>The roles and classes that define most of the functionality for IO are defined in S32-setting-library/IO.pod. The main functions used are listed in S29 with references to S32-setting-library/IO.pod.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Special_Quoting_Syntax"
>Special Quoting Syntax</a></h2>

<p>The use of filenames requires a special quoting syntax. It works as follows:</p>

<pre><code>qp{/path/to/file}
q:p{/path/to/file}</code></pre>

<p>Both of the above result in the same <code>IO::Path</code> object.</p>

<p>The quote characters can be any of the usual ones, although / is probably a bad choice for filenames.</p>

<p>The code shown above returns a Path object (or a descendant thereof).</p>

<p>Naturally you can also ask for interpolation in filenames:</p>

<pre><code>qp:qq{$directory/$file}
qq:p{$directory/$file}</code></pre>

<p>There are a number of special adverbs that can be applied to the file quoting operator. Most of these are filesystem-specific. They confine what can be included in a filename.</p>

<p>Any path that starts with a &#34;/&#34; is considered an absolute path, otherwise the path is considered relative.</p>

<p>When creating a path with qp{}, the Path.Encoding attribute is set to $?ENC, unless the :bin modifier (see below) is used.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Default_constraints"
>Default constraints</a></h3>

<p>The default constraints can be set with the &#34;use path&#34; pragma, for example:</p>

<pre><code>use path :posix;
use path :modern;
use path :local;</code></pre>

<p>The default when in strict mode is &#34;use path :posix&#34;, whereas the default in lax mode is &#34;use path :local&#34;.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=":posix_constraints"
>:posix constraints</a></h3>

<p>The :modern set of constraints paths are portable POSIX paths (see POSIX.1-2008 sections 4.7 and 3.276). If platform/filesystem specific behavior is needed, specific constraints should be applied as needed (see below).</p>

<p>The default constraints are to only allow &#34;/&#34; as separator and only allows portable POSIX filenames. That means A-Z, a-z, 0-9, &#60;period&#62;, &#60;underscore&#62;, and &#60;hyphen&#62;. Additionally, hyphen may not be the first character in the path.</p>

<p>Any path that starts with a &#34;/&#34; is considered an absolute path, otherwise the path is considered relative.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=":portable"
>:portable</a></h3>

<p>In addition to the POSIX constraints above, the path should fit into 8 characters, followed by a full stop, and then three more characters. Only the one full stop should appear in the filename. Additionally, no path may be longer than 64 characters.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=":local"
>:local</a></h3>

<p>This is :win on a Windows platform, :unix on a Unix platform, etc. Note that this is specifically not portable between platforms with different constraint sets.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=":modern_constraints"
>:modern constraints</a></h3>

<p>The :modern set of constraints are the same as :posix, except that they may contain any UTF-8 character, rather than just those listed.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=":win_constraints"
>:win constraints</a></h3>

<p>We allow Windows style paths so converting and maintaining code on this platform is not a pain.</p>

<p>my Path $path = p:win{C:\Program Files\MS Access\file.file};</p>

<p>Note that this specifically excludes the backslash quoting usually used with q{}.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=":unix_constraints"
>:unix constraints</a></h3>

<p>For Unix specific behavior we have a p:unix{} literal. Here the only limits are what is defined by the locale and the filesystem type. So we won&#39;t be able to write full Unicode if locale is set to Latin1.</p>

<p>my Path $path = p:unix{/usr/src/bla/myfile?:%.file};</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name=":bin_constraints_(no_constraints_at_all)"
>:bin constraints (no constraints at all)</a></h3>

<p>If the above are causing problems, p:bin{} can be used as no checking is done here. However, this leaves the Path.Encoding attribute undefined, which means that certain features of Path will remain unavailable unless this attribute is set.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Other_constraints"
>Other constraints</a></h3>

<p>It is expected that other sets of constraints, such as VMS, DOS, and old-style Mac will be provided by modules.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$*CWD"
>$*CWD</a></h2>

<p>The global variable $*CWD is a <code>IO::Path</code> object with certain special properties, mainly:</p>

<pre><code> * It must check whether the path exists before changing its value
 * It can only be assigned an absolute path; if you want to make relative 
   changes, use the Array interface with .push and .pop</code></pre>

<p>$*CWD is specific to the current thread, unlike <code>%*ENV&#60;PATH&#62;</code> or the native getcwd/chdir path, which are both usually process-wide.</p>

<p>The variable is used in at least these cases:</p>

<pre><code> * When a IO::Path object is created, if the string it is given is not an
   absolute path, then $*CWD is prepended to it.
 * When a subprocess is executed, it is executed with the current
   thread&#39;s $*CWD as its working directory.</code></pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$*TMPDIR"
>$*TMPDIR</a></h2>

<p>The global variable $*TMPDIR is an IO::Path object which points to the system&#39;s temporary directory. It will check the usual places such a <code>%*ENV&#60;TMPDIR&#62;</code>, <code>/tmp</code>, <code>C:\Windows\temp</code>, etc (depending on the OS) for a writable directory. If a writable directory isn&#39;t found, it is set to $*CWD.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Name_Services"
>Name Services</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="User_role"
>User role</a></h2>

<pre><code>role User {
    has $username; # Username (some descendants(?) may want to implement a real $name)
    has $id;  # User ID
    has $dir; # Home directory for files
}</code></pre>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code>method User new($Username?, $UID?) {...}</code></pre>

<p>Creates a new User object, fetching the information either by username or user ID.</p>

<dt><a name="write"
>write</a></dt>

<dd>
<pre><code>method write() {...}</code></pre>

<p>Tries to write the current User object to the user database. This may well fail.</p>

<dt><a name="Str"
>Str</a></dt>

<dd>
<p>When converted to a Str, returns $username.</p>

<dt><a name="Num"
>Num</a></dt>

<dd>
<p>When converted to a Num, returns $uid.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="OS::Unix::User_role"
>OS::Unix::User role</a></h2>

<pre><code>role OS::Unix::User does User {
    has $password;
    has $gid;
    has $gecos;
    has $shell;
}</code></pre>

<p>All the information is naturally fetched from the system via getpwuid, getpwnam, or the like.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Group_role"
>Group role</a></h2>

<pre><code>role Group {
    has $name;
    has $id;
    has @members;
}</code></pre>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre><code>method Group new(:$Name, :$ID);</code></pre>

<dt><a name="write"
>write</a></dt>

<dd>
<pre><code>method write();</code></pre>

<p>Tries to write the group entry into the system group database.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="OS::Unix::NameServices_role"
>OS::Unix::NameServices role</a></h2>

<p>The NameServices role has a bunch of functions that between them will return the whole Name Services database between them, as lists of objects. The lists are specifically intended to be lazy.</p>

<pre><code>role NameServices {
    method List of User     users()     {...} # getpwent, setpwent, endpwent
    method List of Group    groups()    {...} # getgrent, setgrent, endgrent
    method List of Service  services()  {...} # getservent, setservent, endservent
    method List of Protocol protocols() {...} # getprotoent, setprotoent, endprotoent
    method List of Network  networks()  {...} # getnetent, setnetent, endnetent
    method List of Host     hosts()     {...} # gethostent, sethostent, endhostent
}</code></pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Additions"
>Additions</a></h1>

<p>Please post errors and feedback to perl6-language. If you are making a general laundry list, please separate messages by topic.</p>

<!-- end doc -->

</body></html>
