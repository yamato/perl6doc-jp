<?xml version="1.0" encoding="UTF-8"?>
<tmx version="1.4">
  <header adminlang="EN-US" creationdate="20140913T125500Z" creationid="yamato" creationtool="XML::TMX::Writer" creationtoolversion="0.25" datatype="plaintext" o-tmf="plain text" segtype="sentence" srclang="EN-US">
  </header>
<body>

<tu>
  <tuv xml:lang="EN-US"><seg>TITLE</seg></tuv>
  <tuv xml:lang="JA"><seg>タイトル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Synopsis 2:</seg></tuv>
  <tuv xml:lang="JA"><seg>概要2：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Bits and Pieces</seg></tuv>
  <tuv xml:lang="JA"><seg>断片</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>AUTHORS</seg></tuv>
  <tuv xml:lang="JA"><seg>著者</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>VERSION</seg></tuv>
  <tuv xml:lang="JA"><seg>バージョン</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This document summarizes Apocalypse 2, which covers small-scale lexical items and typological issues.</seg></tuv>
  <tuv xml:lang="JA"><seg>このドキュメントはApocalypse 2を要約する。そして、それは小規模の語彙項目とタイプの問題を取り上げる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(These Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &amp;quot;historical documents&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>（また、これらのSynopsesは時間とともにPerl 6の進化しているデザインを反映するために最新版を含む。そして、Apocalypsesと違っている。そして、それは史科としてやがて凍結される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.)</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの最新版は記録されない－概要がそのApocalypseと一致しないならば、Synopsisが正しいと仮定しなさい。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>One-pass parsing</seg></tuv>
  <tuv xml:lang="JA"><seg>ワンパス構文解析</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To the extent allowed by sublanguages' parsers, Perl is parsed using a one-pass, predictive parser.</seg></tuv>
  <tuv xml:lang="JA"><seg>部分言語のパーサーによって許される範囲で、Perlはワンパス（予測型構文解析法）を使って解析される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, lookahead of more than one &amp;quot;longest token&amp;quot; is discouraged.</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、複数の「最も長いトークン」の先読みは、認められない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The currently known exceptions to this are where the parser must:</seg></tuv>
  <tuv xml:lang="JA"><seg>構文解析器がそうしなければならない所で、これに対する現在既知の例外はそうである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* Locate the end of interpolated expressions that begin with a sigil and might or might not end with brackets.</seg></tuv>
  <tuv xml:lang="JA"><seg>* シギルから始めて、ブラケットで終わるかもしれないか、終わらないかもしれない差し込まれた表現の終了を見つけなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* Recognize that a reduce operator is not really beginning a [...] composer.</seg></tuv>
  <tuv xml:lang="JA"><seg>* 減少演算子が[...]コンポーザーを本当に開始していないことを認知しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>One-pass parsing is fundamental to knowing exactly which language you are dealing with at any moment, which in turn is fundamental to allowing unambiguous language mutation in any desired direction.</seg></tuv>
  <tuv xml:lang="JA"><seg>ワンパス構文解析はあなたがいつ何時対処しているかについて、正確にわかっていることの基本となる。そして、それはつぎには、何か望ましい方向で明白な言語変化を許すことの基本となる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Generic languages are allowed, but only if intended;</seg></tuv>
  <tuv xml:lang="JA"><seg>（しかし、意図される場合だけ、一般的な言語は許される;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>accidentally generic languages lead to loss of linguistic identity and integrity.</seg></tuv>
  <tuv xml:lang="JA"><seg>偶然に一般的な言語は、結果として言語アイデンティティと完全性の損失に導く。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is the hard lesson of Perl 5's source filters and other multi-pass parsing mistakes.)</seg></tuv>
  <tuv xml:lang="JA"><seg>これは難しいレッスンであるPerl 5が、ソースフィルタである、そして、他のマルチパス構文解析は誤認する。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Lexical Conventions</seg></tuv>
  <tuv xml:lang="JA"><seg>語彙的な規則</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unicode Semantics</seg></tuv>
  <tuv xml:lang="JA"><seg>ユニコード意味論</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In the abstract, Perl is written in Unicode, and has consistent Unicode semantics regardless of the underlying text representations.</seg></tuv>
  <tuv xml:lang="JA"><seg>抽象的に、Perlにはユニコードに書かれて、根底にある文字列内部表現に関係なく一貫したユニコード意味論がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>By default Perl presents Unicode in &amp;quot;NFG&amp;quot; formation, where each grapheme counts as one character.</seg></tuv>
  <tuv xml:lang="JA"><seg>デフォルトで、Perlは「NFG」形成においてユニコードを示す、そこで、各々の書記素は1つの文字と見なされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A grapheme is what the novice user would think of as a character in their normal everyday life, including any diacritics.</seg></tuv>
  <tuv xml:lang="JA"><seg>書記素は、彼らの通常の日常生活（何か発音区別符号を含む）で文字のように、初心者が考えるものである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl can count Unicode line and paragraph separators as line markers, but that behavior had better be configurable so that Perl's idea of line numbers matches what your editor thinks about Unicode lines.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perlはユニコード行とパラグラフセパレーターをラインマーカーとして計算に入れることができる、しかし、行番号についてのPerlの考えがあなたの編集者がユニコード行について考えるものにマッチするように、そのふるまいは可変だった方がよい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unicode horizontal whitespace is counted as whitespace, but it's better not to use thin spaces where they will make adjoining tokens look like a single token.</seg></tuv>
  <tuv xml:lang="JA"><seg>横空白文字がそうであるユニコードは空白文字と見なされた、しかし、それらが隣接しているトークンを単一トークンのように見えさせる薄いスペースを使わない方が良い。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>On the other hand, Perl doesn't use indentation as syntax, so you are free to use any amount of whitespace anywhere that whitespace makes sense.</seg></tuv>
  <tuv xml:lang="JA"><seg>他方、Perlは構文としてインデントを使わないので、あなたはどんなに多くの空白文字でも空白文字が意味をなすどこでも使って結構である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Comments always count as whitespace.</seg></tuv>
  <tuv xml:lang="JA"><seg>コメントは、常に空白文字と見なされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Bracketing Characters</seg></tuv>
  <tuv xml:lang="JA"><seg>文字を括弧に入れること</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For some syntactic purposes, Perl distinguishes bracketing characters from non-bracketing.</seg></tuv>
  <tuv xml:lang="JA"><seg>若干の構文法の目的のために、Perlは非夾叉法から文字を括弧に入れることを識別する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Bracketing characters are defined as any Unicode characters with either bidirectional mirrorings or Ps/Pe/Pi/Pf properties.</seg></tuv>
  <tuv xml:lang="JA"><seg>括弧に入れている文字は、双方向性ミラーリングかPs/Pe/Pi/Pfプロパティによる何かユニコード文字と定義される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In practice, though, you're safest using matching characters with Ps/Pe/Pi/Pf properties, though ASCII angle brackets are a notable exception, since they're bidirectional but not in the Ps/Pe/Pi/Pf sets.</seg></tuv>
  <tuv xml:lang="JA"><seg>実際には、しかし、それらが双方向性であるが、Ps/Pe/Pi/Pfセットでない時から、ASCIIかぎ括弧が顕著な例外であるけれども、あなたはマッチする文字を使用してPs/Pe/Pi/Pfプロパティにとって最も安全である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Characters with no corresponding closing character do not qualify as opening brackets.</seg></tuv>
  <tuv xml:lang="JA"><seg>対応する終わりの文字のない文字は、左大括弧としての資格を得ない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This includes the second section of the Unicode BidiMirroring data table.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、ユニコードBidiMirroringデータテーブルの市場第二部を含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If a character is already used in Ps/Pe/Pi/Pf mappings, then any entry in BidiMirroring is ignored (both forward and backward mappings).</seg></tuv>
  <tuv xml:lang="JA"><seg>文字がPs/Pe/Pi/Pfマッピングですでに使われるならば、BidiMirroringの何かエントリーは無視される（両方のマスト傾斜角マッピング）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For any given Ps character, the next Pe codepoint (in numerical order) is assumed to be its matching character even if that is not what you might guess using left-right symmetry.</seg></tuv>
  <tuv xml:lang="JA"><seg>ピコセカンド文字を与えられる何のためにでも、たとえそれがあなたが左の右対称性を使って推測するかもしれないものでないとしても、次のペーコードポイント（番号順で）はそのマッチする文字であるとされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Therefore U+298D maps to U+298E, not U+2990, and U+298F maps to U+2990, not U+298E.</seg></tuv>
  <tuv xml:lang="JA"><seg>したがって、U+298DはU+2990（U+298Eでない）に、U+298E、U+2990でないとU+298Fマップに写像する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Neither U+298E nor U+2990 are valid bracket openers, despite having reverse mappings in the BidiMirroring table.</seg></tuv>
  <tuv xml:lang="JA"><seg>BidiMirroringテーブルに逆のマッピングを持つことにもかかわらず、U+298EもU+2990も、有効なブラケットオープナーでない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The U+301D codepoint has two closing alternatives, U+301E and U+301F;</seg></tuv>
  <tuv xml:lang="JA"><seg>U+301Dコードポイントは、2つの終わりの選択肢、U+301EとU+301Fを持つ;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 only recognizes the one with lower code point number, U+301E, as the closing brace.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6は、低いコードポイント番号（U+301E）で、一方を右中括弧と認知するだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This policy also applies to new one-to-many mappings introduced in the future.</seg></tuv>
  <tuv xml:lang="JA"><seg>この方針も、将来持ち出される新しい１対多のマッピングにあてはまる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, many-to-one mappings are fine;</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、多対1マッピングはすばらしい;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>multiple opening characters may map to the same closing character.</seg></tuv>
  <tuv xml:lang="JA"><seg>文字が同じ終わりの文字にマップするかもしれない複数の開始。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For instance, U+2018, U+201A, and U+201B may all be used as the opener for the U+2019 closer.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、U+2018、U+201AとU+201Bのすべてが、より近いU+2019のためのオープナーとして使われるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Constructs that count openers and closers assume that only the given opener is special.</seg></tuv>
  <tuv xml:lang="JA"><seg>オープナーとクローザーを数える構成概念は、所定のオープナーだけが特別であると仮定する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, if you open with one of the alternatives, all other alternatives are treated as non-bracketing characters within that construct.</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、あなたが選択肢の1つで始めるならば、他の全ての選択肢はその構成概念の範囲内で文字を非括弧に入れることとみなされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Multiline Comments</seg></tuv>
  <tuv xml:lang="JA"><seg>マルチラインコメント</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Pod sections may be used reliably as multiline comments in Perl 6.</seg></tuv>
  <tuv xml:lang="JA"><seg>ポッドセクションが、Perl 6のマルチラインコメントとして、信頼できるように使われるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unlike in Perl 5, Pod syntax now lets you use =begin comment and =end comment delimit a Pod block correctly without the need for =cut.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 5のとは異なり、ポッド構文は現在あなたに=begin commentを使わせる、そして、=end commentは=cutの正しくポッドブロックを区切る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(In fact, =cut is now gone.) The format name does not have to be comment -- any unrecognized format name will do to make it a comment.</seg></tuv>
  <tuv xml:lang="JA"><seg>フォーマット名はcommentである必要はない（実際、=cutは現在なくなる。）－何か認められていないフォーマット名でもコメントにするために良い。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(However, bare =begin and =end probably aren't good enough, because all comments in them will show up in the formatted output.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（しかし、それらのすべてのコメントが書式付き出力で現れるので、裸の=beginと=endは多分十分によくないだろう。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>We have single paragraph comments with =for comment as well.</seg></tuv>
  <tuv xml:lang="JA"><seg>我々は、同様に=for commentで一回のパラグラフコメントをする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That lets =for keep its meaning as the equivalent of a =begin and =end combined.</seg></tuv>
  <tuv xml:lang="JA"><seg>=beginと=end相当が組み合わさったので、それは=forをその意味を保たせる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As with =begin and =end, a comment started in code reverts to code afterwards.</seg></tuv>
  <tuv xml:lang="JA"><seg>=beginと=endと同様に、暗号で始まるコメントは、その後コードに戻る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since there is a newline before the first =, the Pod form of comment counts as whitespace equivalent to a newline.</seg></tuv>
  <tuv xml:lang="JA"><seg>改行文字が最初の=の前にあるので、コメントのポッドの形態は改行文字への空白文字等価物と見なされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See S26 for more on embedded documentation.</seg></tuv>
  <tuv xml:lang="JA"><seg>埋め込みドキュメンテーションの詳細についてS26を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Single-line Comments</seg></tuv>
  <tuv xml:lang="JA"><seg>１行コメント</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Except within a quote literal, a # character always introduces a comment in Perl 6.</seg></tuv>
  <tuv xml:lang="JA"><seg>文字通りの引用の範囲内であること以外は、#文字は常にPerl 6でコメントを始める。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There are two forms of comment based on #.</seg></tuv>
  <tuv xml:lang="JA"><seg>#に基づくコメントの2つの形が、ある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Embedded comments require the # to be followed by a backtick (`) plus one or more opening bracketing characters.</seg></tuv>
  <tuv xml:lang="JA"><seg>埋め込みコメントは、文字を括弧に入れているbacktick（`）プラス一つ以上の開始が続くことを#に要求する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All other uses of # are interpreted as single-line comments that work just as in Perl 5, starting with a # character and ending at the subsequent newline.</seg></tuv>
  <tuv xml:lang="JA"><seg>#の他の全ての使用はPerl 5の場合のようにちょうど機能する１行コメントと解釈される。そして、#文字から始めて、以降の改行文字のところで終わる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>They count as whitespace equivalent to newline for purposes of separation.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらは、分離のための改行文字への空白文字等価物と見なされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unlike in Perl 5, # may not be used as the delimiter in quoting constructs.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 5のとは異なり、#が、構成物を引合いに出すことでのデリミタとして使われないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Embedded Comments</seg></tuv>
  <tuv xml:lang="JA"><seg>埋め込みコメント</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Embedded comments are supported as a variant on quoting syntax, introduced by #` plus any user-selected bracket characters (as defined in &amp;quot;Bracketing Characters&amp;quot; above):</seg></tuv>
  <tuv xml:lang="JA"><seg>埋め込みコメントは構文を引合いに出すことの変形としてサポートされる。そして、#`さらに何かユーザーを選ばれたブラケット文字（上の文字を括弧に入れる際に定義されるように）によって始められる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Brackets may be nested, following the same policy as ordinary quote brackets.</seg></tuv>
  <tuv xml:lang="JA"><seg>普通の引用が括弧に入れるのと同じ方針の後、ブラケットはネスト状である場合がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There must be no space between the #` and the opening bracket character.</seg></tuv>
  <tuv xml:lang="JA"><seg>#`と左大括弧文字の間の隙間が、あってはならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(There may be the visual appearance of space for some double-wide characters, however, such as the corner quotes above.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（しかし、若干の2倍幅文字のためのスペース（例えば上の角引用）の外観があるかもしれない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For multiline comments it is recommended (but not required) to use two or more brackets both for visual clarity and to avoid relying too much on internal bracket counting heuristics when commenting code that may accidentally miscount single brackets:</seg></tuv>
  <tuv xml:lang="JA"><seg>一つのブラケットを偶然に数え誤るかもしれないコードを注釈するとき、マルチラインコメントのために、それは視覚の明快さのために両方とも複数のブラケットを使って、あまりにたくさん発見的教授法を含む内部のブラケットに頼ることを避けると勧められる（しかし、必要でない）：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, it's sometimes better to use Pod comments because they are implicitly line-oriented.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、それらが暗黙のうちに行を指向するので、ポッドコメントを使うことは、時々よりよい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>User-selected Brackets</seg></tuv>
  <tuv xml:lang="JA"><seg>ユーザーを選ばれたブラケット</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For all quoting constructs that use user-selected brackets, you can open with multiple identical bracket characters, which must be closed by the same number of closing brackets.</seg></tuv>
  <tuv xml:lang="JA"><seg>ユーザーを選ばれたブラケットを使う構成物を引合いに出しているすべてのために、あなたは複数の同一のブラケット文字で始めることができる。そして、それは同じ数の右大括弧によって閉じられなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Counting of nested brackets applies only to pairs of brackets of the same length as the opening brackets:</seg></tuv>
  <tuv xml:lang="JA"><seg>入れ子になったブラケットのカウントは、左大括弧と同じ長さのブラケットの組だけにあてはまる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note however that bare circumfix or postcircumfix &amp;lt;&amp;lt;...&amp;gt;&amp;gt; is not a user-selected bracket, but the ASCII variant of the ≪...≫ interpolating word list.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、裸のcircumfixまたはpostcircumfix &amp;lt;&amp;lt;...&amp;gt;&amp;gt;がユーザーを選ばれたブラケットでなく、ワードリストを改変している≪...≫のASCII変形である点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Only #` and the q-style quoters (including m, s, tr, and rx) enable subsequent user-selected brackets.</seg></tuv>
  <tuv xml:lang="JA"><seg>#`とqスタイルの引用者（m、s、trとrxを含む）だけは、以降のユーザーを選ばれたブラケットを可能にする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unspaces</seg></tuv>
  <tuv xml:lang="JA"><seg>Unspaces</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Some languages such as C allow you to escape newline characters to combine lines.</seg></tuv>
  <tuv xml:lang="JA"><seg>Cのようないくらかの言語は、行を結合するために改行文字をエスケープすることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Other languages (such as regexes) allow you to backslash a space character for various reasons.</seg></tuv>
  <tuv xml:lang="JA"><seg>他の言語（例えば正規表現）は、賛成にいろいろな空白文字が論じるバックスラッシュに、あなたを許す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 generalizes this notion to any kind of whitespace.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6は、この概念をどんな空白文字にでも一般化する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any contiguous whitespace (including comments) may be hidden from the parser by prefixing it with \.</seg></tuv>
  <tuv xml:lang="JA"><seg>何か隣接する空白文字（コメントを含む）は、\でそれを前に置くことによって、構文解析器から隠されるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is known as the &amp;quot;unspace&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、「unspace」として知られている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An unspace can suppress any of several whitespace dependencies in Perl.</seg></tuv>
  <tuv xml:lang="JA"><seg>unspaceは、Perlでいくつかの空白文字依存のどれでも抑制することができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For example, since Perl requires an absence of whitespace between a noun and a postfix operator, using unspace lets you line up postfix operators:</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、Perlが名詞と後置演算子の間で空白文字の欠如を必要とする時から、unspaceを使うことはあなたに後置演算子を一列に並べさせる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As a special case to support the use above, a backslash where a postfix is expected is considered a degenerate form of unspace.</seg></tuv>
  <tuv xml:lang="JA"><seg>上記の使用をサポートする特例として、接尾辞が予想されるバックスラッシュは、unspaceに退歩した形を考えられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that whitespace is not allowed before that, hence</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに、空白文字がそれの前に許されないことに注意すべきである</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>is a syntax error (two terms in a row).</seg></tuv>
  <tuv xml:lang="JA"><seg>構文エラー（列の2つの項）である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>And</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>will be parsed as a list operator with a Capture argument:</seg></tuv>
  <tuv xml:lang="JA"><seg>Capture引数によるリスト演算子として解析される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, other forms of unspace may usefully be preceded by whitespace.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、unspaceの他の形は、有効に空白文字の後にあるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Unary uses of backslash may therefore never be followed by whitespace or they would be taken as an unspace.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（したがって、バックスラッシュを単一体の使う自由の後に空白文字が決して続かないかもしれない、または、それらはunspaceとしてとられる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Other postfix operators may also make use of unspace:</seg></tuv>
  <tuv xml:lang="JA"><seg>他の後置演算子は、unspaceを使用もするかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Another normal use of a you-don't-see-this-space is typically to put a dotted postfix on the next line:</seg></tuv>
  <tuv xml:lang="JA"><seg>you-don't-see-this-spaceのもう一つの通常使用は、一般的に、ドットの接尾辞を次行に置くことである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>But unspace is mainly about language extensibility:</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、unspaceは主に言語拡張性についてある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>it lets you continue the line in any situation where a newline might confuse the parser, regardless of your currently installed parser.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたの現在設置された構文解析器に関係なく、それはあなたに改行文字が構文解析器を混同するかもしれない何か状況で線を続けさせる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Unless, of course, you override the unspace rule itself...)</seg></tuv>
  <tuv xml:lang="JA"><seg>（もちろん、あなたがunspaceルール自体にオーバーライドしない限り、...）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Although we say that the unspace hides the whitespace from the parser, it does not hide whitespace from the lexer.</seg></tuv>
  <tuv xml:lang="JA"><seg>我々がunspaceが空白文字を構文解析器から隠すと言うが、それは空白文字をlexerから隠さない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As a result, unspace is not allowed within a token.</seg></tuv>
  <tuv xml:lang="JA"><seg>その結果、unspaceはトークンの中で許されない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Additionally, line numbers are still counted if the unspace contains one or more newlines.</seg></tuv>
  <tuv xml:lang="JA"><seg>その上、unspaceが一つ以上の改行文字を含むならば、線番号はまだ数えられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since Pod chunks count as whitespace to the language, they are also swallowed up by unspace.</seg></tuv>
  <tuv xml:lang="JA"><seg>ポッド塊が言語への空白文字と見なされるので、それらはunspaceによってものみこまれる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Heredoc boundaries are suppressed, however, so you can split excessively long heredoc intro lines like this:</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、ヒアドキュメント境界線は抑制されるので、あなたはこのように極端に長いヒアドキュメントイントロ行を分割することができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To the heredoc parser that just looks like:</seg></tuv>
  <tuv xml:lang="JA"><seg>ちょうど以下のように見えるヒアドキュメント構文解析器に：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that this is one of those cases in which it is fine to have whitespace before the unspace, since we're only trying to suppress the newline transition, not all whitespace as in the case of postfix parsing.</seg></tuv>
  <tuv xml:lang="JA"><seg>我々が改行文字移行（接尾辞構文解析の場合のようにすべての空白文字でない）を抑制しようとしているだけの時から、これがunspaceの前に空白文字を持つために天気がよいそれらのケースの1つである点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Note also that the example above is not meant to spec how the test suite works.</seg></tuv>
  <tuv xml:lang="JA"><seg>（また、上の例がテストスイートが機能する仕様にとって意味されない点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>) Comments in Unspaces and vice versa</seg></tuv>
  <tuv xml:lang="JA"><seg>）Unspacesで、そして、逆もまた同じコメントする</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An unspace may contain a comment, but a comment may not contain an unspace.</seg></tuv>
  <tuv xml:lang="JA"><seg>unspaceはコメントを含むかもしれない、しかし、コメントはunspaceを含まないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In particular, end-of-line comments do not treat backslash as significant.</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、重要であるように、行末コメントはバックスラッシュを扱わない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you say:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが以下のように言うならば：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>or</seg></tuv>
  <tuv xml:lang="JA"><seg>または、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>it is an end-of-line comment, not an embedded comment.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、行末コメント（埋め込みコメントでない）である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Write:</seg></tuv>
  <tuv xml:lang="JA"><seg>書きなさい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>to mean the other thing.</seg></tuv>
  <tuv xml:lang="JA"><seg>他のものを意味すること。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Optional Whitespace and Exclusions</seg></tuv>
  <tuv xml:lang="JA"><seg>オプションの空白文字と除外</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In general, whitespace is optional in Perl 6 except where it is needed to separate constructs that would be misconstrued as a single token or other syntactic unit.</seg></tuv>
  <tuv xml:lang="JA"><seg>一般に、それが単一トークンまたは他の構文単位として誤解される構成物を切り離すために必要な場合を除き、空白文字はPerl 6でオプションである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(In other words, Perl 6 follows the standard longest-token principle, or in the cases of large constructs, a prefer shifting to reducing principle.</seg></tuv>
  <tuv xml:lang="JA"><seg>（言い換えると、Perl 6は、あるいは、大きな構成概念のケースで、標準的な最も長く形だけの主義に従う。そして、主義を減らすことに変わるのを好みなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See &amp;quot;Grammatical Categories&amp;quot; below for more on how a Perl program is analyzed into tokens.)</seg></tuv>
  <tuv xml:lang="JA"><seg>Perlプログラムがトークンに分析される方法の詳細について、下記の「文法範疇」を見なさい。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is an unchanging deep rule, but the surface ramifications of it change as various operators and macros are added to or removed from the language, which we expect to happen because Perl 6 is designed to be a mutable language.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは変わらない深いルールである、しかし、いろいろな演算子とマクロが言語に加えられるか、それから取り除かれて、それの表面の結果は変わる、そしてそれは、Perl 6が変わりやすい言語であるようになっているので、我々は起こると思っている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In particular, there is a natural conflict between postfix operators and infix operators, either of which may occur after a term.</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、後置演算子と中置演算子の自然な対立がある。そして、そのいずれかが項の後起こる場合がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If a given token may be interpreted as either a postfix operator or an infix operator, the infix operator requires space before it.</seg></tuv>
  <tuv xml:lang="JA"><seg>所定のトークンが後置演算子かインフィックスオペレータと解釈されるならば、インフィックスオペレータはそれの前にスペースを必要とする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Postfix operators may never have intervening space, though they may have an intervening dot.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらが間のドットを持っているかもしれないけれども、後置演算子は間のスペースを決して持っていないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If further separation is desired, an unspace or embedded comment may be used as described above, as long as no whitespace occurs outside the unspace or embedded comment.</seg></tuv>
  <tuv xml:lang="JA"><seg>更なる区切りが要求されるならば、空白文字がunspaceまたは埋め込みコメントの外で起こらない限り、unspaceまたは埋め込みコメントが先に述べたように使われるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For instance, if you were to add your own infix:&amp;lt;++&amp;gt; operator, then it must have space before it.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、あなたがあなた自身のinfix:&amp;lt;++&amp;gt;演算子を加えることになっているならば、それはそれの前にスペースを持っていなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The normal autoincrementing postfix:&amp;lt;++&amp;gt; operator may never have space before it, but may be written in any of these forms:</seg></tuv>
  <tuv xml:lang="JA"><seg>通常のautoincrementingしているpostfix:&amp;lt;++&amp;gt;演算子は、それの前にスペースを決して持っていないかもしれなくて、これらの形の少しも書き込まれるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Implicit Topical Method Calls</seg></tuv>
  <tuv xml:lang="JA"><seg>陰の時事的なメソッドは訪問する</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A consequence of the postfix rule is that (except when delimiting a quote or terminating an unspace) a dot with whitespace in front of it is always considered a method call on $_ where a term is expected.</seg></tuv>
  <tuv xml:lang="JA"><seg>接尾辞支配の結果は、それの前の空白文字による点が項が予想される$_の上のメソッド呼び出しと常に考えられるということで（引用を区切るか、unspaceを終了するとき以外は）ある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If a term is not expected at this point, it is a syntax error.</seg></tuv>
  <tuv xml:lang="JA"><seg>項がこの点で期待されないならば、それは構文エラーである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Unless, of course, there is an infix operator of that name beginning with dot.</seg></tuv>
  <tuv xml:lang="JA"><seg>（もちろん、それの中置演算子がない限り、ドットで始めを挙げなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You could, for instance, define a Fortranly infix: &amp;lt;.EQ.&amp;gt; if the fit took you.</seg></tuv>
  <tuv xml:lang="JA"><seg>合うものがあなたを連れて行くならば、あなたは、たとえば、Fortranlyなinfix: &amp;lt;.EQ.&amp;gt;を定義することができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>But you'll have to be sure to always put whitespace in front of it, or it would be interpreted as a postfix method call instead.)</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、あなたがそれの前に常に空白文字を置くことは確実でなければならない、または、それはその代わりに接尾辞メソッド呼び出しと解釈される。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For example,</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>and</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>will always be interpreted as</seg></tuv>
  <tuv xml:lang="JA"><seg>常に通訳される</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>but never as</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、決してでなく、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use some variant of</seg></tuv>
  <tuv xml:lang="JA"><seg>若干の変形を使いなさい</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>if you mean the postfix method call.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが接尾辞メソッドを意味するならば、電話しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>One consequence of all this is that you may no longer write a Num as 42. with just a trailing dot.</seg></tuv>
  <tuv xml:lang="JA"><seg>こんな1つの結果は、ちょうど後置点による42.としてNumをもはや書かなくてもよいということである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You must instead say either 42 or 42.0.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、42か42.0をその代わりに言わなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In other words, a dot following a number can only be a decimal point if the following character is a digit.</seg></tuv>
  <tuv xml:lang="JA"><seg>言い換えると、以下の文字が桁であるならば、数の後の点は小数点でありえるだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Otherwise the postfix dot will be taken to be the start of some kind of method call syntax.</seg></tuv>
  <tuv xml:lang="JA"><seg>さもなければ、接尾辞点は、何らかのメソッド呼び出し構文の始まりであるとみなされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The .123 form with a leading dot is still allowed however when a term is expected, and is equivalent to 0.123 rather than $_.123.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（項が予想されるとき、先頭のドットによる.123の形はしかしまだ許されて、$_.123よりもむしろ0.123に等しい。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Built-In Data Types</seg></tuv>
  <tuv xml:lang="JA"><seg>組み込みデータ型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 has an optional type system that helps you write safer code that performs better.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6には、あなたがよりよく機能するより安全なコードを書くのに役立つオプションの型システムがある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The compiler is free to infer what type information it can from the types you supply, but it will not complain about missing type information unless you ask it to.</seg></tuv>
  <tuv xml:lang="JA"><seg>コンパイラは何がそれがあなたが供給する型からそうすることができるという情報を入力するかについて推測することができる、しかし、あなたがそれを尋ねない限り、それはなくなった型情報について不満を言わない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 is an OO engine, but you're not generally required to think in OO when that's inconvenient.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6はオブジェクト指向エンジンである、しかし、あなたはそれが不便であるオブジェクト指向で考えることを一般に要求されない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, some built-in concepts such as filehandles are more object-oriented in a user-visible way than in Perl 5.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、ファイルハンドルのような若干のビルトインコンセプトは、Perl 5でよりユーザー見える方法で、オブジェクト指向である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The P6opaque Datatype</seg></tuv>
  <tuv xml:lang="JA"><seg>P6opaqueデータ型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In support of OO encapsulation, there is a new fundamental data representation:</seg></tuv>
  <tuv xml:lang="JA"><seg>オブジェクト指向カプセル化を支持して、新しい基本的なデータ表現がある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>P6opaque.</seg></tuv>
  <tuv xml:lang="JA"><seg>P6opaque。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>External access to opaque objects is always through method calls, even for attributes.</seg></tuv>
  <tuv xml:lang="JA"><seg>属性のためにさえ、不透明オブジェクトへの外部のアクセスは、常にメソッド呼び出しを通してある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Name Equivalence of Types</seg></tuv>
  <tuv xml:lang="JA"><seg>型の名前同値</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Types are officially compared using name equivalence rather than structural equivalence.</seg></tuv>
  <tuv xml:lang="JA"><seg>型は、構造同値よりもむしろ名前同値を使って、表向きは比較される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, we're rather liberal in what we consider a name.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、我々は、名前を何であると考えるかについて、むしろ寛大である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For example, the name includes the version and authority associated with the module defining the type (even if the type itself is &amp;quot;anonymous&amp;quot;).</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、名前はバージョンを含む、そして、権限は型（たとえ型自体が「匿名である」としても）を定義しているモジュールと結びついた。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Beyond that, when you instantiate a parametric type, the arguments are considered part of the &amp;quot;long name&amp;quot; of the resulting type, so one Array of Int is equivalent to another Array of Int.</seg></tuv>
  <tuv xml:lang="JA"><seg>それを越えて、あなたがパラメータの型を具体例をあげて示すとき、引数は結果として生じる型の「長い名前」のよく考えた部分であるので、1つのArray of Intはもう一つのArray of Intに等しい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Another way to look at it is that the type instantiation &amp;quot;factory&amp;quot; is memoized.) Typename aliases are considered equivalent to the original type.</seg></tuv>
  <tuv xml:lang="JA"><seg>Typename別名は、最初の型に等しいと考えられる（それを見るもう一つの方法は、型インスタンス化「ファクトリー」がmemoizedされるということである。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In particular, the Array of Int syntax is just sugar for Array:of(Int), which is the canonical form of an instantiated generic type.</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、Array of Int構文はちょうどArray:of(Int)のためのシュガーである。そして、それは具体例をあげて示された汎用的な型の標準形である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This name equivalence of parametric types extends only to parameters that can be considered immutable (or that at least can have an immutable snapshot taken of them).</seg></tuv>
  <tuv xml:lang="JA"><seg>パラメータの型のこの名前同値は、不変である（または、それは不変のスナップショットをそれらの撮って少なくともおくことができる）と考えられることができるパラメータだけに及ぶ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Two distinct classes are never considered equivalent even if they have the same attributes because classes are not considered immutable.</seg></tuv>
  <tuv xml:lang="JA"><seg>クラスが不変であると考えられないのでたとえそれらには同じ属性があるとしても、2つの異なったクラスは等しいと決して考えられない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Properties on Objects</seg></tuv>
  <tuv xml:lang="JA"><seg>オブジェクトのプロパティ</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 supports the notion of properties on various kinds of objects.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6は、いろいろなオブジェクトでプロパティの概念をサポートする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Properties are like object attributes, except that they're managed by the individual object rather than by the object's class.</seg></tuv>
  <tuv xml:lang="JA"><seg>プロパティはオブジェクト属性のようであるが、それらはオブジェクトのクラスによってよりもむしろ個々のオブジェクトによって管理される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>According to S12, properties are actually implemented by a kind of mixin mechanism, and such mixins are accomplished by the generation of an individual anonymous class for the object (unless an identical anonymous class already exists and can safely be shared).</seg></tuv>
  <tuv xml:lang="JA"><seg>S12によると、プロパティは実は一種のミキシンメカニズムで実装される、そして、そのようなミキシンはオブジェクト（同一の匿名のクラスがすでに存在して、問題なく共有されることができない限り）のために個々の匿名のクラスの生成によって達成される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Traits</seg></tuv>
  <tuv xml:lang="JA"><seg>トレイト</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Properties applied to objects constructed at compile-time, such as variables and classes, are also called traits.</seg></tuv>
  <tuv xml:lang="JA"><seg>コンパイル時（例えば変数とクラス）で造られるオブジェクトに適用されるプロパティは、トレイトとも呼ばれている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Traits cannot be changed at run-time.</seg></tuv>
  <tuv xml:lang="JA"><seg>トレイトは、実行時で変わることができない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Changes to run-time properties are done via mixin instead, so that the compiler can optimize based on declared traits.</seg></tuv>
  <tuv xml:lang="JA"><seg>実行時プロパティへの変化はその代わりにミキシンを通してされる、そのため、コンパイラはに基づく宣言されたトレイトを最適化することができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Types as Constraints</seg></tuv>
  <tuv xml:lang="JA"><seg>制約としての型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A variable's type is a constraint indicating what sorts of values the variable may contain.</seg></tuv>
  <tuv xml:lang="JA"><seg>変数の型は、変数がどんな種類の値を含むかもしれないかについて示している制約である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>More precisely, it's a promise that the object or objects contained in the variable are capable of responding to the methods of the indicated &amp;quot;role&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>より正確に、変数に含まれるオブジェクトまたはオブジェクトが示された「ロール」のメソッドに反応することができることは、約束である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See S12 for more about roles.</seg></tuv>
  <tuv xml:lang="JA"><seg>ロールについてより多くについてはS12を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Container Types</seg></tuv>
  <tuv xml:lang="JA"><seg>コンテナ型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A variable may itself be bound to a container type that specifies how the container works, without specifying what kinds of things it contains.</seg></tuv>
  <tuv xml:lang="JA"><seg>それがどんな種類のものを含むか指定することなく、変数はそれ自体コンテナがどのように動くかについて指定するコンテナ型の束縛を受ける場合がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Constraints and container types can be used together:</seg></tuv>
  <tuv xml:lang="JA"><seg>制約とコンテナ型が、一緒に使われることができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that $x is also initialized to the Int type object.</seg></tuv>
  <tuv xml:lang="JA"><seg>$xがIntタイプオブジェクトにも初期化されることに注意すべきである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See below for more on this.</seg></tuv>
  <tuv xml:lang="JA"><seg>これの詳細について下記を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Nil</seg></tuv>
  <tuv xml:lang="JA"><seg>Nil</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is a special value named Nil.</seg></tuv>
  <tuv xml:lang="JA"><seg>Nilという名前をつけられる特殊値が、ある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It means &amp;quot;there is no value here&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、「値が、ここにない」ことを意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is a little bit like the empty () list, insofar as both represent an absence of values, except that () is defined and means &amp;quot;there are 0 arguments here if you're counting that low&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>両方とも値の欠如を表現する限り、それは少し空の()リストのようであるが、()は定義される、そして、あなたが低くそれを数えているならば、そこの手段はここの0の引数である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Nil value represents the absence of a value where there should be one, so it does not disappear in list context, but relies on something downstream to catch it or blow up.</seg></tuv>
  <tuv xml:lang="JA"><seg>Nil値は人がいなければならない値の欠如を表現するので、それはリストコンテキストで消えなくて、それを捕えるか、爆発するために下流の何かに頼る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Nil also indicates a failed match.</seg></tuv>
  <tuv xml:lang="JA"><seg>Nilも、失敗したマッチを示す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since method calls are performed directly on any object, Nil can respond to certain method calls.</seg></tuv>
  <tuv xml:lang="JA"><seg>メソッド呼び出しが何かオブジェクトで直接実行される時から、Nilは特定のメソッド呼び出しに応じることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Nil.defined returns False (whereas ().defined returns True).</seg></tuv>
  <tuv xml:lang="JA"><seg>Nil.defined収益False（ところが、().defined収益True）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Nil.so also returns False.</seg></tuv>
  <tuv xml:lang="JA"><seg>Nil.soも、Falseを返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Nil.ACCEPTS always returns Nil.</seg></tuv>
  <tuv xml:lang="JA"><seg>Nil.ACCEPTSは、常にNilを返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Nil.perl and Nil.gist return 'Nil'.</seg></tuv>
  <tuv xml:lang="JA"><seg>Nil.perlとNil.gistは、'Nil'を返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Nil.Stringy and Nil.Str throw a resumable warning that returns a value of '' on resumption.</seg></tuv>
  <tuv xml:lang="JA"><seg>Nil.StringyとNil.Strは、再開に関して''の値を返るresumableな警告を投げる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Nil.Numeric likewise throws a resumable warning that returns 0 on resumption.</seg></tuv>
  <tuv xml:lang="JA"><seg>Nil.Numericは、resumableな警告に再開のその収益0を同様に投げる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any undefined method call on Nil returns Nil, so that Nil propagates down method call chains.</seg></tuv>
  <tuv xml:lang="JA"><seg>Nilの上の何か未定義メソッド呼び出しはNilを返る、そのため、Nilは下のメソッド呼び出しチェーンを伝達する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Likewise any subscripting operation on Nil returns Nil.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、Nilの上の何か添え字付け演算は、Nilを返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Assigning Nil to any scalar container causes the container to throw out any contents and restore itself to an uninitialized state (after which it will appear to contain an object appropriate to the declared default of the container, where Any is the default default;</seg></tuv>
  <tuv xml:lang="JA"><seg>Nilを何かスカラーコンテナに割り当てることは、コンテナが何か内容を投げ出して、それ自体を初期化されていない州に戻す原因になる（コンテナ（Anyはデフォルトデフォルトである）の宣言されたデフォルトにオブジェクト適正を含むことがどれのように見えるか;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>the element may be simply deleted if that's how the default can be represented in the structure).</seg></tuv>
  <tuv xml:lang="JA"><seg>それがデフォルトが構造で表現されることができる方法であるならば、要素は単にアンインストール済みである場合がある）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Binding of Nil with := simply puts Nil in the container.</seg></tuv>
  <tuv xml:lang="JA"><seg>:=によるNilのバインディングは、単にNilをコンテナに入れる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, binding Nil to a parameter (::= semantics) works more like assignment;</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、パラメータ（::=意味論）へのバインディングNilは、割当てのようにより動く;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>passing Nil to a parameter with a default causes that parameter to be set to its default value rather than an undefined value, as if the argument had not been supplied.</seg></tuv>
  <tuv xml:lang="JA"><seg>まるで引数が供給されなかったように、デフォルトによるパラメータへの一時的なNilはそのパラメータが未定義値よりもむしろそのデフォルト値に設定される原因になる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Assigning Nil to any entire composite container (such as an Array or Hash) empties the container, resetting it back to an uninitialized state.</seg></tuv>
  <tuv xml:lang="JA"><seg>Nilを何か全ての複合コンテナ（例えばArrayまたはHash）に割り当てることはコンテナを空にする。そして、初期化されていない州へそれをリセットする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The container object itself then becomes undefined.</seg></tuv>
  <tuv xml:lang="JA"><seg>それから、コンテナオブジェクトそのものは、未定義になる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Assignment of () leaves it defined.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（()の割当てはそれを定義されるままにしておく。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Type Objects</seg></tuv>
  <tuv xml:lang="JA"><seg>型オブジェクト</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>my Dog $spot by itself does not automatically call a Dog constructor.</seg></tuv>
  <tuv xml:lang="JA"><seg>my Dog $spotは、Dogコンストラクタを単独で自動的に呼ばない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It merely assigns an undefined Dog prototype object to $spot:</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、単に未定義Dogプロトタイプオブジェクトを$spotに割り当てるだけである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any type name used as a value is the undefined prototype object of that type, or type object for short.</seg></tuv>
  <tuv xml:lang="JA"><seg>値として使われる任意型名は、その型の未定義プロトタイプオブジェクトまたは略して型オブジェクトである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See S12 for more on that.</seg></tuv>
  <tuv xml:lang="JA"><seg>それの詳細についてS12を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any type name in rvalue context is parsed as a single type value and expects no arguments following it.</seg></tuv>
  <tuv xml:lang="JA"><seg>rvalue前後関係の任意型名は、シングル式値として解析されて、それの後、引数を予想しない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, a type object responds to the function call interface, so you may use the name of a type with parentheses as if it were a function, and any argument supplied to the call is coerced to the type indicated by the type object.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、型オブジェクトは関数呼出しインタフェースに反応するので、まるでそれが関数であるように、あなたは括弧で型の名前を使用するかもしれない、そして、呼び出しに供給される何か引数は型オブジェクトによって示される型に強制される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If there is no argument in the parentheses, the type object returns itself:</seg></tuv>
  <tuv xml:lang="JA"><seg>引数が括弧でないならば、型オブジェクトはそれ自体返る：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To get a real Dog object, call a constructor method such as new:</seg></tuv>
  <tuv xml:lang="JA"><seg>本当のDogオブジェクトを得て、newのようなコンストラクタメソッドを呼ぶこと：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You can pass in arguments to the constructor as well:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、同様にコンストラクタに引数を渡すことができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Just like &amp;quot;Nil&amp;quot;, type objects do not disappear in list context, but rely on something downstream to catch it or blow up.</seg></tuv>
  <tuv xml:lang="JA"><seg>ちょうど&amp;quot;Nil&amp;quot;のように、型オブジェクトはリストコンテキストで消えなくて、それを捕えるか、爆発するために、下流の何かに頼る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This allows type objects to be assigned to scalars, but to disappear in non-scalar contexts.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、型オブジェクトがスカラーに割り当てられるが、非スカラーコンテキストで消えるのを許可する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Coercive type declarations</seg></tuv>
  <tuv xml:lang="JA"><seg>強制的な型宣言</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The parenthesized form of type coercion may be used in declarations where it makes sense to accept a wider set of types but coerce them to a narrow type.</seg></tuv>
  <tuv xml:lang="JA"><seg>型強制の括弧に入れられた形が、型のより広いセットを受け入れるが、狭い型にそれらを強制することが意味をなす宣言において使われるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(This only works for one-way coercion, so you may not declare any rw parameter with a coercive type.) The type outside the parens indicates the desired end result, and subsequent code may depend on it being that type.</seg></tuv>
  <tuv xml:lang="JA"><seg>括弧の外の型は望ましい結果を示す（これは一方向だけの強制のために動くだけであるので、何も強制的な型によるrwパラメータと宣言しなくてもよい。）、そして、以降のコードはそれの上でその型であること次第かもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The type inside the parens indicates the acceptable set of types that are allowed to be bound or assigned to this location via coercion.</seg></tuv>
  <tuv xml:lang="JA"><seg>括弧の中の型は、結びつけられるか、強制を通してこの場所に割り当てさせられておかれる型の許容できるセットを示す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the wide type is omitted, Any is assumed.</seg></tuv>
  <tuv xml:lang="JA"><seg>広い型が省略されるならば、Anyは装われる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In any case, the wide type is only indicative of permission to coerce;</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれにせよ、広い型は、強制する許可を示すだけである;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>there must still be an available coercion routine from the wide type to the narrow type to actually perform the coercion.</seg></tuv>
  <tuv xml:lang="JA"><seg>利用できる強制ルーチンが、実際に強制を実行するために、まだ広い型から狭い型までなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Coercions may also be specified on the return type:</seg></tuv>
  <tuv xml:lang="JA"><seg>コアーションは、戻り型の上で指定されもするかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Containers of Native Types</seg></tuv>
  <tuv xml:lang="JA"><seg>ネイティブ型のコンテナ</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you say</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが言うならば、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>you are declaring that the elements of @array are native integers, but that the array itself is implemented by the MyArray class.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、@arrayの要素がネイティブ整数である、しかし、配列自体がMyArrayクラスによって実装されると断言している。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Untyped arrays and hashes are still perfectly acceptable, but have the same performance issues they have in Perl 5.</seg></tuv>
  <tuv xml:lang="JA"><seg>Untyped配列とハッシュには、まだ完全に許容できるが、それらにはPerl 5である同じ性能の問題がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Methods on Arrays</seg></tuv>
  <tuv xml:lang="JA"><seg>配列の上のメソッド</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To get the number of elements in an array, use the .elems method.</seg></tuv>
  <tuv xml:lang="JA"><seg>配列で要素数を得るために、.elemsメソッドを使用しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You can also ask for the total string length of an array's elements, in codepoints or graphemes, using these methods, .codes or .graphs respectively on the array.</seg></tuv>
  <tuv xml:lang="JA"><seg>コードポイントまたは書記素で、あなたは配列の要素の総ストリング長を求めることもできる。そして、配列の上でそれぞれこれらのメソッド、.codesまたは.graphsを使う。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The same methods apply to strings as well.</seg></tuv>
  <tuv xml:lang="JA"><seg>同法は、同様に文字列にあてはまる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Note that .codes is not well-defined unless you know which canonicalization is in effect.</seg></tuv>
  <tuv xml:lang="JA"><seg>（あなたがどの標準化が活動中かについてわからない限り、.codesがはっきりしていないことに注意すべきである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hence, it allows an optional argument to specify the meaning exactly if it cannot be known from context.)</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに、必ずしも前後関係からはわかることができないならば、それは任意の引数を意味を指定させる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is no .length method for either arrays or strings, because length does not specify a unit.</seg></tuv>
  <tuv xml:lang="JA"><seg>lengthが単位を指定しないので、.lengthメソッドがどちらの配列または文字列のためにもない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Built-in Type Conventions</seg></tuv>
  <tuv xml:lang="JA"><seg>組込み型規則</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Built-in object types start with an uppercase letter.</seg></tuv>
  <tuv xml:lang="JA"><seg>ビルトインオブジェクトタイプは、大文字から始める。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This includes immutable types (e.g. Int, Num, Complex, Rat, Str, Bit, Regex, Set, Block, Iterator), as well as mutable (container) types, such as Scalar, Array, Hash, Buf, Routine, Module, and non-instantiable Roles such as Callable and Integral.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、不変の型（例えばInt、Num、Complex、Rat、Str、Bit、Regex、Set、Block、Iterator）ならびに変わりやすい（コンテナ）型（例えばScalar、Array、Hash、Buf、Routine、Moduleと非instantiableなロール（例えばCallableとIntegral））を含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Non-object (native) types are lowercase:</seg></tuv>
  <tuv xml:lang="JA"><seg>型がそうである非オブジェクト（ネイティブ）は、以下を小文字にする：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>int, num, complex, rat, buf, bit.</seg></tuv>
  <tuv xml:lang="JA"><seg>int、num、complex、rat、buf、bit。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Native types are primarily intended for declaring compact array storage, that is, a sequence of storage locations of the specified type laid out in memory contiguously without pointer indirection.</seg></tuv>
  <tuv xml:lang="JA"><seg>ネイティブ型は、主にコンパクトな配列記憶領域（つまり、ポインター間接的行動なしで隣接してメモリで配置される指定された型の一連の記憶場所）を宣言することを意図される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, Perl will try to make those look like their corresponding uppercase types if you treat them that way.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、あなたがそのようにそれらを扱うならば、Perlはそれらを彼らの対応する大文字の型のように見えさせようとする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(In other words, it does autoboxing and autounboxing as necessary.</seg></tuv>
  <tuv xml:lang="JA"><seg>（言い換えると、それは、autoboxingして、必要に応じてautounboxingすることをする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note, however, that repeated autoboxing and unboxing can make your program much slower, compared to a program that makes consistent use of either native types or object types.)</seg></tuv>
  <tuv xml:lang="JA"><seg>なお、しかし、それはautoboxingすることを繰り返した、そして、ネイティブ型かオブジェクトタイプを一貫して利用するプログラムと比較して、箱から出すことはあなたのプログラムを非常により遅くすることができる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The .WHICH Method for Value Types</seg></tuv>
  <tuv xml:lang="JA"><seg>値型のための.WHICHメソッド</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Some object types can behave as value types.</seg></tuv>
  <tuv xml:lang="JA"><seg>若干のオブジェクトタイプは、値型としてふるまうことができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Every object can produce a &amp;quot;WHICH&amp;quot; value that uniquely identifies the object for hashing and other value-based comparisons.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべてのオブジェクトは、ハッシュと他の値ベースの比較のためにオブジェクトをユニークに識別する&amp;quot;WHICH&amp;quot;値を生じることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Normal objects just use their location as their identity, but if a class wishes to behave as a value type, it can define a .WHICH method that makes different objects look like the same object if they happen to have the same contents.</seg></tuv>
  <tuv xml:lang="JA"><seg>通常のオブジェクトはちょうど彼らのアイデンティティとして彼らの場所を使う、しかし、クラスが値型としてふるまうことを望むならば、それはそれらが偶然同じ内容を持っていることが起こるならば、異なるオブジェクトを同じオブジェクトのように見えさせる.WHICHメソッドを定義することができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The ObjAt Type</seg></tuv>
  <tuv xml:lang="JA"><seg>ObjAt型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When we say that a normal object uses its location as its identity, we do not mean that it returns its address as a number.</seg></tuv>
  <tuv xml:lang="JA"><seg>通常のオブジェクトがそのアイデンティティとしてその場所を使うと言うとき、我々はそれが数としてアドレスを返ると言っていない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In the first place, not all objects are in the same memory space (see the literature on NUMA, for instance), and two objects should not accidentally have the same identity merely because they were stored at the same offset in two different memory spaces.</seg></tuv>
  <tuv xml:lang="JA"><seg>第一に、すべてのオブジェクトが同じメモリ空間（たとえば、NUMAについての文献を見る）にあるというわけではない、そして、単にそれらが2つの異なるメモリ空間に同じオフセットで保存されたのでだけ、2つのオブジェクトには同じアイデンティティが偶然にあってはならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>We also do not want to allow accidental identity collisions with values that really are numbers (or strings, or any other mundane value type).</seg></tuv>
  <tuv xml:lang="JA"><seg>我々も、本当に数（または文字列または少しも他のありふれた値型）である値との偶発的なアイデンティティ衝突を許したくない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Nor should we be encouraging people to think of object locations that way in any case.</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、我々は人々がいずれにせよそのようにオブジェクト場所について考えるのを奨励していてはならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>So WHICH still returns a value rather than another object, but that value must be of a special ObjAt type that prevents accidental confusion with normal value types, and at least discourages trivial pointer arithmetic.</seg></tuv>
  <tuv xml:lang="JA"><seg>WHICHがまだ返るように、もう一つのオブジェクトよりもむしろ値はその値以外の通常の値型の偶然の混同を防ぐ特別なObjAt型でなければならなくて、少なくとも取るに足らないポインターの算術演算をはばむ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Certainly, it is difficult to give a unique name to every possible address space, let alone every possible address within every such a space.</seg></tuv>
  <tuv xml:lang="JA"><seg>確かに、それはすべてのあり得るアドレス空間に固有の名に与えるのが難しくて、される単独であり得るアドレスそのようなすべてのスペース。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In the absence of a universal naming scheme, it can only be made improbable that two addresses from two different spaces will collide.</seg></tuv>
  <tuv xml:lang="JA"><seg>一般的な命名スキームがない場合、2つの異なるスペースからの2アドレスが衝突することは、ありそうもなくなることができるだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A sufficiently large random number may represent the current address space on output of an ObjAt to a different address space, or if serialized to YAML or XML.</seg></tuv>
  <tuv xml:lang="JA"><seg>異なるアドレス空間にとって、または、YAMLまたはXMLに順番に並べられるならば、十分に大きな乱数はObjAtの出力の上で現在のアドレス空間を表現するかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(This extra identity component need not be output for debugging messages that assume the current address space, since it will be the same big number consistently, unless your process really is running under a NUMA.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（それが一貫して同じ大きい数である時から、この余分の単位元成分はあなたのプロセスがNUMAの下で本当に動作しない限り、現在のアドレス空間を引き受けるメッセージをデバッグするための出力である必要はない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Alternately, if an object is being serialized to a form that does not preserve object identity, there is no requirement to preserve uniqueness, since in this case the object is really being translated to a value type representation, and reconstituted on the other end as a different unique object.</seg></tuv>
  <tuv xml:lang="JA"><seg>あるいは、オブジェクトがオブジェクト識別性を保たない形に順番に並べられているならば、本例でオブジェクトが本当に値タイプ代表に変形されていて、異なる独特のオブジェクトとして反対側で再構成されている時から、ユニークさを保存する必要性がない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Variables Containing Undefined Values</seg></tuv>
  <tuv xml:lang="JA"><seg>未定義値を含んでいる変数</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A variable with a non-native type constraint may contain an undefined value such as a type object, provided the undefined value meets the type constraint.</seg></tuv>
  <tuv xml:lang="JA"><seg>未定義値が型制約に直面するならば、ネイティブでない型制約による変数は型オブジェクトのような未定義値を含むかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Variables with native types do not support undefinedness:</seg></tuv>
  <tuv xml:lang="JA"><seg>ネイティブ型による変数は、未定義をサポートしない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>it is an error to assign an undefined value to them:</seg></tuv>
  <tuv xml:lang="JA"><seg>未定義値をそれらに割り当てることは、エラーである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since num can support the value NaN but not the general concept of undefinedness, you can coerce an undefined value like this:</seg></tuv>
  <tuv xml:lang="JA"><seg>numが未定義の一般概念でなく値NaNをサポートすることができるので、あなたはこのように未定義値を強制することができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Variables of non-native types start out containing a type object of the appropriate type unless explicitly initialized to a defined value.</seg></tuv>
  <tuv xml:lang="JA"><seg>はっきりと定義済み値に初期化されない限り、ネイティブでない型の変数は適正型の型オブジェクトを含んで始める。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any container's default may be overridden by the is default(VALUE) trait.</seg></tuv>
  <tuv xml:lang="JA"><seg>何かコンテナのデフォルトは、is default(VALUE)トレイトによってオーバーライドされるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the container's contents are deleted, the value is notionally set to the provided default value;</seg></tuv>
  <tuv xml:lang="JA"><seg>コンテナの内容がアンインストール済みであるならば、値は提供されたデフォルト値に抽象的にセットされる;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>this value may or may not be physically represented in memory, depending on the implementation of the container.</seg></tuv>
  <tuv xml:lang="JA"><seg>コンテナの実装に従い、この値は、メモリで物理的に表現されるかもしれないか、表現されないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You should officially not care about that (much).</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、それ（非常に）が公式に好きであるべきでない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The HOW Method</seg></tuv>
  <tuv xml:lang="JA"><seg>HOWメソッド</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Every object supports a HOW function/method that returns the metaclass instance managing it, regardless of whether the object is defined:</seg></tuv>
  <tuv xml:lang="JA"><seg>オブジェクトが定義されるか否かを問わず、すべてのオブジェクトはそれを管理しているメタクラスインスタンスを返るHOW関数/メソッドをサポートする：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(For a prototype system (a non-class-based object system), all objects are merely managed by the same meta object.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（プロトタイプシステム（非クラスベースオブジェクトシステム）については、すべてのオブジェクトは単に同じメタオブジェクトによって管理されるだけである。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Roles</seg></tuv>
  <tuv xml:lang="JA"><seg>ロール</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl supports generic types through what are called &amp;quot;roles&amp;quot; which represent capabilities or interfaces.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perlは、機能またはインターフェースを表現する「ロール」と呼ばれていることを通して、汎用的な型をサポートする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These roles are generally not used directly as object types.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらのロールが、通常、オブジェクトタイプとして直接使われない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For instance all the numeric types perform the Numeric role, and all string types perform the Stringy role, but there's no such thing as a &amp;quot;Numeric&amp;quot; object, since these are generic types that must be instantiated with extra arguments to produce normal object types.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、すべての数値型はNumericロールを実行する、そして、すべての文字列型はStringyロールを実行する、しかし、これらが通常のオブジェクトタイプを生じるために余分の引数で具体例をあげて示されなければならない汎用的な型である時から、&amp;quot;Numeric&amp;quot;オブジェクトなんてものがない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Common roles include:</seg></tuv>
  <tuv xml:lang="JA"><seg>一般のロールは以下を含む：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Numeric Types</seg></tuv>
  <tuv xml:lang="JA"><seg>Numeric型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 intrinsically supports big integers and rationals through its system of type declarations.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6は、型宣言のそのシステムによって、大きい整数と有理数を本質的にサポートする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Int automatically supports promotion to arbitrary precision, as well as holding Inf and NaN values. Note that Int assumes 2's complement arithmetic, so +^1 == -2 is guaranteed.</seg></tuv>
  <tuv xml:lang="JA"><seg>Intは随意精度（現状維持のInfとNaN値だけでなく）に昇進を自動的にサポートする。Intが2の補数を算数とみなすことに注意すべきであるので、+^1 == -2は保証される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Native int operations need not support this on machines that are not natively 2's complement.</seg></tuv>
  <tuv xml:lang="JA"><seg>（ネイティブint演算は、最適化されて2の補数でない機械で、これをサポートする必要はない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You must convert to and from Int to do portable bitops on such ancient hardware.)</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、そのような古代のハードウェアの上で携帯型ビット演算をするために、Intへ／から変わらなければならない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Num must support the largest native floating point format that runs at full speed.</seg></tuv>
  <tuv xml:lang="JA"><seg>Numは、フルスピードで走る最大のネイティブ浮動小数点フォーマットをサポートしなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It may be bound to an arbitrary precision type, but by default it is the same type as a native num.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは随意精度型の束縛を受ける場合がある、しかし、デフォルトで、それはネイティブnumと同じ型である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See below.</seg></tuv>
  <tuv xml:lang="JA"><seg>下記参照。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Rat supports extended precision rational arithmetic.</seg></tuv>
  <tuv xml:lang="JA"><seg>Ratは、拡張精度有理数演算をサポートする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Dividing two Integral objects using infix:&amp;lt;/&amp;gt; produces a Rat, which is generally usable anywhere a Num is usable, but may also be explicitly cast to Num.</seg></tuv>
  <tuv xml:lang="JA"><seg>2つのIntegralを分けることはinfix:&amp;lt;/&amp;gt;を使うことがRatを生じると反対する、通常、どこでも使える。そして、Numは使えるが、Numにもはっきりと投げられるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Also, if either side is Num already, infix:&amp;lt;/&amp;gt; gives you a Num instead of a Rat.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（また、どちらの側でもすでにNumであるならば、infix:&amp;lt;/&amp;gt;はRatの代わりにあなたにNumを与える。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Rat and Num both do the Real role.</seg></tuv>
  <tuv xml:lang="JA"><seg>RatとNumは、Realロールを両方ともする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Lowercase types like int and num imply the native machine representation for integers and floating-point numbers, respectively, and do not promote to arbitrary precision, though larger representations are always allowed for temporary values.</seg></tuv>
  <tuv xml:lang="JA"><seg>小文字の型はintに合う、そして、より大きな表現が常にテンポラリー値のために許されるけれども、numは、それぞれ、整数と浮動小数点数のために在来マシン代表を意味して、随意精度に昇進させない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unless qualified with a number of bits, int and num types represent the largest native integer and floating-point types that run at full speed.</seg></tuv>
  <tuv xml:lang="JA"><seg>いくつかのビットで制限されない限り、intとnum型は最大のネイティブ整数を表現する、そして、浮動小数点はフルスピードでその実行を入力する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Because temporary values are biased in favor of correct semantics over compact storage, native numeric operators that might overflow must come in two variants, one which returns a guaranteed correct boxed value, and one of which returns a guaranteed fast native value.</seg></tuv>
  <tuv xml:lang="JA"><seg>テンポラリー値が集密書庫の上に正しい意味論に賛成して偏るので、あふれるかもしれないネイティブ算術演算子は2つの変形、保証された正しい箱入り値を返るものと保証された速いネイティブ値が返る一つで来なければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>By default the boxing variant is selected (probably by virtue of hiding the native variants), but within a given lexical scope, the use native pragma will allow use of the dangerous but fast variants instead.</seg></tuv>
  <tuv xml:lang="JA"><seg>デフォルトで、ボクシング変形は選ばれる（おそらくネイティブ変形を隠すことによって）、しかし、所定のレキシカルスコープの中で、use nativeプラグマはその代わりに危険であるが、速い変形の使用を許す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Arguments to the pragma can be more specific about what types of return values are allowed, e.g. use native 'int'; and such.</seg></tuv>
  <tuv xml:lang="JA"><seg>プラグマへの引数は、どんな型の戻り値が許されるか（例えばuse native 'int'; その他）について、よりはっきりしていることがありえる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The optimizer is also allowed to substitute such variants when it can determine that the final destination would store natively in any case, or that the variant could not possibly malfunction given the arguments.) [Conjecture: we could allow an 'N' metoperator to select the native variant on a case by case basis.]</seg></tuv>
  <tuv xml:lang="JA"><seg>（オプティマイザーはそれが最終仕向け地がいずれにせよ最適化されて保存する、または、変形が引数を与えられておそらく故障することができなかったと決定することができるそのような変形を代えるのも許される。）［推測する：我々は'N'メタ演算子にケースの基礎によってケースに関してネイティブ変形を選ばせておくことができた。］</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Numeric values in untyped variables use Int and Num semantics rather than int and num.</seg></tuv>
  <tuv xml:lang="JA"><seg>untypedされた変数の数値は、intとnumよりもむしろIntとNum意味論を使う。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Literals, on the other hand, may default to native storage formats if they reasonably can.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらが合理的にそうすることができるならば、リテラルは、他方、ネイティブ記憶領域フォーマットにデフォルトでなるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>We rely on the semantics of boxing temporary values by default (see above) to maintain correct semantics;</seg></tuv>
  <tuv xml:lang="JA"><seg>我々は、正しい意味論を維持するために、デフォルトでボクシングテンポラリー値の意味論に頼る（上記参照）;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>the optimizer is of course allowed to box or unbox a literal at compile time (or cache a boxed/unboxed version of the value) whenever it seems appropriate.</seg></tuv>
  <tuv xml:lang="JA"><seg>それが適正のようなときはいつでも、オプティマイザーはボクシングをするか、コンパイル時（または、値の箱入り/箱から出されたバージョンを貯蔵する）でリテラルを箱から出すのをもちろん許される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In any case, native literals should be preferred under use native semantics.</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれにせよ、ネイティブリテラルは、use native意味論の下で好まれなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For pragmatic reasons, Rat values are guaranteed to be exact only up to a certain point.</seg></tuv>
  <tuv xml:lang="JA"><seg>実際的な理由で、値が確信してだけまで厳密に言えば、保証されるRatは、ポイントする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>By default, this is the precision that would be represented by the Rat64 type, which is an alias for Rational[Int,Uint64], which has a numerator of Int but is limited to a denominator of Uint64 (which may or may not be implemented as a native uint64, since small representations may be desirable for small denominators).</seg></tuv>
  <tuv xml:lang="JA"><seg>デフォルトで、これはRat64型によって表現される精度である。そして、それはRational[Int,Uint64]の別名である。そして、それはIntの分子を持つが、Uint64（小さな表現が少ない分母のために望ましい時から、ネイティブuint64として実装されるかもしれないか、実装されないかもしれない）の分母に限られている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A Rat64 that would require more than 64 bits of storage in the denominator is automatically converted either to a Num or to a lesser-precision Rat, at the discretion of the implementation.</seg></tuv>
  <tuv xml:lang="JA"><seg>実装の意のままで、分母で64ビット以上の記憶領域を必要とするRat64は、Numに、または、より小さい精度Ratに自動的に変わる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Native types such as rat64 limit the size of both numerator and denominator, though not to the same size.</seg></tuv>
  <tuv xml:lang="JA"><seg>（同じサイズにないけれども、rat64のようなネイティブ型は分子と分母のサイズを制限する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The numerator should in general be twice the size of the denominator to support user expectations.</seg></tuv>
  <tuv xml:lang="JA"><seg>分子は、一般にユーザー予想をサポートする分母のサイズの2倍でなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For instance, a rat8 actually supports Rational[int16,uint8], allowing numbers like 100.01 to be represented, and a rat64, defined as Rational[int128,uint64], can hold the number of seconds since the Big Bang with attosecond precision.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、100.01のような数を表現させられて、rat8はRational[int16,uint8]を実際にサポートする、そして、rat64（Rational[int128,uint64]と定義される）はアト秒精度でビッグバンから秒数を持つことができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Though perhaps not with attosecond accuracy...)</seg></tuv>
  <tuv xml:lang="JA"><seg>アト秒精度でおそらくないけれども、...）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The limitation on Rat values is intended to be enforced only on user-visible types.</seg></tuv>
  <tuv xml:lang="JA"><seg>Rat値に対する制限は、ユーザー見える型だけに強制されることを意図される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Intermediate values used in the internal calculations of Rat operators may exceed this precision, or represent negative denominators.</seg></tuv>
  <tuv xml:lang="JA"><seg>Rat演算子の内部の計算において使われる中間の値は、この精度を超えるかもしれないか、否定的な分母を表現するかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, the temporaries used in calculating the new numerator and denominator are (at least in the abstract) of Int type.</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、新しい分子と分母を計算する際に使われるテンポラリーは、Int型である（少なくとも抽象的な）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>After a new numerator and denominator are determined, any sign is forced to be represented only by the numerator.</seg></tuv>
  <tuv xml:lang="JA"><seg>新しい分子と分母が決定されたあと、何か符号は分子だけによって表現されることを強いられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Then if the denominator exceeds the storage size of the unsigned integer used, the fraction is reduced via gcd.</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、分母が使われる符号のない整数の記憶装置の大きさを超えるならば、分数はgcdを通して約分される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the resulting denominator is still larger than the storage size, then and only then may the precision be reduced to fit into a Rat or Num.</seg></tuv>
  <tuv xml:lang="JA"><seg>結果として生じる分母が記憶装置の大きさよりさらに大きいならば、それから、そして、それからだけ、精度はRatまたはNumに適合するために減らされるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Rat addition and subtraction should attempt to preserve the denominator of the more precise argument if that denominator is an integral multiple of the less precise denominator.</seg></tuv>
  <tuv xml:lang="JA"><seg>その分母がより正確でない分母の整数倍であるならば、Rat加算と減算はより正確な引数の分母を保存しようとしなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, in practical terms, adding a column of dollars and cents should generally end up with a result that has a denominator of 100, even if values like 42 and 3.5 were added in. With other operators, this guarantee cannot be made;</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、実際的な項で、たとえ42と3.5のような値が中に加えられたとしても、ドルとセントの列を加えることが100の分母を持つ結果で通常、終わらなければならなくて。他の演算子と、この保証は作られることができない;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>in such cases, the user should probably be explicitly rounding to a particular denominator anyway.</seg></tuv>
  <tuv xml:lang="JA"><seg>そのような場合、ユーザーはいずれにしろ特定の分母まで多分はっきりと丸くなければならないだろう。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For applications that really need arbitrary precision denominators as well as numerators at the cost of performance, FatRat may be used, which is defined as Rational[Int,Int], that is, as arbitrary precision in both parts.</seg></tuv>
  <tuv xml:lang="JA"><seg>パフォーマンスを犠牲にして随意精度分母ならびに分子を本当に必要とするアプリケーションについては、FatRatが使われるかもしれない。そして、それはRational[Int,Int]として定義される（つまり、両方のパーツの随意精度として）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is no literal form for a FatRat, so it must be constructed using FatRat.new($nu,$de).</seg></tuv>
  <tuv xml:lang="JA"><seg>文字通りの形がFatRatのためにないので、それはFatRat.new($nu,$de)を使って造られなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In general, only math operators with at least one FatRat argument will return another FatRat, to prevent accidental promotion of reasonably fast Rat values into arbitrarily slow FatRat values.</seg></tuv>
  <tuv xml:lang="JA"><seg>一般に、少なくとも1つのFatRat引数による数学演算子だけはもう一つのFatRatを返る。そして、任意に遅いFatRat値にかなり速いRat値の偶発的なプロモーションを防ぐ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Although most rational implementations normalize or &amp;quot;reduce&amp;quot; fractions to their smallest representation immediately through a gcd algorithm, Perl allows a rational datatype to do so lazily at need, such as whenever the denominator would run out of precision, but avoid the overhead otherwise.</seg></tuv>
  <tuv xml:lang="JA"><seg>大部分の合理的な実装がgcdアルゴリズムによってすぐ分数を彼らの最も小さな代表に正常化するか、「下げる」が、分母が精度を使い果たすが、さもなければオーバーヘッドを避けるときはいつでも、Perlは合理的なデータ型が必要で、例えばゆったりとそうするのを許す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hence, if you are adding a bunch of Rats that represent, say, dollars and cents, the denominator may stay 100 the entire way through.</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに、あなたが、まあ、ドルとセントを表現するたくさんのRatsを加えているならば、分母は終わりまで全方法で100のままであるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The .nu and .de methods will return these unreduced values.</seg></tuv>
  <tuv xml:lang="JA"><seg>.nuと.deメソッドは、これらのunreducedされた値を返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You can use $rat.=norm to normalize the fraction.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、分数を正常化するために、$rat.=normを使うことができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(This also forces the sign on the denominator to be positive.) The .perl method will produce a decimal number if the denominator is a power of 10, or normalizable to a power of 10 (that is, having factors of only 2 and 5 (and -1)).</seg></tuv>
  <tuv xml:lang="JA"><seg>分母が10の累乗または10（つまり、わずか2と5の（そして、-1）指数を持つ）の力へのnormalizableであるならば、.perlメソッドは十進数を生じる（これも分母の符号にプラスのことを強いる。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Otherwise it will normalize and return a rational literal of the form &amp;lt;-47/3&amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>さもなければ、それは正常化して、形&amp;lt;-47/3&amp;gt;の合理的なリテラルを返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Stringifying a rational via .gist or .Str returns an exact decimal number if possible, and otherwise rounds off the repeated decimal based on the size of the denominator.</seg></tuv>
  <tuv xml:lang="JA"><seg>.gistまたは.Strを経た有理数ができれば正確な十進数に返るStringifying、やその他は、分母のサイズに基づく繰り返された小数を四捨五入する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For full details see the documentation of Rat.gist in S32.</seg></tuv>
  <tuv xml:lang="JA"><seg>完全細目のために、S32でRat.gistのドキュメンテーションを見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Num.Str and Num.gist both produce valid Num literals, so they must include the e for the exponential.</seg></tuv>
  <tuv xml:lang="JA"><seg>Num.StrとNum.gistは有効なNumリテラルを両方とも生じるので、それらは指数関数のためにeを含まなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Infinity and NaN</seg></tuv>
  <tuv xml:lang="JA"><seg>無限とNaN</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 by default makes standard IEEE floating point concepts visible, such as Inf (infinity) and NaN (not a number).</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6は、Inf（無限）とNaN（特別なビットパターン表現法）のような、標準的なIEEE浮動小数点概念をデフォルトで見えるようにする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Within a lexical scope, pragmas may specify the nature of temporary values, and how floating point is to behave under various circumstances.</seg></tuv>
  <tuv xml:lang="JA"><seg>レキシカルスコープの中で、プラグマは、テンポラリー値の性質と浮動小数点がいろいろな状況の下でふるまうことになっている方法を指定するかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All IEEE modes must be lexically available via pragma except in cases where that would entail heroic efforts to bypass a braindead platform.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべてのIEEEモードは、それがbraindeadプラットホームを迂回する英雄的な努力を伴うケースを除いて、プラグマを通して辞書的に利用できなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The default floating-point modes do not throw exceptions but rather propagate Inf and NaN.</seg></tuv>
  <tuv xml:lang="JA"><seg>デフォルト浮動小数点モードは例外を投げなくて、むしろ最大下界とナンを繁殖させる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The boxed object types may carry more detailed information on where overflow or underflow occurred.</seg></tuv>
  <tuv xml:lang="JA"><seg>箱入りオブジェクトタイプは、オーバーフローかアンダーフローがどこで起こったかについて、より多くの詳細をもたらすかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Numerics in Perl are not designed to give the identical answer everywhere.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perlの数字は、至る所で同一の答えをするようになっていない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>They are designed to give the typical programmer the tools to achieve a good enough answer most of the time.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらは、典型的プログラマーにほとんど良い十分な答えを成し遂げるためのツールを与えるようになっている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Really good programmers may occasionally do even better.) Mostly this just involves using enough bits that the stupidities of the algorithm don't matter much.</seg></tuv>
  <tuv xml:lang="JA"><seg>大部分はこれは、ちょうどアルゴリズムの愚かさがあまり重要でない十分なビットを使うことが必要である（本当に良いプログラマーは、よりよく時折しさえするかもしれない。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Strings, the Str Type</seg></tuv>
  <tuv xml:lang="JA"><seg>文字列、Str型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A Str is a Unicode string object. There is no corresponding native str type.</seg></tuv>
  <tuv xml:lang="JA"><seg>Strはユニコード文字列オブジェクトである。対応するネイティブstr型がない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, since a Str object may fill multiple roles, we say that a Str keeps track of its minimum and maximum Unicode abstraction levels, and plays along nicely with the current lexical scope's idea of the ideal character, whether that is bytes, codepoints, graphemes, or characters in some language.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、Strオブジェクトが複数のロールを満たすかもしれない時から、Strがその最小限で最大ユニコード抽象概念レベルの経過を追って、うまく、それがいくらかの言語のバイト、コードポイント、書記素または文字であるかどうかにかかわらず理想的な文字についての現在のレキシカルスコープの考えと調子を合わせると、我々は言う。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The StrPos Type</seg></tuv>
  <tuv xml:lang="JA"><seg>StrPos型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For all builtin operations, all Str positions are reported as position objects, not integers.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべての組み込まれた演算のために、すべてのStr位置は、位置オブジェクト（整数でない）として報告される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These StrPos objects point into a particular string at a particular location independent of abstraction level, either by tracking the string and position directly, or by generating an abstraction-level independent representation of the offset from the beginning of the string that will give the same results if applied to the same string in any context.</seg></tuv>
  <tuv xml:lang="JA"><seg>抽象概念レベル（直接文字列と位置を行くことによるどちらでも）から独立している特定の場所で、または、何か前後関係で同じ文字列に適用されるならば、同じ結果を与える文字列の始まりからオフセットの抽象概念レベルの独立した表現を生み出すことによって、これらのStrPosオブジェクトは、特定の文字列にポイントする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is assuming the string isn't modified in the meanwhile;</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、文字列が合間に修正されないと仮定している;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>a StrPos is not a &amp;quot;marker&amp;quot; and is not required to follow changes to a mutable string.</seg></tuv>
  <tuv xml:lang="JA"><seg>StrPosは目印でなくて、変わりやすい文字列の変更に続くことを要求されない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For instance, if you ask for the positions of matches done by a substitution, the answers are reported in terms of the original string (which may now be inaccessible!), not as positions within the modified string.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、あなたが代用によってされるマッチの位置を求めるならば、改訂文字列の範囲内の位置ではなく、答えは元の文字列（そしてそれは、現在近づきがたい場合がある！）に関して報告される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The StrLen Type</seg></tuv>
  <tuv xml:lang="JA"><seg>StrLen型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The subtraction of two StrPos objects gives a StrLen object, which is also not an integer, because the string between two positions also has multiple integer interpretations depending on the units.</seg></tuv>
  <tuv xml:lang="JA"><seg>2つの位置の間の文字列も単位に従い複数の整数字句解釈をするので、2つのStrPosオブジェクトの引き算はStrLenオブジェクト（それは整数でもない）を伝える。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A given StrLen may know that it represents 7 codepoints, 3 graphemes, and 1 letter in Malayalam, but it might only know this lazily because it actually just hangs onto the two StrPos endpoints within the string that in turn may or may not just lazily point into the string.</seg></tuv>
  <tuv xml:lang="JA"><seg>所定のStrLenはそれがマラーヤラム語で7つのコードポイント、3つの書記素と1通の手紙を表現するということを知っているかもしれない、しかし、文字列につぎにはちょうどゆったりと指すかもしれないか、指さないかもしれない文字列の範囲内で実はちょうど2つのStrPosエンドポイントにしがみつくので、それはゆったりとこれを知っているだけかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The lazy implementation of StrLen is much like a Range object in that respect.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（StrLenの怠惰な実装はその点で非常にRangeオブジェクトのようである。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Units of Position Arguments</seg></tuv>
  <tuv xml:lang="JA"><seg>位置引数の単位</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you use integers as arguments where position objects are expected, it will be assumed that you mean the units of the current lexically scoped Unicode abstraction level.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが位置オブジェクトが予想される引数として整数を使うならば、あなたが現在の辞書的に捜し出されたユニコード抽象概念レベルの単位を意味すると仮定される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Which defaults to graphemes.) Otherwise you'll need to coerce to the proper units:</seg></tuv>
  <tuv xml:lang="JA"><seg>さもなければあなたは、適当な単位に以下を強制する必要がある（そしてそれは書記素へのデフォルト。）：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Of course, such a dimensional number will fail if used on a string that doesn't provide the appropriate abstraction level.</seg></tuv>
  <tuv xml:lang="JA"><seg>もちろん、適正抽象概念レベルを提供しない文字列で使われるならば、そのような次元の数は失敗する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Numeric Coercion of StrPos or StrLen</seg></tuv>
  <tuv xml:lang="JA"><seg>StrPosまたはStrLenの数の強制</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If a StrPos or StrLen is forced into a numeric context, it will assume the units of the current Unicode abstraction level.</seg></tuv>
  <tuv xml:lang="JA"><seg>StrPosまたはStrLenが数値コンテキストに強制されるならば、それは現在のユニコード抽象概念レベルの単位を引き受ける。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is erroneous to pass such a non-dimensional number to a routine that would interpret it with the wrong units.</seg></tuv>
  <tuv xml:lang="JA"><seg>間違った単位でそれを解釈するルーチンにそのような無次元数を通過することは、誤りである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Implementation note:</seg></tuv>
  <tuv xml:lang="JA"><seg>処理系への注：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>since Perl 6 mandates that the default Unicode processing level must view graphemes as the fundamental unit rather than codepoints, this has some implications regarding efficient implementation.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6がデフォルトユニコード処理段階が書記素をコードポイントよりもむしろ基本単位として見なければならないと命じる時から、これには効率的実装に関して若干の含みがある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is suggested that all graphemes be translated on input to unique grapheme numbers and represented as integers within some kind of uniform array for fast substr access.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべての書記素がユニークな書記素番号への入力で変形されて、速いsubstrアクセスのための何らかの均一な配列の中の整数として表現されることを示唆される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For those graphemes that have a precomposed form, use of that codepoint is suggested.</seg></tuv>
  <tuv xml:lang="JA"><seg>precomposedされた形があるそれらの書記素のために、そのコードポイントの使用は、提案される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Note that this means Latin-1 can still be represented internally with 8-bit integers.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（この手段ラテン語-1がまだ８ビット整数で内部的に表現されることができることに注意すべきである。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For graphemes that have no precomposed form, a temporary private id should be assigned that uniquely identifies the grapheme.</seg></tuv>
  <tuv xml:lang="JA"><seg>precomposedされた形がない書記素のために、書記素をユニークに識別する一時的な個人的なIDは、割り当てられなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If such ids are assigned consistently throughout the process, comparison of two graphemes is no more difficult than the comparison of two integers, and comparison of base characters no more difficult than a direct lookup into the id-to-NFD table.</seg></tuv>
  <tuv xml:lang="JA"><seg>そのようなIDがプロセスを通して一貫して割り当てられるならば、2つの書記素の比較は2整数の比較とNFDへのIDテーブルへの直接ルックアップと同様、難しくないベース文字の比較と同様、難しくない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Obviously, any temporary grapheme ids must be translated back to some universal form (such as NFD) on output, and normal precomposed graphemes may turn into either NFC or NFD forms depending on the desired output.</seg></tuv>
  <tuv xml:lang="JA"><seg>明らかに、何かテンポラリー書記素IDは出力の上で若干の一般的な形（例えばNFD）へ変形されなければならない、そして、通常のprecomposedされた書記素はNFCか所望出力次第であるNFDの形態に変わるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Maintaining a particular grapheme/id mapping over the life of the process may have some GC implications for long-running processes, but most processes will likely see a limited number of non-precomposed graphemes.</seg></tuv>
  <tuv xml:lang="JA"><seg>プロセスの人生の間特定の書記素/IDマッピングを維持することは長時間にわたるプロセスへの若干のGC含みがあるかもしれない、しかし、大部分のプロセスは限られた数の非precomposedされた書記素にたぶん遭遇する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the program has a scope that wants a codepoint view rather than a grapheme view, the string visible to that lexical scope must also be translated to universal form, just as with output translation.</seg></tuv>
  <tuv xml:lang="JA"><seg>プログラムが書記素見方よりもむしろコードポイント見方が欲しいスコープを持つならば、ちょうど出力翻訳と同様に、そのレキシカルスコープに見える文字列は一般的な形にも変形されなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Alternately, the temporary grapheme ids may be hidden behind an abstraction layer.</seg></tuv>
  <tuv xml:lang="JA"><seg>あるいは、一時的な書記素IDは、抽象概念層の後に隠されるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In any case, codepoint scope should never see any temporary grapheme ids.</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれにせよ、コードポイントスコープは、何かテンポラリー書記素IDに決して遭遇してはならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The lexical codepoint declaration should probably specify which normalization form it prefers to view strings under.</seg></tuv>
  <tuv xml:lang="JA"><seg>（語彙的なコードポイント宣言は、それがどの正常化用紙の下で文字列を見るのを好むかについて、多分指定しなければならないだろう。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Such a declaration could be applied to input translation as well.)</seg></tuv>
  <tuv xml:lang="JA"><seg>そのような宣言は、同様に翻訳を入力するために適用されることができた。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Buf Type</seg></tuv>
  <tuv xml:lang="JA"><seg>Buf型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A Buf is a stringish view of an array of integers, and has no Unicode or character properties without explicit conversion to some kind of Str.</seg></tuv>
  <tuv xml:lang="JA"><seg>Bufは多数の整数のstringish見方で、何らかのStrへの明示的転換なしで、ユニコードまたは文字プロパティを持たない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The buf8, buf16, buf32, and buf64 types are the native counterparts;</seg></tuv>
  <tuv xml:lang="JA"><seg>（buf8、buf16、buf32とbuf64型は、ネイティブ対応する物である;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>native buf types are required to occupy contiguous memory for the entire buffer.) Typically a Buf is an array of bytes serving as a buffer.</seg></tuv>
  <tuv xml:lang="JA"><seg>ネイティブbuf型は全てのバッファのために連続メモリを占有することを要求される。）、一般的に、Bufはバッファとして用いられている多数のバイトである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Bitwise operations on a Buf treat the entire buffer as a single large integer.</seg></tuv>
  <tuv xml:lang="JA"><seg>Bufの上のビットごとの演算は、全てのバッファを一つの大きな整数とみなす。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Bitwise operations on a Str generally fail unless the Str in question can provide an abstract Buf interface somehow.</seg></tuv>
  <tuv xml:lang="JA"><seg>問題のStrがどうにか、抽象的なBufインターフェースを提供することができない限り、Strの上のビットごとの演算は一般に失敗する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Coercion to Buf should generally invalidate the Str interface.</seg></tuv>
  <tuv xml:lang="JA"><seg>Bufへの強制は、通常、Strインターフェースを無効にしなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As a generic role Buf may be instantiated as any of buf8, buf16, or buf32 (or as any type that provides the appropriate Buf interface), but when used to create a buffer Buf is punned to a class implementing buf8 (actually Buf[uint8]).</seg></tuv>
  <tuv xml:lang="JA"><seg>一般的なロールBufがbuf8、buf16またはbuf32（または適正にBufインターフェースを提供する何か型として）のどれとしてでも具体例をあげて示されるかもしれなくて、わずかにいつBufがそうであるバッファをつくったものであるbuf8（実際にBuf[uint8]）を実装しているクラスにもじった。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unlike Str types, Buf types prefer to deal with integer string positions, and map these directly to the underlying compact array as indices.</seg></tuv>
  <tuv xml:lang="JA"><seg>Str型とは異なり、Buf型は整数文字列位置に対処するのを好んで、インデックスとして直接これらを根底にあるコンパクトな配列にマップする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, these are not necessarily byte positions--an integer position just counts over the number of underlying positions, where one position means one cell of the underlying integer type.</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、これらが必ずしもバイト位置であるというわけではない－整数位置はちょうど下にある位置の数以上数える、そこで、1つの位置は根底にある整数型の1つのセルを意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Builtin string operations on Buf types return integers and expect integers when dealing with positions.</seg></tuv>
  <tuv xml:lang="JA"><seg>位置に対処するとき、Buf型に関する組み込まれた文字列演算は整数を返って、整数を予想する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As a limiting case, buf8 is just an old-school byte string, and the positions are byte positions.</seg></tuv>
  <tuv xml:lang="JA"><seg>制限的なケースとして、buf8はちょうど保守的なバイト文字列である、そして、位置はバイト位置である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note, though, that if you remap a section of buf32 memory to be buf8, you'll have to multiply all your positions by 4.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、あなたがbuf8であるbuf32メモリのセクションを再配置するならば、あなたがあなたのすべての位置に4を掛け算しなければならない点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Native buf Types</seg></tuv>
  <tuv xml:lang="JA"><seg>ネイティブbuf型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These native types are defined based on the Buf role, parameterized by the native integer type it is composed of:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらのネイティブ型は、Bufロールに基づいて、それが成るネイティブ整数型によってパラメータ化されて定義される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There are no signed buf types provided as built-ins, but you may say</seg></tuv>
  <tuv xml:lang="JA"><seg>内蔵として提供される署名されたbuf型がない、しかし、あなたは言うかもしれない</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>to get buffers of signed integers.</seg></tuv>
  <tuv xml:lang="JA"><seg>符号付き整数のバッファを得ること。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is also possible to define a Buf based on non-integers or on non-native types:</seg></tuv>
  <tuv xml:lang="JA"><seg>非整数次の上で、または、ネイティブでない型上で基づくBufを定義することも、あり得る：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, no guarantee of memory contiguity can be made for non-native types.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、メモリ接近の保証は、ネイティブでない型のために作られることができない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Whatever Object</seg></tuv>
  <tuv xml:lang="JA"><seg>Whateverオブジェクト</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The * character as a standalone term captures the notion of &amp;quot;Whatever&amp;quot;, the meaning of which can be decided lazily by whatever it is an argument to. Alternately, for those unary and binary operators that don't care to handle * themselves, it is automatically primed at compile time into a closure that takes one or two arguments.</seg></tuv>
  <tuv xml:lang="JA"><seg>独立型項としての*文字は、&amp;quot;Whatever&amp;quot;の概念をとらえる。そして、それの意味は、それが引数であるものは何によってでも、ゆったりと決定されることができる。あるいは、単一体のそれらと*自体を取り扱いたいと思わない2項演算子については、それは、1、2引数をするクロージャに、コンパイル時で自動的に準備をされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(See below.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（下記参照。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Generally, when an operator handles * itself, it can often be thought of as a &amp;quot;glob&amp;quot; that gives you everything it can in that argument position.</seg></tuv>
  <tuv xml:lang="JA"><seg>通常、演算子が*自体を取り扱うとき、それはあなたにそれがその引数位置でそうすることができるすべてを与える&amp;quot;glob&amp;quot;としばしばみなされることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For instance, here are some operators that choose to handle * and give it special meaning:</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、*を取り扱って、それに以下を意味しているスペシャルを与えるほうを選ぶ一部の演算子は、ここにいる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whatever is an undefined prototype object derived from Any.</seg></tuv>
  <tuv xml:lang="JA"><seg>Whateverは、Anyに由来する未定義プロトタイプオブジェクトである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As a type it is abstract, and may not be instantiated as a defined object.</seg></tuv>
  <tuv xml:lang="JA"><seg>型として、それは抽象的で、定義済みオブジェクトとして具体例をあげて示されないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When used for a particular MMD dispatch, and nothing in the MMD system claims it, it dispatches to as an Any with an undefined value, and (we hope) blows up constructively.</seg></tuv>
  <tuv xml:lang="JA"><seg>特定のMMDディスパッチとMMDシステム主張の何ものためにそれを使わなかったとき、それは指名する｛何でも｝、未定義値と上へ（我々は期待する）打撃建設的にで。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since the Whatever object is effectively immutable, the optimizer is free to recognize * and optimize in the context of what operator it is being passed to.</seg></tuv>
  <tuv xml:lang="JA"><seg>Whateverオブジェクトが事実上不変であるので、オプティマイザーはそれがどんな演算子であるかという前後関係の*と最適化が渡ったことを認知するのは無料である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An operator can declare that it wants to handle * either by declaring one or more of its arguments for at least one of its candidates with an argument of type Whatever, or by marking the proto sub with the trait, is like-Whatever-and-stuff.</seg></tuv>
  <tuv xml:lang="JA"><seg>それが1を宣言することによる、または、より型Whateverの引数をもつ、または、トレイト（is like-Whatever-and-stuff）でプロトサブに跡を残すことによる候補の少なくとも1人のための引数の*を取り扱いたいと、演算子は断言することができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>[Conjecture: actually, this is negotiable--we might shorten it to is like(Whatever) or some such. :-)]</seg></tuv>
  <tuv xml:lang="JA"><seg>［推測する：実は、これは交渉可能である－我々は、is like(Whatever)または少しそれにそれを短くするかもしれない。:-)]</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Autopriming of Unary and Binary Operators with Whatever</seg></tuv>
  <tuv xml:lang="JA"><seg>同類をもつ単一体とバイナリの演算子のAutopriming</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 has several ways of performing partial function application.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6には、部分関数アプリケーションを実行することのいくつかの方法がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since this is an unwieldy term, we've settled on calling it priming.</seg></tuv>
  <tuv xml:lang="JA"><seg>これが扱いにくい項であるので、我々はそれをプライミングと呼ぶことにした。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Many folks call this &amp;quot;currying&amp;quot;, but that's not really a correct technical usage of the term.) Most generally, priming is performed on a Callable object by calling its .assuming method, described elsewhere.</seg></tuv>
  <tuv xml:lang="JA"><seg>最も通常、準備をすることはその.assumingメソッドを呼ぶことによってCallableオブジェクトで実行される（多くの人々はこの「カレーで調理する」ことを呼ぶ、しかし、それは本当に項の正しい技術的な使用法でない。）。そして、どこかほかで記述される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This section is about a convenient syntactic sugar for that.</seg></tuv>
  <tuv xml:lang="JA"><seg>このセクションは、それのために便利な構文法のシュガーについてである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For any unary or binary operator (specifically, any prefix, postfix, and infix operator), if the operator has not specifically requested (via signature matching) to handle * itself, the compiler is required to translate directly to an appropriately primed closure at compile time.</seg></tuv>
  <tuv xml:lang="JA"><seg>単一体の何でもまたは2項演算子（とりわけ、何か接頭辞、接尾辞とインフィックスオペレータ）については、演算子が特に*自体を取り扱うことを要求しなかった（合っているシグネチャを通して）ならば、コンパイラはコンパイルで適切に準備をされたクロージャに直接時間を変形することを要求される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>We call this autopriming.</seg></tuv>
  <tuv xml:lang="JA"><seg>我々は、このautoprimingを呼ぶ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Most of the built-in numeric operators fall into this category.</seg></tuv>
  <tuv xml:lang="JA"><seg>大部分のビルトイン算術演算子は、このカテゴリーに分類される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>So:</seg></tuv>
  <tuv xml:lang="JA"><seg>そう：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>are autoprimed into closures of one or two arguments:</seg></tuv>
  <tuv xml:lang="JA"><seg>1、2引数のクロージャにautoprimedされる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This rewrite happens after variables are looked up in their lexical scope, and after declarator install any variables into the lexical scope, with the result that</seg></tuv>
  <tuv xml:lang="JA"><seg>変数が彼らのレキシカルスコープで調べられて、宣言の後レキシカルスコープに何か変数をインストールしたあと、このリライトは起こる、結果でその</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>is effectively primed into:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下に効果的に準備をされる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>rather than:</seg></tuv>
  <tuv xml:lang="JA"><seg>むしろ以下より：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In other words, * priming does not create a useful lexical scope.</seg></tuv>
  <tuv xml:lang="JA"><seg>言い換えると、*準備をすることは、役に立つレキシカルスコープをつくらない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Though it does have a dynamic scope when it runs.) This prevents the semantics from changing drastically if the operator in question suddenly decides to handle Whatever itself.</seg></tuv>
  <tuv xml:lang="JA"><seg>問題の演算子がWhatever自体を取り扱うことに突然決めるならば、これは意味論がまったく変わるのを防ぐ（それが走るときそれが動的スコープを持つけれども。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As a postfix operator, a method call is one of those operators that is automatically primed.</seg></tuv>
  <tuv xml:lang="JA"><seg>後置演算子として、メソッド呼び出しは、自動的に準備をされるそれらの演算子の1人である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Something like:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下のような何か：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>is rewritten as:</seg></tuv>
  <tuv xml:lang="JA"><seg>書き直す：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In addition to priming a method call without an invocant, such primed methods are handy anywhere a smartmatcher is expected:</seg></tuv>
  <tuv xml:lang="JA"><seg>インボカントなしでメソッド呼び出しの準備をすることに加えて、そのような準備をされたメソッドは、すぐ手近に、スマートマッチャーが予想される場所である：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Metaoperators are treated as normal operators;</seg></tuv>
  <tuv xml:lang="JA"><seg>メタ演算子は、通常の演算子とみなされる;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>the autopriming does not automatically distribute to the inner operator.</seg></tuv>
  <tuv xml:lang="JA"><seg>autoprimingすることは、内部の演算子に自動的に割り当てない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For example,</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>does not make a list of closures, but is equivalent to</seg></tuv>
  <tuv xml:lang="JA"><seg>doesは、クロージャのリストをしない、等しくない</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Postcircumfixes (with or without the dot) are also autoprimed, so we have</seg></tuv>
  <tuv xml:lang="JA"><seg>Postcircumfixes（点の有無にかかわらず）もautoprimedされるので、我々はそうした</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The WhateverCode Types</seg></tuv>
  <tuv xml:lang="JA"><seg>WhateverCode型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These returned closures are of type WhateverCode:($) or WhateverCode:($,$) rather than type Whatever, so constructs that do want to handle * or its derivative closures can distinguish them by type:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの返られたクロージャは型Whateverよりもむしろ型WhateverCode:($)またはWhateverCode:($,$)であるので、*またはその派生的なクロージャを取り扱いたい構成概念はそれらを型によって識別することができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For any prefix, infix, postfix, or postcircumfix operator that would be primed by a Whatever, a WhateverCode also autoprimes it, such that any noun phrase based on * as a head noun autoprimes transitively outward as far as it makes sense, including outward through metaoperators.</seg></tuv>
  <tuv xml:lang="JA"><seg>何か接頭辞、挿入辞、接尾辞またはWhateverによって準備をされるpostcircumfix演算子のために、WhateverCodeもautoprimesそれ（それがメタ演算子を通して外向きを含む意味をなす限り何か名詞句が他動的に外へヘッド名詞autoprimesとして*に基づいたような）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hence:</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note in particular that parentheses will autoprime on a WhateverCode, so</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、そう、括弧がWhateverCodeの上でautoprimeにそうする注</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>means</seg></tuv>
  <tuv xml:lang="JA"><seg>手段</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>rather than</seg></tuv>
  <tuv xml:lang="JA"><seg></seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you want the latter semantics for some reason, use a temporary:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが何かの理由で後の意味論を望むならば、テンポラリーを使いなさい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>or just put the autoprime in parens:</seg></tuv>
  <tuv xml:lang="JA"><seg>あるいは、ちょうどautoprimeを括弧に置く：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Operators with idiosyncratic Whatever</seg></tuv>
  <tuv xml:lang="JA"><seg>特有のWhateverをもつ演算子</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The above is only for operators that are not Whatever-aware.</seg></tuv>
  <tuv xml:lang="JA"><seg>上記は、Whateverわかっていない演算子に賛成であるだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is no requirement that a Whatever-aware operator return a WhateverCode when Whatever is used as an argument;</seg></tuv>
  <tuv xml:lang="JA"><seg>Whateverわかっている演算子がWhateverが引数として使われるWhateverCodeを返るという必要が、ない;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>that's just the typical behavior for functions that have no intrinsic &amp;quot;globbish&amp;quot; meaning for *.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、ちょうど*のために固有の&amp;quot;globbish&amp;quot;意味を持たない関数のための典型的ふるまいである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you want to prime one of these globbish operators, you'll need to write an explicit closure or do an explicit priming on the operator with .assuming().</seg></tuv>
  <tuv xml:lang="JA"><seg>これらのglobbish演算子の1人の準備をしたいならば、あなたは明示的クロージャを書くか、.assuming()で演算子の上で明示的プライミングをする必要がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Operators in this class, such as infix:&amp;lt;..&amp;gt; and infix:&amp;lt;xx&amp;gt;, typically do autoprime arguments of type WhateverCode even though they do not autoprime Whatever, so we have:</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえそれらがautoprime｛全く｝をしないとしても、このクラス（例えばinfix:&amp;lt;..&amp;gt;とinfix:&amp;lt;xx&amp;gt;）の演算子は型WhateverCodeのautoprime引数を概してするので、我々は以下を持つ：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(If the last is used as a subscript, the subscripter notices there are two arguments and passes that dimension's size twice.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（最後が添え字として使われるならば、subscripterは2つの引数があると気がついて、二回その次元のサイズを超える。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Non-closure-returning Operators with *</seg></tuv>
  <tuv xml:lang="JA"><seg>*をもつ非クロージャ返っている演算子</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Operators that are known to return non-closure values with * include:</seg></tuv>
  <tuv xml:lang="JA"><seg>*で非クロージャ値を返るために有名である演算子は、以下を含む：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that the last two also do not autoprime WhateverCode, because assignment and smartmatching are not really normal binary operators, but syntactic sugar for underlying primitives.</seg></tuv>
  <tuv xml:lang="JA"><seg>割当てとsmartmatchingすることが本当に通常の2項演算子でなく、根底にあるプリミティブのための構文法のシュガーであるので、最後の2つもautoprime WhateverCodeをしない点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Such pseudo operators may also place restrictions on which meta-operators work on them.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（そのような疑似演算子はメタ演算子がそれらの上で動く規制も置くかもしれない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Neither do the sequence operators &amp;amp;infix:&amp;lt;...&amp;gt; and &amp;amp;infix:&amp;lt;...^&amp;gt; autoprime WhateverCode, because we want to allow WhateverCode closures as the stopper:</seg></tuv>
  <tuv xml:lang="JA"><seg>我々がストッパーとしてWhateverCodeクロージャを許したいので、そして、シーケンス演算子&amp;amp;infix:&amp;lt;...&amp;gt;と&amp;amp;infix:&amp;lt;...^&amp;gt; autoprime WhateverCodeはそうしない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>[Conjecture: it is possible that, for most of the above operators that take * to mean Inf, we could still actually return a closure that defaults that particular argument to Inf.</seg></tuv>
  <tuv xml:lang="JA"><seg>［推測しなさい：平均Infに*をする大部分の上記の演算子にとって、我々がInfに対するその特定の引数を怠るクロージャを実はまだ返ることができたことは、あり得る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, this would work only if we provide a &amp;quot;value list context&amp;quot; that forbids closures, in the sense that it always calls any closure it finds in its list and replaces the closure in the list with its return value or values, and then rescans from that point (kinda like a text macro does), in case the closure returned a list containing a closure.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、それが常にリストで発見する何かクロージャを呼んで、戻り値または値でリストでクロージャに代わるという点で、我々がクロージャを禁ずる「値リストコンテキスト」を提供する場合だけ、これは働く、そして、クロージャがクロージャを含んでいるリストを返る場合に備えて、それからの再走査はポイントする（いくらかマクロがするテキストのような）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>So for example, the closure returned by 0..* would interpolate a Range object into the list when called.</seg></tuv>
  <tuv xml:lang="JA"><seg>とてもたとえば、呼ばれるとき、0..*によって返納印クロージャはリストにRangeオブジェクトを差し込む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Alternately, it could return the 0, followed by another closure that does 1..*.</seg></tuv>
  <tuv xml:lang="JA"><seg>あるいは、それは0を返ることができた。そして、1..*をするもう一つのクロージャが続いた。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Even the ... operator could likely be redefined in terms of a closure that regenerates itself, as long as we figure out some way of remembering the last N values each time.]</seg></tuv>
  <tuv xml:lang="JA"><seg>我々が各時最後のN値を覚えていることの若干の方法を見つけ出す限り、...演算子さえ再生するクロージャに関してたぶん再定義されることができた。］</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In any case, array indexes must behave as such a 'value list context', since you can't directly index an array with anything other than a number.</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれにせよ、あなたが数以外の何でも配列に直接索引付けすることができない時から、配列の添字はそのような『値リストコンテキスト』としてふるまわなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The final element of an array is subscripted as @a[*-1], which means that when the subscripting operation discovers a Code:($) object for a subscript, it calls it and supplies an argument indicating the number of elements in (that dimension of) the array.</seg></tuv>
  <tuv xml:lang="JA"><seg>最終的な配列の要素は@a[*-1]（添え字付け演算が添え字のためにCode:($)オブジェクトを発見するとき、それはそれを意味する）としてsubscriptedされる。そして、それはそれを呼んで、要素数を中で示している引数を供給する（その次元）配列。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See S09.</seg></tuv>
  <tuv xml:lang="JA"><seg>S09を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The HyperWhatever Type</seg></tuv>
  <tuv xml:lang="JA"><seg>HyperWhatever型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A variant of * is the ** term, which is of type HyperWhatever.</seg></tuv>
  <tuv xml:lang="JA"><seg>*の変形は**項である。そして、それは型HyperWhateverである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is generally understood to be a multidimension form of * when that makes sense.</seg></tuv>
  <tuv xml:lang="JA"><seg>それが意味をなす*の多重次元の形であることは、通常、理解される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When modified by an operator that would turn * into a function of one argument, WhateverCode:($), ** instead turns into a function with one slurpy argument, Code(*@), such that multiple arguments are distributed to some number of internal whatevers.</seg></tuv>
  <tuv xml:lang="JA"><seg>演算子によって修正されるとき、それが1つの引数（WhateverCode:($)）の関数への*に変わって、複数の引数が若干の数の内部のwhateversに割り当てられるように、**は1つのslurpy引数（Code(*@)）で関数にその代わりに変わる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is:</seg></tuv>
  <tuv xml:lang="JA"><seg>すなわち：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Therefore @array[^**] represents @array[ map ^* , @_ ], that is to say, every element of the array, no matter how many dimensions.</seg></tuv>
  <tuv xml:lang="JA"><seg>したがって、@array[^**]は@array[ map ^* , @_ ]を表現する ― それが言うことになっている ― 配列のすべての要素、気にするな、どれくらいの次元。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(However, @array[**] means the same thing because (as with ... above), the subscript operator will interpret bare ** as meaning all the subscripts, not the list of dimension sizes.</seg></tuv>
  <tuv xml:lang="JA"><seg>（しかし、@array[**]は同じものを意味する、すべての添え字（次元サイズのリストでない）を意味するように、添字演算子は裸の**を解釈する（上の...と同様に）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The meaning of Whatever is always controlled by the first context it is bound into.)</seg></tuv>
  <tuv xml:lang="JA"><seg>Whateverの意味は、それが結びつけられる最初の前後関係によって、常にコントロールされる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Other uses for * and ** will doubtless suggest themselves over time.</seg></tuv>
  <tuv xml:lang="JA"><seg>*と**の他の用途は、おそらく時間とともに自分自身を暗示する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These can be given meaning via the MMD system, if not the compiler.</seg></tuv>
  <tuv xml:lang="JA"><seg>コンパイラとまではいかないが、これらはMMDシステムによって意味を与えられることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In general a Whatever should be interpreted as maximizing the degrees of freedom in a dwimmy way, not as a nihilistic &amp;quot;don't care anymore--just shoot me&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>Whateverがdwimmy方法で自由度を最大にして解釈されなければならない一般に、ではなく虚無主義的な、もう気にかけてはいけない－ちょうど私を撃ちなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Native types</seg></tuv>
  <tuv xml:lang="JA"><seg>ネイティブ型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Values with these types autobox to their uppercase counterparts when you treat them as objects:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの型autoboxがあなたがそれらをオブジェクトとみなす彼らの大文字の対応する物へにある値：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since native types cannot represent Perl's concept of undefined values, in the absence of explicit initialization, native floating-point types default to NaN, while integer types (including bit) default to 0.</seg></tuv>
  <tuv xml:lang="JA"><seg>ネイティブ型が未定義値のPerlの概念を表現することができないので、明示的初期化がない場合、整数型（bitを含む）が0にデフォルトでなる間、ネイティブ浮動小数点型はNaNにデフォルトでなる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The complex type defaults to NaN + NaN\i.</seg></tuv>
  <tuv xml:lang="JA"><seg>複素数型は、NaN + NaN\iにデフォルトでなる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A buf type of known size defaults to a sequence of 0 values.</seg></tuv>
  <tuv xml:lang="JA"><seg>既知のサイズのbuf型は、一連の0の値にデフォルトでなる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You can set a different default on any container type by use of a trait such as is default(42).</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、is default(42)のようなトレイトの使用によって、異なるデフォルトを何かコンテナ型の上に置くことができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Deleting or undefining such a container sets the contents back to the default value (or optionally removes it in cases where the default value can be autovivified on demand).</seg></tuv>
  <tuv xml:lang="JA"><seg>そのようなコンテナを削除するか、undefiningすることは、デフォルト値（または、任意に、デフォルト値が要求に応じてautovivifiedされることができる場合、それを取り除く）まで、内容を戻す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you wish for a native declaration to attempt no initialization, but leave whatever garbage was in memory, you may use the is default(*) trait.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえどんなゴミがメモリであったとしてもネイティブ宣言のために初期化を試みなくて、去りたいならば、あなたはis default(*)トレイトを使うかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There are several use cases for this, if you know you're going to initialize the memory otherwise, or you're doing some form of memory mapping.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが特にメモリを初期化することになるということを知っているならば、いくつかの使用事例がこれのためにある、または、あなたは何らかのメモリマッピングをしている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If a buf type is initialized with a Unicode string value, the string is decomposed into Unicode codepoints, and each codepoint shoved into an integer element.</seg></tuv>
  <tuv xml:lang="JA"><seg>buf型がユニコード文字列値で初期化されるならば、文字列はユニコードコードポイントに分解される、そして、各々のコードポイントは整数要素に押した。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the size of the buf type is not specified, it takes its length from the initializing string.</seg></tuv>
  <tuv xml:lang="JA"><seg>buf型のサイズが指定されないならば、それは長さを初期化している文字列から引く。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the size is specified, the initializing string is truncated or 0-padded as necessary.</seg></tuv>
  <tuv xml:lang="JA"><seg>サイズが指定されるならば、初期化している文字列は頭を切って短くされるか、必要に応じて0パッドを入れられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If a codepoint doesn't fit into a buf's integer type, a parse error is issued if this can be detected at compile time;</seg></tuv>
  <tuv xml:lang="JA"><seg>コードポイントが適合しないもしも、bufは整数型である、これがコンパイル時で見つけられることができるならば、解析エラーは出される;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>otherwise a warning is issued at run time and the overflowed buffer element is filled with an appropriate replacement character, either U+FFFD (REPLACEMENT CHARACTER) if the element's integer type is at least 16 bits, or U+007f (DELETE) if the larger value would not fit.</seg></tuv>
  <tuv xml:lang="JA"><seg>さもなければ、警告は実行時で発される、そして、氾濫する緩衝素子は適正置換文字（より大きな値が合わないならば要素の整数型が少なくとも16ビットまたはU+007f（削除する）であるならばどちらのU+FFFD（置換文字）でも）で満たされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If any other conversion is desired, it must be specified explicitly.</seg></tuv>
  <tuv xml:lang="JA"><seg>何か他の転換が要求されるならば、それははっきりと指定されなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In particular, no conversion to UTF-8 or UTF-16 is attempted;</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、UTF-8またはUTF-16への転換は、試みられない;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>that must be specified explicitly.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、はっきりと指定されなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(As it happens, conversion to a buf type based on 32-bit integers produces valid UTF-32 in the native endianness.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（たまたま、32ビット整数に基づくbuf型への転換はネイティブendiannessで有効なUTF-32を生じる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Mu type</seg></tuv>
  <tuv xml:lang="JA"><seg>Mu型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Among other things, Mu is named after the eastern concept of &amp;quot;Mu&amp;quot; or 無 (see http://en.wikipedia.org/wiki/MU, especially the &amp;quot;Mu (negative)&amp;quot; entry), so in Perl 6 it stands in for Perl 5's concept of &amp;quot;undef&amp;quot; when that is used as a noun.</seg></tuv>
  <tuv xml:lang="JA"><seg>その他のものと一緒に、Muは&amp;quot;Mu&amp;quot;または無の東の概念の名をとって名づけられる（特にhttp://en.wikipedia.org/wiki/MU,を見るムー（否定的な）エントリー）、Perl 6でそれがPerlに直面しそうなままであるように、5つはそれが名詞として使われる&amp;quot;undef&amp;quot;の概念である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, Mu is also the &amp;quot;nothing&amp;quot; from which everything else is derived via the undefined type objects, so it stands in for the concept of &amp;quot;Object&amp;quot; as used in languages like Java.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、Muであるまた、そうである何もでない、他の全てがどれを通して派生しているか、未定義型は反対するので、それはジャバのような言語にて用いられているように、オブジェクトの概念に直面しそうなままである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Or think of it as a &amp;quot;micro&amp;quot; or μ-object that is the basis for all other objects, something atomic like a Muon.</seg></tuv>
  <tuv xml:lang="JA"><seg>または、それを、他の全てのオブジェクト（μ中間子のように原子何か）の基礎である「マイクロ」またはμ-オブジェクトとみなしなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Or if acronyms make you happy, there are a variety to pick from:</seg></tuv>
  <tuv xml:lang="JA"><seg>または、頭字語があなたを幸せにするならば、以下から拾い上げる多様性がある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Or just think of it as a sound a cow makes, which simultaneously means everything and nothing.</seg></tuv>
  <tuv xml:lang="JA"><seg>または、ちょうど音としてそれの牛を製造（すべてと何も同時に意味しない）と考えなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Undefined types</seg></tuv>
  <tuv xml:lang="JA"><seg>未定義型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 does not have a single value representing undefinedness.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6は、未定義を表現している一つの値も持たない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instead, objects of various types can carry type information while nevertheless remaining undefined themselves.</seg></tuv>
  <tuv xml:lang="JA"><seg>その代わりに、それでも自分自身未定義ままの間、様々な型のオブジェクトは型情報をもたらすことができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whether an object is defined is determined by whether .defined returns true or not.</seg></tuv>
  <tuv xml:lang="JA"><seg>.definedが真実に返るかどうかにかかわらず、オブジェクトが定義されるかどうかは決定される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These typed objects typically represent uninitialized values.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの入力されたオブジェクトは、初期化されていない値を概して表現する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Failure objects are also officially undefined despite carrying exception information;</seg></tuv>
  <tuv xml:lang="JA"><seg>失敗オブジェクトも、例外情報をもたらすことにもかかわらず、公式に未定義である;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>these may be created using the fail function, or by direct construction of a Failure object of some sort.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらは、fail関数を用いて、または、何らかのFailureオブジェクトの直接の構築によってつくられるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(See S04 for how failures are handled.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（失敗が取り扱われる方法についてはS04を見なさい。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whenever you declare any kind of type, class, module, or package, you're automatically declaring a undefined prototype value with the same name, known as the type object.</seg></tuv>
  <tuv xml:lang="JA"><seg>どんな型、クラス、モジュールまたはパッケージを宣言もするときはいつでも、あなたは同じ名前で未定義プロトタイプ値を自動的に宣言している。そして、型オブジェクトとして知られている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The name itself returns that type object:</seg></tuv>
  <tuv xml:lang="JA"><seg>名前そのものは、その型オブジェクトを返る：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All user-defined classes derive from the Any class by default.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべてのユーザー定義のクラスは、デフォルトでAnyクラスに由来する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Type objects sometimes stringify to their name in parens, to indicate undefinedness.</seg></tuv>
  <tuv xml:lang="JA"><seg>オブジェクトが括弧で彼らの名前に時々stringifyする型（未定義を示すために）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that type objects are not classes, but may be used to name classes when the type's associated meta-object allows it:</seg></tuv>
  <tuv xml:lang="JA"><seg>型オブジェクトがクラスでなくて、型の関連したメタオブジェクトがそれを許すとき名前クラスに使われるかもしれないことに注意すべきである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Any type encompasses all normal value and object types.</seg></tuv>
  <tuv xml:lang="JA"><seg>Any型は、すべての通常の値とオブジェクトタイプを含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is the unit type, but includes units that are containers of multiple values.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは単位型であるが、多値のコンテナである単位を含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is not the most general type, however.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、それは最も一般的な型でない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any derives from Mu, which is the top type in Perl 6, and encompasses certain conceptual types that fall outside the realm of ordinary Any values.</seg></tuv>
  <tuv xml:lang="JA"><seg>AnyはMu（それはPerl 6のトップ型である）に由来して、普通のAny値の領域から外れる特定の概念上の型を含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These conceptual types include:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの概念上の型は以下を含む：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Conceptual types rely on the failure to match an Any type in order to trigger various extraordinary behaviors.</seg></tuv>
  <tuv xml:lang="JA"><seg>概念上の型は、いろいろな並外れた性質を起動させるためにAny型にマッチする失敗に頼る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Junction and Each types trigger an inside-out linguistic distribution of various list behaviors from inside a scalar expression that pretends a bunch of values are really a single value.</seg></tuv>
  <tuv xml:lang="JA"><seg>JunctionとEach型は、たくさんの値が本当に一つの値であると偽るスカラー式の中にから、いろいろなリスト性質のインサイドアウト言語配布を誘発する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(These are modeled on similar linguistic behaviors in English.) The distributional behavior triggered for these types is known as autothreading.</seg></tuv>
  <tuv xml:lang="JA"><seg>autothreadingするように、これらの型のために引き起こされる分配ふるまいは知られている（これらは英語で類似した言語性質にならって作られる。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Failure type is considered conceptual so that dynamic context can determine the treatment of failures that in other languages would always throw exceptions.</seg></tuv>
  <tuv xml:lang="JA"><seg>ダイナミックな前後関係が他の言語の常に例外を投げる失敗の治療を決定することができるように、Failure型は概念的であると考えられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This gives Perl 6 programs the flexibility to handle exceptions either in-band or out-of-band.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、帯域内であるか帯域外例外を取り扱うために、Perl 6プログラムに柔軟性を与える。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is particularly important to be able to handle exceptions in-band when you are trying to perform parallel operations, so that the failure of one computation does not result in fratricide of all its fellow computations.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが並行オペレーションを行おうとしているとき、帯域内例外を取り扱うことができることは特に重要である、そのため、1つの計算の失敗が結果としてすべてのその仲間の計算の兄弟殺しになるというわけではない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(You can think of this as analogous to the way NaN propagates through floating-point calculations.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（NaNが浮動小数点計算を通して伝播する方法に類似しているように、あなたはこれについて考えることができる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Single dispatch of a Failure invocant to any method not in Failure returns the same Failure, so that cascaded method calls can be checked with a single check:</seg></tuv>
  <tuv xml:lang="JA"><seg>Failureの何かメソッドへのFailureインボカントの一つのディスパッチも同じFailureを返らない、そのため、カスケードされたメソッド呼び出しは一回のチェックと照合されることができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Failures may only be passed into functions via parameters that allow Mu or Failure, and a failure may only be returned from a function whose return type permits it.</seg></tuv>
  <tuv xml:lang="JA"><seg>失敗はMuまたはFailureを許すパラメータを通して関数に通過されるだけかもしれない、そして、失敗は戻り型がそれを許す関数から返納印である場合があるだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>After the failure is returned, any subsequent attempt to use the failure in an Any context will be subject to further failure analysis, and will likely throw an exception immediately.</seg></tuv>
  <tuv xml:lang="JA"><seg>失敗が不履行を使う返られた、少しも以降の試みであったあと、Any前後関係は更なる不良解析を受けて、すぐに例外をたぶん投げる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Likewise, discarding the failure in sink context produces an immediate exception.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、不履行シンク前後関係を放棄することは、即時の例外を生じる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that a Failure object is undefined, but may contain one or more defined Exception objects, which are considered normal objects that just happen to be used in exception throwing and handling.</seg></tuv>
  <tuv xml:lang="JA"><seg>Failureオブジェクトが未定義であるが、一つ以上の定義済みExceptionオブジェクトを含むかもしれないことに注意すべきである。そして、それはちょうど偶然例外投げと取扱いにおいて使われることが起こる考えられた通常のオブジェクトである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Immutable types</seg></tuv>
  <tuv xml:lang="JA"><seg>不変の型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Objects with these types behave like values, i.e. $x === $y is true if and only if their types and contents are identical (that is, if $x.WHICH eqv $y.WHICH).</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの型によるオブジェクトは値のようにふるまう、すなわち、彼らの型と内容が同一の（つまり、$x.WHICH eqv $y.WHICHならば）場合に限り、$x === $yは真実である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Set values may be composed with the set listop or method. Bag values may be composed with the bag listop or method. Mix values may be composed with the mix listop or method.</seg></tuv>
  <tuv xml:lang="JA"><seg>Set値はset listopまたはメソッドで組み立てられるかもしれない。Bag値はbag listopまたはメソッドで組み立てられるかもしれない。Mix値は｛混合物｝listopまたはメソッドで組み立てられるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instants and Durations are measured in atomic seconds with fractions.</seg></tuv>
  <tuv xml:lang="JA"><seg>InstantsとDurationsは、分数で原子秒で測られる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Notionally they are real numbers which may be implemented in any Real type of sufficient precision, preferably a Rat or FatRat.</seg></tuv>
  <tuv xml:lang="JA"><seg>抽象的に、それらは、十分な精度、望ましくはRatまたはFatRatの何かReal型で実装されるかもしれない実数である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Implementations that make fixed-point assumptions about the available subsecond precision are discouraged;</seg></tuv>
  <tuv xml:lang="JA"><seg>（利用できるsubsecond精度について固定小数点奪取をする実装は、はばまれる;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>the user interface must act like real numbers in any case.) Interfaces that take Duration arguments, such as sleep(), may also take Real arguments, but Instant arguments must be explicitly created via any of various culturally aware time specification APIs. A small number of Instant values that represent common epoch instant values are also available.</seg></tuv>
  <tuv xml:lang="JA"><seg>ユーザインタフェースは、いずれにせよ実数のようなふりをしなければならない。）、Durationに引数（例えばsleep()）を持っていくインターフェースは、Realにも引数を持っていくかもしれない、しかし、Instant引数は、いろいろな文化的にわかっている時間仕様APIのどれによってでも、はっきりとつくられなければならない。一般のエポック瞬間値を表現する少数のInstant値も、利用できる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In numeric context a Duration happily returns a Rat or FatRat representing the number of seconds.</seg></tuv>
  <tuv xml:lang="JA"><seg>数値コンテキストでは、Durationは、秒数を表現しているRatまたはFatRatを首尾よく返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instant values, on the other hand, are largely opaque, numerically speaking, and in particular are epoch agnostic.</seg></tuv>
  <tuv xml:lang="JA"><seg>Instant値は、他方、主に不透明で、数値的に話していて、特にエポックを選ばないものである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Any epoch is just a particular Instant, and all times related to that epoch are really Instant ± Duration, which returns a new Instant.) In order to facilitate the writing of culturally aware time modules, the Instant type provides Instant values corresponding to various commonly used epochs, such as the 1958 TAI epoch, the POSIX epoch, the Mac epoch, and perhaps the year 2000 epoch as UTC thinks of it.</seg></tuv>
  <tuv xml:lang="JA"><seg>文化的にわかっているタイムモデュールを書くことを促進するために、｛即座の｝型はいろいろな一般的に用いられるエポック（例えば1958のタイ系諸族のエポック、POSIXエポック、Macエポック）と一致している値を提供する｛即座の｝（何かエポックはちょうど特定のInstantである、そして、そのエポックに関連したすべての時代は本当にInstant±Durationである。そして、それは新しいInstantを返る。）、そして、UTCとしてのだいたい2000年エポックはそれについて考える。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There's no reason to exclude any useful epoch that is well characterized in atomic seconds.</seg></tuv>
  <tuv xml:lang="JA"><seg>原子秒でよく特徴づけられる少しも役に立つエポックを除外する理由が、ない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All normal times can be calculated from those epoch instants using addition and subtraction of Duration values. Note that the Duration values are still just atomic time without any cultural deformations;</seg></tuv>
  <tuv xml:lang="JA"><seg>標準時間の間ずっとはDuration値の加算と減算を使用しているそれらのエポック瞬間から計算されることができる。Duration値がまだちょうど何か文化的な変形のない原子時間であることに注意すべきである;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>in particular, the Duration formed of by subtracting Instant::Epoch::POSIX from the current instant will contain more seconds than the current POSIX time() due to POSIX's abysmal ignorance of leap seconds.</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、Instant::Epoch::POSIXを現在の瞬間から引くことによってできられるDurationは、閏秒についてのPOSIXの実にひどい不案内のための現在のPOSIX time()より多くの秒を含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is not the fault of the universe, which is not fooled (neglecting relativistic considerations).</seg></tuv>
  <tuv xml:lang="JA"><seg>これは宇宙の誤りでない。そして、それは馬鹿にされない（相対論的な考慮点を怠る）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instants and Durations are always linear atomic seconds.</seg></tuv>
  <tuv xml:lang="JA"><seg>InstantsとDurationsは、常に線形原子秒である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Systems which cannot officially provide a steady time base, such as POSIX systems, will simply have to make their best guess as to the correct atomic time when asked to interconvert between cultural time and atomic time.</seg></tuv>
  <tuv xml:lang="JA"><seg>文化的な時間と原子時間の間でinterconvertに尋ねられるとき、安定したタイムベース（例えばPOSIXシステム）を公式に提供することができないシステムは単に彼らのベストを正しい原子時間に関して推測させなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Alternately, they may use some other less-official time mechanism to achieve steady clock behavior.</seg></tuv>
  <tuv xml:lang="JA"><seg>あるいは、それらは、落ち着いた時計ふるまいを成し遂げるために、若干の他のより公式でない時間メカニズムを使うかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Most Unix systems can count clock ticks, even if POSIX time types get confused.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえPOSIX回の型が混乱するとしても、大部分のUnixシステムはクロック単位を数えることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Although the conceptual type of an Instant resembles FatRat, with arbitrarily large size in either numerator or denominator, the internal form may of course be optimized internally for &amp;quot;nearby&amp;quot; times, so that, if we know the year as an integer, the instant within the year can just be a Rat representing the offset from the beginning of the year.</seg></tuv>
  <tuv xml:lang="JA"><seg>Instantの概念上の型がFatRatに似ているが、どちらの分子または分母の任意にかなりのサイズででも、内部の形はもちろん近くの時代のために内部的に最適化されるかもしれない、そのため、我々が年を整数として知っているならば、年以内の瞬間はちょうど期首からオフセットを表現しているRatでありえる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Calculations that fall within the same year can then be done in Rat rather than FatRat, or a table of yearly offsets can find the difference in integer seconds between two years, since (so far) nobody has had the nerve to propose fractional leap seconds.</seg></tuv>
  <tuv xml:lang="JA"><seg>それから、同じ年に入る計算はFatRatよりもむしろRatでされることができる、または、誰もわずかな閏秒を提案するために図々しくなかった時から（ここまで）、年間オフセットの表は2年の間で違いを整数おかわりで見つけることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Or whatever.</seg></tuv>
  <tuv xml:lang="JA"><seg>または、いったい何。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instant is opaque, so we can swap implementations in and out without user-visible consequences.</seg></tuv>
  <tuv xml:lang="JA"><seg>Instantは不透明であるので、我々はユーザー見える結果なしで中に、そして、外に実装を交換することができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The term now returns the current time as an Instant.</seg></tuv>
  <tuv xml:lang="JA"><seg>項nowは、Instantとして現在の時返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As with the rand and self terms, it is not a function, so don't put parens after it.</seg></tuv>
  <tuv xml:lang="JA"><seg>randとself項と同様に、それは関数でないので、それの後括弧を置いてはいけない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It also never looks for arguments, so the next token should be an operator or terminator.</seg></tuv>
  <tuv xml:lang="JA"><seg>それも引数を決して探さないので、次のトークンは演算子またはターミネータでなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Basic math operations are defined for instants and durations such that the sum of an instant and a duration is always an instant, while the difference of two instants is always a duration.</seg></tuv>
  <tuv xml:lang="JA"><seg>2つの瞬間の違いが常に期間である間、瞬間と期間の合計が常に瞬間であるように、基本的な演算操作は瞬間と期間の間定義される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Math on instants may only be done with durations (or numbers that will be taken as durations, as above);</seg></tuv>
  <tuv xml:lang="JA"><seg>瞬間の数学は、期間（または、上記のように、期間としてとられる数）で、されるだけかもしれない;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>you may not add two instants.</seg></tuv>
  <tuv xml:lang="JA"><seg>2つの瞬間を加えなくてもよい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Numeric operations on durations return Duration where that makes sense (addition, subtraction, modulus).</seg></tuv>
  <tuv xml:lang="JA"><seg>期間の算術演算は、それが意味をなす（追加、引き算、率）Durationを返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The type returned for other numeric operations is unspecified;</seg></tuv>
  <tuv xml:lang="JA"><seg>他の算術演算のために返納印型は、明らかでない;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>they may return normal numeric types or they may return other dimensional types that attempt to assist in dimensional analysis.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらは通常の数値型を返るかもしれない、または、それらは次元解析を援助しようとする他の次元の型を返るかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The latter approach should likely require explicit declaration for now, until we can demonstrate that it does not adversely impact the average programmer, and that it plays well with the concept of gradual typing.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（我々がそれが平均的プログラマに逆に衝撃を与えない、そして、それが段階的なタイピングの概念でうまくやることを証明することができるまで、後のアプローチは今のところ明示的宣言をたぶん必要としなければならない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Blob type is like an immutable buffer, and therefore responds both to array and (some) stringy operations.</seg></tuv>
  <tuv xml:lang="JA"><seg>Blob型は不変のバッファのようで、したがって、配列と（いくつか）繊維質の演算に応じる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that, like a Buf, its size is measured in whatever the base unit is, which is not always bytes.</seg></tuv>
  <tuv xml:lang="JA"><seg>なお、Bufのように、そのサイズは基本単位がそうであるものは何ででも計られる。そして、それは必ずしもバイトでない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you have a my Blob[bit] $blob, then $blob.elems returns the number of bits in it.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたがmy Blob[bit] $blobを持つならば、$blob.elemsはそれの中にビットの数を返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As with buffers, various native types are automatically derived from native unsigned int types:</seg></tuv>
  <tuv xml:lang="JA"><seg>バッファと同様に、いろいろなネイティブ型は、ネイティブ符号なしint型に自動的に由来する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The utf8 type is derived from blob8, with the additional constraint that it may only contain validly encoded UTF-8.</seg></tuv>
  <tuv xml:lang="JA"><seg>それが有効にコード化されたUTF-8を含むだけかもしれない更なる制約で、utf8型は、blob8に由来する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Likewise, utf16 is derived from blob16, and utf32 from blob32.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、utf16はblob16とblob32からutf32に由来する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that since these are type names, parentheses must always be used to call them as coercers, since the listop form is not allowed for coercions.</seg></tuv>
  <tuv xml:lang="JA"><seg>listopの形がコアーションのために許されない時から、これらがタイプ名である時から、括弧が常に強制者としてそれらを呼ぶのに用いられなければならない点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is:</seg></tuv>
  <tuv xml:lang="JA"><seg>すなわち：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>is always parsed as</seg></tuv>
  <tuv xml:lang="JA"><seg>常に解析される</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>and never as</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、決してでなく、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These types do (at least) the following roles:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの型は、以下のロールをする（少なくとも）：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>[Conjecture: Stringy may best be split into 2 roles where both Str and Blob compose the more general one and just Str composes a less general one.</seg></tuv>
  <tuv xml:lang="JA"><seg>［推測しなさい：StringyはStrとBlobがより一般的なものを組み立てる2つのロールに最も分けられるかもしれない、そして、ちょうどStrはより少ない一般1を組み立てる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The more general of those would apply to what is common to any dense sequence (&amp;quot;string&amp;quot;) that Str and Blob both are (either of characters or bits or integers etc), and the string operators like catenation (~) and replication (x, xx) would be part of the more general role.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらでより一般的なものは何がStrとBlobが両方ともそうである（文字またはビットまたは整数のどちらでもその他）何か高密度配列（「文字列」）に共通かについてあてはまる、そして、列演算子はカテネーション（~）を好む、そして、複製（x、xx）はより多くの一般ロールの一部である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The more specific role would apply to Str but not Blob and includes any specific operators that are specific to characters and don't apply to bits or integers etc. The other alternative is to more clearly distance character strings from bit strings, keeping ~/etc for character strings only and adding an analogy for bit strings.]</seg></tuv>
  <tuv xml:lang="JA"><seg>より特定のロールがBlobでなくStrに申し込んで、文字に特有で、ビットまたは整数その他に申し込まない何か特定の演算子を含むほど選択肢はより明らかに文字文字列をビット列から遠ざけるためにより別である。そして、文字文字列のためにだけ~/etcをとっておいて、ビット列のために類似を加える。］</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Iterable role indicates not that you can iterate the type directly, but that you can request the type to return an iterator.</seg></tuv>
  <tuv xml:lang="JA"><seg>Iterableロールは、あなたが直接型を繰り返すことができて、でなく、あなたが型に反復子を返るよう求めることができることを示す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Iterable types may have multiple iterators (lists) running across them simultaneously, but an iterator/list itself has only one thread of consumption.</seg></tuv>
  <tuv xml:lang="JA"><seg>Iterableな型には同時にそれらに出会っている複数の反復子（リスト）があるかもしれない、しかし、反復子/リストそのものは消費の1つのスレッドだけを持つ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Every time you do get on an iterator, a value disappears from its list.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが反復子でgetをするすべての時、値はそのリストから消える。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that Set, Bag, and Mix iterators return only keys, not values.</seg></tuv>
  <tuv xml:lang="JA"><seg>Set、BagとMix反復子がキー（値でない）だけを返ることに注意すべきである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You must explicitly use c&amp;lt;.pairs&amp;gt; to get key/value pairs.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、cをはっきりと使わなければならない&amp;lt;キー/値組を得る.pairs＞。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Mutable types</seg></tuv>
  <tuv xml:lang="JA"><seg>変わりやすい型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Objects with these types have distinct .WHICH values that do not change even if the object's contents change.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの型によるオブジェクトは、たとえオブジェクトの内容が変わるとしても、変わらない異なった.WHICH値を持つ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Routines are considered mutable because they can be wrapped in place.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（それらが適所に包まれることができるので、ルーチンは変わりやすいと考えられる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The QuantHash role differs from a normal Associative hash in how it handles default values.</seg></tuv>
  <tuv xml:lang="JA"><seg>QuantHashロールは、通常のAssociativeハッシュと、それがデフォルト値を取り扱う方法において異なる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the value of a QuantHash element is set to the default value for the QuantHash, the element is deleted.</seg></tuv>
  <tuv xml:lang="JA"><seg>QuantHash要素の値がQuantHashのためにデフォルト値にセットされるならば、要素はアンインストール済みである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If undeclared, the default default for a QuantHash is 0 for numeric types, False for boolean types, and the null string for string and buffer types.</seg></tuv>
  <tuv xml:lang="JA"><seg>宣言されていないならば、QuantHashのためのデフォルトデフォルトは数値型のための0、論理型のためのFalseと文字列とバッファタイプの空文字列である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A QuantHash of an object type defaults to the undefined prototype for that type.</seg></tuv>
  <tuv xml:lang="JA"><seg>オブジェクト型のQuantHashは、その型のために未定義プロトタイプにデフォルトでなる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>More generally, the default default is whatever defined value a Nil would convert to for that value type.</seg></tuv>
  <tuv xml:lang="JA"><seg>より通常、デフォルトデフォルトは、Nilがその値型のために変わるどんな定義済み値でもある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A QuantHash of Scalar deletes elements that go to either 0 or the null string.</seg></tuv>
  <tuv xml:lang="JA"><seg>ScalarのQuantHashは、0か空文字列へ行く要素を削除する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A QuantHash also autodeletes keys for normal undefined values (that is, those undefined values that do not contain an unthrown exception).</seg></tuv>
  <tuv xml:lang="JA"><seg>また、autodeletesが通常の未定義値（つまり、unthrown例外を含まないそれらの未定義値）のために観察するQuantHash。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A SetHash is a QuantHash of booleans with a default of False.</seg></tuv>
  <tuv xml:lang="JA"><seg>SetHashは、FalseのデフォルトによるブーリアンのQuantHashである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you use the Hash interface and increment an element of a SetHash its value becomes true (creating the element if it doesn't exist already).</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたがHashインターフェースを使用して、SetHashの要素をインクリメントするならば、その値は真実に（それがすでに存在しないならば、要素を作成する）なる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you decrement the element it becomes false and is automatically deleted.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが要素をデクリメントするならば、それは間違ったようになって、自動的にアンインストール済みである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Decrementing a non-existing value results in a False value.</seg></tuv>
  <tuv xml:lang="JA"><seg>非既存の値をデクリメントすることは、結果としてFalse値になる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Incrementing an existing value results in True.</seg></tuv>
  <tuv xml:lang="JA"><seg>既存の値をインクリメントすることは、結果としてTrueになる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When not used as a Hash (that is, when used as an Array or list or Set object) a SetHash behaves as a Set of its keys. (Since the only possible value of a SetHash is the True value, it need not be represented in the actual implementation with any bits at all.)</seg></tuv>
  <tuv xml:lang="JA"><seg>Hash（つまり、ArrayまたはリストまたはSetオブジェクトとして使われるとき）として使われないとき、SetHashはそのキーのSetとしてふるまう。（SetHashの唯一のあり得る値がTrue値であるので、それはまったく何かビットで実際の実装で表現される必要はない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A BagHash is a QuantHash of UInt with default of 0.</seg></tuv>
  <tuv xml:lang="JA"><seg>BagHashは、0のデフォルトによるUIntのQuantHashである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you use the Hash interface and increment an element of a BagHash its value is increased by one (creating the element if it doesn't exist already).</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたがHashインターフェースを使用して、BagHashの要素をインクリメントするならば、その値は1（それがすでに存在しないならば、要素を作成する）増やされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you decrement the element the value is decreased by one;</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが要素をデクリメントするならば、値は1時までに減少する;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>if the value goes to 0 the element is automatically deleted.</seg></tuv>
  <tuv xml:lang="JA"><seg>値が0へ行くならば、要素は自動的にアンインストール済みである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An attempt to decrement a non-existing value returns a Failure value. When not used as a Hash (that is, when used as an Array or list or Bag object) a BagHash behaves as a Bag of its keys, with each key replicated the number of times specified by its corresponding value.</seg></tuv>
  <tuv xml:lang="JA"><seg>非既存の値をデクリメントする試みは、Failure値を返る。BagHashがそのキーのBagとして行儀よくするHash（つまり、ArrayまたはリストまたはBagオブジェクトとして使われるとき）として使われないとき、各々で、キーはその相当値で特定された回数を複製した。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Use .kv or .pairs to suppress this behavior in list context.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（リストコンテキストでこのふるまいを抑えるために、.kvまたは.pairsを使いなさい。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As with Hash types, Pair and PairSeq are mutable in their values but not in their keys.</seg></tuv>
  <tuv xml:lang="JA"><seg>Hash型と同様に、PairとPairSeqは、彼らのキーでなく彼らの値で変わりやすい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(A key can be a reference to a mutable object, but cannot change its .WHICH identity.</seg></tuv>
  <tuv xml:lang="JA"><seg>（キーは可変対象物への言及でありえるが、その.WHICHアイデンティティを変えることができない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In contrast, the value may be rebound to a different object, just as a hash element may.)</seg></tuv>
  <tuv xml:lang="JA"><seg>対照的に、ちょうどハッシュ要素がそうするかもしれなくて、値は異なるオブジェクトに再結合されるかもしれない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The following roles are supported:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下のロールはサポートされる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Types that do the List role are generally hidden from casual view, since iteration is typically triggered by context rather than by explicit call to the iterator's .get method.</seg></tuv>
  <tuv xml:lang="JA"><seg>繰り返しが反復子の.getメソッドへの明示的呼び出しによってよりもむしろ前後関係によって典型的に引き起こされる時から、Listロールをする型は通常、さりげない見方から隠される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Filehandles are a notable exception.</seg></tuv>
  <tuv xml:lang="JA"><seg>ファイルハンドルは、顕著な例外である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See &amp;quot;Wrapping&amp;quot; in S06 for a discussion of soft vs. hard routines.</seg></tuv>
  <tuv xml:lang="JA"><seg>柔らかい対難しいルーチンに関する議論のために、S06で&amp;quot;Wrapping&amp;quot;を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Of types</seg></tuv>
  <tuv xml:lang="JA"><seg>型の</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Explicit types are optional.</seg></tuv>
  <tuv xml:lang="JA"><seg>明示的型はオプションである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl variables have two associated types:</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl変数には、2つの関連した型がある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>their &amp;quot;of type&amp;quot; and their &amp;quot;container type&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>彼ら「型」と彼らの「コンテナ型」の。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(More generally, any container has a container type, including subroutines and modules.) The of type is stored as its of property, while the container type of the container is just the object type of the container itself.</seg></tuv>
  <tuv xml:lang="JA"><seg>コンテナのコンテナ型がちょうどコンテナ自体のオブジェクト型である間、of型はそのofの資産として保存される（より通常、何かコンテナはコンテナ型（サブルーチンとモジュールを含む）を持つ。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The word returns is allowed as an alias for of.</seg></tuv>
  <tuv xml:lang="JA"><seg>ワードreturnsは、ofの別名として許される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The of type specifies what kinds of values may be stored in the variable.</seg></tuv>
  <tuv xml:lang="JA"><seg>of型は、どんな種類の値が変数に保管されるかもしれないかについて指定する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An of type is given as a prefix or with the of keyword:</seg></tuv>
  <tuv xml:lang="JA"><seg>of型は、接頭辞として、または、ofキーワードで与えられる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In either case this sets the of property of the container to Dog.</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれにせよ、これはコンテナのofプロパティをDogに設定する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may not mix these notations;</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの表記法を混ぜなくてもよい;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>if you do, a compiler error will result.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたがそうするならば、コンパイラエラーは起こる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An of type on an array or hash specifies the type stored by each element:</seg></tuv>
  <tuv xml:lang="JA"><seg>配列またはハッシュに関するof型は、各々の要素で保存される型を指定する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The key type of a hash may be specified as a shape trait--see S09.</seg></tuv>
  <tuv xml:lang="JA"><seg>ハッシュのキー型は形トレイトとして指定されるかもしれない－S09を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Containers enforce type safety on setting, whereas subroutines enforce type safety on return.</seg></tuv>
  <tuv xml:lang="JA"><seg>コンテナは型安全をセッティングに強制する、ところが、サブルーチンは型安全を復帰に強制する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The returns declarations is an alias for the of type of a subroutine.</seg></tuv>
  <tuv xml:lang="JA"><seg>returns宣言、ofの別名は、サブルーチンの型である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To coerce your return value, use a coercion type:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたの戻り値を強制して、強制型を使うこと：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For a container, however, use of a coercion type as the of coerces upon setting rather than returning the value.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、コンテナのために、ofとしての強制型の使用は、返ることよりもむしろセッティングと同時に、値を強制する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Container types</seg></tuv>
  <tuv xml:lang="JA"><seg>コンテナ型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The container type specifies how the variable itself is implemented.</seg></tuv>
  <tuv xml:lang="JA"><seg>コンテナ型は、変数自体がどのように実装されるかについて指定する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is given as a trait of the variable:</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、変数のトレイトとして与えられる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Defining a container type is the Perl 6 equivalent to tying a variable in Perl 5.</seg></tuv>
  <tuv xml:lang="JA"><seg>コンテナ型を定義することは、Perl 5で変数を結合することに等しいPerl 6である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>But Perl 6 variables are tied directly at declaration time, and for performance reasons may not be tied with a run-time tie statement unless the variable is explicitly declared with a container type that does the Tieable role.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、Perl 6変数は宣言時間に直接結合されて、パフォーマンス理由のために、変数がTieableロールをするコンテナ型ではっきりと宣言されない限り実行時tie文で結合されないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, package variables are always considered Tieable by default.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、パッケージ変数は、デフォルトで常によく考えたTieableである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As a consequence, all named packages are also Tieable by default.</seg></tuv>
  <tuv xml:lang="JA"><seg>結果として、すべての挙げられたパッケージは、デフォルトでTieableでもある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Classes and modules may be viewed as differently tied packages.</seg></tuv>
  <tuv xml:lang="JA"><seg>クラスとモジュールは、違って結合されたパッケージとして見られるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Looking at it from the other direction, classes and modules that wish to be bound to a global package name must be able to do the Package role.</seg></tuv>
  <tuv xml:lang="JA"><seg>縛られていることを望む他の方向、クラスとモジュールから世界的なパッケージ名までそれを見ることは、Packageロールをすることができなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hierarchical types</seg></tuv>
  <tuv xml:lang="JA"><seg>階層型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A non-scalar type may be qualified, in order to specify what type of value each of its elements stores:</seg></tuv>
  <tuv xml:lang="JA"><seg>その要素の各々がどんなタイプの値を保存するかについて指定するために、非スカラー型型は資格がある場合がある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Each successive of makes the type on its right a parameter of the type on its left.</seg></tuv>
  <tuv xml:lang="JA"><seg>各々の連続したofは、右の上の型をその左の上の型のパラメータとする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Parametric types are named using square brackets, so:</seg></tuv>
  <tuv xml:lang="JA"><seg>パラメータの型は、そう、角括弧を使って挙げられる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>actually means:</seg></tuv>
  <tuv xml:lang="JA"><seg>実は、以下を意味する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>which is:</seg></tuv>
  <tuv xml:lang="JA"><seg>そしてそれは以下の通りである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Because the actual variable can be hard to find when complex types are specified, there is a postfix form as well:</seg></tuv>
  <tuv xml:lang="JA"><seg>複素数型が指定されるとき実際の変数が見つけるのが難しくありえるので、接尾辞の形態が同様にある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Alternately, the return type may be specified within the signature:</seg></tuv>
  <tuv xml:lang="JA"><seg>あるいは、戻り型は、シグネチャの中で指定されるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may also specify the type as the of trait (with returns allowed as a synonym):</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、ofトレイト（同義語としてreturnsを許す）として、型を指定もするかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Parameter types</seg></tuv>
  <tuv xml:lang="JA"><seg>パラメーターの型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Parameters may be given types, just like any other variable:</seg></tuv>
  <tuv xml:lang="JA"><seg>パラメータは、型（ちょうど気まぐれな他の人のような）を与えられるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Generic types</seg></tuv>
  <tuv xml:lang="JA"><seg>汎用的な型</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Within a declaration, a class variable (either by itself or following an existing type name) declares a new type name and takes its parametric value from the actual type of the parameter it is associated with.</seg></tuv>
  <tuv xml:lang="JA"><seg>宣言の範囲内で、クラス変数（それ自体または既存のタイプ名に続くことによって）は新しいタイプ名を宣言して、それが関連するパラメータの実際の型から、そのパラメータの値をとる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It declares the new type name in the same scope as that of the associated declaration.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、関連した宣言のそれと同じスコープで、新しいタイプ名を宣言する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The new type name is introduced immediately, so two such types in the same signature must unify compatibly if they have the same name:</seg></tuv>
  <tuv xml:lang="JA"><seg>新しいタイプ名はすぐに持ち出されるので、それらには同じ名前があるならば、同じシグネチャのそのような2つの型は両立できるようにひとつにならなければならない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Cool class (and package)</seg></tuv>
  <tuv xml:lang="JA"><seg>Coolクラス（そして、パッケージ）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Cool type is derived from Any, and contains all the methods that are &amp;quot;cool&amp;quot; (as in, &amp;quot;I'm cool with an argument of that type.&amp;quot;).</seg></tuv>
  <tuv xml:lang="JA"><seg>Cool型はAnyに由来して、クールである（中であって、私はその型の引数でクールである。）すべてのメソッドを含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>More specifically, these are the methods that are culturally universal, insofar as the typical user will expect the name of the method to imply conversion to a particular built-in type that understands the method in question.</seg></tuv>
  <tuv xml:lang="JA"><seg>より詳しくは、典型的ユーザーがメソッドの名前が問題のメソッドを理解する特定の組込み型への転換を意味すると思う限り、これらは文化的に一般的であるメソッドである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For instance, $x.abs implies conversion to an appropriate numeric type if $x is &amp;quot;cool&amp;quot; but doesn't already support a method of that name.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、$xが涼しいが、その名前のメソッドをすでにサポートしないならば、$x.absは適正数値型への転換を意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Conversely, $x.substr implies conversion to a string or buffer type.</seg></tuv>
  <tuv xml:lang="JA"><seg>反対に、$x.substrは文字列またはバッファタイプへの転換を意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Cool module also contains all multisubs of last resort;</seg></tuv>
  <tuv xml:lang="JA"><seg>Coolモジュールも、最後の手段のすべてのmultisubsを含む;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>these are automatically searched if normal multiple dispatch does not find a viable candidate.</seg></tuv>
  <tuv xml:lang="JA"><seg>通常の複数のディスパッチが生存可能な候補を見つけないならば、これらは自動的に捜される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that the Cool package is mutable, and both single and multiple dispatch must take into account changes there for the purposes of run-time monkey patching.</seg></tuv>
  <tuv xml:lang="JA"><seg>Coolパッケージが変わりやすいことに注意すべきである、そして、一つで複数のディスパッチは実行時モンキーパッチングのために変化をそこで考慮しなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, since the multiple dispatcher uses the Cool package only as a failover, compile-time analysis of such dispatches is largely unaffected for any arguments with an exact or close match.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、複数のディスパッチャがフェールオーバだけとしてCoolパッケージを使用する時から、そのようなディスパッチのコンパイル時分析は主に正確であるか近いマッチで何か引数のために影響を受けない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Likewise any single dispatch a method that is more specific than the Cool class is not affected by the mutability of Cool.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、一つの何でも、CoolクラスがCoolの移り気に影響を受けないより、はっきりしているメソッドを送る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>User-defined classes don't derive from Cool by default, so such classes are also unaffected by changes to Cool.</seg></tuv>
  <tuv xml:lang="JA"><seg>ユーザー定義のクラスはデフォルトでCoolに由来しないので、そのようなクラスはCoolに変化にも影響を受けない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Names and Variables</seg></tuv>
  <tuv xml:lang="JA"><seg>名前と変数</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Apostrophe separator</seg></tuv>
  <tuv xml:lang="JA"><seg>アポストロフィセパレーター</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The $Package'var syntax is gone.</seg></tuv>
  <tuv xml:lang="JA"><seg>$Package'var構文はなくなる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use $Package::var instead.</seg></tuv>
  <tuv xml:lang="JA"><seg>その代わりに$Package::varを使いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Note, however, that identifiers may now contain an apostrophe or hyphen if followed by a character matching &amp;lt;.alpha&amp;gt;)</seg></tuv>
  <tuv xml:lang="JA"><seg>（しかし、&amp;lt;.alpha&amp;gt;にマッチしている文字が続くならば、識別子が現在アポストロフィまたはハイフンを含むかもしれない点に注意しなさい）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Sigils</seg></tuv>
  <tuv xml:lang="JA"><seg>シギル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 includes a system of sigils to mark the fundamental structural type of a variable:</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6は、基本的な構造様式変数の世代に跡を残すために、シギルのシステムを含む：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Within a declaration, the &amp;amp; sigil also declares the visibility of the subroutine name without the sigil within the scope of the declaration:</seg></tuv>
  <tuv xml:lang="JA"><seg>宣言の範囲内で、&amp;amp;シギルも、シギルなしでサブルーチン名の可視性を宣言の範囲内であると宣言する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Within a signature or other declaration, the :: pseudo-sigil followed by an identifier marks a type variable that also declares the visibility of a package/type name without the sigil within the scope of the declaration.</seg></tuv>
  <tuv xml:lang="JA"><seg>シグネチャまたは他の宣言の範囲内で、識別子が続く::疑似シギルは、また、シギルなしでパッケージ/型名の可視性を宣言の範囲内であると宣言する型変数に跡を残す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The first such declaration within a scope is assumed to be an unbound type, and takes the actual type of its associated argument.</seg></tuv>
  <tuv xml:lang="JA"><seg>スコープの中の第1のそのような宣言は、束縛を解かれた型であるとされて、その関連した引数の実際の型をする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>With subsequent declarations in the same scope the use of the pseudo-sigil is optional, since the bare type name is also declared.</seg></tuv>
  <tuv xml:lang="JA"><seg>裸のタイプ名も宣言される時から、同じスコープの以降の宣言で、疑似シギルの使用はオプションである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A declaration nested within must not use the sigil if it wishes to refer to the same type, since the inner declaration would rebind the type.</seg></tuv>
  <tuv xml:lang="JA"><seg>内部の宣言が型を再結合する時から、それが同一性に言及することを望むならば、入れ子にされる宣言はシギルを使ってはならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Note that the signature of a pointy block counts as part of the inner block, not the outer block.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（とがったブロックのシグネチャが内側ブロック（外側ブロックでない）の一部と見なされることに注意すべきである。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Sigils indicate interface</seg></tuv>
  <tuv xml:lang="JA"><seg>シギルは、インターフェースを示す</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Sigils indicate overall interface, not the exact type of the bound object.</seg></tuv>
  <tuv xml:lang="JA"><seg>シギルは、全体的なインターフェース（縛られたオブジェクトの正確な型でない）を示す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Different sigils imply different minimal abilities.</seg></tuv>
  <tuv xml:lang="JA"><seg>異なるシギルは、異なる最小の能力を意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>$x may be bound to any object, including any object that can be bound to any other sigil.</seg></tuv>
  <tuv xml:lang="JA"><seg>$xは、何かオブジェクト（他のどのシギルの束縛を受けることもありえる何かオブジェクトを含む）の束縛を受ける場合がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Such a scalar variable is always treated as a singular item in any kind of list context, regardless of whether the object is essentially composite or unitary.</seg></tuv>
  <tuv xml:lang="JA"><seg>オブジェクトが基本的に合成であるか単位を構成するか否かを問わず、そのようなスカラー変数は常にどんなリストコンテキストの他に類のないアイテムとでもみなされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It will not automatically dereference to its contents unless placed explicitly in some kind of dereferencing context.</seg></tuv>
  <tuv xml:lang="JA"><seg>はっきりと何らかの間接参照前後関係に置かれない限り、それは自動的に内容に間接参照を遺贈しない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In particular, when interpolating into list context, $x never expands its object to anything other than the object itself as a single item, even if the object is a container object containing multiple items.</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、リストコンテキストに改竄するとき、たとえオブジェクトが複数のアイテムを含んでいるコンテナオブジェクトであるとしても、$xは一つのアイテムとしてもそのオブジェクトをオブジェクトそのもの以外の何にも決して拡大しない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>@x may be bound to an object of the Array class, but it may also be bound to any object that does the Positional role, such as a Range, Buf, Parcel, or Capture.</seg></tuv>
  <tuv xml:lang="JA"><seg>@xはArrayクラスのオブジェクトの束縛を受ける場合がある、しかし、それはPositionalロール（例えばRange、Buf、ParcelまたはCapture）をする何かオブジェクトの束縛を受ける場合もある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Positional role implies the ability to support postcircumfix:&amp;lt;[ ]&amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>Positionalロールは、postcircumfix:&amp;lt;[ ]&amp;gt;をサポートする能力を意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Likewise, %x may be bound to any object that does the Associative role, such as Pair, PairSet, Set, Bag, Mix, or Capture.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、%xは、Associativeロール（例えばPair、PairSet、Set、Bag、MixまたはCapture）をする何かオブジェクトの束縛を受ける場合がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Associative role implies the ability to support postcircumfix:&amp;lt; &amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>Associativeロールは、postcircumfix:&amp;lt; &amp;gt;をサポートする能力を意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>&amp;amp;x may be bound to any object that does the Callable role, such as any Block or Routine.</seg></tuv>
  <tuv xml:lang="JA"><seg>&amp;amp;xは、Callableロール（例えば何かBlockまたはRoutine）をする何かオブジェクトの束縛を受ける場合がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Callable role implies the ability to support postcircumfix:&amp;lt;( )&amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>Callableロールは、postcircumfix:&amp;lt;( )&amp;gt;をサポートする能力を意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In any case, the minimal container role implied by the sigil is checked at binding time at the latest, and may fail earlier (such as at compile time) if a semantic error can be detected sooner.</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれにせよ、シギルによってほのめかされる最小のコンテナロールは、遅くともバインディング時でチェックされて、意味上の誤りがよりすぐに見つけられることができるならば以前に失敗する場合がある（例えばコンパイル時で）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you wish to bind an object that doesn't yet do the appropriate role, you must either stick with the generic $ sigil, or mix in the appropriate role before binding to a more specific sigil.</seg></tuv>
  <tuv xml:lang="JA"><seg>適正ロールをまだしないオブジェクトを結びつけたいならば、あなたは一般的な$シギルに固執しなければならないか、より特定のシギルにバインディングの前に適正ロールを混ぜなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An object is allowed to support both Positional and Associative.</seg></tuv>
  <tuv xml:lang="JA"><seg>オブジェクトは、PositionalとAssociativeをサポートするのを許可される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An object that does not support Positional may not be bound directly to @x.</seg></tuv>
  <tuv xml:lang="JA"><seg>Positionalをサポートしないオブジェクトは、直接@xの束縛を受けない場合がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, any construct such as %x that can interpolate the contents of such an object into list context can automatically construct a list value that may then be bound to an array variable.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、リストコンテキストにそのようなオブジェクトの内容を差し込むことができる%xのような何か構成概念は、それから配列変数の束縛を受ける場合があるリスト値を自動的に造ることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Subscripting such a list does not imply subscripting back into the original object.</seg></tuv>
  <tuv xml:lang="JA"><seg>リストのような添え字付けは、最初のオブジェクトへと添え字付けを意味しない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>No intervening whitespace</seg></tuv>
  <tuv xml:lang="JA"><seg>中の空白文字でない</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unlike in Perl 5, you may no longer put whitespace between a sigil and its following name or construct.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 5のとは異なり、シギルとその以下の名前または構成概念の間に空白文字をもはや置かなくてもよい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Twigils</seg></tuv>
  <tuv xml:lang="JA"><seg>Twigils</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Ordinary sigils indicate normally scoped variables, either lexical or package scoped.</seg></tuv>
  <tuv xml:lang="JA"><seg>普通のシギルは通常捜し出された変数を示す。そして、語彙的であるか、捜し出されて一括である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Oddly scoped variables include a secondary sigil (a twigil) that indicates what kind of strange scoping the variable is subject to:</seg></tuv>
  <tuv xml:lang="JA"><seg>妙に捜し出された変数は、変数がどんな変なスコーピングを受けるかについて示す第二のシギル（twigil）を含む：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Most variables with twigils are implicitly declared or assumed to be declared in some other scope, and don't need a &amp;quot;my&amp;quot; or &amp;quot;our&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>twigilsによる大部分の変数が、暗黙のうちに宣言されるか、若干の他のスコープで宣言されるとされて、&amp;quot;my&amp;quot;または&amp;quot;our&amp;quot;を必要でない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Attribute variables are declared with has, though.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、属性変数は、hasで宣言される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Scope declarators</seg></tuv>
  <tuv xml:lang="JA"><seg>スコープ宣言</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Normal names and variables are declared using a scope declarator:</seg></tuv>
  <tuv xml:lang="JA"><seg>通常の名前と変数は、スコープ宣言を使って宣言される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Names may also be declared in the signature of a function.</seg></tuv>
  <tuv xml:lang="JA"><seg>名前は、関数のシグネチャで宣言されもするかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These are equivalent to a my declaration inside the block of the function, except that such parameters default to readonly.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらは関数のブロック内でmy宣言に等しいが、そのようなパラメータはreadonlyなものにデフォルトでなる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The anon declarator allows a declaration to provide a name that can be used in error messages, but that isn't put into any external symbol table:</seg></tuv>
  <tuv xml:lang="JA"><seg>anon宣言は、宣言をエラーメッセージで使われることができる、しかし、少しも外部シンボルテーブルに入れられない名前を提供させる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, the name is introduced into the scope of the declaration itself, so it may be used to call itself recursively:</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、名前は宣言そのもののスコープにもたらされるので、それは再帰的に以下を名乗るのに用いられるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Invariant sigils</seg></tuv>
  <tuv xml:lang="JA"><seg>不変のシギル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Sigils are now invariant.</seg></tuv>
  <tuv xml:lang="JA"><seg>シギルは、現在不変である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>$ always means a scalar variable, @ an array variable, and % a hash variable, even when subscripting.</seg></tuv>
  <tuv xml:lang="JA"><seg>$は常にスカラー変数を意味する。そして、@が配列変数である、そして、添え字付けときでも、%がハッシュ変数である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In item context, variables such as @array and %hash simply return themselves as Array and Hash objects.</seg></tuv>
  <tuv xml:lang="JA"><seg>アイテム前後関係では、@arrayと%hashのような変数は、単にArrayとHashオブジェクトとして自分自身を返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Item context was formerly known as scalar context, but we now reserve the &amp;quot;scalar&amp;quot; notion for talking about variables rather than contexts, much as arrays are disassociated from list context.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（アイテム前後関係は以前スカラーコンテキストとして知られていた、しかし、非常に配列がリストコンテキストから分離されて、我々は現在「スカラー」概念を前後関係よりもむしろ変数について話すことに確保する。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>List stringification</seg></tuv>
  <tuv xml:lang="JA"><seg>リストstringification</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In string contexts, lists and list-like objects automatically stringify to appropriate (white-space separated) string values.</seg></tuv>
  <tuv xml:lang="JA"><seg>ストリングコンテキストでは、リストとリストのようなオブジェクトは、適正（空白文字は分かれた）に、文字列値を自動的にstringifyする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In numeric contexts, the number of elements in the container is returned.</seg></tuv>
  <tuv xml:lang="JA"><seg>数値コンテキストでは、コンテナの要素数は、返納印である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In boolean contexts, a true value is returned if and only if there are any elements in the container.</seg></tuv>
  <tuv xml:lang="JA"><seg>ブール値コンテキストでは、何か要素がコンテナの中にある場合に限り、真値は返納印である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The .perl method</seg></tuv>
  <tuv xml:lang="JA"><seg>.perlメソッド</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To get a Perlish representation of any object, use the .perl method.</seg></tuv>
  <tuv xml:lang="JA"><seg>何かオブジェクトのPerlish表現を得るために、.perlメソッドを使用しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Like the Data::Dumper module in Perl 5, the .perl method will put quotes around strings, square brackets around list values, curlies around hash values, constructors around objects, etc., so that Perl can evaluate the result back to the same object.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 5でData::Dumperモジュールのようで、.perlメソッドは文字列のあたりの引用、リスト値のあたりの角括弧、ハッシュ値のあたりのcurlies、オブジェクトなどのあたりのコンストラクタを置く、そのため、Perlは同じオブジェクトへ結果を評価することができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The .perl method will return a representation of the object on the assumption that, if the code is reparsed at some point, it will be used to regenerate the object as a scalar in item context.</seg></tuv>
  <tuv xml:lang="JA"><seg>.perlメソッドは、コードが数ポイントで再解析されるならば、それがアイテム前後関係のスカラーとしてオブジェクトを再生させるのに用いられるという仮定に関して、オブジェクトの表現を返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you wish to interpolate the regenerated object in a list context, it may be necessary to use prefix:&amp;lt;|&amp;gt; to force interpolation.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが再生するオブジェクトをリストコンテキストに勝手に入れたいならば、改竄者を押しつけるためにprefix:&amp;lt;|&amp;gt;を使うことが必要である場合がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that .perl has a very specific definition, and it is expected that some modules will rely on the ability to roundtrip values with EVAL.</seg></tuv>
  <tuv xml:lang="JA"><seg>.perlが非常に特定の定義を持つことに注意すべきである、そして、若干のモジュールがEVALでroundtrip値に能力に頼ると予想される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As such, overriding .perl with a different format (globally using MONKEY_TYPING, or for specific classes unless special care is taken to maintain parsability) is unwise.</seg></tuv>
  <tuv xml:lang="JA"><seg>それ自体、異なるフォーマットによる.perlをオーバーライドする（グローバルに使う｛MONKEY_TYPING｝こと、または、特別な世話が好きになられない限り、特定クラスについては、parsabilityを維持しなさい）賢明でない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Code which does not depend on .perl's definition should use .gist instead to allow more control.</seg></tuv>
  <tuv xml:lang="JA"><seg>載って.perlがそうである依存をしないコード、定義は、より多くの支配を許すために、その代わりに.gistを使わなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The .gist method</seg></tuv>
  <tuv xml:lang="JA"><seg>.gistメソッド</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>.gist, by contrast with .perl, returns a flexible form of an object intended for human interpretation.</seg></tuv>
  <tuv xml:lang="JA"><seg>.gist、.perlとの対照によって、人間の字句解釈を意図されるオブジェクトの柔軟体は、返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Specific user classes are encouraged to override .gist to do something appropriate, and it is completely acceptable to monkey patch .gist methods while doing debugging, without risk of breaking any used module.</seg></tuv>
  <tuv xml:lang="JA"><seg>特定のユーザクラスは適切な何かをするために.gistにオーバーライドするのを奨励される、そして、デバッギングをしている間、それはモンキーパッチ.gistメソッドにとって完全に容認できる、何か中古のモジュールをこわす危険なしで。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>.gist, like any method, will accept and ignore unrecognized named arguments;</seg></tuv>
  <tuv xml:lang="JA"><seg>.gist（何かメソッドのような）は、認められていない名をつけられた引数を受け入れて、無視する;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>implementations of .gist are encouraged to standardize on a set of flags.</seg></tuv>
  <tuv xml:lang="JA"><seg>.gistの実装は、一組のフラグの上で標準化するように促される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>[Some conjectural suggestions:</seg></tuv>
  <tuv xml:lang="JA"><seg>［いくらかの推測的な提案：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Conjecturally, .gist on system-defined classes could redispatch to &amp;amp;*PRETTYPRINTER or some similar system, allowing for a more disciplined way to change pretty formats.</seg></tuv>
  <tuv xml:lang="JA"><seg>推測で、より規律を守る方法がかわいいフォーマットを変えるのを許して、システム定義のクラスの.gistは、&amp;amp;*PRETTYPRINTERまたは若干の類似したシステムにredispatchにそうすることができた。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It may also be desirable to use a richer format for intermediate strings than simple Str, for instance using an object format that can handle intelligent line breaking.</seg></tuv>
  <tuv xml:lang="JA"><seg>中間の文字列のために単純なStr（たとえば知的な行分けを取り扱うことができるオブジェクトフォーマットを用いた）より豊かなフォーマットを使うことは、望ましい場合もある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, that's probably overkill.]</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、それは多分過剰であるだろう。］</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The .fmt method</seg></tuv>
  <tuv xml:lang="JA"><seg>.fmtメソッド</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To get a formatted representation of any scalar value, use the .fmt('%03d') method to do an implicit sprintf on the value.</seg></tuv>
  <tuv xml:lang="JA"><seg>何かスカラー値のフォーマット化された表現を得るために、値の上で潜在的なsprintfをするために、.fmt('%03d')メソッドを使用しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To format an array value separated by commas, supply a second argument:</seg></tuv>
  <tuv xml:lang="JA"><seg>コンマで区切られる配列値をフォーマット化して、2回目の引数を供給すること：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>.fmt('%03d', ', ').</seg></tuv>
  <tuv xml:lang="JA"><seg>.fmt('%03d', ', ')。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To format a hash value or list of pairs, include formats for both key and value in the first string:</seg></tuv>
  <tuv xml:lang="JA"><seg>組のハッシュ値またはリストの書式を設定して、ファーストストリングでキーと値のためにフォーマットを含むこと：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>.fmt('%s:%s', &amp;quot;\n&amp;quot;).</seg></tuv>
  <tuv xml:lang="JA"><seg>.fmt('%s:%s', &amp;quot;\n&amp;quot;)。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Subscripts</seg></tuv>
  <tuv xml:lang="JA"><seg>添え字</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Subscripts now consistently dereference the container produced by whatever was to their left.</seg></tuv>
  <tuv xml:lang="JA"><seg>添え字は、彼らの左にあったものは何によってでも生産されるコンテナを現在一貫して間接参照する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whitespace is not allowed between a variable name and its subscript.</seg></tuv>
  <tuv xml:lang="JA"><seg>空白文字は、変数名とその添え字の間で許されない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, there are two ways to stretch the construct out visually.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、2つの方法が、視覚的に構成概念を伸ばすためにある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since a subscript is a kind of postfix operator, there is a corresponding dot form of each subscript (@foo.[1] and %bar.'a') that makes the dereference a little more explicit.</seg></tuv>
  <tuv xml:lang="JA"><seg>添え字が一種の後置演算子であるので、もう少し間接参照を明示的にする各々の添え字（@foo.[1]と%bar.'a'）の対応する点の形態がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Constant string subscripts may be placed in angles, so %bar.'a' may also be written as %bar&amp;lt;a&amp;gt; or %bar.&amp;lt;a&amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>定数列添え字は角度に置かれるかもしれないので、%bar.'a'は%bar&amp;lt;a&amp;gt;または%bar.&amp;lt;a&amp;gt;としても書かれるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Additionally, you may insert extra whitespace using the unspace.</seg></tuv>
  <tuv xml:lang="JA"><seg>その上、あなたは、unspaceを使っている余分の空白文字を付け加えるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Slicing is specified by the nature of the subscript, not by the sigil.</seg></tuv>
  <tuv xml:lang="JA"><seg>シギルによってでなく、スライスは添え字の性質によって指定される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Subscripts have list context</seg></tuv>
  <tuv xml:lang="JA"><seg>添え字には、リストコンテキストがある</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The context in which a subscript is evaluated is no longer controlled by the sigil either.</seg></tuv>
  <tuv xml:lang="JA"><seg>添え字が評価される前後関係は、シギルによってももはやコントロールされない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Subscripts are always evaluated in list context.</seg></tuv>
  <tuv xml:lang="JA"><seg>添え字は、常にリストコンテキストで評価される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(More specifically, they are evaluated in a variant of list context known as lol context (List of List), which preserves dimensional information so that you can do multi-dimensional slices using semicolons.</seg></tuv>
  <tuv xml:lang="JA"><seg>（より詳しくは、それらはlol前後関係（リストのリスト）として知られているリストコンテキストの変形で評価される。そして、あなたがセミコロンを使っている多次元スライスをすることができるように、それは次元の情報を保存する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, each slice dimension evaluates its sublist in normal list context, so functions called as part of a subscript don't see a lol context.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、各々のスライス次元は通常のリストコンテキストでそのサブリストを評価するので、添え字の一部として呼ばれる関数はlol前後関係がわからない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See S09 for more on slicing.)</seg></tuv>
  <tuv xml:lang="JA"><seg>スライスの詳細についてS09を見なさい。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you need to force inner context to item (scalar), we now have convenient single-character context specifiers such as + for numbers and ~ for strings:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたがアイテム（段階的な）に内部の前後関係を強制する必要があるならば、我々には現在文字列のために数と~のために+のような便利な単一キャラクター前後関係指示子がある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Sigils used as functions with parenthesis also force context, so these also work:</seg></tuv>
  <tuv xml:lang="JA"><seg>括弧に対する関数としても使われるシギルは前後関係を強制するので、これらも動く：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>But note that these don't do the same thing:</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、これらが同じことをしない点に注意する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Array and Hash variables can be evaluated in item context by prefixing them with a single dollar sign:</seg></tuv>
  <tuv xml:lang="JA"><seg>配列とハッシュ変数は、一つのドル記号でそれらを前に置くことによって、アイテム前後関係で評価されることができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>List assignment and binding</seg></tuv>
  <tuv xml:lang="JA"><seg>リスト割当てとバインディング</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is a need to distinguish list assignment from list binding.</seg></tuv>
  <tuv xml:lang="JA"><seg>リスト割当てとリストバインディングを区別する必要が、ある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>List assignment works much like it does in Perl 5, copying the values.</seg></tuv>
  <tuv xml:lang="JA"><seg>それがPerl 5でするように、リスト割当ては非常に動く。そして、値をコピーする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There's a new := binding operator that lets you bind names to Array and Hash objects without copying, in the same way as subroutine arguments are bound to formal parameters.</seg></tuv>
  <tuv xml:lang="JA"><seg>サブルーチン引数が仮パラメータの束縛を受けるのと同じ方法では、あなたにならい削りなしで名前をArrayとHashオブジェクトに結びつけさせる新しい:=結合性演算子が、ある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See S06 for more about binding.</seg></tuv>
  <tuv xml:lang="JA"><seg>バインディングについてより多くについてはS06を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Parcels</seg></tuv>
  <tuv xml:lang="JA"><seg>パーセル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A list of zero or more comma-separated objects may be grouped together by parentheses into a &amp;quot;parenthesis cell&amp;quot;, or Parcel.</seg></tuv>
  <tuv xml:lang="JA"><seg>0以上コンマで区切られたオブジェクトのリストは、「括弧セル」またはParcelに括弧によって集められるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This kind of list should not be confused with the flattening list context.</seg></tuv>
  <tuv xml:lang="JA"><seg>この種のリストは、平坦化リストコンテキストと混同されてはならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instead, this is a raw syntactic list that has not yet committed to flattening;</seg></tuv>
  <tuv xml:lang="JA"><seg>その代わりに、これは、平らになることにまだ専念しなかった荒々しい構文法のリストである;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>no interpretation is made of the list inside without knowing what context it will be evaluated in. For example, when you say:</seg></tuv>
  <tuv xml:lang="JA"><seg>字句解釈は、あなたが以下のように言うとき、例えば、それがそうであるどんな前後関係がインチを評価したかわかっていることなく、リストで中でできていない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>the result is a Parcel object containing three Int objects and a Pair object, that is, four positional objects.</seg></tuv>
  <tuv xml:lang="JA"><seg>結果は、3つのIntオブジェクトとPairオブジェクト（つまり、4つの位置オブジェクト）を含んでいるParcelオブジェクトである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When, however, you say something like:</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、あなたが以下のような何かを言うとき：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>the syntactic Parcel is translated (at compile time, in this case) into a Capture object with three positionals and one named argument in preparation for binding.</seg></tuv>
  <tuv xml:lang="JA"><seg>構文法のParcelは、バインディングに備えて3つのpositionalsと1つの挙げられた引数でCaptureオブジェクトに変形される（本例で、コンパイル時で）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>More generally, a parcel is transmuted to a capture any time it is bound to a complete signature.</seg></tuv>
  <tuv xml:lang="JA"><seg>より通常、それが完全なシグネチャの束縛を受ける何か時、パーセルはキャプチャーに変えられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may force immediate conversion to a Capture object by prefixing the parcel composer with a backslash:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、バックスラッシュでパーセルコンポーザーを前に置くことによって、Captureオブジェクトへの即時の転換を強制するかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unlike Capture objects, Parcel objects are ephemeral, insofar as the user almost never sees one as a real standalone object, since binding or assignment always turns a parcel into something else.</seg></tuv>
  <tuv xml:lang="JA"><seg>Captureオブジェクトとは異なり、バインディングまたは割当てが常にパーセルを何か他のものに変える時から、ユーザーが1つを本当の独立型オブジェクトとほとんどみなさない限り、Parcelオブジェクトは短命である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A parcel may generally only be preserved as a part of an outer parcel or capture object.</seg></tuv>
  <tuv xml:lang="JA"><seg>パーセルは、通常、外のパーセルの一部またはキャプチャーオブジェクトとして保たれるだけかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Individual arguments in a parcel or capture composer are parsed as ordinary expressions, and any functions mentioned are called immediately, with each function's results placed as an argument (often a subparcel, if the function returns multiple values) within the outer parcel (or capture).</seg></tuv>
  <tuv xml:lang="JA"><seg>パーセルまたはキャプチャーコンポーザーの個々の引数は普通の表現として解析される、そして、各機能の結果が外のパーセル（またはキャプチャー）の中の引数（しばしばsubparcelファンクションリターン多値ならば）とわかって、記載の何か関数はすぐに呼ばれる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whether any given argument is flattened will depend on its eventual binding, and in general cannot be known at parcel/capture composition time.</seg></tuv>
  <tuv xml:lang="JA"><seg>何かされた引数が平らにされるかどうかはその最終的なバインディングに依存する、そして、中で、一般はパーセル/キャプチャー構成時間にわかっていることができない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>We use &amp;quot;argument&amp;quot; here to mean anything that would be taken as a single argument if bound to a positional or named parameter:</seg></tuv>
  <tuv xml:lang="JA"><seg>我々は、位置であるか挙げられたパラメータに密接に結びつくならば、一回の引数としてとられるだろう何でも意味するために、「引数」をここで使う：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In these examples, the first argument to the function is a parcel in all but the first case, where it is simply the literal integer 1.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの例では、関数に対する最初の引数は最初のケース以外はのパーセルである、そこで、それは単に文字通りの整数1である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An argument is either of:</seg></tuv>
  <tuv xml:lang="JA"><seg>引数は、以下のどちらでもある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* A parcel that groups together a sublist, or</seg></tuv>
  <tuv xml:lang="JA"><seg>* サブリストを集めるパーセル、または、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* Any other object that can function as a single argument.</seg></tuv>
  <tuv xml:lang="JA"><seg>* 一回の引数として機能することができる他のどのオブジェクトも。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Looking at it the other way, all arguments that don't actually need to be wrapped up in a parcel are considered degenerate parcels in their own right when it comes to binding.</seg></tuv>
  <tuv xml:lang="JA"><seg>その他の方法でそれを見て、実はパーセルに包まれる必要はないすべての引数は、バインディングに関しては右のよく考えた退歩したパーセルである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that a capture is not considered a kind of parcel, so does not flatten in flat context.</seg></tuv>
  <tuv xml:lang="JA"><seg>キャプチャーがパーセルの1種類考えられなくて、それで、平らな前後関係で平らにならないことに注意すべきである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Parcels, parameters, and Captures</seg></tuv>
  <tuv xml:lang="JA"><seg>パーセル、パラメータとキャプチャー</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When a Parcel is bound to a parameter, the behavior depends on whether the parameter is &amp;quot;flattening&amp;quot; or &amp;quot;argumentative&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>Parcelがパラメータの束縛を受けるとき、ふるまいはパラメータが平らになっているか、論争好きかどうか次第である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Positional parameters and slice parameters are argumentative and call .getarg on the internal iterator and just return the next syntactic argument (parcel or other object) without flattening.</seg></tuv>
  <tuv xml:lang="JA"><seg>位置パラメーターとスライスパラメータは、論争好きで、内部の反復子で.getargを呼んで、ちょうど平らになることなく、次の構文法の引数（パーセルまたは他のオブジェクト）を返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(A slice differs from an ordinary positional parameter in being &amp;quot;slurpy&amp;quot;, that is, it is intended to fetch multiple values from the variadic region of the surrounding capture.</seg></tuv>
  <tuv xml:lang="JA"><seg>（スライスは普通の位置パラメーターと「slurpy」であることにおいて異なる、つまり、それは周囲のキャプチャーのvariadicな地域から多値を取ってくることを意図される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Slurpy contexts come in both flattening (* parameters) and slicing (** parameters) forms.)</seg></tuv>
  <tuv xml:lang="JA"><seg>Slurpy前後関係は、平らになって（*パラメータ）、形をスライスして（**パラメータ）入る。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The fact that a parameter is being bound implies that there is an outer capture being bound to a signature.</seg></tuv>
  <tuv xml:lang="JA"><seg>パラメータが結びつけられているという事実は、シグネチャに密接に結びついている外のキャプチャーがあることを意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The capture's iterator provides a .get and a .getarg method to tell the iterator what context to bind in. For positional/slice parameters, the .getarg method returns the entire next argument from the iterator.</seg></tuv>
  <tuv xml:lang="JA"><seg>キャプチャーの反復子は、どんな前後関係で結合するべきかについて、反復子に話すために、.getと.getargメソッドを提供する。位置/スライスパラメータについては、.getargメソッドは、反復子から全ての次の引数を返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It returns other objects unchanged.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、他のオブジェクトに不変であると返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In contrast, flat parameters call .get on the capture's iterator, which flattens any subparcels before pulling out the next item.</seg></tuv>
  <tuv xml:lang="JA"><seg>対照的に、平らなパラメータはキャプチャーの反復子で.getを呼ぶ。そして、それは次項を引き抜く前に何かsubparcelsを平らにする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In either case, no bare parcel object is seen as a normal bound argument.</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれにせよ、裸のパーセルオブジェクトは、通常の縛られた引数とみなされない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(There is a way to bind the underlying parcel using backslash, however.</seg></tuv>
  <tuv xml:lang="JA"><seg>（方法が、しかし、バックスラッシュを使っている根底にあるパーセルを結びつけるためにある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is how internal routines can deal with parcels as real objects.)</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、内部のルーチンが実物体としてパーセルに対処することができる方法である。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In contrast to parameter binding, if a Parcel is bound to an entire signature (typically as part of a function or method call), it will be transformed first into a capture object, which is much like a parcel but has its arguments divvied up into positional and named subsets for faster binding.</seg></tuv>
  <tuv xml:lang="JA"><seg>パラメータ結合と対照的に、Parcelが全てのシグネチャ（一般的に関数またはメソッドの一部として電話しなさい）の束縛を受けるならば、それは最初にキャプチャーオブジェクトに変わる。そして、それは非常にパーセルのようであるが、その引数をより変わらぬバインディングのために位置で名をつけられたサブセットに分けておく。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Usually this transformation happens at compile time.) If the first positional is followed by a colon instead of a comma, it is marked as the invocant in case it finds itself in a context that cares.</seg></tuv>
  <tuv xml:lang="JA"><seg>位置最初の後にコンマの代わりにコロンが続くならば、気にかける前後関係にいるのに気づく場合に備えて、それはインボカントとして跡を残される（通常、この変化はコンパイル時で起こる。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It's illegal to use the colon in place of the comma anywhere except after the first argument.</seg></tuv>
  <tuv xml:lang="JA"><seg>最初の引数の後あること以外は、どこでもコンマの代わりにコロンを使うことは無効である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Explicit binding to an individual variable is considered a form of signature binding, which is to say a declarator puts implicit signature parens around the unparenthesized form:</seg></tuv>
  <tuv xml:lang="JA"><seg>個別変数へのバインディングがそうである完はシグネチャバインディングの形を考えた。そして、それは宣言がunparenthesizedされた形のまわりに潜在的なシグネチャ括弧を置くと言うことになっている：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The parens are, of course, required if there is more than one parameter.</seg></tuv>
  <tuv xml:lang="JA"><seg>複数のパラメータがあるならば、括弧は、もちろん、必要とされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Capture objects are immutable in the abstract, but evaluate their arguments lazily.</seg></tuv>
  <tuv xml:lang="JA"><seg>Captureオブジェクトは抽象的に不変であるが、ゆったりと彼らの引数を評価する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Before everything inside a Capture is fully evaluated (which happens at compile time when all the arguments are constants), the eventual value may well be unknown.</seg></tuv>
  <tuv xml:lang="JA"><seg>Captureの中のすべてが完全に評価される（すべての引数が定数であるときコンパイル時で起こる）前に、最終的な値は知られていないだろう。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All we know is that we have the promise to make the bits of it immutable as they become known.</seg></tuv>
  <tuv xml:lang="JA"><seg>我々が知っているすべては、それらが明らかとなって、我々にはそれのビットを不変にするという約束があるということである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Capture objects may contain multiple unresolved iterators such as feeds or parcels or lists of parcels.</seg></tuv>
  <tuv xml:lang="JA"><seg>Captureオブジェクトは、複数の未解決の反復子（例えばパーセルの飼料またはパーセルまたはリスト）を含むかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>How these are resolved depends on what they are eventually bound to.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらが解決される方法は、結局、それらが密接に結びつくもの次第である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Some bindings are sensitive to multiple dimensions while others are not.</seg></tuv>
  <tuv xml:lang="JA"><seg>他がそうでない間、若干のバインディングは複数の次元に敏感である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Binding to a list of lists is often known as &amp;quot;slicing&amp;quot;, because it's commonly used to index &amp;quot;slices&amp;quot; of a potentially multi-dimensional array.</seg></tuv>
  <tuv xml:lang="JA"><seg>それが潜在的に多次元配列のインデックス「スライス」に一般的に用いられるので、リストのリストへのバインディングは「スライス」としてしばしば知られている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may retrieve parts from a Capture object with a prefix sigil operator:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、接頭辞シギル演算子でパーツをCaptureオブジェクトから取り出すかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When cast into an array, you can access all the positional arguments;</seg></tuv>
  <tuv xml:lang="JA"><seg>配列にキャストされるとき、あなたはすべての位置引数にアクセスすることができる;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>into a hash, all named arguments.</seg></tuv>
  <tuv xml:lang="JA"><seg>ハッシュに、すべては引数に名をつけた。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All prefix sigil operators accept one positional argument, evaluated in item context as a rvalue.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべての接頭辞シギル演算子は1つの位置引数に応じる。そして、rvalueとしてアイテム前後関係で評価される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>They can interpolate in strings if called with parentheses.</seg></tuv>
  <tuv xml:lang="JA"><seg>括弧で呼ばれるならば、それらは文字列で改竄することができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The special syntax form $() translates into $( $.made // Str($/) ) to operate on the current match object;</seg></tuv>
  <tuv xml:lang="JA"><seg>$()が現在のマッチオブジェクトに作用するために$( $.made // Str($/) )に変形する特別な構文用紙;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>similarly @() and %() can extract positional and named submatches.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、@()と%()は、位置で名をつけられたsubmatchesを抽出することができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Parcel and Capture objects fill the ecological niche of references in Perl 6.</seg></tuv>
  <tuv xml:lang="JA"><seg>ParcelとCaptureオブジェクトは、引用の生態的地位をPerl 6で満たす。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You can think of them as &amp;quot;fat&amp;quot; references, that is, references that can capture not only the current identity of a single object, but also the relative identities of several related objects.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、それらを、「ずんぐりした」引用（つまり、一つのオブジェクトのも現在のアイデンティティだけでなく、いくつかの関連オブジェクトの相対的なアイデンティティも捕えることができる引用）とみなすことができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Conversely, you can think of Perl 5 references as a degenerate form of Capture when you want to refer only to a single item.</seg></tuv>
  <tuv xml:lang="JA"><seg>反対に、あなたは、一つのアイテムだけに言及したいCaptureの退歩した形として、Perlの5つの引用を考えることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The sink statement prefix will eagerly evaluate any block or statement, throw away the results, and instead return the empty Parcel value, ().</seg></tuv>
  <tuv xml:lang="JA"><seg>sink文接頭語は、熱心に何かブロックまたは文を評価して、結果を捨てて、その代わりに空のParcel値（()）を返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This can be useful to peg some behavior to an empty list while still returning an empty list:</seg></tuv>
  <tuv xml:lang="JA"><seg>まだ空きリストを返る間、これはいくらかのふるまいを空きリストに留めるために役に立つことがありえる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Given sink, there's no need for an &amp;quot;else&amp;quot; clause on Perl 6's loops, and the sink construct works in any list, not just for loops.</seg></tuv>
  <tuv xml:lang="JA"><seg>sinkを与える、必要がない。そして、他に、Perl 6に関する条項は輪になる、そして、sinkは何かリスト（ちょうどforループでない）で作業を造る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>CaptureCursors</seg></tuv>
  <tuv xml:lang="JA"><seg>CaptureCursors</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A CaptureCursor object is a view into another capture with an associated start position.</seg></tuv>
  <tuv xml:lang="JA"><seg>CaptureCursorオブジェクトは、関連した開始位置によるもう一つのキャプチャーへの見方である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Such a cursor is essentially a pattern-matching state.</seg></tuv>
  <tuv xml:lang="JA"><seg>そのようなカーソルは、基本的にパターンマッチング州である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Capture cursors are used for operations like grep and map and for loops that need to apply a short signature multiple times to a longer list of values supplied by the base capture.</seg></tuv>
  <tuv xml:lang="JA"><seg>キャプチャーカーソルが、複数回短いシグネチャをベースキャプチャーによって供給される値のより長いリストに適用する必要があるgrepとmapとforループのような演算のために使われる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When we say &amp;quot;capture&amp;quot; we sometimes mean either Capture or CaptureCursor.</seg></tuv>
  <tuv xml:lang="JA"><seg>「キャプチャー」を言うとき、我々はCaptureかCaptureCursorを時々意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>CaptureCursors are also immutable.</seg></tuv>
  <tuv xml:lang="JA"><seg>CaptureCursorsも、不変である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When pattern matching a signature against a cursor, you get a new cursor back which tells you the new position in the base capture.</seg></tuv>
  <tuv xml:lang="JA"><seg>カーソルとシグネチャを比べることをパターン化するとき、あなたはベースキャプチャーであなたに新しい位置を教える新しいカーソルを取り戻す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Signature objects</seg></tuv>
  <tuv xml:lang="JA"><seg>シグネチャオブジェクト</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A signature object (Signature) may be created with colon-prefixed parens:</seg></tuv>
  <tuv xml:lang="JA"><seg>シグネチャオブジェクト（Signature）は、コロンを前に置かれた括弧で作成されるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Expressions inside the signature are parsed as parameter declarations rather than ordinary expressions.</seg></tuv>
  <tuv xml:lang="JA"><seg>シグネチャの表現は、普通の表現よりもむしろパラメタ宣言として解析される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See S06 for more details on the syntax for parameters.</seg></tuv>
  <tuv xml:lang="JA"><seg>パラメータのために構文上で詳細はS06を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Declarators generally make the colon optional:</seg></tuv>
  <tuv xml:lang="JA"><seg>宣言は、コロンを一般にオプションにする：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Signature objects bound to type variables (as in the example above) may be used within other signatures to apply additional type constraints.</seg></tuv>
  <tuv xml:lang="JA"><seg>変数（上の例の場合のように）を入力するにちがいないシグネチャオブジェクトが、更なる型制約を適用するために、他のシグネチャの範囲内で使われるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When applied to a capture argument, the signature allows you to take the types of the capture's arguments from MySig, but declare the (untyped) variable names yourself via an additional signature in parentheses:</seg></tuv>
  <tuv xml:lang="JA"><seg>キャプチャー引数に適用されるとき、シグネチャはMySigからキャプチャーの引数の型をとるが、（untypedされた）変数名を括弧の更なるシグネチャを経た自分自身と宣言することができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Ampersand and invocation</seg></tuv>
  <tuv xml:lang="JA"><seg>アンパサンドと起動</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unlike in Perl 5, the notation &amp;amp;foo merely stands for the foo function as a Routine object without calling it.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 5のとは異なり、表記法&amp;amp;fooは、それを呼ぶことのないRoutineオブジェクトとして、単にfoo関数を表すだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may call any Code object by dereferencing it with parens (which may, of course, contain arguments):</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、何でも括弧（もちろん、引数を含むかもしれない）でそれを間接参照することによるCodeオブジェクトと呼ぶかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whitespace is not allowed before the parens because it is parsed as a postfix.</seg></tuv>
  <tuv xml:lang="JA"><seg>それが接尾辞として解析されるので、空白文字は括弧の前に許されない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As with any postfix, there is also a corresponding .() operator, and you may use the &amp;quot;unspace&amp;quot; form to insert optional whitespace and comments between the backslash and either of the postfix forms:</seg></tuv>
  <tuv xml:lang="JA"><seg>何か接尾辞と同様に、対応する.()演算子もある、そして、あなたはバックスラッシュと接尾辞の形態のどちらの間ででもオプションの空白文字とコメントを付け加えるためにunspaceの形を使用するかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note however that the parentheses around arguments in the &amp;quot;normal&amp;quot; named forms of function and method calls are not postfix operators, so do not allow the .() form, because the dot is indicative of an actual dereferencing operation, which the named forms aren't doing.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、関数とメソッド呼び出しの「通常の」挙げられた形の引数のあたりの括弧が後置演算子でない点に注意しなさいので、点が実際の間接参照演算を示すので、.()の形を許してはいけない、そしてそれは、挙げられた形はしていない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may, however, use &amp;quot;unspace&amp;quot; to install extra space before the parens in the forms:</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、あなたは、形で括弧の前に余分のスペースをインストールするために、「unspace」を使うかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you do use the dotty form on these special forms, it will assume you wanted to call the named form without arguments, and then dereference the result of that.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたがこれらの特殊形式でおかしい形を使用するならば、それはあなたが引数のない挙げられた形、そして、間接参照をそれの結果と言いたかったと仮定する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Specifying a dispatch candidate</seg></tuv>
  <tuv xml:lang="JA"><seg>ディスパッチ候補を指定すること</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>With multiple dispatch, &amp;amp;foo is actually the name of a dispatch routine (instantiated from a proto) controlling a set of candidate functions (which you can use as if it were an ordinary function, because a dispatch is really an only function with pretensions to management of a dispatcher).</seg></tuv>
  <tuv xml:lang="JA"><seg>複数のディスパッチで、&amp;amp;fooは実は、一組の候補関数（あなたがそれが普通の関数であったことをように扱うことができるdispatchが本当にディスパッチャの管理の主張によるonly関数であるので）を制御しているdispatchルーチン（protoから具体例をあげて示される）の名前である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, in that case &amp;amp;foo by itself is not sufficient to uniquely name a specific function.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、その場合、&amp;amp;fooはユニークに特殊関数を挙げるのに単独で十分でない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To do that, the type may be refined by using a signature literal as a postfix operator:</seg></tuv>
  <tuv xml:lang="JA"><seg>そうするために、型は後置演算子として文字通りのシグネチャを用いて洗練されているかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use of a signature that does not unambiguously select a single multi results in failure.</seg></tuv>
  <tuv xml:lang="JA"><seg>一つのマルチも明白に選ばないシグネチャの使用は、結果として失敗になる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It still just returns a Routine object.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、まだちょうどRoutineオブジェクトを返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A call may also be partially applied (primed) by using the .assuming method:</seg></tuv>
  <tuv xml:lang="JA"><seg>呼び出しは、.assumingメソッドを用いて部分的に適用されもするかもしれない（準備をされる）：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Multidimensional slices and parcels</seg></tuv>
  <tuv xml:lang="JA"><seg>多次元スライスとパーセル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Slicing syntax is covered in S09.</seg></tuv>
  <tuv xml:lang="JA"><seg>構文をスライスすることは、S09でカバーされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A multidimensional slice will be done with semicolons between individual slice sublists.</seg></tuv>
  <tuv xml:lang="JA"><seg>多次元スライスは、個々のスライスサブリストの間でセミコロンでされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The semicolons imply one extra level of tree-ness, where the top list is of type LoL and sublists are Listss (or non-iterable items that can function as single-item parcels).</seg></tuv>
  <tuv xml:lang="JA"><seg>セミコロンはさらに1レベルの木-みさきを意味する、そこで、トップリストは型LoLである、そして、サブリストはListss（または一つのアイテムパーセルとして機能することができる非iterableなアイテム）である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>So when you say</seg></tuv>
  <tuv xml:lang="JA"><seg>それで、あなたが言うとき、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>really means</seg></tuv>
  <tuv xml:lang="JA"><seg>本当に手段</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Each such slice sub-parcel is evaluated lazily.</seg></tuv>
  <tuv xml:lang="JA"><seg>各スライス下位パーセルは、ゆったりと評価される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Subscript adverbs</seg></tuv>
  <tuv xml:lang="JA"><seg>下に書いた副詞</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To make a slice subscript return something other than values, append an appropriate adverb to the subscript.</seg></tuv>
  <tuv xml:lang="JA"><seg>スライス添え字復帰に値以外の何かを作るために、添え字に適正副詞を追加しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These adverbial forms all weed out non-existing entries if the adverb is true;</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞が真実であるならば、これらの副詞形は非既存のエントリーをすべて除く;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>if not, they leave them in, just as an ordinary slice would.</seg></tuv>
  <tuv xml:lang="JA"><seg>もしそうでなければ、ちょうど普通のスライスがそうして、それらはそれらを入れたままにしておく。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>So:</seg></tuv>
  <tuv xml:lang="JA"><seg>そう：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Likewise,</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>deletes the entries en passant while returning them.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらを返っている間、ついでにエントリーを削除する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Of course, any of these forms also work in the degenerate case of a slice containing a single index.) Note that these forms work by virtue of the fact that the subscript is the topmost previous operator.</seg></tuv>
  <tuv xml:lang="JA"><seg>なお、これらの形は、添え字が一番上の前の演算子であるという事実によって動く（もちろん、これらの形のどれでも、一つのインデックスを含んでいるスライスの退歩したケースで動く。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may have to parenthesize or force list context if some other operator that is tighter than comma would appear to be topmost:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、コンマより別のよりきつい若干の演算子がそうであるように見えるリストコンテキストもしもを括弧に入れなければならないかもしれないか、強制しなければならないかもしれない一番上の：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The situation does not often arise for the slice modifiers above because they are usually used in list context, which operates at comma precedence.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（それらが通常リストコンテキストで使われるので、状況は上のスライス修飾子のためにしばしば起こらない。そして、それはコンマ優先順位で動く。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The element is deleted only if the adverb is true.</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞が真実の場合だけ、要素はアンインストール済みである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>While :!delete is essentially a no-op;</seg></tuv>
  <tuv xml:lang="JA"><seg>:!deleteが基本的にノーオペレーションである間;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>you could conditionally delete entries en passant based on passing a flag such as in :delete($kill'em).</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、例えば:delete($kill'em)でフラグを渡すことに基づくエントリーアンパッサンを条件つきで削除することができた。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In either case, the values are returned.</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれにせよ、値は返納印である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may also perform an existence test, either on a single item or a junction of items:</seg></tuv>
  <tuv xml:lang="JA"><seg>アイテムの一つの条項または交差点で、あなたは存在テストも行うかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Using the :exists adverb together with a list slice results in in a Parcel of Bool, which you could also put in a junction with similar semantics:</seg></tuv>
  <tuv xml:lang="JA"><seg>スライスがBoolのParcelで結果としてなるリストと共に:exists副詞を使用すること、それをあなたは類似した意味論で交差点に置くこともできた：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>although with different optimization options for the compiler.</seg></tuv>
  <tuv xml:lang="JA"><seg>コンパイラのために異なる最適化オプションであるが。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may use :!exists to test for non-existence.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、不存在に対する検査に、:!existsを使うかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is specifically handy because of precedence rules making !%hash&amp;lt;a:exists&amp;gt; apply the :exists to the prefix !.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、!%hash&amp;lt;a：存在＞を:existsを接頭辞!に適用させている優先順位規則のため、特に便利である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>%hash&amp;lt;a:!exists&amp;gt; does not have that problem.</seg></tuv>
  <tuv xml:lang="JA"><seg>%hash&amp;lt;a：存在＞には、その問題がない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Combining subscript adverbs</seg></tuv>
  <tuv xml:lang="JA"><seg>下に書いた副詞を結合すること</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Like named parameters in a call, there is no order in handling multiple adverbs with subscripts.</seg></tuv>
  <tuv xml:lang="JA"><seg>呼び出しの挙げられたパラメータのように、順序が、添え字で複数の副詞を取り扱う際にない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Some combinations make sense, such as:</seg></tuv>
  <tuv xml:lang="JA"><seg>例えば、若干の組合せは意味をなす：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>would slice out pairs for the given the keys out of one hash into another.</seg></tuv>
  <tuv xml:lang="JA"><seg>1の中の鍵がもう一つにハッシュする既知の事実のために、一組を外にスライスさせる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whereas</seg></tuv>
  <tuv xml:lang="JA"><seg></seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>would return the keys that were actually deleted from the hash.</seg></tuv>
  <tuv xml:lang="JA"><seg>実はハッシュから削除されたキーを返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The adverbs that specify a return type only, can not be combined, because combinations such as :</seg></tuv>
  <tuv xml:lang="JA"><seg>戻り型だけを指定して、結合されることができない副詞例えば組合せ：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>kv:p or :</seg></tuv>
  <tuv xml:lang="JA"><seg>kv：p、または：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>v:k simply do not make sense.</seg></tuv>
  <tuv xml:lang="JA"><seg>v：kは、単に意味をなさない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These combinations are considered legal and mean the following:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの組合せは合法的であると考えられて、以下を意味する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An implementation is free to silently ignore any other combinations or silently prefer one of the adverbs given above any other.</seg></tuv>
  <tuv xml:lang="JA"><seg>実装は、黙って他のどの組合せも無視するか、黙って、他のものより上に伝えられる副詞の1つを好むことができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Numeric and boolean context of hashes</seg></tuv>
  <tuv xml:lang="JA"><seg>ハッシュの数字とブール値コンテキスト</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In numeric context (i.e. when cast into Int or Num), a Hash object becomes the number of pairs contained in the hash.</seg></tuv>
  <tuv xml:lang="JA"><seg>数値コンテキスト（すなわちIntまたはNumへ投げられるとき）では、Hashオブジェクトは、ハッシュに含まれる組の数になる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In a boolean context, a Hash object is true if there are any pairs in the hash.</seg></tuv>
  <tuv xml:lang="JA"><seg>ブール値コンテキストでは、何か組がハッシュであるならば、ハッシュオブジェクトは真実である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>List sorting</seg></tuv>
  <tuv xml:lang="JA"><seg>リストソーティング</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Sorting a list of pairs should sort on their keys by default, then on their values.</seg></tuv>
  <tuv xml:lang="JA"><seg>組のリストがデフォルトによる彼らのキーの上で、それから彼らの値の上でソートしなければならないソート。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Sorting a list of lists should sort on the first elements, then the second elements, etc. For more on sort see S29.</seg></tuv>
  <tuv xml:lang="JA"><seg>リストのリストをソートすることは最初の上で要素をソートしなければならない、そして、第2の要素、sortの上のより多くのためのその他はS29を見る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Special variables</seg></tuv>
  <tuv xml:lang="JA"><seg>特殊変数</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Many of the special variables of Perl 5 are going away.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 5の特殊変数の多くは、去っている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Those that apply to some object such as a filehandle will instead be attributes of the appropriate object.</seg></tuv>
  <tuv xml:lang="JA"><seg>ファイルハンドルのような若干のオブジェクトにあてはまるものは、その代わりに適切なオブジェクトの属性である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Those that are truly global will have global alphabetic names, such as $*PID or @*ARGS.</seg></tuv>
  <tuv xml:lang="JA"><seg>本当に全世界であるものには、世界的なアルファベットの名前（例えば$*PIDまたは@*ARGS）がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any remaining special variables will be lexically scoped.</seg></tuv>
  <tuv xml:lang="JA"><seg>特殊変数のままになっている何でも、辞書的に捜し出される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This includes $_ and @_, as well as the new $/, which is the return value of the last regex match.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは$_と@_（新しい$/だけでなく）を含む。そして、それは最後の正規表現マッチの戻り値である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>$0, $1, $2, etc., are aliases into the $/ object.</seg></tuv>
  <tuv xml:lang="JA"><seg>$0、$1、$2、その他は、$/オブジェクトへの別名である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Array end index</seg></tuv>
  <tuv xml:lang="JA"><seg>配列端部インデックス</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The $#foo notation is dead.</seg></tuv>
  <tuv xml:lang="JA"><seg>$#foo表記法は死んでいる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use @foo.end or @foo[*-1] instead.</seg></tuv>
  <tuv xml:lang="JA"><seg>その代わりに@foo.endまたは@foo[*-1]を使いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Or @foo.shape[$dimension] for multidimensional arrays.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（または多次元配列のための@foo.shape[$dimension]。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Names</seg></tuv>
  <tuv xml:lang="JA"><seg>名前</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An identifier is composed of an alphabetic character followed by any sequence of alphanumeric characters.</seg></tuv>
  <tuv xml:lang="JA"><seg>識別子は、英数字の何か連作が続く英字から成る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The definitions of alphabetic and numeric include appropriate Unicode characters.</seg></tuv>
  <tuv xml:lang="JA"><seg>アルファベットのものの定義と数字は、適正ユニコード文字を含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Underscore is always considered alphabetic.</seg></tuv>
  <tuv xml:lang="JA"><seg>アンダーラインは、常に考えられるアルファベットの。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An identifier may also contain isolated apostrophes or hyphens provided the next character is alphabetic.</seg></tuv>
  <tuv xml:lang="JA"><seg>識別子は、文字がそうである次を提供される孤立したアポストロフィまたはハイフンも含むかもしれないアルファベットの。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A name is anything that is a legal part of a variable name (not counting the sigil).</seg></tuv>
  <tuv xml:lang="JA"><seg>名前は、変数名（シギルを数えない）の法律部分である何でもある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This includes</seg></tuv>
  <tuv xml:lang="JA"><seg>これが、含む</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When not used as a sigil, the semantic function of :: within a name is to force the preceding portion of the name to be considered a package through which the subsequent portion of the name is to be located.</seg></tuv>
  <tuv xml:lang="JA"><seg>シギルとして使われないとき、名前の範囲内の::の意味関数は名前の前の部分に名前の以降の部分が位置することであるパッケージと考えられることを強いることである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the preceding portion is null, it means the package is unspecified and must be searched for according to the nature of what follows.</seg></tuv>
  <tuv xml:lang="JA"><seg>前の部分が無効であるならば、それはパッケージが明らかでなくて、あとに続くことの性質に一致することを求めて捜されなければならないことを意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Generally this means that an initial :: following the main sigil is a no-op on names that are known at compile time, though ::() can also be used to introduce an interpolation (see below).</seg></tuv>
  <tuv xml:lang="JA"><seg>::()が改竄者（下記参照）を紹介するのに用いられることもできるけれども、通常、これは、主なシギルの後の最初の::がコンパイル時で知られている名前に関するノーオペレーションであることを意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Also, in the absence of another sigil, :: can serve as its own sigil indicating intentional use of a not-yet-declared package name.</seg></tuv>
  <tuv xml:lang="JA"><seg>また、もう一つのシギルがない場合、::は、意図的な使用を示しているそれ自身のシギルとして、取り扱うことができるnot-yet-declaredしたパッケージ名。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unlike in Perl 5, if a sigil is followed by comma, semicolon, a colon not followed by an identifier, or any kind of bracket or whitespace (including Unicode brackets and whitespace), it will be taken to be a sigil without a name rather than a punctuational variable.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 5のとは異なり、シギルの後にコンマ、セミコロン、識別子が続かないコロンまたはブラケットまたは空白文字（ユニコードブラケットと空白文字を含む）の何か種類が続くならば、punctuationalな変数よりもむしろ名前のないシギルであることはとられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This allows you to use sigils as coercion operators:</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、強制演算子としてシギルを使うことができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In declarative constructs bare sigils may be used as placeholders for anonymous variables:</seg></tuv>
  <tuv xml:lang="JA"><seg>叙述的な構成概念において、裸のシギルが、無名変数のためのプレースホールダーとして使われるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Outside of declarative constructs you may use * for a placeholder:</seg></tuv>
  <tuv xml:lang="JA"><seg>叙述的な構成概念の外で、あなたはプレースホールダーのために*を使うかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Attempts to say something like:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下のような何かを言う試み：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>will result in the message, &amp;quot;Anonymous variable requires declarator&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>結果としてメッセージ（「無名変数は、宣言を必要とする」）になる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Package-qualified names</seg></tuv>
  <tuv xml:lang="JA"><seg>パッケージ-修飾された名前</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Ordinary package-qualified names look like they do in Perl 5:</seg></tuv>
  <tuv xml:lang="JA"><seg>それらがPerl 5でするように、普通のパッケージ-修飾された名前は見る：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Sometimes it's clearer to keep the sigil with the variable name, so an alternate way to write this is:</seg></tuv>
  <tuv xml:lang="JA"><seg>時々、変数名でシギルを保つことはより明白であるので、これを書く交互の方法は以下の通りである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is resolved at compile time because the variable name is a constant.</seg></tuv>
  <tuv xml:lang="JA"><seg>変数名が定数であるので、これはコンパイル時で解決される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Pseudo-packages</seg></tuv>
  <tuv xml:lang="JA"><seg>擬似パッケージ</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The following pseudo-package names are reserved at the front of a name:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下の疑似パッケージ名は、名前の先頭に確保される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The following relative names are also reserved but may be used anywhere in a name:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下の関係名が確保されもするが、名前でどこでも使われるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Other all-caps names are semi-reserved.</seg></tuv>
  <tuv xml:lang="JA"><seg>他のオールキャプス名は、半確保される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>We may add more of them in the future, so you can protect yourself from future collisions by using mixed case on your top-level packages.</seg></tuv>
  <tuv xml:lang="JA"><seg>我々は将来それらのより多くを加えるかもしれないので、あなたはトップレベルのパッケージで入り混じったケースを用いて将来の衝突から身を守ることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(We promise not to break any existing top-level CPAN package, of course.</seg></tuv>
  <tuv xml:lang="JA"><seg>（我々は、もちろん、何か既存のトップレベルのCPANパッケージをあけないと約束する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Except maybe ACME, and then only for coyotes.)</seg></tuv>
  <tuv xml:lang="JA"><seg>多分ACME以外はだろう、そして、コヨーテのためにだけ。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The file's scope is known as UNIT, but there are one or more lexical scopes outside of that corresponding to the linguistic setting (often known as the prelude in other cultures).</seg></tuv>
  <tuv xml:lang="JA"><seg>ファイルのスコープはUNITとして知られている、しかし、一つ以上のレキシカルスコープが言語セッティング（しばしば他の文化の序曲として知られる）と一致してそれの外にある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hence, the SETTING scope is equivalent to UNIT::OUTER.</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに、｛セッティング｝スコープは、UNIT::OUTERに等しい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For a standard Perl program SETTING is the same as CORE, but various startup options (such as -n or -p) can put you into a domain specific language, in which case CORE remains the scope of the standard language, while SETTING represents the scope defining the DSL that functions as the setting of the current file.</seg></tuv>
  <tuv xml:lang="JA"><seg>標準のために、PerlプログラムSETTINGはCOREと同じである、しかし、いろいろな最初のオプション（例えば-nまたは-p）はあなたを領域特定言語に翻訳することができる、その場合には、SETTINGが現行ファイルをセットすることとして機能するDSLを定義しているスコープを表現する間、COREは標準言語のスコープのままである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See also the -L/--language switch described in S19.</seg></tuv>
  <tuv xml:lang="JA"><seg>S19で記述される-L/--languageスイッチ参照。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If a setting wishes to gain control of the main execution, it merely needs to declare a MAIN routine as documented in S06.</seg></tuv>
  <tuv xml:lang="JA"><seg>セッティングが主要な処刑の利得制御に望むならば、S06で文書化されるように、それは単にMAINを日常的であると宣言する必要があるだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In this case the ordinary execution of the user's code is suppressed;</seg></tuv>
  <tuv xml:lang="JA"><seg>この場合、ユーザーのコードの普通の実行は、抑えられる;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>instead, execution of the user's code is entirely delegated to the setting's MAIN routine, which calls back to the user's lexically embedded code with YOU_ARE_HERE.</seg></tuv>
  <tuv xml:lang="JA"><seg>その代わりに、ユーザーのコードの実行はセッティングのMAINルーチンにまったく委任される。そして、それはYOU_ARE_HEREでユーザーの辞書的に埋め込みコードにかけ直す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The YOU_ARE_HERE functions within the setting as a proxy for the user's UNIT block, so -n and -p may be implemented in a setting with:</seg></tuv>
  <tuv xml:lang="JA"><seg>YOU_ARE_HEREはユーザーのUNITブロックの代用として舞台の中で機能するので、-nと-pはセッティングで以下で実装されるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>or</seg></tuv>
  <tuv xml:lang="JA"><seg>または、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>and the user may use loop control phasers as if they were directly in the loop block.</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、まるでそれらが直接ループブロックにあるように、ユーザーはループ制御フェイザー銃を使うかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any OUTER in the user's code refers to the block outside of YOU_ARE_HERE.</seg></tuv>
  <tuv xml:lang="JA"><seg>ユーザーのコードの何かOUTERは、YOU_ARE_HEREの外でブロックに言及する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If used as a standalone statement, YOU_ARE_HERE runs as if it were a bare block.</seg></tuv>
  <tuv xml:lang="JA"><seg>独立型文として使われるならば、まるでそれが裸のブロックであるように、YOU_ARE_HEREは走る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that, since the UNIT of an EVAL is the evaluated string itself, the SETTING of an EVAL is the language in effect at the point of the EVAL, not the language in effect at the top of the file.</seg></tuv>
  <tuv xml:lang="JA"><seg>なお、EVALのUNITが評価された文字列そのものである時から、EVALのSETTINGはEVAL（ファイルの最上位で活動中の言語でない）の間際に活動中の言語である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(You may, however, use OUTER::SETTING to get the setting of the code that is executing the EVAL.) In more traditional terms, the normal program is functioning as the &amp;quot;prelude&amp;quot; of the EVAL.</seg></tuv>
  <tuv xml:lang="JA"><seg>より伝統的な項に（しかし、あなたはEVALを実行しているコードのセッティングを得るためにOUTER::SETTINGを使うかもしれない。）、通常のプログラムは、EVALの序曲として機能している。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>So the outermost lexical scopes nest like this, traversed via OUTER:</seg></tuv>
  <tuv xml:lang="JA"><seg>それで、最も外部のレキシカルスコープはこのように入れ子にする。そして、OUTERを通して横断される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The outermost package scopes nest like this, traversed via PARENT:</seg></tuv>
  <tuv xml:lang="JA"><seg>最も外部のパッケージスコープはこのように入れ子にする。そして、PARENTを通して横断される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Your main program starts up in the GLOBAL package and the UNIT lexical scope.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたの主プログラムは、GLOBALパッケージとUNITレキシカルスコープを始める。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whenever anything is declared with &amp;quot;our&amp;quot; semantics, it inserts a name into both the current package and the current lexical scope.</seg></tuv>
  <tuv xml:lang="JA"><seg>何でも「我々」の意味論で宣言されるときはいつでも、それは名前をカレントパッケージと現在のレキシカルスコープに挿入する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(And &amp;quot;my&amp;quot; semantics only insert into the current lexical scope.) Note that the standard setting, CORE, is a lexical scope, not a package;</seg></tuv>
  <tuv xml:lang="JA"><seg>なお、標準的なセッティング（CORE）は、レキシカルスコープ（パッケージでない）である（そして、「私」のセマンティックは、レキシカルスコープを流れに挿入するだけである。）;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>the various items that are defined within (or imported into) CORE are *not* in GLOBAL, which is pretty much empty when your program starts compiling, and mostly only contains things you either put there yourself, or some other module put there because you used that module.</seg></tuv>
  <tuv xml:lang="JA"><seg>COREの中で（または重要だった）定義されるいろいろなアイテムはGLOBALの*not*である。そして、あなたのプログラムが編集し始めるとき、それはほとんど空で、あなたがそのモジュールを使用したので大部分はあなたも自分でそこに置いた、または、若干の他のモジュールがそこに置いたものを含むだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In general things defined within (or imported into) CORE should only be declared or imported with &amp;quot;my&amp;quot; semantics.</seg></tuv>
  <tuv xml:lang="JA"><seg>一般に、（または、重要だった）COREの中で定義されるものは、私の意味論で宣言されなければならないだけであるか、輸入されなければならないだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All Perl code can see CORE anyway as the outermost lexical scope, so there's no need to also put such things into GLOBAL.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべてのPerlコードは少なくともCOREを最も外部のレキシカルスコープとみなすことができるので、また、そのようなものをGLOBALに入れる必要がない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The GLOBAL package itself is accessible via UNIT::GLOBAL.</seg></tuv>
  <tuv xml:lang="JA"><seg>GLOBALパッケージそのものは、UNIT::GLOBALを通して利用できる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The PROCESS package is accessible via UNIT::PROCESS.</seg></tuv>
  <tuv xml:lang="JA"><seg>PROCESSパッケージは、UNIT::PROCESSを通して利用できる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The PROCESS package is not the parent of GLOBAL.</seg></tuv>
  <tuv xml:lang="JA"><seg>PROCESSパッケージは、GLOBALの親でない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, searching up the dynamic stack for dynamic variables will look in all nested dynamic scopes (mapped automatically to each call's lexical scope, not package scope) out to the main dynamic scope;</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、動的変数のためにダイナミックなスタックの上で捜すことは、外へすべての入れ子になった動的スコープ（自動的に各々の呼び出しのレキシカルスコープ（パッケージスコープでない）にマップされる）を、主な動的スコープにのぞく;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>once all the dynamic scopes are exhausted, it also looks in the GLOBAL package and then in the PROCESS package, so $*OUT typically finds the process's standard output handle.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべての動的スコープが使い果たされたら、それもGLOBALパッケージで、そして、PROCESSパッケージでのぞくので、$*OUTはプロセスの標準出力ハンドルを概して見つける。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hence, PROCESS and GLOBAL serve as extra outer dynamic scopes, much like CORE and SETTING function as extra outer lexical scopes.</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに、PROCESSとGLOBALは、余分の外の動的スコープ（非常に余分の外のレキシカルスコープとしてのCOREとSETTING関数のような）として用いられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Extra SETTING scopes keep their identity and their nesting within CORE, so you may have to go to OUTER several times from UNIT before you get to CORE.</seg></tuv>
  <tuv xml:lang="JA"><seg>余分のSETTINGスコープは彼らのアイデンティティと彼らが入れ子にすることをCOREの中で保つので、COREに着く前に、あなたはUNITから数回OUTERへ行かなければならないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Normally, however, there is only the core setting, in which case UNIT::OUTER ends up meaning the same as SETTING which is the same as CORE.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、通常、中心的なセッティングだけがある、その場合には、UNIT::OUTERは結局COREと同じであるSETTINGと同じことを意味することになる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Extra GLOBAL scopes are treated differently.</seg></tuv>
  <tuv xml:lang="JA"><seg>余分のGLOBALスコープは、違って扱われる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Every compilation unit has its own associated UNIT::GLOBAL package.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべてのコンパイル単位には、それ自身の関連したUNIT::GLOBALパッケージがある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As the currently compiling compilation unit expresses the need for various other compilation units, the global names known to those other units must be merged into the new unit's UNIT::GLOBAL.</seg></tuv>
  <tuv xml:lang="JA"><seg>現在編集しているコンパイル単位がいろいろな他のコンパイル単位の必要を表して、それらの他の単位に知られているグローバル名は新しい単位のUNIT::GLOBALに合併されなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(This includes the names in all the packages within the global package.) If two different units use the same global name, they must generally be taken to refer to the same item, but only if the type signatures can be meshed (and augmentation rules followed, in the case of package names).</seg></tuv>
  <tuv xml:lang="JA"><seg>2つの異なる単位が同じグローバル名を使用するならば、しかし、型シグネチャがかみ合うことができる（そして、パッケージ名の場合、増加規則はあとに続いた）場合だけ、それらは同じアイテムに言及するために通常、とられなければならない（これは世界的なパッケージの範囲内で名前をすべてのパッケージに含む。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If two units provide package names with incompatible type signatures, the compilation of the unit fails.</seg></tuv>
  <tuv xml:lang="JA"><seg>2つの単位がパッケージ名に非互換の型シグネチャを提供するならば、単位の編集は失敗する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In other words, you may not use incompatible global types to provide a union type.</seg></tuv>
  <tuv xml:lang="JA"><seg>言い換えると、共用体型を提供するために、非互換の世界的な型を使わなくてもよい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, if one or the other unit underspecifies the type in a compatible way, the underspecified type just takes on the extra type information as it learns it. (Presumably some combination of Liskov substitution, duck-typing, and run-time checking will prevent tragedy in the unit that was compiled with the underspecified type.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、どちらか一方の単位が互換性を持つ方法で型をunderspecifiesするならば、それがそれを学んで、underspecifiedされた型はちょうど余分の情報を引き受ける。（おそらく、Liskov代用の若干の組合せ、カモ-タイピングとチェックしている実行時は、underspecifiedされた型で編集された単位で、悲劇を防止する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Alternately, the compiler is allowed to recompile or re-examine the unit with the new type constraints to see if any issues are certain to arise at run time, in which case the compiler is free to complain.)</seg></tuv>
  <tuv xml:lang="JA"><seg>あるいは、コンパイラは何か問題が実行時で起こることは確かかどうか見るために新しい型制約で単位を再コンパイルするか、再検査するのを許可される、その場合には、コンパイラは不満を言うことができる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any dynamic variable declared with our in the user's main program (specifically, the part compiled with GLOBAL as the current package) is accessible (by virtue of being in GLOBAL) as a dynamic variable even if not directly in the dynamic call chain.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえダイナミックな呼び出しチェーンで直接ないとしても、動的変数がユーザーの主プログラム（とりわけ、カレントパッケージとしてGLOBALで編集される部分）でourで宣言した何でも動的変数としてアクセスできる（GLOBALであることによって）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that dynamic vars do *not* look in CORE for anything. (They might look in SETTING if you're running under a setting distinct from CORE, if that setting defines a dynamic scope outside your main program, such as for the -n or -p switch.) Context variables declared with our in the GLOBAL or PROCESS packages do not need to use the * twigil, since the twigil is stripped before searching those packages.</seg></tuv>
  <tuv xml:lang="JA"><seg>ダイナミックなバールがどうあってもCOREで*not*観察をすることに注意すべきである。twigilがそれらのパッケージを捜す前にむかれる時から、GLOBALでourで宣言される前後関係変数またはPROCESSパッケージは* twigilを使う必要はない（そのセッティングがあなたの主プログラムの外で動的スコープを定義する（例えば-nまたは-pスイッチについては）ならば、あなたがCOREとは別のセッティングの下に走っているならば、それらはSETTINGをのぞくかもしれない。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hence, your environment variables are effectively declared without the sigil:</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに、あなたの環境変数は、シギルなしで効果的に宣言される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Interpolating into names</seg></tuv>
  <tuv xml:lang="JA"><seg>名前への補間</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may interpolate a string into a package or variable name using ::($expr) where you'd ordinarily put a package or variable name.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、通常パッケージまたは変数名を置くだろう::($expr)を使っているパッケージまたは変数名に文字列を改変するかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The string is allowed to contain additional instances of ::, which will be interpreted as package nesting.</seg></tuv>
  <tuv xml:lang="JA"><seg>文字列は::の更なるインスタンスを含ませておかれる。そして、それは入れ子にしているパッケージと解釈される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may only interpolate entire names, since the construct starts with ::, and either ends immediately or is continued with another :: outside the parens.</seg></tuv>
  <tuv xml:lang="JA"><seg>構成概念が::から始めて、すぐに終わるか、括弧の外でもう一つの::で続けられる時から、あなたは全名前を差し込むだけかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Most symbolic references are done with this notation:</seg></tuv>
  <tuv xml:lang="JA"><seg>大部分の記号参照は、この表記法でされる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that unlike in Perl 5, initial :: doesn't imply global.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 5のとは異なり、最初の::が全世界に含蓄しない点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Here as part of the interpolation syntax it doesn't even imply package.</seg></tuv>
  <tuv xml:lang="JA"><seg>ここでは展開構文の一部として、それはパッケージさえ意味しない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>After the interpolation of the ::() component, the indirect name is looked up exactly as if it had been there in the original source code, with priority given first to leading pseudo-package names, then to names in the lexical scope (searching scopes outwards, ending at CORE).</seg></tuv>
  <tuv xml:lang="JA"><seg>::()構成要素の展開の後、正確にまるでそれがそれからレキシカルスコープ（外へスコープを捜して、COREのところで終わる）に名前に、最初に主要な疑似パッケージ名にプライオリティーを与えて、元のソースコードでそこにあったように、間接的な名前は調べられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The current package is searched last.</seg></tuv>
  <tuv xml:lang="JA"><seg>カレントパッケージは、最後に捜される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use the MY pseudopackage to limit the lookup to the current lexical scope, and OUR to limit the scopes to the current package scope.</seg></tuv>
  <tuv xml:lang="JA"><seg>検索を現在のレキシカルスコープに制限するMY擬似パッケージとスコープをカレントパッケージスコープに制限するOURを使いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Strict lookup</seg></tuv>
  <tuv xml:lang="JA"><seg>厳しい検索</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When &amp;quot;strict&amp;quot; is in effect (which is the default except for one-liners), non-qualified variables (such as $x and @y) are only looked up from lexical scopes, but never from package scopes.</seg></tuv>
  <tuv xml:lang="JA"><seg>「厳しい」ものは活動中である（そしてそれは冗談以外のデフォルトである）とき、資格がない変数（例えば$xと@y）は決してパッケージスコープからでなく、レキシカルスコープから調べられるだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To bind package variables into a lexical scope, simply say our ($x, @y).</seg></tuv>
  <tuv xml:lang="JA"><seg>レキシカルスコープにパッケージ変数を結びつけるために、単にour ($x, @y)を言いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To bind global variables into a lexical scope, predeclare them with use:</seg></tuv>
  <tuv xml:lang="JA"><seg>レキシカルスコープ（predeclareにuseによるそれら）にグローバル変数を結びつけること：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Or just refer to them as $*IN and $*OUT.</seg></tuv>
  <tuv xml:lang="JA"><seg>または、ちょうどそれらを$*INと$*OUTと称しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Direct lookup</seg></tuv>
  <tuv xml:lang="JA"><seg>直接ルックアップ</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To do direct lookup in a package's symbol table without scanning, treat the package name as a hash:</seg></tuv>
  <tuv xml:lang="JA"><seg>ウイルスチェックなしでパッケージのシンボルテーブルで直接ルックアップをして、パッケージ名をハッシュとみなすこと：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The :: before the subscript is required here, because the Foo::Bar... syntax is reserved for attaching a &amp;quot;WHENCE&amp;quot; initialization closure to an autovivifiable type object.</seg></tuv>
  <tuv xml:lang="JA"><seg>添え字の前の::は、ここで必要とされる、Foo::Bar...構文が付属するために予約の、autovivifiableな型への初期化クロージャが、反対する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(see S12).</seg></tuv>
  <tuv xml:lang="JA"><seg>（S12を見る）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unlike ::() symbolic references, this does not parse the argument for ::, nor does it initiate a namespace scan from that initial point.</seg></tuv>
  <tuv xml:lang="JA"><seg>::()記号参照と違って、これは::のために引数を解析しないし、それはその始点から名前空間走査を始めない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In addition, for constant subscripts, it is guaranteed to resolve the symbol at compile time.</seg></tuv>
  <tuv xml:lang="JA"><seg>そのうえ、固定添え字のために、コンパイル時でシンボルを解決することは、保証される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The null pseudo-package is reserved to mean the same search list as an ordinary name search.</seg></tuv>
  <tuv xml:lang="JA"><seg>無効な擬似パッケージは、普通の名前検索と同じ検索リストを意味するために確保される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, the following are all identical in meaning:</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、以下のすべては、意味で同一である：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, each of them scans lexical scopes outward, and then the current package scope (though the package scope is then disallowed when &amp;quot;strict&amp;quot; is in effect).</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、それらの各々は、外へレキシカルスコープ、そして、カレントパッケージスコープ（「厳しい」ものは活動中であるときそれからパッケージスコープが認められないけれども）を探査する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As a result of these rules, you can write any arbitrary variable name as either of:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの規則の結果、あなたは以下のどちらとしてでも、何にでも任意の変数名を書くことができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You can also use the ::&amp;lt;&amp;gt; form as long as there are no spaces in the name.</seg></tuv>
  <tuv xml:lang="JA"><seg>スペースが名前でない限り、あなたは::&amp;lt;&amp;gt;の形を使用することもできる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Symbol tables</seg></tuv>
  <tuv xml:lang="JA"><seg>シンボルテーブル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The current lexical symbol table is now accessible through the pseudo-package MY.</seg></tuv>
  <tuv xml:lang="JA"><seg>現在の語彙的なシンボルテーブルは、現在擬似パッケージMYを通してアクセスできる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The current package symbol table is visible as pseudo-package OUR.</seg></tuv>
  <tuv xml:lang="JA"><seg>カレントパッケージシンボルテーブルは、擬似パッケージOURとして見える。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The OUTER name refers to the MY symbol table immediately surrounding the current MY, and OUTER::OUTER is the one surrounding that one.</seg></tuv>
  <tuv xml:lang="JA"><seg>OUTER名はすぐに現在のMYを囲んでいるMYシンボルテーブルを指す、そして、OUTER::OUTERはあれを囲んでいるものである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may not use any lexically scoped symbol table, either by name or by reference, to add symbols to a lexical scope that is done compiling.</seg></tuv>
  <tuv xml:lang="JA"><seg>シンボルを編集することをされるレキシカルスコープに加えるために、名前で、または、参照によって、少しも辞書的に捜し出されたシンボルテーブルを使用しなくてもよい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(We reserve the right to relax this if it turns out to be useful though.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（それがしかし役に立つことがわかるならば、我々はこれをリラックスさせる権利を保有する。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Dynamic lookup</seg></tuv>
  <tuv xml:lang="JA"><seg>ダイナミックな検索</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The CALLER package refers to the lexical scope of the (dynamically scoped) caller.</seg></tuv>
  <tuv xml:lang="JA"><seg>CALLERパッケージは、（ダイナミックに捜し出される）発信者のレキシカルスコープに言及する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The caller's lexical scope is allowed to hide any user-defined variable from you.</seg></tuv>
  <tuv xml:lang="JA"><seg>発信者のレキシカルスコープは、何か利用者変数をあなたから隠させておかれる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In fact, that's the default, and a lexical variable must have the trait &amp;quot;is dynamic&amp;quot; to be visible via CALLER.</seg></tuv>
  <tuv xml:lang="JA"><seg>実際、それはデフォルトである、そして、静的変数はCALLERを通して見えるトレイト&amp;quot;is dynamic&amp;quot;を持たなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>($_, $! and $/ are always dynamic, as are any variables whose declared names contain a * twigil.) If the variable is not visible in the caller, it returns Failure.</seg></tuv>
  <tuv xml:lang="JA"><seg>変数が発信者で見えないならば、それはFailureを返る（$_、$!と$/は常にダイナミックである。そして、そのことは宣言された名前が* twigilを含む何か変数である。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Variables whose names are visible at the point of the call but that come from outside that lexical scope are controlled by the scope in which they were originally declared as dynamic.</seg></tuv>
  <tuv xml:lang="JA"><seg>名前が呼び出しの際に見える、しかし、そのレキシカルスコープの外でから来る変数は、ダイナミックであるように、それらが当初宣言されたスコープによってコントロールされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hence the visibility of CALLER::&amp;lt;$*foo&amp;gt; is determined where $*foo is actually declared, not by the caller's scope (unless that's where it happens to be declared).</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに、$*fooが実は宣言される所で、CALLER::&amp;lt;$*foo&amp;gt;の可視性は決定される、発信者のスコープ（それがそれが偶然宣言されることが起こるところでない限り）によってでなく。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Likewise CALLER::CALLER::&amp;lt;$x&amp;gt; depends only on the declaration of $x visible in your caller's caller.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、CALLER::CALLER::&amp;lt;$x&amp;gt;はあなたの発信者の訪問者で見える$xの宣言だけに依存する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>User-defined dynamic variables should generally be initialized with ::= unless it is necessary for variable to be modified.</seg></tuv>
  <tuv xml:lang="JA"><seg>変数が修正されることが必要でない限り、ユーザー定義の動的変数は通常、::=で初期化されなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Marking dynamic variables as readonly is very helpful in terms of sharing the same value among competing threads, since a readonly variable need not be locked.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（readonlyな変数がロックされる必要がない時から、readonlyであるように、動的変数に跡を残すことは同じ値を競争している糸で分配する観点から非常に役に立つ。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>DYNAMIC</seg></tuv>
  <tuv xml:lang="JA"><seg>DYNAMIC</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The DYNAMIC pseudo-package is just like CALLER except that it starts in the current dynamic scope and from there scans outward through all dynamic scopes (frames) until it finds a dynamic variable of that name in that dynamic frame's associated lexical pad.</seg></tuv>
  <tuv xml:lang="JA"><seg>動的フレームのものが語彙的なパッドを結びつけたという点でそれがその名前の動的変数を見つけるまでそれが現在の動的スコープで始まって、そこからすべての動的スコープ（フレーム）で外へざっと目を通すこと以外は、DYNAMIC擬似パッケージはちょうどCALLERのようである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(This search is implied for variables with the * twigil;</seg></tuv>
  <tuv xml:lang="JA"><seg>（この検索は、* twigilで変数のために意味される;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>hence $*FOO is equivalent to DYNAMIC::&amp;lt;$*FOO&amp;gt;.) If, after scanning outward through all those dynamic scopes, there is no variable of that name in any immediately associated lexical pad, it strips the * twigil out of the name and looks in the GLOBAL package followed by the PROCESS package.</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに、$*FOOはDYNAMIC::&amp;lt;$*FOO&amp;gt;に等しい。）、外へすべてのそれらの動的スコープを通してのウイルスチェックの後、その名前の変数が何かすぐに関連した語彙的な離着陸場にないならば、それは名前から* twigilをむいて、PROCESSパッケージが続くGLOBALパッケージをのぞく。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the value is not found, it returns failure.</seg></tuv>
  <tuv xml:lang="JA"><seg>値が見つからないならば、それは失敗を返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unlike CALLER, DYNAMIC will see a dynamic variable that is declared in the current scope, since it starts search 0 scopes up the stack rather than 1.</seg></tuv>
  <tuv xml:lang="JA"><seg>CALLERとは異なり、DYNAMICは現在のスコープで宣言される動的変数を見る、それが始まる時から、1よりもむしろスタックの上で0のスコープを捜しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may, however, use CALLER::&amp;lt;$*foo&amp;gt; to bypass a dynamic definition of $*foo in your current scope, such as to initialize it with the outer dynamic value:</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、例えば外のダイナミックな値でそれを初期化するために、あなたは、現在のスコープで$*fooのダイナミックな定義を迂回するために、CALLER::&amp;lt;$*foo&amp;gt;を使うかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The temp declarator may be used (without an initializer) on a dynamic variable to perform a similar operation:</seg></tuv>
  <tuv xml:lang="JA"><seg>temp宣言が、類似した演算を実行するために、動的変数で使われるかもしれない（イニシャライザなしで）：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The main difference is that by default it initializes the new $*foo with its current value, rather than the caller's value.</seg></tuv>
  <tuv xml:lang="JA"><seg>主要な違いは、デフォルトで、それが現在の値（発信者の値よりもむしろ）で新しい$*fooを初期化するということである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Also, it is allowed only on read/write dynamic variables, since the only reason to make a copy of the outer value would be because you'd want to override it later and then forget the changes at the end of the current dynamic scope.</seg></tuv>
  <tuv xml:lang="JA"><seg>また、外の値のコピーを製作する唯一の理由があなたが後でそれにオーバーライドして、それから現在の動的スコープの終わりに変化を忘れたいだろうからである時から、それは読み出し／書き込み動的変数だけで許される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may also use OUTER::&amp;lt;$*foo&amp;gt; to mean you want to start the search in your outer lexical scope, but this will succeed only if that outer lexical scope also happens to be one of your current dynamic scopes.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは外のレキシカルスコープで検索を始めることを望む平均にOUTER::&amp;lt;$*foo&amp;gt;も使うかもしれない、しかし、その外のレキシカルスコープも偶然あなたの現在の動的スコープの1つであるのの場合だけ、これは成功する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, the same search is done as with the bare $*foo, but any &amp;quot;hits&amp;quot; are ignored until we've got to the OUTER scope in our traversal.</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、同じ検索は裸の$*fooと同様にされる、しかし、我々が横断においてOUTERスコープに着くまで、何かヒットは無視される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Package lookup</seg></tuv>
  <tuv xml:lang="JA"><seg>パッケージ検索</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is no longer any special package hash such as %Foo::.</seg></tuv>
  <tuv xml:lang="JA"><seg>%Foo::のようなもはや少しも特別なパッケージハッシュが、ない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Just subscript the package object itself as a hash object, the key of which is the variable name, including any sigil.</seg></tuv>
  <tuv xml:lang="JA"><seg>ちょうどそれ自体ハッシュオブジェクト（キー）としてのパッケージオブジェクトが変数名（何かシギルを含む）である添え字。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The package object can be derived from a type name by use of the :: postfix:</seg></tuv>
  <tuv xml:lang="JA"><seg>パッケージオブジェクトは、::接尾辞の用法によって、タイプ名に由来することができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Directly subscripting the type with either square brackets or curlies is reserved for various generic type-theoretic operations.</seg></tuv>
  <tuv xml:lang="JA"><seg>（直接、どちらの正方形による型でも括弧に入れる添え字付けまたはcurliesは、いろいろな汎用的な型理論的な演算のために予約である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In most other matters type names and package names are interchangeable.)</seg></tuv>
  <tuv xml:lang="JA"><seg>大部分の他の問題では、タイプ名とパッケージ名は、交換可能である。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Typeglobs are gone.</seg></tuv>
  <tuv xml:lang="JA"><seg>Typeglobsはなくなる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use binding (:= or ::=) to do aliasing.</seg></tuv>
  <tuv xml:lang="JA"><seg>エイリアシングをするために、バインディング（:=または::=）を使いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Individual variable objects are still accessible through the hash representing each symbol table, but you have to include the sigil in the variable name now:</seg></tuv>
  <tuv xml:lang="JA"><seg>個別変数オブジェクトは各々のシンボルテーブルを表現しているハッシュを通してまだアクセスできる、しかし、あなたは現在シギルを変数名に含めなければならない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>MyPackage::'$foo' or the equivalent MyPackage::&amp;lt;$foo&amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>MyPackage::'$foo'または等しいMyPackage::&amp;lt;$foo&amp;gt;。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Globals</seg></tuv>
  <tuv xml:lang="JA"><seg>グローバル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Interpreter globals live in the GLOBAL package.</seg></tuv>
  <tuv xml:lang="JA"><seg>GLOBALパッケージの通訳グローバルライブ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The user's program starts in the GLOBAL package, so &amp;quot;our&amp;quot; declarations in the mainline code go into that package by default.</seg></tuv>
  <tuv xml:lang="JA"><seg>ユーザープログラムはGLOBALパッケージで始まるので、主流をなすコードの&amp;quot;our&amp;quot;宣言はデフォルトでそのパッケージに使われる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Process-wide variables live in the PROCESS package.</seg></tuv>
  <tuv xml:lang="JA"><seg>プロセスに広がる変数は、PROCESSパッケージで生きる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Most predefined globals such as $*UID and $*PID are actually process globals.</seg></tuv>
  <tuv xml:lang="JA"><seg>$*UIDのような大部分のあらかじめ定義されたグローバルと$*PIDは、実はプロセスグローバルである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The PROCESS package</seg></tuv>
  <tuv xml:lang="JA"><seg>PROCESSパッケージ</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is only ever a single PROCESS package.</seg></tuv>
  <tuv xml:lang="JA"><seg>一つのPROCESSパッケージが、これまでにだけある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For an ordinary Perl program running by itself, there is only one GLOBAL package as well.</seg></tuv>
  <tuv xml:lang="JA"><seg>単独で動作している普通のPerlプログラムについては、1つのGLOBALパッケージだけが、同様にある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, in certain situations (such as shared hosting under a webserver), the actual process may contain multiple virtual processes or interpreters, each running its own &amp;quot;main&amp;quot; code.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、特定の状況（webserverの下でホスティングを共有したようであるもの）では、実加工は複数の仮想過程または通訳を含むかもしれない。そして、各々がそれ自身の&amp;quot;main&amp;quot;コードを実行する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In this case, the GLOBAL namespace holds variables that properly belong to the individual virtual process, while the PROCESS namespace holds variables that properly belong to the actual process as a whole.</seg></tuv>
  <tuv xml:lang="JA"><seg>この場合、PROCESS名前空間が全体として実加工にきちんと属している変数を持つ間、GLOBAL名前空間は個々の仮想過程にきちんと属している変数を持つ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>From the viewpoint of the program there is little difference as long as all global variables are accessed as if they were dynamic variables (by using the * twigil).</seg></tuv>
  <tuv xml:lang="JA"><seg>まるでそれらが動的変数（* twigilを用いて）であるようにすべてのグローバル変数がアクセスされる限り、プログラムの視点から、五十歩百歩がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The process as a whole may place restrictions on the mutability of process variables as seen by the individual subprocesses.</seg></tuv>
  <tuv xml:lang="JA"><seg>個々のサブプロセスによって見られるように、プロセスは規制をプロセス変数の移り気に全体として置くかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Also, individual subprocesses may not create new process variables.</seg></tuv>
  <tuv xml:lang="JA"><seg>また、個々のサブプロセスは、新しいプロセス変数をつくらないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the process wishes to grant subprocesses the ability to communicate via the PROCESS namespace, it must supply a writeable dynamic variable to all the subprocesses granted that privilege.</seg></tuv>
  <tuv xml:lang="JA"><seg>プロセスがサブプロセスにPROCESS名前空間によって通信する能力を与えることを望むならば、それはその特権を受けるすべてのサブプロセスに書き込み可能な動的変数を供給しなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Dynamic variable creation</seg></tuv>
  <tuv xml:lang="JA"><seg>動的変数創造</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is illegal to assign or bind a dynamic variable that does not already exist.</seg></tuv>
  <tuv xml:lang="JA"><seg>すでに存在しない動的変数を割り当てるか、結びつけることは、無効である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It will not be created in GLOBAL (or PROCESS) automatically, nor is it created in any lexical scope.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは自動的にGLOBAL（またはPROCESS）でつくられないし、それは何かレキシカルスコープでつくられない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instead, you must assign directly using the package name to get that to work:</seg></tuv>
  <tuv xml:lang="JA"><seg>その代わりに、あなたは、仕事にそれを得るためにパッケージ名を直接使用することを割り当てなければならない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The magic input handle</seg></tuv>
  <tuv xml:lang="JA"><seg>マジックの入力ハンドル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The magic command-line input handle is $*ARGFILES.</seg></tuv>
  <tuv xml:lang="JA"><seg>マジックのコマンドライン入力ハンドルは、$*ARGFILESである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The arguments themselves come in @*ARGS.</seg></tuv>
  <tuv xml:lang="JA"><seg>引数自体は、@*ARGSで来る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See also &amp;quot;Declaring a MAIN subroutine&amp;quot; in S06.</seg></tuv>
  <tuv xml:lang="JA"><seg>S06で「主要なサブルーチンを宣言する」こと参照。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Magical access to documentation</seg></tuv>
  <tuv xml:lang="JA"><seg>ドキュメンテーションへの不思議な接近</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The Pod documentation in a file is accessible from code in the same file via variables with a = secondary sigil.</seg></tuv>
  <tuv xml:lang="JA"><seg>ファイルのポッドドキュメンテーションは、=第二のシギルで変数を通して同じファイルでコードからアクセスできる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>$=data is the accessor for your =data section(s), for instance.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、$=dataはあなたの=dataセクション(s)のためのアクセッサである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All Pod structures are available as a hierarchical data structure, through $=pod.</seg></tuv>
  <tuv xml:lang="JA"><seg>$=podを通して、すべてのポッド構造は、階層的なデータ構造として使われる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As with *, the = may also be used as a package name:</seg></tuv>
  <tuv xml:lang="JA"><seg>*と同様に、=がパッケージ名としても使われるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>$=::data.</seg></tuv>
  <tuv xml:lang="JA"><seg>$=::data。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Magical lexically scoped values</seg></tuv>
  <tuv xml:lang="JA"><seg>不思議な辞書的に捜し出された値</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Magical lexically scoped values live in variables with a ? secondary sigil.</seg></tuv>
  <tuv xml:lang="JA"><seg>不思議な辞書的に捜し出された値は、?第二のシギルで変数で生きる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These are all values that are known to the compiler, and may in fact be dynamically scoped within the compiler itself, and only appear to be lexically scoped because dynamic scopes of the compiler resolve to lexical scopes of the program.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらは、コンパイラに知られていて、コンパイラそのものの範囲内で実際ダイナミックに捜し出されるかもしれないすべての値で、コンパイラの動的スコープがプログラムのレキシカルスコープに分解するので辞書的に捜し出されるように見えるだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All $? variables are considered constants, and may not be modified after being compiled in. The user is also allowed to define or (redefine) such constants:</seg></tuv>
  <tuv xml:lang="JA"><seg>すべての$?変数はよく考えた定数で、中で編集された後に修正されるというわけではないかもしれない。ユーザーは限定またはそのような定数（再定義する）にも入ることができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Note that the constant declarator always evaluates its initialization expression at compile time.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（一定の宣言が常にコンパイル時でその初期化表現を評価することに注意すべきである。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>$?FILE and $?LINE are your current file and line number, for instance.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、$?FILEと$?LINEはあなたの現行ファイルと行番号である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instead of $?OUTER::FOO you probably want to write OUTER::&amp;lt;$?FOO&amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>$?OUTER::FOOの代わりに、あなたは多分OUTER::&amp;lt;$?FOO&amp;gt;を書きたいだろう。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Within code that is being run during the compile, such as BEGIN blocks, or macro bodies, or constant initializers, the compiler variables must be referred to as (for instance) COMPILING::&amp;lt;$?LINE&amp;gt; if the bare $?LINE would be taken to be the value during the compilation of the currently running code rather than the eventual code of the user's compilation unit.</seg></tuv>
  <tuv xml:lang="JA"><seg>コード（つまりコンパイルの間の実行、例えばBEGINブロックまたはマクロボディであることまたは恒常的なイニシャライザ）の範囲内で、裸の$?LINEがユーザーのコンパイル単位の最終的なコードよりもむしろ現在実行コードのコンパイルの間の値であるとみなされるならば、コンパイラ変数は（たとえば）COMPILING::&amp;lt;$?LINE&amp;gt;と呼ばれなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For instance, within a macro body $?LINE is the line within the macro body, but COMPILING::&amp;lt;$?LINE&amp;gt; is the line where the macro was invoked.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、マクロボディの中で、$?LINEはマクロボディの中の線である、しかし、COMPILING::&amp;lt;$?LINE&amp;gt;はマクロが呼び出された線である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See below for more about the COMPILING pseudo package.</seg></tuv>
  <tuv xml:lang="JA"><seg>COMPILING疑似パッケージについてより多くのために下記参照。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Here are some possibilities:</seg></tuv>
  <tuv xml:lang="JA"><seg>若干の可能性は、ここにある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The following return objects that contain all pertinent info:</seg></tuv>
  <tuv xml:lang="JA"><seg>すべての関係する情報を含む以下の戻りオブジェクト：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is relatively easy to smartmatch these constant objects against pairs to check various attributes such as name, version, or authority:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの定数がいろいろな属性（例えば名前、バージョンまたは権限）をチェックするために組に対して反対することは、スマートマッチに比較的容易である：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Matches of constant pairs on constant objects may all be resolved at compile time, so dead code can be eliminated by the optimizer.</seg></tuv>
  <tuv xml:lang="JA"><seg>恒常的なオブジェクトの一定の組のマッチのすべてはコンパイル時で分解されるかもしれないので、不要コードはオプティマイザーによって除かれることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that some of these things have parallels in the * space at run time:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらのものの一部が実行時で*スペースに平行を持つことに注意すべきである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You should not assume that these will have the same value as their compile-time cousins.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、これらが彼らのコンパイル時いとこと同じ値を持つと仮定するべきでない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The COMPILING pseudopackage</seg></tuv>
  <tuv xml:lang="JA"><seg>COMPILING擬似パッケージ</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>While $? variables are constant to the run time, the compiler has to have a way of changing these values at compile time without getting confused about its own $? variables (which were frozen in when the compile-time code was itself compiled).</seg></tuv>
  <tuv xml:lang="JA"><seg>$?変数が実行時まで一定の間、コンパイラにはそれ自身の$?変数（コンパイル時コードがそれ自体コンパイルされたとき、凍結した）について混乱したようになることなくコンパイル時でこれらの値を変えることの方法がなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The compiler can talk about these compiler-dynamic values using the COMPILING pseudopackage.</seg></tuv>
  <tuv xml:lang="JA"><seg>コンパイラは、COMPILING擬似パッケージを用いたこれらのコンパイラダイナミックな値について話すことができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>References to COMPILING variables are automatically hoisted into the lexical scope currently being compiled.</seg></tuv>
  <tuv xml:lang="JA"><seg>COMPILING変数への言及は、現在編集されているレキシカルスコープに、自動的に上げられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Setting or temporizing a COMPILING variable sets or temporizes the incipient $? variable in the surrounding lexical scope that is being compiled.</seg></tuv>
  <tuv xml:lang="JA"><seg>固まってまたは一時しのぎをする、COMPILING変数は固まる、または、一時しのぎをする編集されている周囲のレキシカルスコープの初期の$?変数。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If nothing in the context is being compiled, an exception is thrown.</seg></tuv>
  <tuv xml:lang="JA"><seg>前後関係の何も編集されていないならば、例外は投げられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that CALLER::&amp;lt;$?FOO&amp;gt; might discover the same variable as COMPILING::&amp;lt;$?FOO&amp;gt;, but only if the compiling scope is the immediate caller.</seg></tuv>
  <tuv xml:lang="JA"><seg>CALLER::&amp;lt;$?FOO&amp;gt;がCOMPILING::&amp;lt;$?FOO＞と同じ変数を発見するかもしれない点に、しかし、編集しているスコープが近い発信者である場合だけ、注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Likewise OUTER::&amp;lt;$?FOO&amp;gt; might or might not get you to the right place.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、OUTER::&amp;lt;$?FOO&amp;gt;はあなたを適所に連れて行くかもしれないか、連れて行かないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In the abstract, COMPILING::&amp;lt;$?FOO&amp;gt; goes outwards dynamically until it finds a compiling scope, and so is guaranteed to find the &amp;quot;right&amp;quot; $?FOO.</seg></tuv>
  <tuv xml:lang="JA"><seg>抽象的に、それが編集しているスコープを見つけるまで、COMPILING::&amp;lt;$?FOO＞はダイナミックに外へ行って、そして、正しい$?FOOを見つけると保証される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(In practice, the compiler hopefully keeps track of its current compiling scope anyway, so no scan is needed.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（実際には、コンパイラは期待を持って、いずれにしろスコープを編集しているその流れの経過を追うので、走査が必要でない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perceptive readers will note that this subsumes various &amp;quot;compiler hints&amp;quot; proposals.</seg></tuv>
  <tuv xml:lang="JA"><seg>知覚の鋭い読者は、これがいろいろな「コンパイラヒント」提案を包含する点に注意する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Crazy readers will wonder whether this means you could set an initial value for other lexicals in the compiling scope.</seg></tuv>
  <tuv xml:lang="JA"><seg>狂った読者は、あなたがそうすることができたこの手段がスコープを編集する際に初期値を他のlexicalsに設定したかどうか疑問に思う。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The answer is yes.</seg></tuv>
  <tuv xml:lang="JA"><seg>答えは、はいである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In fact, this mechanism is probably used by the exporter to bind names into the importer's namespace.</seg></tuv>
  <tuv xml:lang="JA"><seg>実際、このメカニズムは、輸出者によって輸入業者の名前空間に名前を結びつけるのに多分用いられるだろう。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Switching parsers</seg></tuv>
  <tuv xml:lang="JA"><seg>切換パーサー</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The currently compiling Perl parser is switched by modifying one of the braided languages in COMPILING::&amp;lt;%?LANG&amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>現在編集しているPerl構文解析器は、COMPILING::&amp;lt;%?LANG&amp;gt;で編まれた言語の1つを修正することによって変えられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Lexically scoped parser changes should temporize the modification.</seg></tuv>
  <tuv xml:lang="JA"><seg>辞書的に捜し出された構文解析器変化は一時しのぎをしなければならない修正。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Changes from here to end-of-compilation unit can just assign or bind it.</seg></tuv>
  <tuv xml:lang="JA"><seg>ここから編集の終了単位への変化は、ちょうどそれを割り当てることができるか、結びつけることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In general, most parser changes involve deriving a new grammar and then pointing one of the COMPILING::&amp;lt;%?LANG&amp;gt; entries at that new grammar.</seg></tuv>
  <tuv xml:lang="JA"><seg>一般に、大部分の構文解析器変化は、その新しい文法で新しい文法とそれからCOMPILING::&amp;lt;%?LANG&amp;gt;エントリーのポイントしている一つを引き出すことが必要である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Alternately, the tables driving the current parser can be modified without derivation, but at least one level of anonymous derivation must intervene from the preceding Perl grammar, or you might be messing up someone else's grammar.</seg></tuv>
  <tuv xml:lang="JA"><seg>あるいは、現在の構文解析器を駆動しているテーブルは起源なしで修正されることができる、しかし、少なくとも1レベルの匿名の起源は前のPerl文法から介入しなければならない、または、あなたは他の誰かの文法をだいなしにしているかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Basically, the current set of grammars in %?LANG has to belong only to the current compiling scope.</seg></tuv>
  <tuv xml:lang="JA"><seg>基本的に、%?LANGの文法書の現在のセットは、スコープを編集している流れだけに属していなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It may not be shared, at least not without explicit consent of all parties.</seg></tuv>
  <tuv xml:lang="JA"><seg>少なくともすべての党の明示的同意なしででない、それは共有されないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>No magical syntax at a distance.</seg></tuv>
  <tuv xml:lang="JA"><seg>少し離れた不思議な構文でない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Consent of the governed, and all that.</seg></tuv>
  <tuv xml:lang="JA"><seg>支配するもの、その他の同意。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Slangs</seg></tuv>
  <tuv xml:lang="JA"><seg>俗語</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Individual sublanguages (&amp;quot;slangs&amp;quot;) may be referred to using the ~ twigil.</seg></tuv>
  <tuv xml:lang="JA"><seg>個々の部分言語（「俗語」）は、~ twigilを使うことを参照するかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The following are useful:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下は役に立つ：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hence, when you are defining a normal Perl macro, you're replacing $~MAIN with a derived language, but when you define a new regex backslash sequence, you're replacing $~Regex with a derived language.</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに、通常のPerlマクロを定義しているとき、あなたは$~MAINを派生言語と入れ替えている、しかし、新しい正規表現バックスラッシュシーケンスを定義するとき、あなたは$~Regexを派生言語と入れ替えている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(There may or may not be a syntax in the main language to do this.) Note that such changes are automatically scoped to the lexical scope;</seg></tuv>
  <tuv xml:lang="JA"><seg>なお、そのような変化は、レキシカルスコープに自動的に捜し出される（構文が、こうするために、主要な言語であるかもしれないか、ないかもしれない。）;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>as with real slang, the definitions are temporary and embedded in a larger language inherited from the surrounding culture.</seg></tuv>
  <tuv xml:lang="JA"><seg>本当の俗語と同様に、定義はテンポラリーで、周囲の文化から受け継がれるより大きな言語に埋め込まれる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instead of defining macros directly you may also mix in one or more grammar rules by lexically scoped declaration of a new sublanguage:</seg></tuv>
  <tuv xml:lang="JA"><seg>直接マクロを定義する代わりに、あなたは新しい部分言語の辞書的に捜し出された宣言によって、一つ以上の文法規則も混ぜるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This tends to be more efficient since it only has to do one mixin at the end of the block.</seg></tuv>
  <tuv xml:lang="JA"><seg>それがブロックの終わりに1つのミキシンをしなければならないだけの時から、これはより効率的な傾向がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that the slang declaration has nothing to do with package Regex, but only with $~Regex.</seg></tuv>
  <tuv xml:lang="JA"><seg>$~Regexだけで以外、俗語宣言がパッケージRegexとは無関係であることに注意すべきである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Sublanguages are in their own namespace (inside the current value of %?LANG, in fact).</seg></tuv>
  <tuv xml:lang="JA"><seg>部分言語は、彼ら自身の名前空間（実際、%?LANGの現在の値の中に）にある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hence augment is modifying one of the local strands of a braided language, not a package somewhere else.</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに、augmentは編まれた言語（どこかのパッケージでない他に）のローカル要素の1つを修正している。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may also supersede a sublang entirely if, for example, you just want to disable that sublanguage in the current lexical scope:</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、ちょうど現在のレキシカルスコープでその部分言語を働かなくしたいならば、あなたは完全にsublangにも取って代わるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you supersede MAIN then you're replacing the Perl parser entirely.</seg></tuv>
  <tuv xml:lang="JA"><seg>MAINに取って代わるならば、あなたは完全にPerl構文解析器を交換している。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This might be done by, say, the &amp;quot;use COBOL&amp;quot; declaration.</seg></tuv>
  <tuv xml:lang="JA"><seg>まあ、これは&amp;quot;use COBOL&amp;quot;宣言によってされるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>:-)</seg></tuv>
  <tuv xml:lang="JA"><seg>:-)</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Extended identifiers</seg></tuv>
  <tuv xml:lang="JA"><seg>拡張識別子</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is often convenient to have names that contain arbitrary characters or other data structures.</seg></tuv>
  <tuv xml:lang="JA"><seg>任意の文字またはその他のデータ構造を含む名前を持つことは、しばしば便利である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Typically these uses involve situations where a set of entities shares a common &amp;quot;short&amp;quot; name, but still needs for each of its elements to be identifiable individually.</seg></tuv>
  <tuv xml:lang="JA"><seg>一般的に、これらの用途は、一組の実体が普通の「短い」名前を共有するが、まだその要素の各々のために個々に定義可能な必要がある状況を含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For example, you might use a module whose short name is ThatModule, but the complete long name of a module includes its version, naming authority, and perhaps even its source language.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえば、あなたは短いファイル名がThatModuleであるモジュールを使用するかもしれない、しかし、モジュールの完全な長い名前はそのバージョン、命名機関とおそらくその起点言語さえ含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Similarly, sets of operators work together in various syntactic categories with names like prefix, infix, postfix, etc. The long names of these operators, however, often contain characters that are excluded from ordinary identifiers.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、しかし、演算子の仲間はprefix、infix、postfix、その他のような名前でいろいろな構文法のカテゴリーで一緒にこれらの演算子の長い名前を働かせる。そして、しばしば、通常識別子から除外される文字を含みなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For all such uses, an identifier followed by a subscript-like adverbial form (see below) is considered an extended identifier:</seg></tuv>
  <tuv xml:lang="JA"><seg>すべてのそのような用途（添え字のような副詞形が続く識別子）（下記参照）のために、延長した識別子は考えられる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This name is to be thought of semantically, not syntactically.</seg></tuv>
  <tuv xml:lang="JA"><seg>この名前は、構文的にでなく、意味論的に、考えられることになっている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, the bracketing characters used do not count as part of the name;</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、使われる括弧に入れている文字は、名前の一部として数えない;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>only the quoted data matters.</seg></tuv>
  <tuv xml:lang="JA"><seg>引合いに出されたデータ問題だけ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These are all the same name:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらは、すべての同じ名前である：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Despite the appearance as a subscripting form, these names are resolved not at run time but at compile time.</seg></tuv>
  <tuv xml:lang="JA"><seg>添え字付けの形としての出演にもかかわらず、これらの名前は、実行時でなくコンパイル時で分解される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The pseudo-subscripts need not be simple scalars.</seg></tuv>
  <tuv xml:lang="JA"><seg>疑似添え字は、単純なスカラーである必要はない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These are extended with the same two-element list:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらは、同じ2-要素リストで広げられる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An identifier may be extended with multiple named identifier extensions, in which case the names matter but their order does not.</seg></tuv>
  <tuv xml:lang="JA"><seg>識別子は複数の挙げられた識別子拡張で広げられるかもしれない、その場合には、名前は重要である、しかし、彼らの順序はそうしない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These name the same module:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらは、同じモジュールを挙げる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Adverbial syntax will be described more fully later.</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞の構文は、後でより完全に記述される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Literals</seg></tuv>
  <tuv xml:lang="JA"><seg>リテラル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 has a rich set of literal forms, many of which can be used for textual input as well.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6は文字通りの形の豊かなセットを持っている。そして、それの多くが同様に原文の入力のために使われることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For those forms simple enough to be allowed, the val() function treats such a string value as if it were a literal in the program.</seg></tuv>
  <tuv xml:lang="JA"><seg>許されるのに十分単純なそれらの形については、まるでそれがプログラムのリテラルであるように、val()関数はそのような文字列値を扱う。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In some cases the val() function will be applied on your behalf, and in other cases you must do so explicitly.</seg></tuv>
  <tuv xml:lang="JA"><seg>場合によっては、val()関数は代わりに適用される、そして、その他の場合、あなたははっきりとそうしなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The rationale for this function is that there are many cases where the programmer or user is forced to use a string type to represent a value that is intended to become a numeric type internally.</seg></tuv>
  <tuv xml:lang="JA"><seg>この関数のための正当性は、プログラマーまたはユーザーが内部的に数値型になることを意図される値を表現するために文字列型を使うことを強制される多くのケースがあるということである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Committing pre-emptively to either a string type or a numeric type is likely to be wrongish, so Perl 6 instead provides the concept of allomorphic literals.</seg></tuv>
  <tuv xml:lang="JA"><seg>文字列型か数値型に先買権でゆだねることはwrongishでありそうであるので、Perl 6はallomorphicなリテラルの概念をその代わりに提供する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>How these work is described below in &amp;quot;Allomorphic value semantics&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>なんて、これらの仕事は、「Allomorphic値意味論」で後述するだろう。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When used as literals in a program, most of these forms produce an exact type, and are not subject to val() processing.</seg></tuv>
  <tuv xml:lang="JA"><seg>プログラムのリテラルとして使われるとき、大部分のこれらの形は正確な型を生じて、val()処理を受けない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The exceptions will be noted as we go.</seg></tuv>
  <tuv xml:lang="JA"><seg>我々が行って、例外は注意される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Underscores</seg></tuv>
  <tuv xml:lang="JA"><seg>アンダーライン</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A single underscore is allowed only between any two digits in a literal number, where the definition of digit depends on the radix.</seg></tuv>
  <tuv xml:lang="JA"><seg>一つのアンダーラインは文字通りの数で何の間でだけでも2桁許される、そこで、桁の定義は根次第である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(A single underscore is also allowed between a radix prefix and a following digit, as explained in the next section.) Underscores are not allowed anywhere else in any numeric literal, including next to the radix point or exponentiator, or at the beginning or end.</seg></tuv>
  <tuv xml:lang="JA"><seg>（次のセクションで説明されるように、一つのアンダーラインも根接頭辞と以下の桁の間でも許される。）アンダーラインは、何か数値リテラル（基数点またはexponentiatorへの次を含む）の他のどこにも、または、始めまたは終わりで許されない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Radix markers</seg></tuv>
  <tuv xml:lang="JA"><seg>根目印</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Initial 0 no longer indicates octal numbers by itself.</seg></tuv>
  <tuv xml:lang="JA"><seg>最初の0は、単独で八進数をもはや示さない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You must use an explicit radix marker for that.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、それの明示的根標識を使わなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Pre-defined radix prefixes include:</seg></tuv>
  <tuv xml:lang="JA"><seg>あらかじめ定義された根接頭辞は以下を含む：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Each of these allows an optional underscore after the radix prefix but before the first digit.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの各々は、最初の桁の前に根接頭辞の後オプションのアンダーラインを以外許す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These all mean the same thing:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらのすべては、同じものを意味する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>General radices</seg></tuv>
  <tuv xml:lang="JA"><seg>一般根</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The general radix form of a number involves prefixing with the radix in adverbial form:</seg></tuv>
  <tuv xml:lang="JA"><seg>番号の一般根の形態は、副詞形で根でプレフィクシングを含む：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Extra digits are assumed to be represented by a..z and A..Z, so you can go up to base 36.</seg></tuv>
  <tuv xml:lang="JA"><seg>余分の桁はa..zによって表現されて、A..Zであるとされるので、あなたはベース36に上がることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Use A and B for base twelve, not T and E.) Alternately you can use a list of digits in decimal:</seg></tuv>
  <tuv xml:lang="JA"><seg>代わりとして、あなたは小数で桁のリストを使うことができる（ベース12、TでないとEのためにAとBを使いなさい。）：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All numbers representing digits must be less than the radix, or an error will result (at compile time if constant-folding can catch it, or at run time otherwise).</seg></tuv>
  <tuv xml:lang="JA"><seg>桁を表現しているすべての数は根より少なくなければならない、または、エラーは起こる（定数畳込みが、あるいは、さもなければ実行時で、それを捕えることができるならばコンパイル時状態にある）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any radix may include a fractional part.</seg></tuv>
  <tuv xml:lang="JA"><seg>何か根は、小数点部を含むかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A dot is never ambiguous because you have to tell it where the number ends:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが数がどこで終わるかについてそれに話さなければならないので、点は決してあいまいでない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Exponentials</seg></tuv>
  <tuv xml:lang="JA"><seg>指数関数</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Only base 10 (in any form) allows an additional exponentiator starting with 'e' or 'E'.</seg></tuv>
  <tuv xml:lang="JA"><seg>ベース10（どんな形でも）だけは、更なるexponentiatorが『e』または『E』から始めているのを許す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All other radixes must either rely on the constant folding properties of ordinary multiplication and exponentiation, or supply the equivalent two numbers as part of the string, which will be interpreted as they would outside the string, that is, as decimal numbers by default:</seg></tuv>
  <tuv xml:lang="JA"><seg>他の全ての根は普通の掛け算と累乗の定数畳込みプロパティに頼らなければならないか、デフォルトで十進数として、文字列（それらが文字列の外でそうして、それは解釈される）の一部として、つまり、等価2番号を供給しなければならない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It's true that only radixes that define e as a digit are ambiguous that way, but with any radix it's not clear whether the exponentiator should be 10 or the radix, and this makes it explicit:</seg></tuv>
  <tuv xml:lang="JA"><seg>桁としてeを定義する根だけがそのようにあいまいであるというのは本当である、しかし、何か根で、exponentiatorが10か根でなければならないかどうかは明らかでない、そして、これは明示的にする：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>So we write those as</seg></tuv>
  <tuv xml:lang="JA"><seg>我々がそれらを書くように、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The generic string-to-number converter will recognize all of these forms (including the * form, since constant folding is not available to the run time).</seg></tuv>
  <tuv xml:lang="JA"><seg>一般的な数への文字列コンバータは、これらの形（*の形を含む、定数畳込みが実行時が利用できない時から）の全てを認知する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Also allowed in strings are leading plus or minus, and maybe a trailing Units type for an implied scaling.</seg></tuv>
  <tuv xml:lang="JA"><seg>また、入れられた文字列は、意味されたスケーリングのためにプラスまたはマイナスと多分後置単位型を導いているだろう。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Leading and trailing whitespace is ignored.</seg></tuv>
  <tuv xml:lang="JA"><seg>主要なおよび後置空白文字は無視される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note also that leading 0 by itself never implies octal in Perl 6.</seg></tuv>
  <tuv xml:lang="JA"><seg>また、主要な0がPerl 6で８進を単独で決して意味しない点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In all these cases, the type produced will be the narrowest of Int, Rat, or Num that can accurately represent the number.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべてのこれらのケースに、生み出される型は、Int、Ratまたは数を正確に表現することができるNumで最も狭い。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If no type can represent it exactly, it should be returned as either a Rat or a Num, whichever is more accurate.</seg></tuv>
  <tuv xml:lang="JA"><seg>型が必ずしもそれを表現することができないならば、それはRatかNum（より正確であるものはどれでも）として返納印でなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Rat64 will tend to be more accurate for numbers of normal or large magnitude, while Num64 may be more accurate for numbers of very small magnitude, since the Rat's size mismatch of numerator and denominator will eventually cost more accuracy than the Num's exponent overhead.</seg></tuv>
  <tuv xml:lang="JA"><seg>（Ratが分子のサイズ不適当な組合せである時から、Num64が非常に少ない大きさの番号のためにより正確である場合がある間、Rat64は通常であるかかなりの大きさの番号のためにより正確な傾向がある、そして、結局、分母はNumが頭上で主唱者であるより多くの正確さを犠牲にする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As a limiting case, a Rat64 cannot represent any number smaller than :10&amp;lt;1*2**-64&amp;gt;.)</seg></tuv>
  <tuv xml:lang="JA"><seg>制限的なケースとして、Rat64は:10&amp;lt;1*2**-64&amp;gt;より少ない何か数を表現することができない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A consequence of the preceding is that you cannot make a FatRat using colon notation.</seg></tuv>
  <tuv xml:lang="JA"><seg>先立つ結果は、あなたがFatRatをコロン表記法を使用しているようにすることができないということである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You must rely on constructors and constant folding:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、コンストラクタと定数畳込みに頼らなければならない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Conversion functions</seg></tuv>
  <tuv xml:lang="JA"><seg>転換関数</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any of the adverbial forms may be used as a function:</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞形のどれでも、関数として使われるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Think of these as setting the default radix, not forcing it.</seg></tuv>
  <tuv xml:lang="JA"><seg>それを強制しなくて、デフォルト根をセットするように、これらについて考えなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Like Perl 5's old oct() function, any of these will recognize a number starting with a different radix marker and switch to the other radix.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 5の古いoct()が機能するように、これらのどれでも異なる根目印から始めている数を認知して、他の根に変わる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, note that the :16() converter function will interpret leading 0b or 0d as hex digits, not radix switchers.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、:16()コンバータ関数が主要な0bまたは0dを16進数（根スイッチャでない）と解釈する点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use of the functional form on anything that is not a string will throw an exception explaining that the user has confused a number with the textual representation of a number.</seg></tuv>
  <tuv xml:lang="JA"><seg>文字列でない何の関数形式の使用でも、ユーザーが数を数の原文の表現と混同したと説明している例外を投げる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is to catch errors such as a :8(777) that should have been :8&amp;lt;777&amp;gt;, or the attempt to use the function in reverse to produce a textual representation from a number.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、エラー（例えば:8&amp;lt;777&amp;gt;でなければならなかった:8(777)または原文の代表を数から作り出すために逆に関数を使う試み）を捕えることである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Rational literals</seg></tuv>
  <tuv xml:lang="JA"><seg>合理的なリテラル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Rational literals are indicated by separating two integer literals (in any radix) with a slash, and enclosing the whole in angles:</seg></tuv>
  <tuv xml:lang="JA"><seg>合理的なリテラルは、スラッシュで2つの整数リテラル（何か根の）を切り離して、全体を角度に入れることによって示される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whitespace is not allowed on either side of the slash or it will be split under normal quote-words semantics:</seg></tuv>
  <tuv xml:lang="JA"><seg>空白文字はスラッシュの両側に許されない、または、それは通常の引用-ワード意味論の下で割られる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Because of constant folding, you may often get away with leaving out the angles:</seg></tuv>
  <tuv xml:lang="JA"><seg>定数畳込みのため、あなたは角度を無視してしばしば逃げのびるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, in that case you have to pay attention to precedence and associativity.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、その場合、あなたは優先順位と結合性に注意を払わなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The following does not cube 2/3:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下は、2/3をさいの目にしない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Decimal fractions not using &amp;quot;e&amp;quot; notation are also treated as literal Rat values:</seg></tuv>
  <tuv xml:lang="JA"><seg>「e」表記法を使用していない小数は、文字通りのRat値ともみなされる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Literals specified in angle brackets are always subject to val() processing, so &amp;lt;1/2&amp;gt; produces a value that is both a Rat and a Str.</seg></tuv>
  <tuv xml:lang="JA"><seg>かぎ括弧で指定されているリテラルは常にval()処理を受けるので、&amp;lt;1/2&amp;gt;はRatとStrである値を生じる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See &amp;quot;Allomorphic value semantics&amp;quot; below.</seg></tuv>
  <tuv xml:lang="JA"><seg>下記の「Allomorphic値意味論」を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Complex literals</seg></tuv>
  <tuv xml:lang="JA"><seg>複雑なリテラル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Complex literals are similarly indicated by writing an addition or subtraction of two real numbers (again, without spaces around the operators) inside angles:</seg></tuv>
  <tuv xml:lang="JA"><seg>複雑なリテラルは、2実数の追加または引き算を書くことによって、同じように示される再び、スペースが演算子のあたりになくて、（）角度の中に：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As with rational literals, constant folding would produce the same complex number, but this form parses as a single term, ignoring surrounding precedence.</seg></tuv>
  <tuv xml:lang="JA"><seg>合理的なリテラルと同様に、定数畳込みは同じ複素数を生じる、しかし、この形はシングルとして項を解析する。そして、周囲の優先順位を無視する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Note that these are not actually special syntactic forms:</seg></tuv>
  <tuv xml:lang="JA"><seg>（これらが実際に特別な構文法の形でないことに注意すべきである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>both rational and complex literal forms fall out naturally from the semantic rules of qw quotes described below.)</seg></tuv>
  <tuv xml:lang="JA"><seg>合理的で複雑な文字通りの形は、以下に記すqw引用の意味規則から、自然に運ぶ。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Literals specified in angle brackets are always subject to val() processing, so &amp;lt;1+2i&amp;gt; produces a value that is both a Complex and a Str.</seg></tuv>
  <tuv xml:lang="JA"><seg>かぎ括弧で指定されているリテラルは常にval()処理を受けるので、&amp;lt;1+2i&amp;gt;はComplexとStrである値を生じる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See &amp;quot;Allomorphic value semantics&amp;quot; below.</seg></tuv>
  <tuv xml:lang="JA"><seg>下記の「Allomorphic値意味論」を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Blob literals</seg></tuv>
  <tuv xml:lang="JA"><seg>Blobリテラル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Blob literals look similar to integer literals with radix markers, but use curlies instead of angles:</seg></tuv>
  <tuv xml:lang="JA"><seg>Blobリテラルは根目印で整数リテラルと類似しているように見えるが、角度の代わりにcurliesを使う：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whitespace and underscores are allowed but ignored.</seg></tuv>
  <tuv xml:lang="JA"><seg>空白文字とアンダーラインは、許されるが、無視される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Radix interpolation</seg></tuv>
  <tuv xml:lang="JA"><seg>根展開</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Characters indexed by hex numbers can be interpolated into strings by introducing with &amp;quot;\x&amp;quot;, followed by either a bare hex number (&amp;quot;\x263a&amp;quot;) or a hex number in square brackets (&amp;quot;\x[263a]&amp;quot;).</seg></tuv>
  <tuv xml:lang="JA"><seg>十六進数によって索引付けされる文字は&amp;quot;\x&amp;quot;で持ち出すことによって文字列に改変されることができる。そして、角括弧（&amp;quot;\x[263a]&amp;quot;）でぎりぎりの十六進数（&amp;quot;\x263a&amp;quot;）か十六進数が続く。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Similarly, &amp;quot;\o12&amp;quot; and &amp;quot;\o[12]&amp;quot; interpolate octals--but generally you should be using hex in the world of Unicode.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、&amp;quot;\o12&amp;quot;と&amp;quot;\o[12]&amp;quot;は８進を差し込む－しかし、通常、あなたはユニコードの世界で16進法を使用していなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Multiple characters may be specified within any of the bracketed forms by separating the numbers with comma:</seg></tuv>
  <tuv xml:lang="JA"><seg>複数の文字は、コンマで数を切り離すことによって、括弧に入れられた形のどれの範囲内ででも指定されるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>&amp;quot;\x[41,42,43]&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>&amp;quot;\x[41,42,43]&amp;quot;。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You must use the bracketed form to disambiguate if the unbracketed form would &amp;quot;eat&amp;quot; too many characters, because all of the unbracketed forms eat as many characters as they think look like digits in the radix specified.</seg></tuv>
  <tuv xml:lang="JA"><seg>unbracketedされた形の全てがそれらが根で桁のような観察が指定されたと考えるのと同じくらい多くの文字を食べるので、あなたはunbracketedされた形があまりに多くの文字を「食べる」ならば、曖昧さをなくす括弧に入れられた形を使用しなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>None of these notations work in normal Perl code.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの表記法のどれも、通常のPerlコードで動かない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>They work only in interpolations and regexes and the like.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらは、展開と正規表現などだけで動く。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that the inside of the brackets is not an expression, and you may not interpolate there, since that would be a double interpolation.</seg></tuv>
  <tuv xml:lang="JA"><seg>ブラケットの内部が表現でないことに注意すべきである、そして、それが二重の補間法である時から、そこで改竄しなくてもよい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use curlies to interpolate the values of expressions.</seg></tuv>
  <tuv xml:lang="JA"><seg>表現の値を差し込むために、curliesを使いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The old \123 form is now illegal, as is the \0123 form.</seg></tuv>
  <tuv xml:lang="JA"><seg>\0123ができられているように、古い\123の形は現在無効である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Only \0 remains, and then only if the next character is not in the range '0'..'7'.</seg></tuv>
  <tuv xml:lang="JA"><seg>\0だけは残る、そして、次がある場合だけ、文字は範囲'0'..'7'でない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Octal characters must use \o notation.</seg></tuv>
  <tuv xml:lang="JA"><seg>８進の文字は、\o表記法を使用しなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note also that backreferences are no longer represented by \1 and the like--see S05.</seg></tuv>
  <tuv xml:lang="JA"><seg>また、後方参照が\1などによってもはや表現されない点に注意しなさい－S05を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Angle quotes (quote words)</seg></tuv>
  <tuv xml:lang="JA"><seg>角度は、引用する（ワードを引合いに出す）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The qw/foo bar/ quote operator now has a bracketed form:</seg></tuv>
  <tuv xml:lang="JA"><seg>qw/foo bar/引用演算子には、現在括弧に入れられた形がある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>&amp;lt;foo bar&amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>&amp;lt;foo bar&amp;gt;。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When used as a subscript it performs a slice equivalent to 'foo','bar'.</seg></tuv>
  <tuv xml:lang="JA"><seg>添え字として使われるとき、それは'foo','bar'に等しいスライスを実行する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Elsewhere it is equivalent to a parenthesized list of strings:</seg></tuv>
  <tuv xml:lang="JA"><seg>どこかほかで、それは文字列の括弧に入れられたリストに等しい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>('foo','bar').</seg></tuv>
  <tuv xml:lang="JA"><seg>('foo','bar')。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since parentheses are generally reserved just for precedence grouping, they merely autointerpolate in flat list context.</seg></tuv>
  <tuv xml:lang="JA"><seg>括弧が通常、ちょうど優先順位グループのために予約されているので、それらは単に平らなリストコンテキストでautointerpolateするだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Therefore</seg></tuv>
  <tuv xml:lang="JA"><seg>したがって、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>is equivalent to:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下に等しい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>which is the same as:</seg></tuv>
  <tuv xml:lang="JA"><seg>そしてそれは以下と同じようにある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In item context, the implied grouping parentheses are still there, so</seg></tuv>
  <tuv xml:lang="JA"><seg>アイテム前後関係では、そう、意味されたグループ括弧は、まだそこにある</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>is equivalent to:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下に等しい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>which assigns a Parcel to the variable.</seg></tuv>
  <tuv xml:lang="JA"><seg>そしてそれはParcelを変数に割り当てる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>On the other hand, if you backslash the parcel:</seg></tuv>
  <tuv xml:lang="JA"><seg>他方で、もしもである、あなたバックスラッシュは、パーセルである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>it is like:</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、以下のようにある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>and ends up storing a Capture object (which weeds out any named arguments into a separate structure, in contrast to a Parcel, which keeps everything in its original list).</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、Captureオブジェクト（Parcelと対照的に、すべてをその元のリストに保つ別構造に少しも名をつけられた引数を除く）を格納することの上の端。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Binding is different from assignment.</seg></tuv>
  <tuv xml:lang="JA"><seg>バインディングは、割当てと異なる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If bound to a signature, the &amp;lt;a b&amp;gt; parcel will be promoted to a Capture object, but if bound to a parameter, it will make the flattening/slicing decision based on the nature of the individual parameter.</seg></tuv>
  <tuv xml:lang="JA"><seg>シグネチャに密接に結びつくならば、&amp;lt;a b&amp;gt;パーセルはCaptureオブジェクトに昇進させられる、しかし、パラメータに密接に結びつくならば、それは個々のパラメータの性質に基づく平らになっている/スライス決定をする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, if you pass &amp;lt;a b&amp;gt; as an argument, it will bind as a single item to a positional or slice parameter, and as two items to a slurpy parameter.</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、あなたが引数として&amp;lt;a b&amp;gt;を通過するならば、それは位置またはスライスパラメータへの一つのアイテムとして、そして、slurpyパラメータへの2つのアイテムとして結合する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>But note that under the parenthesis-rewrite rule, a single value will still act like a single value.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、括弧-書き換え規則の下で、一つの値がまだ一つの値のようなふりをする点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These are all the same:</seg></tuv>
  <tuv xml:lang="JA"><seg>これらは、それでもなお以下の通りである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Strings within angle brackets are subject to val() processing, and any component that parses successfully as a numeric literal will become both a string and a number.</seg></tuv>
  <tuv xml:lang="JA"><seg>かぎ括弧の範囲内の文字列はval()処理を受ける、そして、それが数値リテラルとしてうまく解析する何か構成要素は文字列と数になる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See &amp;quot;Allomorphic value semantics&amp;quot; below.</seg></tuv>
  <tuv xml:lang="JA"><seg>下記の「Allomorphic値意味論」を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Explicit Parcel construction</seg></tuv>
  <tuv xml:lang="JA"><seg>明示的パーセル構築</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As the previous section shows, a parcel is not automatically constructed by parens;</seg></tuv>
  <tuv xml:lang="JA"><seg>前のセクションショーとして、パーセルは括弧によって自動的に造られない;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>the parcel is actually constructed by the comma, not by the parens.</seg></tuv>
  <tuv xml:lang="JA"><seg>括弧によってでなく、パーセルは実はコンマによって造られる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To force a single value to become a composite object in item context, either add a comma inside parens, or use an appropriate constructor or composer for clarity as well as correctness:</seg></tuv>
  <tuv xml:lang="JA"><seg>一つの値にアイテム前後関係のコンポジットオブジェクトになることを強制するために、括弧内部にコンマを加えるか、明快さならびに正しさのために適切なコンストラクタまたはコンポーザーを使いなさい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Disallowed forms</seg></tuv>
  <tuv xml:lang="JA"><seg>認められなかった形</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The degenerate case &amp;lt;&amp;gt; is disallowed as a probable attempt to do IO in the style of Perl 5;</seg></tuv>
  <tuv xml:lang="JA"><seg>退歩したケース&amp;lt;&amp;gt;は、Perl 5のスタイルでイオをまねる見込みがある試みとして認められない;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>that is now written lines().</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、現在lines()を書かれる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(&amp;lt;STDIN&amp;gt; is also disallowed.) Empty lists are better written with () in any case because &amp;lt;&amp;gt; will often be misread as meaning ('').</seg></tuv>
  <tuv xml:lang="JA"><seg>('')を意味するように&amp;lt;&amp;gt;がしばしば読み誤られるので、空きリストはいずれにせよ()でより上手に書かれる（&amp;lt;STDIN&amp;gt;も認められない。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Likewise the subscript form %foo&amp;lt;&amp;gt; should be written %foo to avoid misreading as @foo''.) If you really want the angle form for stylistic reasons, you can suppress the error by putting a space inside:</seg></tuv>
  <tuv xml:lang="JA"><seg>文体の理由のために角度の形態を本当に望むならば、あなたはスペースを以下に入れることによってエラーを抑えることができる（同様に、下に書かれた形%foo&amp;lt;&amp;gt;は@foo''として読み違いを避けるために%fooを書かれなければならない。）：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>&amp;lt; &amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>&amp;lt; &amp;gt;.</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Relationship between &amp;lt;&amp;gt; and ≪≫</seg></tuv>
  <tuv xml:lang="JA"><seg>&amp;lt;&amp;gt;と≪≫の関係</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Much like the relationship between single quotes and double quotes, single angles do not interpolate while double angles do. The double angles may be written either with French quotes, ≪$foo @bar[]≫, or with &amp;quot;Texas&amp;quot; quotes, &amp;lt;&amp;lt;$foo @bar[]&amp;gt;&amp;gt;, as the ASCII workaround.</seg></tuv>
  <tuv xml:lang="JA"><seg>非常にシングルクォートとダブルクォート（二重山形がそうする間、角度が差し込まないシングル）の関係ような。二重山形は、フランスの引用（≪$foo @bar[]≫）で、または、ASCII回避方法としてのテキサス引用（&amp;lt;&amp;lt;$foo @bar[]&amp;gt;&amp;gt;）で書かれるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The implicit split is done after interpolation, but respects quotes in a shell-like fashion, so that ≪'$foo' &amp;quot;@bar[]&amp;quot;≫ is guaranteed to produce a list of two &amp;quot;words&amp;quot; equivalent to ('$foo', &amp;quot;@bar[]&amp;quot;).</seg></tuv>
  <tuv xml:lang="JA"><seg>潜在的な分裂は展開の後されるが、耳ファッションで引用を尊重する、そのため、≪'$foo' &amp;quot;@bar[]&amp;quot;≫は('$foo', &amp;quot;@bar[]&amp;quot;)に2つのワード等価物のリストを生産すると保証される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Pair notation is also recognized inside ≪...≫ and such &amp;quot;words&amp;quot; are returned as Pair objects.</seg></tuv>
  <tuv xml:lang="JA"><seg>Pair表記法は≪...≫の中にも認知される、そして、そのようなワードはPairオブジェクトとして返納印である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Colon pairs (but not arrow pairs) are recognized within double angles.</seg></tuv>
  <tuv xml:lang="JA"><seg>コロン組（しかし、矢組でなく）は、二重山形の中で認知される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In addition, the double angles allow for comments beginning with #.</seg></tuv>
  <tuv xml:lang="JA"><seg>そのうえ、二重山形は、#から始めているコメントを考慮に入れる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These comments work exactly like ordinary comments in Perl code.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらのコメントは、Perlコードで普通のコメントのように正確に動く。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unlike in the shells, any literal # must be quoted, even ones without whitespace in front of them, but note that this comes more or less for free with a colon pair like :char&amp;lt;#x263a&amp;gt;, since comments only work in double angles, not single.</seg></tuv>
  <tuv xml:lang="JA"><seg>シェルではとは異なり、何か文字通りの#は空白文字がそれらの前にない引合いに出された、均一なものでなければならないが、これがコメントが二重山形で動くだけの時から:char&amp;lt;#x263a&amp;gt;のようなコロン一組とともに多少無料で来る点に注意しなければならない。そして、独りでない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Adverbial Pair forms</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞の一組の形</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is now a generalized adverbial form of Pair notation.</seg></tuv>
  <tuv xml:lang="JA"><seg>一組表記法の全般的な副詞形が、現在ある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The following table shows the correspondence to the &amp;quot;fatarrow&amp;quot; notation:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下のテーブルは、「fatarrow」表記法との類似を示す：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The fatarrow construct may be used only where a term is expected because it's considered an expression in its own right, since the fatarrow itself is parsed as a normal infix operator (even when autoquoting an identifier on its left).</seg></tuv>
  <tuv xml:lang="JA"><seg>fatarrow自体が通常のインフィックスオペレータ（その左で識別子をautoquotingするときでも）として解析される時から、それがそれ自身のものの表現を正しいと考えたので項が予想される所でだけ、fatarrow構成概念が使われるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Because the left side is a general expression, the fatarrow form may be used to create a Pair with any value as the key.</seg></tuv>
  <tuv xml:lang="JA"><seg>左側が一般表現であるので、fatarrowの形はキーものとして任意の値で一組をつくるのに用いられるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>On the other hand, when used as above to generate Pair objects, the adverbial forms are restricted to the use of identifiers as keys.</seg></tuv>
  <tuv xml:lang="JA"><seg>他方、上記のようにPairオブジェクトを生み出すのに用いられるとき、副詞形はキーとして鑑定人の利用に制限される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You must use the fatarrow form to generate a Pair where the key is not an identifier.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、キーが識別子でないPairを生み出すために、fatarrowの形を使用しなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Despite that restriction, it's possible for other things to come between a colon and its brackets;</seg></tuv>
  <tuv xml:lang="JA"><seg>その規制にもかかわらず、他のものがコロンとそのブラケットの間に入ることは、あり得る;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>however, all of the possible non-identifier adverbial keys are reserved for special syntactical forms.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、あり得る非識別子副詞のキーの全ては、特別な構文的な形のために予約されている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perl 6 currently recognizes decimal numbers and the null key.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6は、現在十進数とヌルキーを認知する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In the following table the first and second columns do not mean the same thing:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下のテーブルでは、第一および第二のコラムは、同じものを意味しない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All of the adverbial forms (including the normal ones with identifier keys) are considered special tokens and are recognized in various positions in addition to term position.</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞形（識別子キーで通常のものを含む）の全ては、よく考えた特別なトークンで、項位置に加えていろいろな位置で公認である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In particular, when used where an infix would be expected they modify the previous topmost operator that is tighter in precedence than &amp;quot;loose unary&amp;quot; (see S03):</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、使われるとき、挿入辞があるところはそれらが「自由に単一体である」（S03を見る）より、優先順位できつい前の一番上の演算子を修正すると予想した：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Within declarations the adverbial form is used to rename parameter declarations:</seg></tuv>
  <tuv xml:lang="JA"><seg>宣言の範囲内で、副詞形はパラメタ宣言の名前を変えるのに用いられる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Adverbs modify the meaning of various quoting forms:</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞は、いろいろな引合いに出している形の意味を修正する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When appended to an identifier (that is, in postfix position), the adverbial syntax is used to generate unique variants of that identifier;</seg></tuv>
  <tuv xml:lang="JA"><seg>識別子（つまり、接尾辞位置で）に付加されたとき、副詞の構文はその識別子のユニークな変形を生み出すのに用いられる;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>this syntax is used for naming operators such as infix:&amp;lt;+&amp;gt; and multiply-dispatched grammatical rules such as statement_control:if.</seg></tuv>
  <tuv xml:lang="JA"><seg>この構文が、命名演算子（例えばstatement_control:ifのようなinfix:&amp;lt;+&amp;gt;と掛算を送られた構文規則）のために使われる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When so used, the adverb is considered an integral part of the name, so infix:&amp;lt;+&amp;gt; and infix:&amp;lt;-&amp;gt; are two different operators.</seg></tuv>
  <tuv xml:lang="JA"><seg>とても使われるとき、副詞は名前のよく考えた構成要素であるので、infix:&amp;lt;+&amp;gt;とinfix:&amp;lt;-&amp;gt;は2人の異なる演算子である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Likewise prefix:&amp;lt;+&amp;gt; is different from infix:&amp;lt;+&amp;gt;.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、prefix:&amp;lt;+&amp;gt;はinfix:&amp;lt;+&amp;gt;と異なる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The notation also has the benefit of grouping distinct identifiers into easily accessible sets;</seg></tuv>
  <tuv xml:lang="JA"><seg>（表記法も、簡単にアクセスできるセットにグループ異なった識別子の助けをかりる;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>this is how the standard Perl 6 grammar knows the current set of infix operators, for instance.)</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、たとえば、標準的なPerl 6文法がインフィックスオペレータの現在のセットを知っている方法である。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Only identifiers that produce a list of one or more values (preferably strings) are allowed as name extensions;</seg></tuv>
  <tuv xml:lang="JA"><seg>一つ以上の値（望ましくは文字列）のリストを提示する鑑定人だけは、名前拡張として許される;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>in particular, closures do not qualify as values, so the :... form is not allowed as a name extender.</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、クロージャは値としての資格を得ないので、:...の形は名前増量剤として許されない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In particular, this frees up the block form after a method name, so it allows us to parse a block as a method argument:</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、これはメソッド名の後ブロックの形を解放するので、それは我々がメソッド引数としてブロックを解析するのを許す：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These might look like it is using pairs, but it is really equivalent to</seg></tuv>
  <tuv xml:lang="JA"><seg>それのようなこれらの力ルックは組を使っている、しかし、それは本当に等しい</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>and the colons are not introducing pairs, but rather introducing the argument list of the method.</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、コロンは一組を導入していなくて、メソッドの引数の並びをむしろ導入している。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(In any other location, :... would be taken as a pair mapping the null key to a closure.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（他のどの場所でも、:...はヌルキーをクロージャにマップしている一組としてされる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Either fatarrow or adverbial pair notation may be used to pass named arguments as terms to a function or method.</seg></tuv>
  <tuv xml:lang="JA"><seg>fatarrowか副詞の一組表記法は、関数またはメソッドへの項として名をつけられた引数を通過するのに用いられるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>After a call with parenthesized arguments, only the adverbial syntax may be used to pass additional arguments.</seg></tuv>
  <tuv xml:lang="JA"><seg>括弧に入れられた引数による呼び出しの後、副詞の構文だけは、更なる引数を通過するのに用いられるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is typically used to pass an extra block:</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、余分のブロックを通り過ぎるのに典型的に用いられる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This just naturally falls out from the preceding rules because the adverbial block is in operator position, so it modifies the &amp;quot;find operator&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞のブロックが演算子位置にあるので、これは前の規則からちょうど自然に抜けるので、それは「検索演算子」を修正する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Parens aren't considered an operator.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（括弧は演算子と考えられない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that (as usual) the ... form (either identifier-based or special) can indicate either a closure or a hash depending on the contents.</seg></tuv>
  <tuv xml:lang="JA"><seg>...の形（識別子ベースであるか特別な）が内容に従いクロージャかハッシュを示すことができる点に（通常通り）注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It does not indicate a subscript, since :key is really equivalent to key =&amp;gt; , and the braces are not behaving as a postfix at all.</seg></tuv>
  <tuv xml:lang="JA"><seg>:keyがkey =&amp;gt; に本当に等しい時から、それは添え字を示さない、そして、ブレースはまったく接尾辞としてふるまっていない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The function to which it is passed can use the value as a subscript if it chooses, however.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（しかし、それが選択をするならば、それが通過される関数は添え字として値を使うことができる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note also that the &amp;lt;a b&amp;gt; form is not a subscript and is therefore equivalent not to .'a','b' but rather to ('a','b').</seg></tuv>
  <tuv xml:lang="JA"><seg>また、&amp;lt;a b&amp;gt;の形が添え字でなくて、したがって、.'a','b'にでなくむしろ('a','b')に等しい点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Bare &amp;lt;a&amp;gt; turns into ('a') rather than ('a',).</seg></tuv>
  <tuv xml:lang="JA"><seg>裸の&amp;lt;a&amp;gt;は、('a',)よりもむしろ('a')に変わる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(However, as with the other bracketed forms, the value may end up being used as a subscript depending on context.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（しかし、他の括弧に入れられた形と同様に、値は結局前後関係に従う添え字として使われることになるかもしれない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Two or more adverbs can always be strung together without intervening punctuation anywhere a single adverb is acceptable.</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞が常にそうであることがありえる二個以上は、一つの副詞が許容できる場所を中の句読点なしでつなぎ合わせた。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When used as named arguments in an argument list, you may put comma between, because they're just ordinary named arguments to the function, and a fatarrow pair would work the same.</seg></tuv>
  <tuv xml:lang="JA"><seg>引数の並びの名をつけられた引数として使われるとき、それらが関数とfatarrowへの一組が同じものを動かすという引数という名のちょうど普通であるので、あなたはコンマを置くかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, this comma is allowed only when the first pair occurs where a term is expected.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、項が予想される所で最初の一組が起こる時だけ、このコンマは許される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Where an infix operator is expected, the adverb is always taken as modifying the nearest preceding operator that is not hidden within parentheses, and if you string together multiple such pairs, you may not put commas between, since that would cause subsequent pairs to look like terms.</seg></tuv>
  <tuv xml:lang="JA"><seg>インフィックスオペレータが待たれている所で、括弧の範囲内で隠されない最も近い前の演算子を修正するように、副詞は常にとられる、そして、あなたがチェーン店をつなぎ合わせる、そのような一組、それが以降の組が項のように見える原因になる時から、コンマを置かなくてもよい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The fatarrow form is not allowed at all in operator position.) See S06 for the use of adverbs as named arguments.</seg></tuv>
  <tuv xml:lang="JA"><seg>挙げられた引数として副詞の用法については、S06を見なさい。（fatarrowの形は、交換台でまったく許されない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The negated form (:!a) and the sigiled forms (:$a, :@a, :%a) never take an argument and don't care what the next character is.</seg></tuv>
  <tuv xml:lang="JA"><seg>否定された形（:!a）とsigiledされた形（:$a、:@a、:%a）は、引数を決してしなくて、次の文字が何であるかについて、気にしない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>They are considered complete.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらは、完全であると考えられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These forms require an identifier to serve as the key.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの形は、キーとして用いられることを識別子に要求する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For identifiers that take a numeric argument, it is allowed to abbreviate, for example, :sweet(16) to :16sweet.</seg></tuv>
  <tuv xml:lang="JA"><seg>数の引数をする識別子のために、それは、たとえば、:sweet(16)を:16sweetと略すのを許される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(This is distinguishable from the :16&amp;lt;deadbeef&amp;gt; form, which never has an alphabetic character following the number.) Only literal decimal numbers may be swapped this way.</seg></tuv>
  <tuv xml:lang="JA"><seg>文字通りの十進数だけは、このように交換されるかもしれない（これは、:16&amp;lt;deadbeef&amp;gt;の形と区別できる。そして、それは数の後、英字を決して持っていない。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Please note that this abbreviation allows:</seg></tuv>
  <tuv xml:lang="JA"><seg>この省略形が以下を許す点に注意してください：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The other forms of adverb (including the bare :a form) always look for an immediate bracketed argument, and will slurp it up.</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞（裸の:aの形を含む）の他の形は、常に即時の括弧に入れられた引数を探して、それを上へ音をたてて飲む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If that's not intended, you must use whitespace between the adverb and the opening bracket.</seg></tuv>
  <tuv xml:lang="JA"><seg>それが意図されないならば、あなたは副詞と左大括弧の間で空白文字を使わなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The syntax of individual adverbs is the same everywhere in Perl 6.</seg></tuv>
  <tuv xml:lang="JA"><seg>個々の副詞の構文は、至る所でPerl 6の同じことである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There are no exceptions based on whether an argument is wanted or not.</seg></tuv>
  <tuv xml:lang="JA"><seg>引数が求められているかどうかに基づく例外が、ない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(There is a minor exception for quote and regex adverbs, which accept only parentheses as their bracketing operator, and ignore other brackets, which must be placed in parens if desired.</seg></tuv>
  <tuv xml:lang="JA"><seg>（引用のためのマイナーな例外と正規表現副詞がある。そして、それは括弧だけを彼らの括弧に入れている演算子と認めて、他のブラケットを無視する。そして、それは必要に応じて括弧に置かれなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See &amp;quot;Paren form&amp;quot; in the table above.)</seg></tuv>
  <tuv xml:lang="JA"><seg>上の表で、「括弧の形」を見なさい。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Except as noted above, the parser always looks for the brackets.</seg></tuv>
  <tuv xml:lang="JA"><seg>上記したように以外は、構文解析器は常にブラケットを探す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Despite not indicating a true subscript, the brackets are similarly parsed as postfix operators.</seg></tuv>
  <tuv xml:lang="JA"><seg>正確な添え字を示さないことにもかかわらず、ブラケットは後置演算子として同じように解析される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As postfixes the brackets may be separated from their initial :foo with either unspace or dot (or both), but nothing else.</seg></tuv>
  <tuv xml:lang="JA"><seg>接尾辞として、ブラケットはどちらのunspaceまたは点（または両方とも）（他の何以外のでないも）ででも彼らの最初の:fooから切り離されるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Regardless of syntax, adverbs used as named arguments (in either term or infix position) generally show up as optional named parameters to the function in question--even if the function is an operator or macro.</seg></tuv>
  <tuv xml:lang="JA"><seg>構文に関係なく、一般に名をつけられた引数（どちらの項または挿入辞位置ででも）として使われる副詞は ― たとえ関数が演算子またはマクロであるとしても ― 問題の関数へのオプションの挙げられたパラメータとして現れる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The function in question neither knows nor cares how weird the original syntax was.</seg></tuv>
  <tuv xml:lang="JA"><seg>問題の関数は、知りもしなく、最初の構文がどれくらい怪しくもあったかについて気にしない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Q forms</seg></tuv>
  <tuv xml:lang="JA"><seg>Qの形</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In addition to q and qq, there is now the base form Q which does no interpolation unless explicitly modified to do so.</seg></tuv>
  <tuv xml:lang="JA"><seg>qとqqに加えて、はっきりとそうするために修正されない限り、展開をしない主成分の形Qが、現在ある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>So q is really short for Q:q and qq is short for Q:qq.</seg></tuv>
  <tuv xml:lang="JA"><seg>それで、qは本当にQ:qの省略である、そして、qqはQ:qqの省略である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In fact, all quote-like forms derive from Q with adverbs:</seg></tuv>
  <tuv xml:lang="JA"><seg>実際、すべての引用のような形は、副詞でQに由来する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Adverbs such as :regex change the language to be parsed by switching to a different parser.</seg></tuv>
  <tuv xml:lang="JA"><seg>:regexのような副詞は、異なる構文解析器に変わることによって解析されるために、言語を変える。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This can completely change the interpretation of any subsequent adverbs as well as the quoted material itself.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、何か以降の副詞ならびに引用された資料自体の字句解釈を完全に変えることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Just as q[...] has the short form '...', and qq[...] has the short form &amp;quot;...&amp;quot;, the completely quoted Q[...] has a short form that uses halfwidth corner brackets:</seg></tuv>
  <tuv xml:lang="JA"><seg>ちょうどq[...]がショート形式'...'を持って、そして、qq[...]はショート形式&amp;quot;...&amp;quot;を持つ、完全に引合いに出されたQ[...]にはhalfwidthな隅持送りを使うショート形式がある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>「...」.</seg></tuv>
  <tuv xml:lang="JA"><seg>「...」。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Adverbs on quotes</seg></tuv>
  <tuv xml:lang="JA"><seg>引用の副詞</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Generalized quotes may now take adverbs:</seg></tuv>
  <tuv xml:lang="JA"><seg>全般的な引用は、現在副詞をとるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may omit the first colon by joining an initial Q, q, or qq with a single short form adverb, which produces forms like:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは最初のQ、qまたはqqを一つのショート形式副詞でつなぐことによって最初のコロンを省略するかもしれない。そして、それは以下のような形を生じる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Note that qx// doesn't interpolate.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（qx//が差し込まない注。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you want to abbreviate further, just define a macro:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたがさらに簡約したいならば、ちょうどマクロを定義しなさい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All the uppercase adverbs are reserved for user-defined quotes.</seg></tuv>
  <tuv xml:lang="JA"><seg>すべての大文字の副詞は、ユーザー定義の引用のために予約されている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>All Unicode delimiters above Latin-1 are reserved for user-defined quotes.</seg></tuv>
  <tuv xml:lang="JA"><seg>ラテン語-1より上のすべてのユニコードデリミタは、ユーザー定義の引用のために予約されている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A consequence of the above is that we can now say:</seg></tuv>
  <tuv xml:lang="JA"><seg>上記の結果は、我々が現在、以下のように言うことができるということである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>or</seg></tuv>
  <tuv xml:lang="JA"><seg>または、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>to interpolate items into a qw.</seg></tuv>
  <tuv xml:lang="JA"><seg>qwにアイテムを差し込むこと。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Conveniently, arrays and hashes interpolate with only whitespace separators by default, so the subsequent split on whitespace still works out.</seg></tuv>
  <tuv xml:lang="JA"><seg>都合の良いことに、配列とハッシュはデフォルトで空白文字セパレーターだけで改竄するので、空白文字の以降の分裂はまだ外へ動く。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(But the built-in ≪...≫ quoter automatically does interpolation equivalent to qq:ww:v/.../.</seg></tuv>
  <tuv xml:lang="JA"><seg>（しかし、ビルトイン≪...≫引用者は、qq:ww:v/.../に展開等価物を自動的にする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The built-in &amp;lt;...&amp;gt; is equivalent to q:w:v/.../.)</seg></tuv>
  <tuv xml:lang="JA"><seg>ビルトイン&amp;lt;...&amp;gt;は、q:w:v/.../に等しい。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The :val modifier</seg></tuv>
  <tuv xml:lang="JA"><seg>:val修飾子</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The :v/:val modifier runs each word through the val() function, which will attempt to recognize literals as defined by the current slang.</seg></tuv>
  <tuv xml:lang="JA"><seg>:v/:val修飾子は各々のワードをval()関数に通す。そして、現在の俗語によって定義されるように、それはリテラルを認知しようとする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(See &amp;quot;Allomorphic value semantics&amp;quot; below.) Only pure literals such as numbers, versions, and enums are so recognized;</seg></tuv>
  <tuv xml:lang="JA"><seg>数、バージョンと列挙型のような純粋なリテラルだけは、とても公認である（下記の「Allomorphic値意味論」を見なさい。）;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>all other words are left as strings.</seg></tuv>
  <tuv xml:lang="JA"><seg>他の全てのワードは、文字列として残される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In any case, use of such an intuited value as a string will reproduce the original string including any leading or trailing whitespace:</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれにせよ、文字列のような直観された値の使用は、何か主要なまたは後置空白文字を含む元の文字列を複製する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Of course, words derived from :w and :ww will not have any whitespace, since that is what the words are split apart on.</seg></tuv>
  <tuv xml:lang="JA"><seg>もちろん、ワードは:wに由来した、そして、それがワードが離れて分裂であるものである時から、:wwは何か空白文字を持っていない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whitespace before adverbs</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞の前の空白文字</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whitespace is allowed between the &amp;quot;q&amp;quot; and its adverb:</seg></tuv>
  <tuv xml:lang="JA"><seg>空白文字は、「q」とその副詞の間で許される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>q :w /.../.</seg></tuv>
  <tuv xml:lang="JA"><seg>q :w /.../。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Delimiters of quoting forms</seg></tuv>
  <tuv xml:lang="JA"><seg>書式を引用するデリミタ</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For these &amp;quot;q&amp;quot; forms the choice of delimiters has no influence on the semantics.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの「q」形式については、デリミタの選択には、意味論に対する影響がない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, '', &amp;quot;&amp;quot;, &amp;lt;&amp;gt;, ≪≫, ``, (), [], and have no special significance when used in place of // as delimiters.</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、デリミタとして//の代わりに使われるとき、''、&amp;quot;&amp;quot;、&amp;lt;&amp;gt;、≪≫、``、()、[]とは特別な重要性を持たない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There may be whitespace before the opening delimiter.</seg></tuv>
  <tuv xml:lang="JA"><seg>空白文字が、始めのデリミタの前にあるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Which is mandatory for parens because q() is a subroutine call and q:w(0) is an adverb with arguments).</seg></tuv>
  <tuv xml:lang="JA"><seg>（q()がサブルーチン呼出しである、そして、q:w(0)が引数による副詞であるので、括弧のために義務的な）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A colon may never be used as the delimiter since it will always be taken to mean another adverb regardless of what's in front of it.</seg></tuv>
  <tuv xml:lang="JA"><seg>それの前にあることに関係なくもう一つの副詞を意味することが常にされる時から、コロンがデリミタとして決して使われないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Nor may a # character be used as the delimiter since it is always taken as whitespace (specifically, as a comment).</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、それからデリミタが常に空白文字周知のことと見なされて、#文字が使われないかもしれないとりわけ、コメントとして、（）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may not use whitespace or alphanumerics for delimiters.</seg></tuv>
  <tuv xml:lang="JA"><seg>デリミタのために空白文字または英数字を使わなくてもよい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Quotes from Macros</seg></tuv>
  <tuv xml:lang="JA"><seg>マクロからの引用</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>New quoting constructs may be declared as macros:</seg></tuv>
  <tuv xml:lang="JA"><seg>新しい引合いに出している構成概念は、マクロと宣言されるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note:</seg></tuv>
  <tuv xml:lang="JA"><seg>注：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>macro adverbs are automatically evaluated at macro call time if the adverbs are included in the parse.</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞が解析に含まれるならば、マクロ副詞はマクロ呼出し時間に自動的に評価される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If an adverb needs to affect the parsing of the quoted text of the macro, then an explicit named parameter may be passed on as a parameter to the is parsed subrule, or used to select which subrule to invoke.</seg></tuv>
  <tuv xml:lang="JA"><seg>副詞がマクロの引用されたテキストの構文解析に影響を及ぼす必要があるならば、明示的挙げられたパラメータは｛解析される｝subruleへのパラメータとして渡されるかもしれないか、どのsubruleに訴えるべきかについて選んだものである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Interpolating into a single-quoted string</seg></tuv>
  <tuv xml:lang="JA"><seg>一つの引用符付きの文字列への補間</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may interpolate double-quotish text into a single-quoted string using the \qq[...] construct.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、\qq[...]構成概念を使っている一つの引用符付きの文字列に、二重のquotishテキストを改変するかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Other &amp;quot;q&amp;quot; forms also work, including user-defined ones, as long as they start with &amp;quot;q&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらが「q」から始める限り、ユーザー定義のものを含んで、他の「q」形式も動く。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Otherwise you'll just have to embed your construct inside a \qq[...].</seg></tuv>
  <tuv xml:lang="JA"><seg>さもなければ、あなたはちょうど構成概念を\qq[...]に埋めなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Interpolation rules</seg></tuv>
  <tuv xml:lang="JA"><seg>展開規則</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Bare scalar variables always interpolate in double-quotish strings.</seg></tuv>
  <tuv xml:lang="JA"><seg>ぎりぎりのスカラー変数は、常に二重のquotish文字列で改竄する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Bare array, hash, and subroutine variables may never be interpolated.</seg></tuv>
  <tuv xml:lang="JA"><seg>裸の配列、ハッシュとサブルーチン変数は、決して差し込まれないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, any scalar, array, hash or subroutine variable may start an interpolation if it is followed by a sequence of one or more bracketed dereferencers:</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、それの後に一連の一つ以上の括弧に入れられたdereferencersが続くならば、スカラー何でも、配列、ハッシュまたはサブルーチン変数は改竄者を始めるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>that is, any of:</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、以下のどれでも：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>1. An array subscript</seg></tuv>
  <tuv xml:lang="JA"><seg>1. 配列の添え字</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>2. A hash subscript</seg></tuv>
  <tuv xml:lang="JA"><seg>2. ハッシュ添え字</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>3. A set of parentheses indicating a function call</seg></tuv>
  <tuv xml:lang="JA"><seg>3. 関数呼び出しを示している一組の括弧</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>4. Any of 1 through 3 in their dot form</seg></tuv>
  <tuv xml:lang="JA"><seg>4. 彼らの点フォームの3を通しての1のどれでも</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>5. A method call that includes argument parentheses</seg></tuv>
  <tuv xml:lang="JA"><seg>5. 引数括弧を含むメソッド呼び出し</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>6. A sequence of one or more unparenthesized method call, followed by any of 1 through 5</seg></tuv>
  <tuv xml:lang="JA"><seg>6. 一連の一つ以上のunparenthesizedされたメソッドは訪問する。そして、5を通して1のどれでも続く、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In other words, this is legal:</seg></tuv>
  <tuv xml:lang="JA"><seg>言い換えると、これは合法的である：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>and is equivalent to</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、等価物である</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>However, no interpolated postfix may start with a backslash, so any backslash or unspace is not recognized, but instead will be assumed to be part of the string outside of the interpolation, and subject to the normal backslashing rules of that quote context:</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、差し込まれた接尾辞はバックスラッシュから始めないかもしれないので、何かバックスラッシュまたはunspaceは認知されなくて、その代わりに、展開の外の、そして、その引用前後関係の通常のbackslashingしている原則を前提として文字列の一部であるとされる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Arrays</seg></tuv>
  <tuv xml:lang="JA"><seg>配列</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In order to interpolate an entire array, it's necessary now to subscript with empty brackets:</seg></tuv>
  <tuv xml:lang="JA"><seg>全ての配列を差し込むために、それは空のブラケットで現在添え字に必要である：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that this fixes the spurious &amp;quot;@&amp;quot; problem in double-quoted email addresses.</seg></tuv>
  <tuv xml:lang="JA"><seg>これが倍を引合いに出された電子メールアドレスで偽の&amp;quot;@&amp;quot;問題を解決することに注意すべきである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As with Perl 5 array interpolation, the elements are separated by a space.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perlで5つが展開を配列して、要素はスペースで区切られる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Except that a space is not added if the element already ends in some kind of whitespace.</seg></tuv>
  <tuv xml:lang="JA"><seg>（が、要素が何らかの空白文字ですでに終わるならば、スペースは加えられない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In particular, a list of pairs will interpolate with a tab between the key and value, and a newline after the pair.)</seg></tuv>
  <tuv xml:lang="JA"><seg>特に、組のリストは、キーと値の間のタブと一組の後の改行文字で改竄する。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hashes</seg></tuv>
  <tuv xml:lang="JA"><seg>ハッシュ</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In order to interpolate an entire hash, it's necessary to subscript with empty braces or angles:</seg></tuv>
  <tuv xml:lang="JA"><seg>全ハッシュを差し込むために、それは空のブレースまたは角度で添え字に必要である：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that this avoids the spurious &amp;quot;%&amp;quot; problem in double-quoted printf formats.</seg></tuv>
  <tuv xml:lang="JA"><seg>これが倍を引合いに出されたprintfフォーマットで偽の&amp;quot;%&amp;quot;問題を避けることに注意すべきである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>By default, keys and values are separated by tab characters, and pairs are terminated by newlines.</seg></tuv>
  <tuv xml:lang="JA"><seg>デフォルトで、キーと値はタブ文字で区切られる、そして、組は改行文字によって終了される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(This is almost never what you want, but if you want something polished, you can be more specific.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（これはほとんど、あなたが望むものでない、しかし、磨かれた何かを望むならば、あなたはよりはっきりしていることがありえる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Sub calls</seg></tuv>
  <tuv xml:lang="JA"><seg>下位呼び出し</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In order to interpolate the result of a sub call, it's necessary to include both the sigil and parentheses:</seg></tuv>
  <tuv xml:lang="JA"><seg>下位呼び出しの結果を差し込むために、シギルと括弧を含むことが、必要である：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Method calls</seg></tuv>
  <tuv xml:lang="JA"><seg>メソッドは訪問する</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In order to interpolate the result of a method call without arguments, it's necessary to include parentheses or extend the call with something ending in brackets:</seg></tuv>
  <tuv xml:lang="JA"><seg>引数なしでメソッド呼び出しの結果を差し込むために、括弧を含むか、ブラケットで終わっている何かで呼び出しを延長することが、必要である：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The method is called in item context.</seg></tuv>
  <tuv xml:lang="JA"><seg>メソッドは、アイテム前後関係で呼ばれる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(If it returns a list, that list is interpolated as if it were an array.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（それがリストを返るならば、まるでそれが配列であるように、そのリストは改変される。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is allowed to have a cascade of argumentless methods as long as the last one ends with parens:</seg></tuv>
  <tuv xml:lang="JA"><seg>最後のものが括弧で終わる限り、それはたくさんのargumentlessなメソッドがあるのを許される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(The cascade is basically counted as a single method call for the end-bracket rule.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（滝はエンドブラケット支配の一回のメソッド要請として基本的に計算に入れられる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Multiple dereferencers</seg></tuv>
  <tuv xml:lang="JA"><seg>複数のdereferencers</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Multiple dereferencers may be stacked as long as each one ends in some kind of bracket or is a bare method:</seg></tuv>
  <tuv xml:lang="JA"><seg>それぞれが何らかのブラケットで終わるか、裸のメソッドである限り、複数のdereferencersは積み重なるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that the final period above is not taken as part of the expression since it doesn't introduce a bracketed dereferencer.</seg></tuv>
  <tuv xml:lang="JA"><seg>それが括弧に入れられたdereferencerを導入しない時から、上記の最後の期間が表現の一部としてかかられないことに注意すべきである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The parens are not required on the .gethash, but they are required on the .attr(), since that terminates the entire interpolation.</seg></tuv>
  <tuv xml:lang="JA"><seg>括弧は.gethashの上で必要とされない、しかし、それが全補間法を終了する時から、それらは.attr()の上で必要とされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In no case may any of the top-level components be separated by whitespace or unspace.</seg></tuv>
  <tuv xml:lang="JA"><seg>いかなる場合も、トップレベルの構成要素の何も、空白文字またはunspaceによって切り離されないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(These are allowed, though, inside any bracketing constructs, such as in the (1, 2, 3) above.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（これらは、しかし、構成概念を括弧に入れている何の中にでも許される（例えば上の(1, 2, 3)で）。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Closures</seg></tuv>
  <tuv xml:lang="JA"><seg>クロージャ</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A bare closure also interpolates in double-quotish context.</seg></tuv>
  <tuv xml:lang="JA"><seg>裸のクロージャも、二重のquotish前後関係で改竄する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It may not be followed by any dereferencers, since you can always put them inside the closure.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが常にそれらをクロージャに入れることができる時から、それの後に何かdereferencersが続かないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The expression inside is evaluated in string item context.</seg></tuv>
  <tuv xml:lang="JA"><seg>中の表現は、文字列項目前後関係で評価される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You can force list context on the expression using the list operator if necessary.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、必要に応じてlist演算子を使っている表現に関して、リストコンテキストを強制することができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A closure in a string establishes its own lexical scope.</seg></tuv>
  <tuv xml:lang="JA"><seg>文字列のクロージャは、それ自身のレキシカルスコープを確立する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Expressions that sneak in without curlies, such as $(...), do not establish their own lexical scope, but use the outer scope, and may even declare variables in the outer scope, since all the code inside (that isn't in an EVAL) is seen at compile time.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（curlies（例えば$(...)）なしでこっそり入る表現は彼ら自身のレキシカルスコープを確立しなくて、外のスコープを使って、中（EVALでない）のすべてのコードがコンパイル時で見られる時から外のスコープで変数を宣言さえするかもしれない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The following means the same as the previous example.</seg></tuv>
  <tuv xml:lang="JA"><seg>以下は、前の例と同じことを意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The final parens are unnecessary since we're providing &amp;quot;real&amp;quot; code in the curlies.</seg></tuv>
  <tuv xml:lang="JA"><seg>我々がcurliesで「本当の」コードを提供している時から、最終的な括弧は不必要である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you need to have double quotes that don't interpolate curlies, you can explicitly remove the capability:</seg></tuv>
  <tuv xml:lang="JA"><seg>curliesを差し込まないダブルクォートを持っている必要があるならば、あなたは機能をはっきりと除去することができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>or equivalently:</seg></tuv>
  <tuv xml:lang="JA"><seg>または、同等に：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Alternately, you can build up capabilities from single quote to tell it exactly what you do want to interpolate:</seg></tuv>
  <tuv xml:lang="JA"><seg>あるいは、あなたは、正確に、何を差し込みたいかについて、それに話すシングルクォートからの機能を確立することができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Twigils</seg></tuv>
  <tuv xml:lang="JA"><seg>Twigils</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Secondary sigils (twigils) have no influence over whether the primary sigil interpolates.</seg></tuv>
  <tuv xml:lang="JA"><seg>第二のシギル（twigils）は、主要なシギルが改竄するかどうかに対する影響力を持たない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, if $a interpolates, so do $^a, $*a, $=a, $?a, $.a, etc. It only depends on the $.</seg></tuv>
  <tuv xml:lang="JA"><seg>すなわち、$aが改竄するならば、それが$次第であるだけであるほど、$^a、$*a、$=a、$?a、$.a、その他をする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Other expressions</seg></tuv>
  <tuv xml:lang="JA"><seg>他の表現</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>No other expressions interpolate.</seg></tuv>
  <tuv xml:lang="JA"><seg>他のいかなる表現も改竄しない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use curlies.</seg></tuv>
  <tuv xml:lang="JA"><seg>curliesを使いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Class methods</seg></tuv>
  <tuv xml:lang="JA"><seg>クラスメソッド</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A class method may not be directly interpolated.</seg></tuv>
  <tuv xml:lang="JA"><seg>クラスメソッドは、直接差し込まれないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use curlies:</seg></tuv>
  <tuv xml:lang="JA"><seg>使用curlies：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Old disambiguation</seg></tuv>
  <tuv xml:lang="JA"><seg>古い一義化</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The old disambiguation syntax:</seg></tuv>
  <tuv xml:lang="JA"><seg>旧一義化構文：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>is dead.</seg></tuv>
  <tuv xml:lang="JA"><seg>死んでいる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use closure curlies instead:</seg></tuv>
  <tuv xml:lang="JA"><seg>その代わりにクロージャcurliesを使いなさい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(You may be detecting a trend here...)</seg></tuv>
  <tuv xml:lang="JA"><seg>（あなたは傾向をここで見つけているかもしれない...）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Topical methods</seg></tuv>
  <tuv xml:lang="JA"><seg>時事的なメソッド</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To interpolate a topical method, use curlies:</seg></tuv>
  <tuv xml:lang="JA"><seg>時事的なメソッド（使用curlies）を差し込むこと：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>&amp;quot;.bark&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>&amp;quot;.bark&amp;quot;。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Function calls</seg></tuv>
  <tuv xml:lang="JA"><seg>関数呼出し</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To interpolate a function call without a sigil, use curlies:</seg></tuv>
  <tuv xml:lang="JA"><seg>シギル（使用curlies）なしで関数呼び出しを差し込むこと：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>&amp;quot;abs $var&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>&amp;quot;abs $var&amp;quot;。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Backslash sequences</seg></tuv>
  <tuv xml:lang="JA"><seg>バックスラッシュシーケンス</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Backslash sequences still interpolate, but there's no longer any \v to mean vertical tab, whatever that is...</seg></tuv>
  <tuv xml:lang="JA"><seg>バックスラッシュシーケンスはまだ改竄する、しかし、それがたとえ何であろうとも、もはや何か\vが平均垂直タブにない...</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(\v now matches vertical whitespace in a regex.) Literal character representations are:</seg></tuv>
  <tuv xml:lang="JA"><seg>（\vは現在正規表現で垂直空白文字に匹敵する。）文字通りの文字表示は、以下の通りである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Other functions</seg></tuv>
  <tuv xml:lang="JA"><seg>他の関数</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There's also no longer any \L, \U, \l, \u, or \Q.</seg></tuv>
  <tuv xml:lang="JA"><seg>もはや何か\L、\U、\l、\uまたは\Qもない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use curlies with the appropriate function instead:</seg></tuv>
  <tuv xml:lang="JA"><seg>適正による使用curliesは、その代わりに機能する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>&amp;quot;tclc $word&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>&amp;quot;tclc $word&amp;quot;。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unicode codepoints</seg></tuv>
  <tuv xml:lang="JA"><seg>ユニコードコードポイント</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may interpolate any Unicode codepoint by name using \c and square brackets:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、\cと角括弧を使用して名前は何かユニコードコードポイントを差し込むかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Multiple codepoints constituting a single character may be interpolated with a single \c by separating the names with comma:</seg></tuv>
  <tuv xml:lang="JA"><seg>一文字を構成している複数のコードポイントは、コンマで名前を切り離すことによって、一つの\cで差し込まれるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Whether that is regarded as one character or two depends on the Unicode support level of the current lexical scope.</seg></tuv>
  <tuv xml:lang="JA"><seg>それが一体となって注意されるかどうかにかかわらず、文字または2は現在のレキシカルスコープのユニコード支持線次第である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is also possible to interpolate multiple codepoints that do not resolve to a single character:</seg></tuv>
  <tuv xml:lang="JA"><seg>一文字に分解しない複数のコードポイントを差し込むことも、あり得る：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>[Note: none of the official Unicode character names contains comma.]</seg></tuv>
  <tuv xml:lang="JA"><seg>［注意する：公式ユニコード文字名のどれもコンマを含まない。］</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may also put one or more decimal numbers inside the square brackets:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、一つ以上の十進数も角括弧に入れるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any single decimal number may omit the brackets:</seg></tuv>
  <tuv xml:lang="JA"><seg>何か一つの十進数は、ブラケットを省略するかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Within a regex you may also use \C to match a character that is not the specified character.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（正規表現の中で、あなたは文字（つまり指定された文字でない）にマッチするために\Cも使うかもしれない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the character following \c or \C is neither a left square bracket nor a decimal digit, the single following character is turned into a control character by the usual trick of XORing the 64 bit.</seg></tuv>
  <tuv xml:lang="JA"><seg>\cまたは\Cの後の文字が左大括弧10進数でももないならば、一つの以下の文字は64が噛んだXORingの普通のこつによって制御文字に変えられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This allows \c@ for NULL and \c? for DELETE, but note that the ESCAPE character may not be represented that way;</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、キャンセル（エスケープ文字がそのように表現されないかもしれないメモ以外の）のために、ヌルと\c?に\c@を見込む;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>it must be represented something like:</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、何かを表現されなければならない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Obviously \e is preferred when brevity is needed.</seg></tuv>
  <tuv xml:lang="JA"><seg>明らかに、簡潔さが必要であるとき、\eは好まれる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Backslashing</seg></tuv>
  <tuv xml:lang="JA"><seg>Backslashing</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any character that would start an interpolation in the current quote context may be protected from such interpolation by prefixing with backslash.</seg></tuv>
  <tuv xml:lang="JA"><seg>改竄者に現在の引用前後関係を始めさせる何か文字は、バックスラッシュでプレフィクシングによってそのような展開から保護されているかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The backslash is always removed in this case.</seg></tuv>
  <tuv xml:lang="JA"><seg>バックスラッシュは、常にこの場合削除される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The treatment of backslashed characters that would not have introduced an interpolation varies depending on the type of quote:</seg></tuv>
  <tuv xml:lang="JA"><seg>改竄者を紹介しなかったbackslashedされた文字の処置は、引用の型に従い変化する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>1. Any quoting form that includes qq or :qq in its semantic derivation (including the normal double quote form) assumes that all backslashes are to be considered meaningful.</seg></tuv>
  <tuv xml:lang="JA"><seg>1. qqまたは:qqをその意味導出（通常のダブルクォート形式を含む）に含む調子を引合いに出している何でも、すべてのバックスラッシュが意味があると考えられることになっていると仮定する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The meaning depends on whether the following character is alphanumeric;</seg></tuv>
  <tuv xml:lang="JA"><seg>意味は、以下の文字が英数字かどうか次第である;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>if it is, the non-interpolating sequence produces a compile-time error.</seg></tuv>
  <tuv xml:lang="JA"><seg>それがそうであるならば、非補間列はコンパイル時エラーを生じる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the character is non-alphanumeric, the backslash is silently removed, on the assumption that the string was backslashed using quotemeta() or some such.</seg></tuv>
  <tuv xml:lang="JA"><seg>文字が非英数字であるならば、文字列がquotemeta()または少しそれを用いてbackslashedされたという仮定に関して、バックスラッシュは黙って削除される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>2. All other quoting forms (including standard single quotes) assume that non-interpolating sequences are to be left unaltered because they are probably intended to pass through to the result.</seg></tuv>
  <tuv xml:lang="JA"><seg>2. 他の全ての引合いに出している形（標準的なシングルクォートを含む）は、それらが終わりまで結果に渡ることを多分意図されるだろうので、非補間列が不変のままにされることになっていると仮定する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Backslashes are removed only for the terminating quote or for characters that would interpolate if unbackslashed.</seg></tuv>
  <tuv xml:lang="JA"><seg>バックスラッシュは、終わっている引用のためにだけ、または、unbackslashedされるならば、それが改変するだろう文字のためにだけ削除される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(In either case, a special exception is made for brackets;</seg></tuv>
  <tuv xml:lang="JA"><seg>（いずれにせよ、特例はブラケットのために作られる;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>if the left bracket would interpolate, the right bracket may optionally also be backslashed, and if so, the backslash will be removed.</seg></tuv>
  <tuv xml:lang="JA"><seg>左大括弧が差し込むならば、右大括弧は任意にbackslashedされもするかもしれない、そして、もしそうならば、バックスラッシュは削除される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If brackets are used as the delimiters, both left and right must be backslashed the same, since they would otherwise be counted wrong in the bracket count.)</seg></tuv>
  <tuv xml:lang="JA"><seg>ブラケットがデリミタとして使われる、両方の左右｛必要なもの｝さもなければそれらがブラケット数の数えられた誤りである時から、backslashedが同じことである。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As a consequence, these all produce the same literal string:</seg></tuv>
  <tuv xml:lang="JA"><seg>結果として、これらのすべては、同じリテラル文字列を生産する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Of course, matching backslashes is likely to make your syntax highlighter a bit happier, along with any other naive bracket counting algorithms...)</seg></tuv>
  <tuv xml:lang="JA"><seg>（もちろん、他のどの単純なブラケットカウントアルゴリズムとともにも、バックスラッシュにマッチすることはあなたの構文マーカーを少しより幸せにしそうである...）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Bare identifiers</seg></tuv>
  <tuv xml:lang="JA"><seg>裸の識別子</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There are no barewords in Perl 6.</seg></tuv>
  <tuv xml:lang="JA"><seg>barewordsが、Perl 6でない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An undeclared bare identifier will always be taken to mean a subroutine name, and be parsed as a list operator.</seg></tuv>
  <tuv xml:lang="JA"><seg>宣言されていない裸の識別子は、常にサブルーチン名を意味するためにとられて、リスト演算子として解析される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Class names (and other type names) are predeclared, or prefixed with the :: type sigil when you're declaring a new one.) A consequence of this is that there's no longer any &amp;quot;use strict 'subs'&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>これの結果は、もはや何か&amp;quot;use strict 'subs'&amp;quot;がないということである（クラス名（そして、他のタイプ名）は、predeclaredされるか、あなたが新しいものを宣言している::タイプシギルで接頭辞を付けられる。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since the syntax for method calls is distinguished from sub calls, it is only unrecognized sub calls that must be treated specially.</seg></tuv>
  <tuv xml:lang="JA"><seg>メソッド呼び出しのための構文が下位呼び出しを区別されるので、それは特別に扱われなければならない認められていない下位呼び出しだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You still must declare your subroutines, but a bareword with an unrecognized name is provisionally compiled as a subroutine call, on the assumption that such a declaration will occur by the end of the current compilation unit:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたはまだサブルーチンを宣言しなければならない、しかし、そのような宣言が現在のコンパイル単位の終りまでに起こるという仮定に関して、認められていない名前によるbarewordはサブルーチン呼出しとして仮に編集される：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If a postdeclaration is not seen, the compile fails at CHECK time, that is, at the end of compilation for this compilation unit.</seg></tuv>
  <tuv xml:lang="JA"><seg>postdeclarationが見られないならば、コンパイルはCHECK時間に失敗する（つまり、このコンパイル単位のための編集終了後）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(You are still free to predeclare subroutines explicitly, of course.) The postdeclaration may be in any lexical or package scope that could have made the declaration visible to the provisional call had the declaration occurred before rather than after the provisional call.</seg></tuv>
  <tuv xml:lang="JA"><seg>postdeclarationは語彙的な何ででもあるかもしれない（もちろん、あなたはまだはっきりとpredeclareサブルーチンに自由である。）、または、暫定的な呼び出しの後よりはむしろ、宣言を暫定的な呼び出しに見えるようにすることができたパッケージスコープは宣言を起こっておいた。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This fixup is done only for provisional calls.</seg></tuv>
  <tuv xml:lang="JA"><seg>このfixupは、暫定的な呼び出しのためにだけされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If there is any real predeclaration visible, it always takes precedence.</seg></tuv>
  <tuv xml:lang="JA"><seg>見える何か本当のpredeclarationがあるならば、それは常に優位をとる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the unrecognized subroutine name is followed by postcircumfix:&amp;lt;( )&amp;gt;,</seg></tuv>
  <tuv xml:lang="JA"><seg>認められていないサブルーチン名の後にpostcircumfix:&amp;lt;( )&amp;gt;が続くならば、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>it is compiled as a provisional function call of the parenthesized form.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、括弧に入れられた形の暫定的な関数呼び出しとして編集される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If it is not, it is compiled as a provisional function call of the list operator form, which may or may not have an argument list.</seg></tuv>
  <tuv xml:lang="JA"><seg>そうでないならば、それはリスト演算子形式の暫定的な関数呼び出しとして編集される。そして、それは引数の並びを持つかもしれないか、持たないかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When in doubt, the attempt is made to parse an argument list.</seg></tuv>
  <tuv xml:lang="JA"><seg>不確かなとき、試みは引数の並びを解析させられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As with any list operator, an immediate postfix operator is illegal unless it is a form of parentheses, whereas anything following whitespace will be interpreted as an argument list if possible.</seg></tuv>
  <tuv xml:lang="JA"><seg>何かリスト演算子と同様に、それが括弧の形でない限り、即座の後置演算子は無効である、ところが、空白文字の後の何でもできれば引数の並びと解釈される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Some examples of how listops, methods and labels interact syntactically:</seg></tuv>
  <tuv xml:lang="JA"><seg>listops、メソッドとラベルがどのように構文的に相互作用するかという若干の例：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The indirect object colon only ever dominates a simple term, where &amp;quot;simple&amp;quot; includes classes and variables and parenthesized expressions, but explicitly not method calls, because the colon will bind to a trailing method call in preference.</seg></tuv>
  <tuv xml:lang="JA"><seg>間接目的語コロンはこれまでに単純な項を支配するだけである、そこで、コロンが選択において後置メソッド呼び出しと結合するので、「単純な」ものはクラスと変数を含んで、はっきりとメソッド呼び出しでなく、表現を括弧に入れた。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>An indirect object that parses as more than one token must be placed in parentheses, followed by the colon.</seg></tuv>
  <tuv xml:lang="JA"><seg>複数のトークンとして解析する間接目的語は括弧に置かれなければならない。そして、コロンが続く。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In short, only an identifier followed by a simple term followed by a postfix colon is ever parsed as an indirect object, but that form will always be parsed as an indirect object regardless of whether the identifier is otherwise declared.</seg></tuv>
  <tuv xml:lang="JA"><seg>要するに、接尾辞コロンが続く単純な項が続く識別子だけは間接目的語として解析されるeverである、さもなければ識別子が宣言されるか否かを問わず、その形以外の、alwaysは間接目的語として解析される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Dereferences</seg></tuv>
  <tuv xml:lang="JA"><seg>間接参照</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There's also no &amp;quot;use strict 'refs'&amp;quot; because symbolic dereferences are now syntactically distinguished from hard dereferences.</seg></tuv>
  <tuv xml:lang="JA"><seg>記号的な間接参照が現在難しい間接参照を構文的に区別されるので、&amp;quot;use strict 'refs'&amp;quot;もない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>@($array) must now provide an actual array object, while @::($string) is explicitly a symbolic reference.</seg></tuv>
  <tuv xml:lang="JA"><seg>@::($string)がはっきりと記号参照である間、@($array)は現在実配列オブジェクトを提供しなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Yes, this may give fits to the P5-to-P6 translator, but I think it's worth it to separate the concepts.</seg></tuv>
  <tuv xml:lang="JA"><seg>（はい、これはP6へのP5翻訳者に発作を与えるかもしれない、しかし、私は概念を切り離すことがそれの価値があると思う。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Perhaps the symbolic ref form will admit real objects in a pinch.)</seg></tuv>
  <tuv xml:lang="JA"><seg>おそらく、記号的な参照用紙は、いざという時には実物体を認める。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hash subscripts and bare keys</seg></tuv>
  <tuv xml:lang="JA"><seg>ハッシュ添え字と裸のキー</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is no hash subscript autoquoting in Perl 6.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6でautoquotingしているハッシュ添え字が、ない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use %x&amp;lt;foo&amp;gt; for constant hash subscripts, or the old standby %x'foo'.</seg></tuv>
  <tuv xml:lang="JA"><seg>固定ハッシュ添え字または古い待機%x'foo'のために%x&amp;lt;foo&amp;gt;を使いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(It also works to say %x≪foo≫ as long as you realized it's subject to interpolation.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（それもあなたの長さの%x≪foo≫がそれが展開を受けると理解したと言うために動く。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>But =&amp;gt; still autoquotes any bare identifier to its immediate left (horizontal whitespace allowed but not comments).</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、=&amp;gt;は、その即時年金への何か裸の識別子が去った（コメントでなく許される横空白文字）autoquotesを静める。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The identifier is not subject to keyword or even macro interpretation.</seg></tuv>
  <tuv xml:lang="JA"><seg>識別子は、キーワードまたはマクロ字句解釈さえ受けない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you say</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが言うならば、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>then $x ends up containing the pair (&amp;quot;if&amp;quot; =&amp;gt; 1).</seg></tuv>
  <tuv xml:lang="JA"><seg>そして結局一組(&amp;quot;if&amp;quot; =&amp;gt; 1)を含むことになる｛$x｝。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Always.</seg></tuv>
  <tuv xml:lang="JA"><seg>常に。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Unlike in Perl 5, where version numbers didn't autoquote.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（Perl 5のとは異なり、そこでバージョン番号はautoquoteにそうしなかった。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You can also use the :key($value) form to quote the keys of option pairs.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、オプション一組のキーを引合いに出すために、:key($value)の形を使用することもできる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To align values of option pairs, you may use the &amp;quot;unspace&amp;quot; postfix forms:</seg></tuv>
  <tuv xml:lang="JA"><seg>オプション組の値を一列に並べるために、あなたは「unspace」接尾辞形を使用するかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These will be interpreted as</seg></tuv>
  <tuv xml:lang="JA"><seg>これらは、通訳される</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Double-underscore forms</seg></tuv>
  <tuv xml:lang="JA"><seg>倍のアンダーラインの形態</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The double-underscore forms are going away:</seg></tuv>
  <tuv xml:lang="JA"><seg>倍のアンダーラインの形態は去っている：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The =begin finish Pod stream (usually written as just =finish) is special in that it assumes there's no corresponding =end finish before end of file.</seg></tuv>
  <tuv xml:lang="JA"><seg>それが対応する=end finishがファイル終りの前にないと仮定するという点で、=begin finishポッド流（通常ちょうど=finishとして書かれる）は特別である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Anything in a source file after a =finish is always treated as Pod.</seg></tuv>
  <tuv xml:lang="JA"><seg>=finishの後のソースファイルの何でも、常にポッドとみなされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is no longer any special DATA stream--any Pod block in the current file can be accessed via a Pod object, such as $=data or $=SYNOPSIS or $=UserBlock etc. That is:</seg></tuv>
  <tuv xml:lang="JA"><seg>もはや少しも特別なDATA流がない－現行ファイルの中の何かポッドブロックはポッドオブジェクト（例えば$=data）によってアクセスされることができる、または、$=SYNOPSISまたは$=UserBlockその他はとても以下の通りである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>a variable with the same name of the desired block, and a = twigil.</seg></tuv>
  <tuv xml:lang="JA"><seg>望ましいブロックの同じ名前による変数と= twigil。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>These Pod objects can be used as Positionals (indexed by their block sequence).</seg></tuv>
  <tuv xml:lang="JA"><seg>これらのポッドオブジェクトが、Positionals（彼らのブロック溶着方法によって索引付けされる）として使われることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>They can also be treated as Associatives (indexed by :key options specified with the block).</seg></tuv>
  <tuv xml:lang="JA"><seg>それらは、Associatives（ブロックで指定される:keyオプションによって索引付けされる）とみなされることもできる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Either way, each Positional or Associative element represents the entire contents of the corresponding Pod block.</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれの方法でも、各々の位置であるか結合要素は、対応するポッドブロックの全コンテンツを表現する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You have to split those contents into lines yourself.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、自分でそれらの内容を線に分けなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Each chunk has a .range property that indicates its line number range within the source file.</seg></tuv>
  <tuv xml:lang="JA"><seg>各々の塊は、ソースファイルの範囲内でその線数値範囲を示す.rangeの資産を持っている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>[Speculative] It may also be possible to treat a Pod object as an IO, to read the Pod information line-by-line (like the DATA filehandle in Perl 5, but for any Pod block).</seg></tuv>
  <tuv xml:lang="JA"><seg>[Speculative] 一行一行ポッド情報を読む（何かポッドブロックを除けば、perl 5の｛データ｝ファイルハンドルのような）ために、ポッドオブジェクトをイオとみなすことは、あり得る場合もある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The lexical routine itself is &amp;amp;?ROUTINE;</seg></tuv>
  <tuv xml:lang="JA"><seg>語彙的なルーチンそのものは、&amp;amp;?ROUTINEである;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>you can get its name with &amp;amp;?ROUTINE.name.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、&amp;amp;?ROUTINE.nameでその名前を得ることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The current block is &amp;amp;?BLOCK.</seg></tuv>
  <tuv xml:lang="JA"><seg>現在ブロックは、&amp;amp;?BLOCKである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If the block has any labels, those shows up in &amp;amp;?BLOCK.labels.</seg></tuv>
  <tuv xml:lang="JA"><seg>ブロックには何かラベルがあるならば、&amp;amp;?BLOCK.labelsで上へそれらのショー。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Within the lexical scope of a statement with a label, the label is a pseudo-object representing the dynamically visible instance of that statement.</seg></tuv>
  <tuv xml:lang="JA"><seg>ラベルによる文のレキシカルスコープの中で、ラベルは、その文のダイナミックに見えるインスタンスを表現している疑似オブジェクトである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(If inside multiple dynamic instances of that statement, the label represents the innermost one.) This is known as lexotic semantics.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、lexoticな意味論として知られている（その文の複数のダイナミックなインスタンスの中にあるならば、ラベルは一番奥のものを表現する。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When you say:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたが以下のように言うとき：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>it is really a method on this pseudo-object, and</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、本当にこの疑似オブジェクトのメソッドである、そして、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>would work just as well.</seg></tuv>
  <tuv xml:lang="JA"><seg>仕事は、ちょうど同様にそうする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You can exit any labeled block early by saying</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、言うことによって早く、何かラベル付きブロックを出ることができる</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Heredocs</seg></tuv>
  <tuv xml:lang="JA"><seg>Heredocs</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Heredocs are no longer written with &amp;lt;&amp;lt;, but with an adverb on any other quote construct:</seg></tuv>
  <tuv xml:lang="JA"><seg>少しも他の引用構成概念に関する副詞で以外、Heredocsは&amp;lt;&amp;lt;でもはや書かれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Other adverbs are also allowed, as are multiple heredocs within the same expression:</seg></tuv>
  <tuv xml:lang="JA"><seg>他の副詞も許される。そして、そのことは同じ表現の範囲内の複数のheredocsである：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Optional whitespace</seg></tuv>
  <tuv xml:lang="JA"><seg>オプションの空白文字</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Heredocs allow optional whitespace both before and after terminating delimiter.</seg></tuv>
  <tuv xml:lang="JA"><seg>Heredocsは、デリミタを終了した前に、そして、それ後にオプションの空白文字を許す。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Leading whitespace equivalent to the indentation of the delimiter will be removed from all preceding lines.</seg></tuv>
  <tuv xml:lang="JA"><seg>デリミタのインデントへの主要な空白文字等価物は、すべての前の線から取り除かれる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If a line is deemed to have less whitespace than the terminator, only whitespace is removed, and a warning may be issued.</seg></tuv>
  <tuv xml:lang="JA"><seg>線がターミネータより少ない空白文字を持っていると考えられるならば、空白文字だけは削除される、そして、警告は発されるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Hard tabs will be assumed to align to the next multiple of ($?TABSTOP // 8) spaces, but as long as tabs and spaces are used consistently that doesn't matter.) A null terminating delimiter terminates on the next line consisting only of whitespace, but such a terminator will be assumed to have no indentation.</seg></tuv>
  <tuv xml:lang="JA"><seg>デリミタを終了しているヌルは空白文字だけから成っている次行で終わる（堅いタブは($?TABSTOP // 8)スペースの次の並列に整列するとされる、しかし、タブとスペースが一貫して使われる限り、それは重要でない。）、しかし、そのようなターミネータはインデントを持たないとされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(That is, it's assumed to match at the beginning of any whitespace.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（つまり、それは何か空白文字の始めに合うとされる。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>One-pass heredoc parsing</seg></tuv>
  <tuv xml:lang="JA"><seg>ワンパスheredoc構文解析</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There are two possible ways to parse heredocs.</seg></tuv>
  <tuv xml:lang="JA"><seg>2つのあり得る方法が、heredocsを解析するためにある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>One is to look ahead for the newline and grab the lines corresponding to the heredoc, and then parse the rest of the original line.</seg></tuv>
  <tuv xml:lang="JA"><seg>人は改行文字の前に見ることになっていて、heredocと一致している線をつかむことになっている、そして、残りの原線を解析しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is how Perl 5 does it.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、Perl 5がそれをする方法である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Unfortunately this suffers from the problem pervasive in Perl 5 of multi-pass parsing, which is masked somewhat because there's no way to hide a newline in Perl 5.</seg></tuv>
  <tuv xml:lang="JA"><seg>残念なことに、これはマルチパス構文解析のPerl 5で全面的な問題で苦しむ。そして、方法がPerl 5で改行文字を隠すためにないので、それはいくぶん覆い隠される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In Perl 6, however, we can use &amp;quot;unspace&amp;quot; to hide a newline, which means that an algorithm looking ahead to find the newline must do a full parse (with possible untoward side effects) in order to locate the newline.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、Perl 6では、我々は改行文字を隠すために「unspace」を使うことができる。そして、それは改行文字が改行文字を見つけるために完全な解析（あり得る厄介な副作用で）をしなければならないとわかるために前を見ているその一アルゴリズムを意味する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instead, Perl 6 takes the one-pass approach, and just lazily queues up the heredocs it finds in a line, and waits until it sees a &amp;quot;real&amp;quot; newline to look for the text and attach it to the appropriate heredoc.</seg></tuv>
  <tuv xml:lang="JA"><seg>その代わりに、テキストを探して、それを適正heredocに付けることが「本当の」改行文字を見るまで、Perl 6はワンパスアプローチをして、それが線で見つけるheredocsの上でちょうどゆったりと待ち行列を作って、待つ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The downside of this approach is a slight restriction--you may not use the actual text of the heredoc in code that must run before the line finishes parsing.</seg></tuv>
  <tuv xml:lang="JA"><seg>このアプローチの不利な面はわずかな規制である－線が構文解析を終える前に、走らなければならないコードでheredocの実際のテキストを使わなくてもよい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Mostly that just means you can't write:</seg></tuv>
  <tuv xml:lang="JA"><seg>大部分はあなたが書くことができないその正当な手段：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You must instead put the entire heredoc into the BEGIN:</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、全てのheredocをBEGINにその代わりに入れなければならない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Version literals</seg></tuv>
  <tuv xml:lang="JA"><seg>バージョンリテラル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A version literal is written with a 'v' followed by the version number in dotted form.</seg></tuv>
  <tuv xml:lang="JA"><seg>文字通りの版は、ドットの形でバージョン番号が続く『v』で書かれる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This always constructs a Version object, not a string.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、常にVersionオブジェクト（文字列でない）を造る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Only integers and certain wildcards are allowed;</seg></tuv>
  <tuv xml:lang="JA"><seg>整数と特定のワイルドカードだけは、許される;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>for anything fancier you must coerce a string to a Version:</seg></tuv>
  <tuv xml:lang="JA"><seg>より装飾的な何のためにでも、あなたはVersionに文字列を強制しなければならない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note though that most places that take a version number in Perl accept it as a named argument, in which case saying :ver&amp;lt;1.2.3beta&amp;gt; is fine.</seg></tuv>
  <tuv xml:lang="JA"><seg>しかし、Perlでバージョン番号をとる大部分の場所がそれを挙げられた引数と認める点に注意しなさい、その場合には、:ver&amp;lt;1.2.3beta&amp;gt;を言うことはすばらしい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See S11 for more on using versioned modules.</seg></tuv>
  <tuv xml:lang="JA"><seg>versionedされたモジュールを使用することの詳細について、S11を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Version objects have a predefined sort order that follows most people's intuition about versioning:</seg></tuv>
  <tuv xml:lang="JA"><seg>バージョンオブジェクトは、バージョニングについて大部分の人々の直観力に続くあらかじめ定義されたソート順を持つ：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>each sorting position sorts numerically between numbers, alphabetically between alphas, and alphabetics in a position before numerics.</seg></tuv>
  <tuv xml:lang="JA"><seg>数値的に数の間の、アルファベット順にアルファの間の各々の分類位置類いと数字の前の位置のalphabetics。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Missing final positions are assumed to be '.0'.</seg></tuv>
  <tuv xml:lang="JA"><seg>なくなった最終位置は、'.0'であるとされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Except for '0' itself, numbers ignore leading zeros.</seg></tuv>
  <tuv xml:lang="JA"><seg>『0』自体を除いて、数は頭のゼロを無視する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For splitting into sort positions, if any alphabetics (including underscore) are immediately adjacent to a number, a dot is assumed between them.</seg></tuv>
  <tuv xml:lang="JA"><seg>並換え位置に分かれるために、何かalphabetics（アンダーラインを含む）がすぐ数に隣接してあるならば、点はそれらの間で装われる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Likewise any non-alphanumeric character is assumed to be equivalent to a dot.</seg></tuv>
  <tuv xml:lang="JA"><seg>同様に、何か非英数字文字は、点に等しいとされる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>So these are all equivalent:</seg></tuv>
  <tuv xml:lang="JA"><seg>それで、これらのすべては等しい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>And these are also equivalent:</seg></tuv>
  <tuv xml:lang="JA"><seg>そして、これらも等しい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>So these are in sorted version order:</seg></tuv>
  <tuv xml:lang="JA"><seg>それで、これらはソートされたバージョン順序である：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note how the last pair assume that an implicit .0 sorts after anything alphabetic, and that alphabetic is defined according to Unicode, not just according to ASCII.</seg></tuv>
  <tuv xml:lang="JA"><seg>最後の一組がそれを潜在的な.0とみなす方法が何の後ででもソートすることを注意するアルファベットの、まったくアルファベットの、ちょうどASCIIによればでない、定義済みに一致することは、ユニコードにある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The intent of all this is to make sure that prereleases sort before releases.</seg></tuv>
  <tuv xml:lang="JA"><seg>こんな意図は、リリースの前にそのプレリリースタイプを確かにすることである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note also that this is still a subset of the versioning schemes seen in the real world.</seg></tuv>
  <tuv xml:lang="JA"><seg>また、これがまだ、リアルワールドで見られるバージョニングスキームのサブセットである点に注意しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Modules with such strange versions can still be used by Perl since by default Perl imports external modules by exact version number.</seg></tuv>
  <tuv xml:lang="JA"><seg>デフォルトによってPerlが正確なバージョン番号によって外端モジュールを輸入する時から、そのような変なバージョンによるモジュールがまだPerlによって使われることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(See S11.) Only range operations will be compromised by an unknown foreign collation order, such as a system that sorts &amp;quot;delta&amp;quot; before &amp;quot;gamma&amp;quot;.</seg></tuv>
  <tuv xml:lang="JA"><seg>測距作業だけは、未知の外国の照合順序（例えば「ガンマ」の前に「デルタ」をソートするシステム）によって危うくされる（S11を見なさい。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Allomorphic value semantics</seg></tuv>
  <tuv xml:lang="JA"><seg>Allomorphic値意味論</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When val() processing is attempted on any list of strings (typically on the individual words within angle brackets), the function attempts to determine if the intent of the programmer or user might have been to provide a numeric value.</seg></tuv>
  <tuv xml:lang="JA"><seg>val()処理が文字列（概してかぎ括弧の範囲内の個々のワードの上で）の何かリストで試みられるとき、関数はプログラマーかユーザーの意図が数値を提供することになっていたかもしれないかどうかについて決定しようとする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>For any item in the list that appears to be numeric, the literal is stored as an object with both a string and a numeric nature, where the string nature always returns the original string.</seg></tuv>
  <tuv xml:lang="JA"><seg>数であるように見えるリストの何かアイテムのために、リテラルは文字列と数の自然によるオブジェクトとして保存される、そこで、文字列自然は常に元の文字列を返る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is implemented via multiple inheritance, to truly represent the allomorphic nature of a literal value that has not committed to which type the user intends.</seg></tuv>
  <tuv xml:lang="JA"><seg>本当に、ユーザーがどの型を意図するかについて、専念しなかったリテラル値のallomorphicな性質を表現するために、これは多重継承を通して実装される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The numeric type chosen depends on the appearance of the literal.</seg></tuv>
  <tuv xml:lang="JA"><seg>選ばれる数値型は、文字通りのものの様子次第である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hence:</seg></tuv>
  <tuv xml:lang="JA"><seg>それゆえに：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>produces objects of classes defined as:</seg></tuv>
  <tuv xml:lang="JA"><seg>定義されるクラスのオブジェクトを生じる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>One purpose of this is to facilitate compile-time analysis of multi-method dispatch, when the user prefers angle notation as the most readable way to represent a list of numbers, which it often is.</seg></tuv>
  <tuv xml:lang="JA"><seg>ユーザーが最も読み込み可能な方法としての角度表記法が数（それはしばしばそうである）のリストを表現するのを好むとき、これの1つの目的はマルチメソッドディスパッチのコンパイル時分析を容易にすることである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Due to the MI semantics, the new object is equally a string and a number, and can be bound as-is to either a string or a numeric parameter.</seg></tuv>
  <tuv xml:lang="JA"><seg>MI意味論のために、新しいオブジェクトは等しく文字列と数で、現状のままで文字列か数値パラメーターの束縛を受けることがありえる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In case multiple dispatch determines that it could dispatch as either string or number, a tie results, which may result in an ambiguous dispatch error.</seg></tuv>
  <tuv xml:lang="JA"><seg>複数のディスパッチがそれがどちらの文字列または数としてでも指名することができたと決定する場合に備えて、タイは起こる。そして、それは結果としてあいまいなディスパッチエラーになるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You'll need to use prefix + or ~ on the argument to resolve the ambiguity in that case.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、その場合曖昧さを分解するために引数の上で接頭辞+または~を使う必要がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>[Conjecture: we may someday find a way to make strings bind a little looser than the numeric types, but for now we conservatively outlaw the dispatch as ambiguous, and watch how this plays out in use.]</seg></tuv>
  <tuv xml:lang="JA"><seg>［推測する：我々は方法が文字列苦境を数値型より少し不安定にするといつかわかるかもしれない、しかし、今のところ、あいまいであるように、我々は保守的にディスパッチを非合法化して、これがどのように使用中に尽きるかについて見る。］</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The allomorphic behavior of angle brackets is not a special case;</seg></tuv>
  <tuv xml:lang="JA"><seg>かぎ括弧のallomorphicな作用は、特例でない;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>it's actually an example of a more general process of figuring out type information by parsing text that comes from any situation where the user is forced to enter text when they really mean other kinds of values.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、実は、それらが他の種類の値を本当に意味するとき、ユーザーがテキストを入力することを強制される何か状況から来るテキストを解析することによって型情報を理解するより一般的なプロセスの例である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A function prompting the user for a single value might usefully pass the result through val() to intuit the proper type.</seg></tuv>
  <tuv xml:lang="JA"><seg>一つの値のためにユーザーを促している関数は、適当な型を直観するために、結果をval()に有効に通すかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The angle form with a single value serves as the literal form of numbers such as Rat and Complex that would otherwise have to be constructed via constant folding.</seg></tuv>
  <tuv xml:lang="JA"><seg>一つの値による角度の形態は、数（例えばさもなければ定数畳込みを通して造られなければならないRatとComplex）の文字通りの形として用いられる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It also gives us a reasonable way of visually isolating any known literal format as a single syntactic unit:</seg></tuv>
  <tuv xml:lang="JA"><seg>それも、我々に一つの構文法の単位として何か既知の文字通りのフォーマットを視覚的に孤立させることの合理的な方法を与える：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any such literal, when written without spaces, produces a pure numeric value without a stringy allomorphism.</seg></tuv>
  <tuv xml:lang="JA"><seg>スペースなしで書かれるとき、そのようなリテラルは繊維質の異形症なしで純粋な数値を生じる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Put spaces to override that:</seg></tuv>
  <tuv xml:lang="JA"><seg>置かれたスペースは、以下にオーバーライドすることになっている</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Or use the ≪≫ form of quotewords, which is always allomorphic:</seg></tuv>
  <tuv xml:lang="JA"><seg>あるいは、quotewords（常にallomorphicである）の≪≫の形を使用する：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Allomorphic Rats</seg></tuv>
  <tuv xml:lang="JA"><seg>Allomorphicネズミ</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any rational literal that would overflow a Rat64 in the denominator is also stored as a string.</seg></tuv>
  <tuv xml:lang="JA"><seg>分母でRat64からあふれ出る何か合理的なリテラルは、文字列としても保存される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(That is, angle brackets will be assumed in this case, producing a RatStr.) If a coercion to a wider type, such as FatRat, is requested, the literal reconverts from the entire original string, rather than just the value that would fit into a Rat64.</seg></tuv>
  <tuv xml:lang="JA"><seg>より広い型（例えばFatRat）への強制が要請されるならば、文字通りのものは全元の文字列（ちょうどRat64に適合する値よりもむしろ）から復帰する（つまり、かぎ括弧はこの場合装われる。そして、RatStrを生じる。）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(It may then cache that converted value for next time, of course.) So if you declare a constant with excess precision, it does not automatically become a FatRat, which would force all calculations into the pessimal FatRat type.</seg></tuv>
  <tuv xml:lang="JA"><seg>そう、あなたが過剰な精度で定数を宣言するならば、それは自動的にFatRatにならない（それから、もちろん、それは次の時間のためにその変換値をたくわえるかもしれない。）。そして、それはすべての計算にpessimalなFatRat型を強いる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Context</seg></tuv>
  <tuv xml:lang="JA"><seg>前後関係</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* Perl still has the three main contexts:</seg></tuv>
  <tuv xml:lang="JA"><seg>* Perlには、まだ3つの主要な前後関係がある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>sink (aka void), item (aka scalar), and list.</seg></tuv>
  <tuv xml:lang="JA"><seg>シンク（別名無効な）、アイテム（別名段階的な）とリスト。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* In addition to undifferentiated items, we also have these item contexts:</seg></tuv>
  <tuv xml:lang="JA"><seg>* 未分化アイテムに加えて、我々にもこれらのアイテム前後関係がある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There are also various container contexts that require particular kinds of containers (such as slice and hash context;</seg></tuv>
  <tuv xml:lang="JA"><seg>特定の種類のコンテナを必要とするいろいろなコンテナ前後関係も、ある（前後関係をスライスして、ハッシュするようであるもの;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>see S03 for details).</seg></tuv>
  <tuv xml:lang="JA"><seg>詳細はS03を見なさい）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* Unlike in Perl 5, objects are no longer always considered true.</seg></tuv>
  <tuv xml:lang="JA"><seg>* Perl 5のとは異なり、オブジェクトは真実であるともはや必ずしも考えられない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It depends on the state of their .Bool method, which may either be a synthetic attribute or an explicitly represented bit in the object.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは彼らの.Boolメソッドの国次第である。そして、それは合成属性またはオブジェクトのはっきりと表現されたビットである場合もある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Classes get to decide which of their values are true and which are false.</seg></tuv>
  <tuv xml:lang="JA"><seg>クラスは、彼らの値のうちどちらが真実か、そして、どちらが間違っているか決定するようになる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Individual objects can override the class definition:</seg></tuv>
  <tuv xml:lang="JA"><seg>個々のオブジェクトは、クラス定義にオーバーライドすることができる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This overrides the .Bool method of the 0 without changing its official type (by mixing the method into an anonymous derived type).</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、その公式型（メソッドを匿名の派生型に混入することによって）を変えることなく、0の.Boolメソッドにオーバーライドする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* The definition of .Bool for the most ancestral type (that is, the Mu</seg></tuv>
  <tuv xml:lang="JA"><seg>* 最も多くの祖先型のための.Boolの定義（つまり、Mu</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>type) is equivalent to .defined.</seg></tuv>
  <tuv xml:lang="JA"><seg>type) .definedに等しい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since type objects are considered undefined, all type objects (including Mu itself) are false unless the type overrides the definition of .Bool to include undefined values.</seg></tuv>
  <tuv xml:lang="JA"><seg>型オブジェクトが未定義であると考えられるので、型が未定義値を含むために.Boolの定義にオーバーライドしない限り、すべての型オブジェクト（Mu自体を含む）は間違っている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instantiated objects default to true unless the class overrides the definition.</seg></tuv>
  <tuv xml:lang="JA"><seg>クラスが定義にオーバーライドしない限り、具体例をあげて示されたオブジェクトは真にデフォルトでなる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that if you could instantiate a Mu it would be considered defined, and thus true.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたがMuを具体例をあげて示すことができるならば、それが定義されて、このように真実であると考えられるだろうことに注意すべきである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(It is not clear that this is allowed, however.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（しかし、これが許されることは明白でない。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* In general any container types should return false if they are empty, and true otherwise.</seg></tuv>
  <tuv xml:lang="JA"><seg>* 一般に、それらが空で、さもなければ真実であるならば、何かコンテナ型は誤って返らなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This is true of all the standard container types except Scalar, which always defers the definition of truth to its contents.</seg></tuv>
  <tuv xml:lang="JA"><seg>これはスカラー以外はすべての標準的なコンテナ型にとって真実である。そして、それは常に真実の定義をその内容に延期する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Non-container types define truthiness much as Perl 5 does.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 5がそうして、非コンテナ型はtruthinessを非常に定義する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Just as with the standard types, user-defined types should feel free to partition their defined values into true and false values if such a partition makes sense in control flow using boolean contexts, since the separate .defined method is always there if you need it.</seg></tuv>
  <tuv xml:lang="JA"><seg>ちょうど標準型と同様に、あなたがそれを必要とするならば別々の.definedメソッドが常にそこにある時から、そのような分割がブール値コンテキストを用いた制御フローで意味をなすならば、利用者定義型は彼らの定義済み値を本当で間違った値に仕切るのを遠慮しなくなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Lists</seg></tuv>
  <tuv xml:lang="JA"><seg>リスト</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Lazy flattening</seg></tuv>
  <tuv xml:lang="JA"><seg>怠惰な平坦化</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>List context in Perl 6 is by default lazy.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6のリストコンテキストは、デフォルトで怠惰である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This means a list can contain infinite generators without blowing up.</seg></tuv>
  <tuv xml:lang="JA"><seg>リストがそうすることができるこの手段は、爆発することなく、無限の発電機を含む。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>No flattening happens to a lazy list until it is bound to the signature of a function or method at call time (and maybe not even then).</seg></tuv>
  <tuv xml:lang="JA"><seg>それが呼び出し時間（そして、多分均一でないそれから）に関数またはメソッドのシグネチャの束縛を受けるだろうまで、平坦化は怠惰なリストに起こらない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>We say that such an argument list is &amp;quot;lazily flattened&amp;quot;, meaning that we promise to flatten the list on demand, but not before.</seg></tuv>
  <tuv xml:lang="JA"><seg>要求に応じてリストを平らにすると約束することを意味して、我々はそのような引数の並びが「ゆったりと平らにされる」と言う、しかし、それまではだめ。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>list, flat, item, and .tree</seg></tuv>
  <tuv xml:lang="JA"><seg>list、flat、itemと.tree</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is a &amp;quot;list&amp;quot; operator which imposes a list context on its arguments even if list itself occurs in a item context.</seg></tuv>
  <tuv xml:lang="JA"><seg>たとえlist自体がアイテム前後関係で起こるとしても、リストコンテキストをその引数に強要する&amp;quot;list&amp;quot;演算子が、ある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To force explicit flattening, use the flat contextualizer.</seg></tuv>
  <tuv xml:lang="JA"><seg>明示的平坦化を強制するために、flat contextualizerを使いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This recursively flattens all parcels into a 1-dimensional list.</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、1次元リストにすべてのパーセルを再帰的に平らにする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When bound to a slurpy parameter, a capture flattens the rest of its positional arguments.</seg></tuv>
  <tuv xml:lang="JA"><seg>slurpyパラメータに密接に結びつくとき、キャプチャーは残りのその位置引数を平らにする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To reform a list so that sub-parcels turn into tree nodes, use the .tree method, which is essentially a level-sensitive map, with one closure provided for remapping the parcels at each level:</seg></tuv>
  <tuv xml:lang="JA"><seg>下位パーセルがツリーノードに変わるように、リストを改革するために、1つのクロージャを各々のレベルでパーセルを再配置するために提供して、.treeメソッド（それは基本的にレベルセンシティブmapである）を使用しなさい：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When bound to a slice parameter (indicated with **), a capture reforms the rest of its positional arguments with one level of &amp;quot;treeness&amp;quot;, equivalent to @args.tree(1), that is, a list of lists, or LoL.</seg></tuv>
  <tuv xml:lang="JA"><seg>スライスパラメータ（**で示される）に密接に結びつくとき、キャプチャーは1レベルのtreenessで残りのその位置引数を改革する。そして、@args.tree(1)（つまり、リストのリストまたはLoL）に等しい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The sublists are not automatically flattened;</seg></tuv>
  <tuv xml:lang="JA"><seg>サブリストは、自動的に平らにされない;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>that is, if a sublist is a Parcel, it remains a list until subsequent processing decides how flat or treelike the sublist should be.</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、サブリストがParcelであるならば、以降の処理がサブリストがどれくらい平らでなければならないかtreelikeでなければならないかについて決めるまで、それはリストのままである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To force a non-flattening item context, use the &amp;quot;item&amp;quot; operator.</seg></tuv>
  <tuv xml:lang="JA"><seg>非平らになっているアイテム前後関係を強制するために、&amp;quot;item&amp;quot;演算子を使いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Forcing capture context</seg></tuv>
  <tuv xml:lang="JA"><seg>強制キャプチャー前後関係</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The | prefix operator may be used to force &amp;quot;capture&amp;quot; context on its argument and also defeat any scalar argument checking imposed by subroutine signature declarations.</seg></tuv>
  <tuv xml:lang="JA"><seg>|前置演算子は、その引数の上にキャプチャー前後関係を押しつけて、そのうえサブルーチンシグネチャ宣言によって課されてチェックしている何かスカラー引数を破るのに用いられるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Any resulting list arguments are then evaluated lazily.</seg></tuv>
  <tuv xml:lang="JA"><seg>それから、何か結果として生じるリスト引数は、ゆったりと評価される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The eager operator</seg></tuv>
  <tuv xml:lang="JA"><seg>eager演算子</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To force non-lazy list processing, use the eager list operator.</seg></tuv>
  <tuv xml:lang="JA"><seg>非怠惰なリスト処理を強制するために、eagerリスト演算子を使用しなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>List assignment is also implicitly eager.</seg></tuv>
  <tuv xml:lang="JA"><seg>リスト割当ても、暗黙のうちに熱心である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Actually, when we say &amp;quot;eager&amp;quot; we usually mean &amp;quot;mostly eager&amp;quot; as defined in S07).</seg></tuv>
  <tuv xml:lang="JA"><seg>（実は、「熱心な」言うとき、我々はS07で定義されるように、「大部分は熱心な」通常言っている）。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>By contrast,</seg></tuv>
  <tuv xml:lang="JA"><seg>対照的に、</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>makes no guarantee about how many lines ahead the iterator has read.</seg></tuv>
  <tuv xml:lang="JA"><seg>反復子が前にどれくらいの線を読み込んだかについて、保証を作らない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Iterators feeding a list are allowed to process in batches, even when stored within an array.</seg></tuv>
  <tuv xml:lang="JA"><seg>配列の中で格納されるときでも、リストを供給している反復子はバッチでプロセスまで許される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The array knows that it is extensible, and calls the iterator as it needs more elements.</seg></tuv>
  <tuv xml:lang="JA"><seg>配列は、それが伸長可能で、より多くの要素を必要として反復子を呼ぶということを知っている。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(Counting the elements in the array will also force eager completion.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（配列で要素を数えることは熱心な完成も強制する。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This operator is agnostic towards flattening or slicing.</seg></tuv>
  <tuv xml:lang="JA"><seg>この演算子は、平らになるか、切る方へ不可知論者である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In merely changes the work-ahead policy for the value generator.</seg></tuv>
  <tuv xml:lang="JA"><seg>値発生器のための仕事前進方針は、単に変わる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The hyper operator</seg></tuv>
  <tuv xml:lang="JA"><seg>hyper演算子</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A variant of eager is the hyper list operator, which declares not only that you want all the values generated now, but that you want them badly enough that you don't care what order they're generated in, as long as the results come back in the right order.</seg></tuv>
  <tuv xml:lang="JA"><seg>eagerの変形はhyperリスト演算子である。そして、もしあなたがそれらをあなたがそれらがどんな順序で発生するかについて気にしないひどく十分にしてもらいたくなければ、それは結果が右整環で戻る限りあなたがすべての値が現在発生することを望むことを除いてはでなく、宣言する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>That is, eager requires sequential evaluation of the list, while hyper requests (but does not require) parallel evaluation.</seg></tuv>
  <tuv xml:lang="JA"><seg>つまり、hyperが（しかし、requireをしない）平行した評価を要請する間、eagerはリストのシーケンシャルな評価を必要とする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In any case, it declares that you don't care about the evaluation order, only the result order.</seg></tuv>
  <tuv xml:lang="JA"><seg>いずれにせよ、それは、あなたは評価順序（結果順序だけ）が好きでないと断言する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This operator is agnostic towards flattening or slicing.</seg></tuv>
  <tuv xml:lang="JA"><seg>この演算子は、平らになるか、切る方へ不可知論者である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It merely changes the work-ahead policy for the value generator.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、単に仕事前進方針を値発生器と交換するだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The race operator</seg></tuv>
  <tuv xml:lang="JA"><seg>race演算子</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A further variant of hyper is the race list operator, which declares that you want the results so badly that you don't even care what order they come back in. Within its arguments, the race operator forces parallel evaluation of any iterator, hyper, or junction, such that if any single thread dies or hangs its computation, it does not block any other thread from returning its results to the race list.</seg></tuv>
  <tuv xml:lang="JA"><seg>hyperの更なる変形は、raceリスト演算子である。そして、それは、あなたがそれらがどんな順序で戻るかについてさえ気にしないほどとても結果を望むと断言する。その引数の中で、race演算子は、何か反復子、ハイパーまたは交差点（何か一条ねじが止まるか、その計算を掛けるならば、それがレースリストに結果を返ることから何か他の糸をブロックしないような）の平行した評価を強制する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When the demand for the race list drops, hung threads may be killed.</seg></tuv>
  <tuv xml:lang="JA"><seg>レースリストを求める要求が減少するとき、掛けられた糸は殺されるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You can think of it as a gather with a 'try take start ...' on parallel computation.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、それを'try take start ...'が並列処理にあるgatherとみなすことができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that exceptions are trapped by default;</seg></tuv>
  <tuv xml:lang="JA"><seg>例外がデフォルトで罠にかけられることに注意すべきである;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>if your car crashes, you simply do not finish the race.</seg></tuv>
  <tuv xml:lang="JA"><seg>車が破壊するならば、あなたは単にレースを終えない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you want notifications of some sort back to the pit crew, you'll have to arrange them yourself.</seg></tuv>
  <tuv xml:lang="JA"><seg>ピットクルーに何らかの通知を返して欲しいならば、あなたは自分でそれらを手配しなければならない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This operator is agnostic towards flattening or slicing.</seg></tuv>
  <tuv xml:lang="JA"><seg>この演算子は、平らになるか、切る方へ不可知論者である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It merely changes the work-ahead policy for the value generator.</seg></tuv>
  <tuv xml:lang="JA"><seg>それは、単に仕事前進方針を値発生器と交換するだけである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>It is a transitive contextualizer insofar as iterators will have to pass on the policy to subiterators.</seg></tuv>
  <tuv xml:lang="JA"><seg>反復子が保険証書をsubiteratorsに渡さなければならない限り、それは他動的なcontextualizerである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The =&amp;gt; operator</seg></tuv>
  <tuv xml:lang="JA"><seg>=&amp;gt;演算子</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The =&amp;gt; operator now constructs Pair objects rather than merely functioning as a comma.</seg></tuv>
  <tuv xml:lang="JA"><seg>=&amp;gt;演算子は、単にコンマとして機能するだけであることよりもむしろPairオブジェクトを現在造る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Both sides are in item context.</seg></tuv>
  <tuv xml:lang="JA"><seg>双方は、アイテム前後関係にある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The .. operator</seg></tuv>
  <tuv xml:lang="JA"><seg>..演算子</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The .. operator now constructs a Range object rather than merely functioning as an operator.</seg></tuv>
  <tuv xml:lang="JA"><seg>単に演算子として機能するだけであるよりはむしろ、..演算子は現在Rangeオブジェクトを造る。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Both sides are in item context.</seg></tuv>
  <tuv xml:lang="JA"><seg>双方は、アイテム前後関係にある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Semantically, the Range acts like a list of its values to the extent possible, but does so lazily, unlike Perl 5's eager range operator.</seg></tuv>
  <tuv xml:lang="JA"><seg>意味論的に、Perl 5の熱心な範囲演算子とは異なり、Rangeは可能な限りその値のリストのようなふりをするが、ゆったりとそうする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hash assignment</seg></tuv>
  <tuv xml:lang="JA"><seg>ハッシュ割当て</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>There is no such thing as a hash list context.</seg></tuv>
  <tuv xml:lang="JA"><seg>ハッシュリストコンテキストなんてものが、ない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Assignment to a hash produces an ordinary list context.</seg></tuv>
  <tuv xml:lang="JA"><seg>ハッシュへの代入は、普通のリストコンテキストを生じる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may assign alternating keys and values just as in Perl 5.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、Perl 5の場合のようにちょうど交互のキーと値を割り当てるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may also assign lists of Pair objects, in which case each pair provides a key and a value.</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたはPairオブジェクトのリストも割り当てるかもしれない、その場合には、各ペアはキーと値を提供する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>You may, in fact, mix the two forms, as long as the pairs come when a key is expected.</seg></tuv>
  <tuv xml:lang="JA"><seg>キーが予想されるとき組が来る限り、あなたは、実際、2つの形を混ぜるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>If you wish to supply a Pair as a key, you must compose an outer Pair in which the key is the inner Pair:</seg></tuv>
  <tuv xml:lang="JA"><seg>キーとしてPairを供給したいならば、あなたはキーが内部のPairである外のPairを組み立てなければならない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The anonymous enum function</seg></tuv>
  <tuv xml:lang="JA"><seg>匿名のenum関数</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The anonymous enum function takes a list of keys or pairs, and adds values to any keys that are not already part of a pair.</seg></tuv>
  <tuv xml:lang="JA"><seg>匿名のenum関数はキーまたは組のリストをとって、値をすでに一組の一部でない何かキーに加える。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The value added is one more than the previous key or pair's value.</seg></tuv>
  <tuv xml:lang="JA"><seg>加えられる値は、前のキーまたは一組の値より、1である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>This works nicely with the new qq:ww form:</seg></tuv>
  <tuv xml:lang="JA"><seg>これは、新しいqq:wwの形でうまく動く：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>are the same as:</seg></tuv>
  <tuv xml:lang="JA"><seg>以下と同じようにある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Hash binding</seg></tuv>
  <tuv xml:lang="JA"><seg>ハッシュバインディング</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>In contrast to assignment, binding to a hash requires a Hash (or Pair) object, or anything that does the Associative role.</seg></tuv>
  <tuv xml:lang="JA"><seg>割当てと対照的に、ハッシュへのバインディングは、Hash（またはPair）オブジェクトまたはAssociativeロールをする何でも必要とする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Files</seg></tuv>
  <tuv xml:lang="JA"><seg>ファイル</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* Filename globs are no longer done with angle brackets.</seg></tuv>
  <tuv xml:lang="JA"><seg>* ファイル名小滴は、かぎ括弧でもはやされない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Use the glob function.</seg></tuv>
  <tuv xml:lang="JA"><seg>glob関数を使いなさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>* Input from a filehandle is no longer done with angle brackets.</seg></tuv>
  <tuv xml:lang="JA"><seg>* ファイルハンドルからの入力は、かぎ括弧でもはやされない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Instead of</seg></tuv>
  <tuv xml:lang="JA"><seg>の代わりに</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>you now write</seg></tuv>
  <tuv xml:lang="JA"><seg>あなたは、現在書く</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Grammatical Categories</seg></tuv>
  <tuv xml:lang="JA"><seg>文法範疇</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Lexing in Perl 6 is controlled by a system of grammatical categories.</seg></tuv>
  <tuv xml:lang="JA"><seg>Perl 6のLexingは、文法範疇のシステムによって支配される。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>At each point in the parse, the lexer knows which subset of the grammatical categories are possible at that point, and follows the longest-token rule across all the active alternatives, including those representing any grammatical categories that are ready to match.</seg></tuv>
  <tuv xml:lang="JA"><seg>解析の各々の点で、lexerは、文法範疇のどのサブセットがそこであり得るかについてわかっていて、マッチに準備ができている何か文法範疇を表現しているそれらを含むすべての活発な選択肢全体で、最も長く形だけの規則に従う。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>See S05 for a detailed description of this process.</seg></tuv>
  <tuv xml:lang="JA"><seg>このプロセスの詳しい説明については、S05を見なさい。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To get a list of the current categories, grep 'token category:</seg></tuv>
  <tuv xml:lang="JA"><seg>現在のカテゴリー（grep『トークンカテゴリー』）のリストを得ること：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>' from STD.pm6.</seg></tuv>
  <tuv xml:lang="JA"><seg>『STD.pm6から。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Category names are used as the short name of both various operators and the rules that parse them, though the latter include an extra &amp;quot;sym&amp;quot;:</seg></tuv>
  <tuv xml:lang="JA"><seg>後者が余分の「sym」を含むけれども、カテゴリー名がそれらを解析するいろいろな演算子と規則の短いファイル名として使われる：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>As you can see, the extension of the name uses colon pair notation.</seg></tuv>
  <tuv xml:lang="JA"><seg>ご覧の通り、名前の拡張は、コロン一組表記法を使用する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The :sym typically takes an argument giving the string name of the operator;</seg></tuv>
  <tuv xml:lang="JA"><seg>:symは、演算子の文字列名を伝えている引数を概してする;</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>some of the &amp;quot;circumfix&amp;quot; categories require two arguments for the opening and closing strings.</seg></tuv>
  <tuv xml:lang="JA"><seg>「circumfix」カテゴリーのいくらかは、開閉文字列のために2つの引数を必要とする。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Since there are so many match rules whose symbol is an identifier, we allow a shorthand:</seg></tuv>
  <tuv xml:lang="JA"><seg>シンボルが識別子であるそれほど多くのマッチ規則があるので、我々は短縮形を許す：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Conjecturally, we might also have other kinds of rules, such as tree rewrite rules:</seg></tuv>
  <tuv xml:lang="JA"><seg>推測で、我々には他の種類の規則（例えば木書き換え規則）もあるかもしれない：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Within a grammar, matching the proto subrule &amp;lt;infix&amp;gt; will match all visible rules in the infix category as parallel alternatives, as if they were separated by '|'.</seg></tuv>
  <tuv xml:lang="JA"><seg>文法の範囲内で、まるでそれらが'|'によって切り離されるように、プロトsubrule &amp;lt;infix&amp;gt;にマッチすることは平行した選択肢として挿入辞カテゴリーですべての見える規則に匹敵する。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Here are some of the names of parse rules in STD:</seg></tuv>
  <tuv xml:lang="JA"><seg>STDの解析規則の名前のいくらかは、ここにある：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Note that some of these produce correspondingly named operators, but not all of them.</seg></tuv>
  <tuv xml:lang="JA"><seg>これらの生産物の一部が対応してそれらの全てでなく、演算子の名前を挙げたことに注意すべきである。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When they do correspond (such as in the cmp example above), this is by convention, not by enforcement.</seg></tuv>
  <tuv xml:lang="JA"><seg>それらが一致する（例えば上のcmp例で）とき、施行によってでなく、これは規則のそばにある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>(However, matching &amp;lt;sym&amp;gt; within one of these rules instead of the literal operator makes it easier to set up this correspondence in subsequent processing.)</seg></tuv>
  <tuv xml:lang="JA"><seg>（しかし、文字通りの演算子の代わりにこれらの規則の1つの範囲内のマッチする&amp;lt;sym&amp;gt;は以降の処理においてこの通信を準備することをより簡単にする。）</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>The STD::Regex grammar also adds these:</seg></tuv>
  <tuv xml:lang="JA"><seg>STD::Regex文法も、これらを加える：</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Deprecations</seg></tuv>
  <tuv xml:lang="JA"><seg>非難</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>A language that doesn't evolve, is a dead language.</seg></tuv>
  <tuv xml:lang="JA"><seg>進化しない言語は、死語である。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Constructs that seem like a good idea now, may turn out not to be such a good idea in the future.</seg></tuv>
  <tuv xml:lang="JA"><seg>現在良い考えのようである構成概念は、将来そのような良い考えでないことがわかるかもしれない。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>Such constructs will thus need to be deprecated.</seg></tuv>
  <tuv xml:lang="JA"><seg>そのような構成概念は、このように廃止必要がある。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>To mark a construct as being deprecated, one can add the &amp;quot;is DEPRECATED($alternative)&amp;quot; trait to a class, an attribute, or a sub / method.</seg></tuv>
  <tuv xml:lang="JA"><seg>廃止にしながら、構成概念に跡を残すために、人は&amp;quot;is DEPRECATED($alternative)&amp;quot;トレイトをクラス、属性またはsub / methodに加えることができる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>During execution, this will cause the caller sites to be recorded without any warnings.</seg></tuv>
  <tuv xml:lang="JA"><seg>実行の間、これは発信者サイトが何か警告なしで記録される原因になる。</seg></tuv>
</tu>

<tu>
  <tuv xml:lang="EN-US"><seg>When execution finishes, a report should be printed to STDERR stating which deprecated features where called where.</seg></tuv>
  <tuv xml:lang="JA"><seg>実行が終わるとき、レポートはそこで呼ばれる所で、どちらが機能を非難したかについて告示しているSTDERRに出力されなければならない。</seg></tuv>
</tu>

</body>
</tmx>
