<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="3.0.8_5" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg># print a piece of SVG that represents a rectangle</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T133236Z" creationid="Toshiyuki" creationdate="20140104T133236Z">
        <seg># 長方形を表すSVGを出力する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$count&lt;/c1&gt;, so the question mark goes directly after the second asterisk.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T230332Z" creationid="Toshiyuki" creationdate="20140221T230332Z">
        <seg>$count&lt;/c1&gt;です。なのでクエスチョンマークは直接第2のアスタリスクを求めます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(&lt;c1&gt;next&lt;/c1&gt; without a label is purely dynamic.) Lexotic and dynamic control flow is implemented by a system of control exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T062449Z" creationid="Toshiyuki" creationdate="20130728T061924Z">
        <seg>（ラベルなしの&lt;c1&gt;next&lt;/c1&gt;は純粋に動的だ。） レギゾチックとダイナミックな制御フローは制御例外としてシステムによって実装される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(All normal types in Perl may be evaluated for truth.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T070644Z" creationid="Toshiyuki" creationdate="20130804T070644Z">
        <seg>（Perlのすべての通常の型は真偽のために評価されるだろう。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Always assuming the user expects the right thing, of course...) In particular, if the user labels a loop with a specific label, and calls a loop control from within the lexical scope of that loop, and if that call mentions the outer loop's label, then that outer loop is the one that must be controlled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080908Z" creationid="Toshiyuki" creationdate="20130817T080908Z">
        <seg>（ユーザーが常に仮定するのは正しいことだ。もちろん）特に、特定のラベルでユーザーがループにラベルを付けるなら、そしてループ制御をそのレキシカルスコープ内でよぶなら、そしてその呼出しが外側のループのラベルを言及するなら、制御されなければならない外側のループは一つだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Assignment of &lt;c3&gt;()&lt;/c3&gt; leaves it defined.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140401T115641Z" creationid="Toshiyuki" creationdate="20140401T115641Z">
        <seg>（&lt;c3&gt;()&lt;/c3&gt;の割り当ては定義されています。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(By similar reasoning, an &lt;c5&gt;unless&lt;/c5&gt; allows binding of a false parameter.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T084132Z" creationid="Toshiyuki" creationdate="20130804T084132Z">
        <seg>（似た理由で、&lt;c5&gt;unless&lt;/c5&gt;偽のパラメータのバインディングを許可する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Contrast with a non-conditional statement such as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T100105Z" creationid="Toshiyuki" creationdate="20130804T100105Z">
        <seg>（条件付きでない文の対比はこのようになる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(FLAT is an acronym meaning Flat Lists Are Typical.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T210028Z" creationid="Toshiyuki" creationdate="20130810T210028Z">
        <seg>（FLATはFlat Lists Are Typicalの頭文字だ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If bare statements were allowed, the temporary binding of &lt;c4&gt;$_&lt;/c4&gt; would leak out past the end of the &lt;c5&gt;CATCH&lt;/c5&gt; or &lt;c6&gt;CONTROL&lt;/c6&gt;, with unpredictable and quite possibly dire consequences.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T091247Z" creationid="Toshiyuki" creationdate="20130818T091247Z">
        <seg>（もし裸の文が許可されるなら、&lt;c4&gt;$_&lt;/c4&gt;の一時的なバインディングは&lt;c5&gt;CATCH&lt;/c5&gt;または &lt;c6&gt;CONTROL&lt;/c6&gt;の終端をすぎてリークする。予測できず、まったく緊急かもしれない結果を伴って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If that is not the block you wish to leave, you must use the &lt;c12&gt;LABEL.leave&lt;/c12&gt; method (or some other control exception such as &lt;c13&gt;return&lt;/c13&gt; or &lt;c14&gt;next&lt;/c14&gt;) to be more specific, since the compiler may find it difficult to guess which surrounding construct was intended as the actual topicalizer.) The value of the inner block is returned as the value of the outer block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T131811Z" creationid="Toshiyuki" creationdate="20130811T131811Z">
        <seg>（もしそれが抜けたくないブロックなら、より明確にするために&lt;c12&gt;LABEL.leave&lt;/c12&gt;メソッド（または&lt;c13&gt;return&lt;/c13&gt;か&lt;c14&gt;next&lt;/c14&gt;のようないくつかの他の制御例外）を使わなければならない。 だからコンパイラが実際のトピカライザーとして意図される周囲の構成物がどれか推測するのは難しいだろう。） 内側のブロックの値は外側のブロックの値として返される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the &lt;c2&gt;LINE&lt;/c2&gt; is not visible, it would have been caught earlier at compile time since &lt;c3&gt;LINE&lt;/c3&gt; would likely be a bareword.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T075529Z" creationid="Toshiyuki" creationdate="20130817T075529Z">
        <seg>（もし&lt;c2&gt;LINE&lt;/c2&gt;が見えないなら、 &lt;c3&gt;LINE&lt;/c3&gt;が裸のワードのようになるまでコンパイル時に早期にキャッチされる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, it's lexotic.) If the &lt;c1&gt;LINE&lt;/c1&gt; label is visible but you aren't actually in a dynamic scope controlled by that label, an exception is thrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T075123Z" creationid="Toshiyuki" creationdate="20130817T075123Z">
        <seg>（言い換えれば、それはレギゾチックだ。）もし&lt;c1&gt;LINE&lt;/c1&gt;ラベルが可視だが実際にはラベルによって制御されたダイナミックスコープにいるなら、例外がスローされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, there is an implicit &lt;c5&gt;.die&lt;/c5&gt; just inside the end of the &lt;c6&gt;CATCH&lt;/c6&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T135455Z" creationid="Toshiyuki" creationdate="20130813T135455Z">
        <seg>（言い換えれば、&lt;c6&gt;CATCH&lt;/c6&gt;ブロックの内部の終端に暗黙の&lt;c5&gt;.die&lt;/c5&gt;があるだけだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Initialization of ordinary variables does not count--presumably the presence of a label will prevent code-movement optimizations past the label.) So, for instance, it's always possible to &lt;c5&gt;goto&lt;/c5&gt; into the next case of a &lt;c6&gt;when&lt;/c6&gt; or into either the "then" or "else" branch of a conditional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T142332Z" creationid="Toshiyuki" creationdate="20130817T142332Z">
        <seg>（普通の変数の初期化はカウントしない―多分、ラベルの存在はラベルを過ぎるcode-movement最適化を防ぐだろう。）なので、例えば、&lt;c5&gt;goto&lt;/c5&gt;で次のケースの&lt;c6&gt;when&lt;/c6&gt;か「then」または「else」の条件分岐に飛ぶことは常に可能だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It is erroneous to depend on this order if the module is used more than once, however, since the phasers are only installed the first time they're noticed.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030324Z" creationid="Toshiyuki" creationdate="20130822T030324Z">
        <seg>（モジュールが2回以上使われるなら、この順番に頼るのは間違いだ。しかしながら、phasersはそれらが初めて気づいた時だけインストールされる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(More generally, any container has a container type, including subroutines and modules.) The &lt;c0&gt;of&lt;/c0&gt; type is stored as its &lt;c1&gt;of&lt;/c1&gt; property, while the container type of the container is just the object type of the container itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T212922Z" creationid="Toshiyuki" creationdate="20140328T212922Z">
        <seg>（より一般化すると、どのようなコンテナもコンテナ型を持っています。それはサブルーチンとモジュールも含みます。）&lt;c0&gt;of&lt;/c0&gt;型は&lt;c1&gt;of&lt;/c1&gt;プロパティとして保存されます。コンテナの型はコンテナ自身のただのオブジェクト型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that both of these scans are done at compile time; if the scans fail, it's a compile-time semantic error.) Typically, such an outer block will be the block of a &lt;c5&gt;given&lt;/c5&gt; or a &lt;c6&gt;for&lt;/c6&gt; statement, but any block that sets the topic can be broken out of.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T165517Z" creationid="Toshiyuki" creationdate="20130812T165517Z">
        <seg>（両方のスキャンはコンパイル時に行われるので注意；もしスキャンが失敗したら、コンパイル時セマンティックエラーだ。）典型的には、そのようなブロックは&lt;c5&gt;given&lt;/c5&gt;か&lt;c6&gt;for&lt;/c6&gt;文のブロックだろう。しかしトピックをセットするどんなブロックでも脱出できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that fatal exception types can do the &lt;c2&gt;Resumable&lt;/c2&gt; role even if thrown via &lt;c3&gt;fail()&lt;/c3&gt;--when uncaught they just hit the outermost fatal handler instead of the outermost warning handler, so some inner scope has to explicitly treat them as warnings and resume them.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T115135Z" creationid="Toshiyuki" creationdate="20130817T115115Z">
        <seg>致命的な例外型は&lt;c3&gt;fail()&lt;/c3&gt;経由でスローされても&lt;c2&gt;Resumable&lt;/c2&gt;ロールを行えるので注意―キャッチされない時は最も外側の警告ハンドラの代わりに最も外側の致命的ハンドラをヒットするだけなので、いくつかの内側のスコープはそれらを警告と、それらを再会するとして明示的に扱う必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that, unlike C's idea of "falling through", subsequent &lt;c3&gt;when&lt;/c3&gt; conditions are evaluated.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115352Z" creationid="Toshiyuki" creationdate="20130813T115245Z">
        <seg>（C言語の「フォールスルー」の考えと違い、その後に続く&lt;c3&gt;when&lt;/c3&gt;の条件は評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note the caller can vary from call to call!)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T065851Z" creationid="Toshiyuki" creationdate="20130811T065851Z">
        <seg>（呼び出し元は呼び出しごとに変わることに注意！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note, however, that the value of a variable calculated at compile time may not persist under run-time cloning of any surrounding closure.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085255Z" creationid="Toshiyuki" creationdate="20130818T085255Z">
        <seg>（注意、けれども、コンパイル時に計算される変数の値はなにか一つの周囲のクロージャの実行時の複製まで残存しないだろう。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note: the implicit default binding of an outer &lt;c10&gt;$_&lt;/c10&gt; to an inner &lt;c11&gt;$_&lt;/c11&gt; can be emulated for a bare block, so that doesn't fall under the prohibition on bypassing formal binding.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T144409Z" creationid="Toshiyuki" creationdate="20130817T144409Z">
        <seg>（注意：外側の&lt;c10&gt;$_&lt;/c10&gt;の暗黙のデフォルトのバインディングから内側の&lt;c11&gt;$_&lt;/c11&gt;は裸のブロックのためにエミュレートできる。それゆえそれは正式のバインディングのバイパスの禁止に該当しない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or we use push semantics and &lt;c3&gt;$!&lt;/c3&gt; means &lt;c4&gt;@![*-1]&lt;/c4&gt;.) This might be more robust than merely making &lt;c5&gt;@!&lt;/c5&gt; a parameter to CATCH.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T152707Z" creationid="Toshiyuki" creationdate="20130817T152707Z">
        <seg>（または我々はpushセマンティクスを使い、&lt;c3&gt;$!&lt;/c3&gt;は&lt;c4&gt;@![*-1]&lt;/c4&gt;を意味する。）これは単に&lt;c5&gt;@!&lt;/c5&gt;をCATCHへのパラメータにするより強いかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Otherwise any &lt;c5&gt;die&lt;/c5&gt; would cause an infinite loop.) Instead we treasure them up and rethrow them to a handler further up.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T120951Z" creationid="Toshiyuki" creationdate="20130814T120951Z">
        <seg>（さもなければ&lt;c5&gt;die&lt;/c5&gt;は無限ループを引き起こすだろう。）その代わりとして我々はそれらを取っておき、さらに上のハンドラに再スローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Perl 6's &lt;c2&gt;eval&lt;/c2&gt; function only evaluates strings, not blocks, and does not catch exceptions.) A &lt;c3&gt;try&lt;/c3&gt; block by default has a &lt;c4&gt;CATCH&lt;/c4&gt; block that handles all fatal exceptions by ignoring them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T122000Z" creationid="Toshiyuki" creationdate="20130813T122000Z">
        <seg>（Perl 6の&lt;c2&gt;eval&lt;/c2&gt;関数はブロックではなく文字列だけを評価し、例外をキャッチしない。）&lt;c3&gt;try&lt;/c3&gt;ブロックはデフォルトでは全ての致命的な例外を無視するように扱う&lt;c4&gt;CATCH&lt;/c4&gt;ブロックを持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See Definition of Success below for more.) &lt;c4&gt;temp&lt;/c4&gt; and &lt;c5&gt;let&lt;/c5&gt; temporize or hypotheticalize the value or the variable depending on whether you do assignment or binding.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T135926Z" creationid="Toshiyuki" creationdate="20130802T135926Z">
        <seg>（以下、詳細は成功の定義を参照）&lt;c4&gt;temp&lt;/c4&gt;と&lt;c5&gt;let&lt;/c5&gt;はあなたが割り当てるかバインドするかどうかに依存して値か変数を一時的にするか仮定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See below.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T123536Z" creationid="Toshiyuki" creationdate="20130813T123536Z">
        <seg>（以下を参照。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That is, in the abstract, they're all anonymous subroutines that take a snapshot of their lexical environment.) How a block is invoked and how its results are used are matters of context, but closures all work the same on the inside.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T120626Z" creationid="Toshiyuki" creationdate="20130729T120626Z">
        <seg>（それは抽象的には、それらは全てレキシカル環境のスナップショットを撮る無名サブルーチンだ。）ブロックがどのように呼び出され、結果がどのように使われるかはコンテキストの問題だが、クロージャは内部で全て同じに動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That is, it is a &lt;c12&gt;Mu&lt;/c12&gt; method, not a &lt;c13&gt;Failure&lt;/c13&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161841Z" creationid="Toshiyuki" creationdate="20130817T161841Z">
        <seg>（すなわち、それは&lt;c12&gt;Mu&lt;/c12&gt;メソッドで、&lt;c13&gt;Failure&lt;/c13&gt;メソッドではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c1&gt;repeat&lt;/c1&gt; keyword forces the conditional to be evaluated at the end of the loop, so it's still C's &lt;c2&gt;do-while&lt;/c2&gt; semantics.) Therefore, even under GNU style rules, the previous example may be rewritten into a very clear:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T054713Z" creationid="Toshiyuki" creationdate="20130810T053604Z">
        <seg>（&lt;c1&gt;repeat&lt;/c1&gt;キーワードは条件文をループの終わりで評価するようにさせるので、それはまだ C言語の&lt;c2&gt;do-while&lt;/c2&gt;セマンティクスだ。）したがって、GNUスタイルの規則でさえ、前の例はとてもわかりやすく書きなおされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c1&gt;while&lt;/c1&gt;'s declaration of &lt;c2&gt;$line&lt;/c2&gt; continues to be visible past the end of the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063315Z" creationid="Toshiyuki" creationdate="20130810T063300Z">
        <seg>（&lt;c1&gt;while&lt;/c1&gt;の&lt;c2&gt;$line&lt;/c2&gt;の宣言はブロックの終わりを過ぎても見え続ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c6&gt;Failure&lt;/c6&gt; may, however, be stored in any container whose type allows the &lt;c7&gt;Failure&lt;/c7&gt; role to be mixed in.) The &lt;c8&gt;.handled&lt;/c8&gt; method returns &lt;c9&gt;False&lt;/c9&gt; on failures that have not been handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161714Z" creationid="Toshiyuki" creationdate="20130817T161714Z">
        <seg>（&lt;c6&gt;Failure&lt;/c6&gt;はおそらく、どんな方法でも、&lt;c7&gt;Failure&lt;/c7&gt;ロールをミックスインされるために型が許可される何か一つのコンテナに格納される。）&lt;c8&gt;.handled&lt;/c8&gt;メソッドはハンドルされたことのない失敗で&lt;c9&gt;False&lt;/c9&gt;を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The difference between Perl 5 and Perl 6 in this respect arises only because Perl 5 didn't have user-defined control structures, hence the sub's lexical scope was &lt;i0&gt;always&lt;/i0&gt; the innermost dynamic scope, so the preference to the lexical scope in the current sub was implicit.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T081757Z" creationid="Toshiyuki" creationdate="20130817T081757Z">
        <seg>（この関係のPerl 5とPerl 6の間の違いは唯一発生する。なぜならPerl 5はユーザー定義の制御構造を持たず、それゆえにsubのレキシカルスコープは&lt;i0&gt;常に&lt;/i0&gt;最も深いダイナミックスコープのようなので、現在のsubのレキシカルスコープの優先傾向は暗黙だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The fat arrow &lt;c4&gt;=&gt;&lt;/c4&gt; separates key and value in a &lt;c5&gt;Pair&lt;/c5&gt;.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T141701Z" creationid="Toshiyuki" creationdate="20131026T141701Z">
        <seg>（太い矢印&lt;c4&gt;=&gt;&lt;/c4&gt;はキーと値を&lt;c5&gt;Pair&lt;/c5&gt;に区切ります。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Think especially about how to avoid collisions in "diamond dependencies", where a &lt;c2&gt;Task&lt;/c2&gt; has two different dependencies which in turn have the same dependency.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T111908Z" creationid="Toshiyuki" creationdate="20140314T213307Z">
        <seg>（特に&lt;c2&gt;Task&lt;/c2&gt;が同じ従属物を持つ2つの異なる従属物を保つ場合に“ダイアモンド従属物”でどのように衝突を避けるか考えてください。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This implies that there are some errors that would ordinarily be found at compile time that cannot be found until we know what the caller's lexical scope looks like at run time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T075655Z" creationid="Toshiyuki" creationdate="20130811T075655Z">
        <seg>（これはいくつかのエラーがあることを伴う。それは通常はコンパイル時に見つかり、我々が実行時のように見える呼び出し元のどのレキシカルスコープか知るまで見つからない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is &lt;e1&gt;autovivification&lt;/e1&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T160814Z" creationid="Toshiyuki" creationdate="20131026T140822Z">
        <seg>（これは&lt;e1&gt;自動有効化&lt;/e1&gt;です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is the only situation in which a cycle can occur.) This requires the addition of a helper method &lt;c1&gt;depends-on&lt;/c1&gt;, which checks whether a task depends on another one, either directly or transitively.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T111205Z" creationid="Toshiyuki" creationdate="20140112T180504Z">
        <seg>（これは循環が起こることがありえる唯一の状況です。）これは、ヘルパーメソッド&lt;c1&gt;depends-on&lt;/c1&gt;（それはタスクが別のものに依存するかどうか調べます）の追加を直接、または、他動的に必要とします.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This only works for one-way coercion, so you may not declare any &lt;c0&gt;rw&lt;/c0&gt; parameter with a coercive type.) The type outside the parens indicates the desired end result, and subsequent code may depend on it being that type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140407T124658Z" creationid="Toshiyuki" creationdate="20140407T124658Z">
        <seg>（これは一方通行の強制のためだけに動作するので、あなたは制約型で&lt;c0&gt;rw&lt;/c0&gt;パラメータを宣言しないでしょう。）括弧の外の型は望んでいる結果を示し、以降のコードはその型によって決まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Use &lt;c4&gt;print&lt;/c4&gt; if you don't want the newline at the end.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T152234Z" creationid="Toshiyuki" creationdate="20131026T152234Z">
        <seg>（終わりに改行文字が不要なら&lt;c4&gt;print&lt;/c4&gt;を使ってください。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Using the term "label" loosely, to include other solutions besides the label syntax, such as .gather and .take methods on some identity object.)]</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T195732Z" creationid="Toshiyuki" creationdate="20130810T195732Z">
        <seg>（「ラベル」という語句を緩く使う、ラベル文法に加えて他の解決策を付け加える、いくつかの識別オブジェクトでの.gatherと.takeメソッドのような 。）］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You can always establish a lexical scope explicitly by using the block form of argument.) As statement introducers, all these keywords must be followed by whitespace.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T081130Z" creationid="Toshiyuki" creationdate="20130811T081130Z">
        <seg>（ブロック形式の引数を使うことでいつでもレキシカルスコープを確立することができる。）文をもたらすものによって、これらすべてのキーワードは空白が続かなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You can say something like &lt;c7&gt;try({...})&lt;/c7&gt;, but then you are calling the &lt;c8&gt;try()&lt;/c8&gt; function using function call syntax instead, and since Perl does not supply such a function, it will be assumed to be a user-defined function.) For purposes of flow control, none of these forms are considered loops, but they may easily be applied to a normal loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T092355Z" creationid="Toshiyuki" creationdate="20130811T092355Z">
        <seg>（あなたは&lt;c7&gt;try({...})&lt;/c7&gt;のような何かを書くことができる。しかし&lt;c8&gt;try()&lt;/c8&gt;関数を代わりに関数呼び出し文法で使い、Perlがそのような関数を供給しないので、それはユーザー定義の関数と仮定されるだろう。）フロー制御の目的のためにこれらの形式はループと見なされないが、これらは通常のループに簡単に適用出来る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You could write a macro that violates this, but resist the urge.) Variables that mediate between an outer statement and an inner block (such as loop variables) should generally be declared as formal parameters to that block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T123354Z" creationid="Toshiyuki" creationdate="20130729T123036Z">
        <seg>（あなたはこれを犯すマクロを書くことが可能だが、衝動を抑えてくれ。）外側の文と内側のブロック（ループ変数のような）の間を仲介する変数は一般的にはそのブロックの仮パラメータとして宣言されるべきだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(loosest precedence)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T124933Z" creationid="Toshiyuki" creationdate="20131027T124926Z">
        <seg>（最も低い優先順位）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(tightest precedence)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121746Z" creationid="Toshiyuki" creationdate="20131027T121746Z">
        <seg>（最もタイトな順位）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-1 for negative, 0 for zero, 1 for positive values</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015839Z" creationid="Toshiyuki" creationdate="20140322T015839Z">
        <seg>負数なら-1、ゼロなら0、正の値なら1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... already contains three different operators: &lt;c0&gt;=&lt;/c0&gt;, &lt;c1&gt;=&gt;&lt;/c1&gt;, and &lt;c2&gt;,&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T124605Z" creationid="Toshiyuki" creationdate="20131027T044839Z">
        <seg>は既に3つの異なる演算子を含んでいます：&lt;c0&gt;=&lt;/c0&gt;、&lt;c1&gt;=&gt;&lt;/c1&gt;、そして&lt;c2&gt;,&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... amount of &lt;c0&gt;X&lt;/c0&gt; characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T065333Z" creationid="Toshiyuki" creationdate="20131027T065333Z">
        <seg>... &lt;c0&gt;X&lt;/c0&gt;文字数の総計。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... an undefined value dispatches to the second candidate.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114015Z" creationid="Toshiyuki" creationdate="20140322T114015Z">
        <seg>... 未定義値は第2候補としてディスパッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... and you'd better not misplace your new &lt;c0&gt;$world&lt;/c0&gt; if it's temporary, as it's the only one you're going to get.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T063530Z" creationid="Toshiyuki" creationdate="20140104T231443Z">
        <seg>…そしてもし新しい&lt;c0&gt;$world&lt;/c0&gt;が一時変数なら、それを置き忘れないほうがいいです。それはあなたが得るただひとつのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... into:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T170124Z" creationid="Toshiyuki" creationdate="20131026T170124Z">
        <seg>を以下に：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... so that &lt;c0&gt;@scores&lt;/c0&gt; will contain only one item.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T111911Z" creationid="Toshiyuki" creationdate="20131027T111911Z">
        <seg>それで、&lt;c0&gt;@scores&lt;/c0&gt;は1つのアイテムだけ含むでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... the name of the sub is &lt;c0&gt;panic&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131935Z" creationid="Toshiyuki" creationdate="20131029T131935Z">
        <seg>サブルーチンの名前は&lt;c0&gt;panic&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... the right-hand side of the assignment produces a list (because of the &lt;c0&gt;,&lt;/c0&gt; operator) that is made of pairs (because of &lt;c1&gt;=&gt;&lt;/c1&gt;), and the result is then assigned to the array variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T111010Z" creationid="Toshiyuki" creationdate="20131027T111010Z">
        <seg>右側の割り当てはリストを生成し、（&lt;c0&gt;,&lt;/c0&gt;演算子によって）それはペアでできています（&lt;c1&gt;=&gt;&lt;/c1&gt;によって）、そして結果は配列変数に割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>... would win against &lt;c0&gt;(::T, T)&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115418Z" creationid="Toshiyuki" creationdate="20140322T115418Z">
        <seg>... は&lt;c0&gt;(::T, T)&lt;/c0&gt;に対して勝ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;?after \w&gt; &lt;!before \w&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134129Z" creationid="Toshiyuki" creationdate="20140322T134129Z">
        <seg>&lt;？after \w&gt; &lt;!before \w&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;?after ^ | \n &gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134457Z" creationid="Toshiyuki" creationdate="20140322T134457Z">
        <seg>&lt;？after ^ | \n &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;link&lt;/a0&gt; lists possible &lt;c1&gt;Pair&lt;/c1&gt; forms and their meanings.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T154658Z" creationid="Toshiyuki" creationdate="20140104T154658Z">
        <seg>&lt;a0&gt;リンク&lt;/a0&gt;は可能な&lt;c1&gt;Pair&lt;/c1&gt;の形式と意味をリストにまとめています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;!=&lt;/c0&gt; is really just a convenience for &lt;c1&gt;!==&lt;/c1&gt;, which in turn is really the &lt;c2&gt;!&lt;/c2&gt; meta operator added to the infix &lt;c3&gt;==&lt;/c3&gt; operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T140517Z" creationid="Toshiyuki" creationdate="20131028T140517Z">
        <seg>&lt;c0&gt;!=&lt;/c0&gt;は本当に&lt;c1&gt;!==&lt;/c1&gt;のための便宜です。それは本当に次々に&lt;c2&gt;!&lt;/c2&gt;メタ演算子を接中辞&lt;c3&gt;==&lt;/c3&gt;演算子に加えたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$&lt;/c0&gt; always means a scalar variable, &lt;c1&gt;@&lt;/c1&gt; an array variable, and &lt;c2&gt;%&lt;/c2&gt; a hash variable, even when subscripting.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022212Z" creationid="Toshiyuki" creationdate="20140329T022212Z">
        <seg>&lt;c0&gt;$&lt;/c0&gt;は常にスカラー変数、&lt;c1&gt;@&lt;/c1&gt;は配列変数、&lt;c2&gt;%&lt;/c2&gt;はハッシュ変数を意味します（たとえ添字付けの場合でも）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$length&lt;/c0&gt; defaults to the rest of the string</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020950Z" creationid="Toshiyuki" creationdate="20140322T020950Z">
        <seg>&lt;c0&gt;$length&lt;/c0&gt;はデフォルトで文字列の残りになります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$o.perl&lt;/c0&gt; returns a string that can be executed as Perl code, and reproduces the original object &lt;c1&gt;$o&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T105129Z" creationid="Toshiyuki" creationdate="20140112T140148Z">
        <seg>&lt;c0&gt;$o.perl&lt;/c0&gt;はPerlコードとして実行可能な文字列を返し、最初のオブジェクト&lt;c1&gt;$o&lt;/c1&gt;を再現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$pairing&lt;/c0&gt; gets the first item of the returned list, and &lt;c1&gt;$result&lt;/c1&gt; the second.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T103547Z" creationid="Toshiyuki" creationdate="20131026T103547Z">
        <seg>&lt;c0&gt;$pairing&lt;/c0&gt;は返されたリストの最初のアイテム、&lt;c1&gt;$result&lt;/c1&gt;は2番目のアイテムを得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$thing++&lt;/c0&gt; is short for &lt;c1&gt;$thing += 1&lt;/c1&gt; or &lt;c2&gt;$thing = $thing + 1&lt;/c2&gt;, with the small exception that the return value of the expression is &lt;c3&gt;$thing&lt;/c3&gt; &lt;e4&gt;before&lt;/e4&gt; the increment, not the incremented value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T142520Z" creationid="Toshiyuki" creationdate="20131026T142520Z">
        <seg>&lt;c0&gt;$thing++&lt;/c0&gt;は&lt;c1&gt;$thing += 1&lt;/c1&gt;または&lt;c2&gt;$thing = $thing + 1&lt;/c2&gt;の短縮形です。小さな例外として、式の戻り値はインクリメントされる&lt;e4&gt;前の&lt;/e4&gt;&lt;c3&gt;$thing&lt;/c3&gt;です。インクリメント後の値ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;'scores'&lt;/c0&gt; is a &lt;e1&gt;string literal&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154353Z" creationid="Toshiyuki" creationdate="20131026T040354Z">
        <seg>&lt;c0&gt;'scores'&lt;/c0&gt;は&lt;e1&gt;文字列リテラル&lt;/e1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;+= $r1&lt;/c0&gt; means &lt;e1&gt;increase the value in the variable on the left by $r1&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T135024Z" creationid="Toshiyuki" creationdate="20131026T135024Z">
        <seg>&lt;c0&gt;+= $r1&lt;/c0&gt;は&lt;e1&gt;$r1によって左の変数の値を増やす&lt;/e1&gt;ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;.+&lt;/c0&gt; greedily calls all methods but dies unless it can call at least one method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T123249Z" creationid="Toshiyuki" creationdate="20140115T141517Z">
        <seg>&lt;c0&gt;.+&lt;/c0&gt;は貪欲にすべてのメソッドを呼びますが、少なくとも1つのメソッドを呼び出せないとdieします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;A&lt;/c0&gt; and &lt;c1&gt;B&lt;/c1&gt; are abstract; how about Integer and Positive Integer?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T225454Z" creationid="Toshiyuki" creationdate="20140113T043713Z">
        <seg>&lt;c0&gt;A&lt;/c0&gt;と&lt;c1&gt;B&lt;/c1&gt;は、抽象的です；IntegerとPositive Integerはどうですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Complex&lt;/c0&gt; numbers have two parts: a real part and an imaginary part.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014703Z" creationid="Toshiyuki" creationdate="20140228T190045Z">
        <seg>&lt;c0&gt;Complex&lt;/c0&gt;数は、2つの部分を持ちます：実数部分と虚数部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Int ~~ Num&lt;/c0&gt; is subject to change, so currently I can't think of a good idea with builtin types - any other idea?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113759Z" creationid="Toshiyuki" creationdate="20140113T044233Z">
        <seg>&lt;c0&gt;Int ~~ Num&lt;/c0&gt;は変更されることがあるので、現在私は組み込まれた型 ― 何の他の考えも ― で良い考えについて考えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Int&lt;/c0&gt; automatically supports promotion to arbitrary precision, as well as holding &lt;c1&gt;Inf&lt;/c1&gt; and &lt;c2&gt;NaN&lt;/c2&gt; values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130411Z" creationid="Toshiyuki" creationdate="20140328T130411Z">
        <seg>&lt;c0&gt;Int&lt;/c0&gt;は&lt;c1&gt;Inf&lt;/c1&gt;値と&lt;c2&gt;NaN&lt;/c2&gt;値だけでなく、随意精度への昇格を自動的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Int&lt;/c0&gt; objects store integer numbers of arbitrary size.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014024Z" creationid="Toshiyuki" creationdate="20140226T143441Z">
        <seg>Intオブジェクトは、任意のサイズの整数を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;MAIN&lt;/c0&gt; routines can also be multis.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T080105Z" creationid="Toshiyuki" creationdate="20140113T080105Z">
        <seg>&lt;c0&gt;MAIN&lt;/c0&gt;ルーチンもマルチになれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Num&lt;/c0&gt; is the floating point type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014055Z" creationid="Toshiyuki" creationdate="20140226T143700Z">
        <seg>&lt;c0&gt;Num&lt;/c0&gt;は、浮動小数点型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Num&lt;/c0&gt; must support the largest native floating point format that runs at full speed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130641Z" creationid="Toshiyuki" creationdate="20140328T130641Z">
        <seg>&lt;c0&gt;Num&lt;/c0&gt;は最大速度で実行できるもっとも大きいネイティブの浮動小数点フォーマットをサポートしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Numeric&lt;/c0&gt; Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130101Z" creationid="Toshiyuki" creationdate="20140328T130101Z">
        <seg>&lt;c0&gt;Numeric&lt;/c0&gt;型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Rat&lt;/c0&gt; supports extended precision rational arithmetic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130731Z" creationid="Toshiyuki" creationdate="20140328T130731Z">
        <seg>&lt;c0&gt;Rat&lt;/c0&gt;は拡張精度有理数演算をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Rat&lt;/c0&gt;, short for &lt;e1&gt;rational&lt;/e1&gt;, stores fractional numbers without loss of precision.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014254Z" creationid="Toshiyuki" creationdate="20140228T185745Z">
        <seg>&lt;c0&gt;Rat&lt;/c0&gt;（&lt;e1&gt;rational&lt;/e1&gt;、有理数の省略）は、精度を損なわずにわずかな数を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;for&lt;/c0&gt; produces a loop that runs the &lt;e1&gt;block&lt;/e1&gt; delimited by curly brackets once for each item of the list, setting the variable &lt;c2&gt;$line&lt;/c2&gt; to the current value of each iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T003758Z" creationid="Toshiyuki" creationdate="20131026T100804Z">
        <seg>&lt;c0&gt;for&lt;/c0&gt;はリストの各項目のために、中括弧によって区切られる&lt;e1&gt;ブロック&lt;/e1&gt;を実行するループを生み出します。そして、変数&lt;c2&gt;$line&lt;/c2&gt;に各々の繰り返しの現在の値をセットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;my Dog $spot&lt;/c0&gt; by itself does not automatically call a &lt;c1&gt;Dog&lt;/c1&gt; constructor.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133640Z" creationid="Toshiyuki" creationdate="20140327T133640Z">
        <seg>&lt;c0&gt;my Dog $spot&lt;/c0&gt;はそれ自体で&lt;c1&gt;Dog&lt;/c1&gt;のコンストラクタを呼びません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;my&lt;/c0&gt; can declare multiple variables simultaneously.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T102351Z" creationid="Toshiyuki" creationdate="20131026T102351Z">
        <seg>&lt;c0&gt;my&lt;/c0&gt;は同時に複数の変数を宣言できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;my&lt;/c0&gt; declares a lexical variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T023751Z" creationid="Toshiyuki" creationdate="20131026T023751Z">
        <seg>&lt;c0&gt;my&lt;/c0&gt;はレキシカル変数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;our&lt;/c0&gt; also makes subroutines visible from the outside of a package or module:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T132844Z" creationid="Toshiyuki" creationdate="20131029T132844Z">
        <seg>&lt;c0&gt;our&lt;/c0&gt;はパッケージかモジュールの外からもサブルーチンを見えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;return&lt;/c0&gt; has the additional effect of immediately exiting the subroutine:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T062912Z" creationid="Toshiyuki" creationdate="20140104T223633Z">
        <seg>加えて、&lt;c0&gt;return&lt;/c0&gt;はサブルーチンを直ちに抜け出すという効果を持っています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;sort&lt;/c0&gt; sorts in ascending order, from smallest to largest.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T151200Z" creationid="Toshiyuki" creationdate="20131026T151200Z">
        <seg>&lt;c0&gt;sort&lt;/c0&gt;は昇順に、最小から最大にソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;split&lt;/c0&gt; decomposes its invocant into a list of strings, so that joining the list items with the separator &lt;c1&gt;' | '&lt;/c1&gt; produces the original string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T103406Z" creationid="Toshiyuki" creationdate="20131026T103406Z">
        <seg>&lt;c0&gt;split&lt;/c0&gt;はそのインボカントを文字列のリストに分解します。したがって、リストのアイテムをセパレーター&lt;c1&gt;' | '&lt;/c1&gt;で連結すると最初の文字列になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;»&lt;/c0&gt; is a &lt;e1&gt;hyper operator&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T000120Z" creationid="Toshiyuki" creationdate="20140309T000120Z">
        <seg>&lt;c0&gt;»&lt;/c0&gt;は&lt;e1&gt;ハイパー演算子&lt;/e1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;ｻ&lt;/c0&gt; is a &lt;e1&gt;hyper operator&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T085528Z" creationid="Toshiyuki" creationdate="20140308T085129Z">
        <seg>&lt;c0&gt;»&lt;/c0&gt;は&lt;e1&gt;ハイパー演算子です&lt;/e1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;�&lt;/c0&gt; is a &lt;e1&gt;hyper operator&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T062827Z" creationid="Toshiyuki" creationdate="20131027T062827Z">
        <seg>&lt;c0&gt;»&lt;/c0&gt;は&lt;e1&gt;ハイパー演算子&lt;/e1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c12&gt;Nil.Stringy&lt;/c12&gt; and &lt;c13&gt;Nil.Str&lt;/c13&gt; throw a resumable warning that returns a value of &lt;c14&gt;''&lt;/c14&gt; on resumption.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140331T113831Z" creationid="Toshiyuki" creationdate="20140331T113831Z">
        <seg>&lt;c12&gt;Nil.Stringy&lt;/c12&gt;と&lt;c13&gt;Nil.Str&lt;/c13&gt;は再開時に&lt;c14&gt;''&lt;/c14&gt;の値を返すレジューム可能な警告をスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c15&gt;Nil.Numeric&lt;/c15&gt; likewise throws a resumable warning that returns 0 on resumption.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140331T130133Z" creationid="Toshiyuki" creationdate="20140331T130133Z">
        <seg>&lt;c15&gt;Nil.Numeric&lt;/c15&gt;は同様に再開時に0を返すレジューム可能な警告をスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;$!&lt;/c1&gt; would then be sugar for &lt;c2&gt;@![0]&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T152257Z" creationid="Toshiyuki" creationdate="20130817T152257Z">
        <seg>&lt;c1&gt;$!&lt;/c1&gt;はその時&lt;c2&gt;@![0]&lt;/c2&gt;のシュガーだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;%sets&lt;/c1&gt; stores the number of sets each player has won.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T155413Z" creationid="Toshiyuki" creationdate="20131026T095159Z">
        <seg>&lt;c1&gt;%sets&lt;/c1&gt;は、各々のプレーヤーが獲得したセットの数を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;&amp;logarithm.signature&lt;/c1&gt; returns the signature associated with the subroutine, and calling &lt;c2&gt;.params&lt;/c2&gt; on the signature returns a list of &lt;c3&gt;Parameter&lt;/c3&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043837Z" creationid="Toshiyuki" creationdate="20140111T074059Z">
        <seg>&lt;c1&gt;&amp;logarithm.signature&lt;/c1&gt;はサブルーチンに結び付けられたシグネチャーを返します。そして&lt;c2&gt;.params&lt;/c2&gt;をシグネチャーで呼び出すと&lt;c3&gt;Parameter&lt;/c3&gt;オブジェクトのリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;.?&lt;/c1&gt;, tries to call one method, but returns a &lt;c2&gt;Failure&lt;/c2&gt; rather then throwing an exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T033352Z" creationid="Toshiyuki" creationdate="20140115T141521Z">
        <seg>&lt;c1&gt;.?&lt;/c1&gt;は1つのメソッドを呼ぼうとしますが、例外をスローするよりも&lt;c2&gt;Failure&lt;/c2&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;IRCBot&lt;/c1&gt; does the latter; it &lt;c2&gt;IRCBot&lt;/c2&gt; defines an attribute &lt;c3&gt;$!bot-nick&lt;/c3&gt; along with an accessor method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T123411Z" creationid="Toshiyuki" creationdate="20140115T141843Z">
        <seg>&lt;c1&gt;IRCBot&lt;/c1&gt;は後者をします；それは、アクセサメソッドとともに属性&lt;c3&gt;$!bot-nick&lt;/c3&gt;を&lt;c2&gt;IRCBot&lt;/c2&gt;に定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;Nil.defined&lt;/c1&gt; returns &lt;c2&gt;False&lt;/c2&gt; (whereas &lt;c3&gt;().defined&lt;/c3&gt; returns &lt;c4&gt;True&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140331T113615Z" creationid="Toshiyuki" creationdate="20140331T113615Z">
        <seg>&lt;c1&gt;Nil.defined&lt;/c1&gt;は&lt;c2&gt;False&lt;/c2&gt;を返します（対して&lt;c3&gt;().defined&lt;/c3&gt;は&lt;c4&gt;True&lt;/c4&gt;を返します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;m/ \w+: 'en'/&lt;/c1&gt; can never match any string, because the &lt;c2&gt;\w+&lt;/c2&gt; always eats up all word characters and never releases them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T050620Z" creationid="Toshiyuki" creationdate="20140222T022449Z">
        <seg>&lt;c2&gt;\w+&lt;/c2&gt;は常にすべてのワード文字を食い尽くして、それらを決してリリースしないので、&lt;c1&gt;m/ \w+: 'en'/&lt;/c1&gt;は何の文字列にも決してマッチすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;to-json&lt;/c1&gt; has many &lt;e2&gt;candidates&lt;/e2&gt;; these subs all have the name &lt;c3&gt;to-json&lt;/c3&gt; but differ in their signatures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112507Z" creationid="Toshiyuki" creationdate="20140112T183431Z">
        <seg>&lt;c1&gt;to-json&lt;/c1&gt;は多くの&lt;e2&gt;候補&lt;/e2&gt;を持ちます；これらのsubsは全て&lt;c3&gt;to-json&lt;/c3&gt;という名前を持ちますが、シグネチャーは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;$!&lt;/c2&gt; is a convenient link to the last failure, and only ever contains one exception, the most recent.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T151646Z" creationid="Toshiyuki" creationdate="20130817T151646Z">
        <seg>&lt;c2&gt;$!&lt;/c2&gt;は最後の失敗への便利なリンクで、一つだけの最も最近の例外を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;[max] 1, 5, 3, 7&lt;/c2&gt; is the same as &lt;c3&gt;1 max 5 max 3 max 7&lt;/c3&gt; and evaluates to &lt;c4&gt;7&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T061823Z" creationid="Toshiyuki" creationdate="20131027T061823Z">
        <seg>&lt;c2&gt;[max] 1, 5, 3, 7&lt;/c2&gt;は&lt;c3&gt;1 max 5 max 3 max 7&lt;/c3&gt;と同じで、&lt;c4&gt;7&lt;/c4&gt;と評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;m/ ^a /&lt;/c2&gt; matches strings beginning with an &lt;c3&gt;a&lt;/c3&gt;, and &lt;c4&gt;m/ ^ a $ /&lt;/c4&gt; matches strings that consist only of an &lt;c5&gt;a&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232410Z" creationid="Toshiyuki" creationdate="20140221T232410Z">
        <seg>&lt;c2&gt;m/ ^a /&lt;/c2&gt;は&lt;c3&gt;a&lt;/c3&gt;で始まる文字列にマッチし、&lt;c4&gt;m/ ^ a $ /&lt;/c4&gt;は &lt;c5&gt;a&lt;/c5&gt;だけから成る文字列にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c3&gt;$/.values&lt;/c3&gt; returns a list of all captures, here either the &lt;c4&gt;object&lt;/c4&gt; or the &lt;c5&gt;array&lt;/c5&gt; capture.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T002305Z" creationid="Toshiyuki" creationdate="20140224T162957Z">
        <seg>&lt;c3&gt;$/.values&lt;/c3&gt;はすべてのキャプチャーのリストを返します。ここでは、&lt;c4&gt;object&lt;/c4&gt;か&lt;c5&gt;array&lt;/c5&gt;のキャプチャーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c3&gt;$0&lt;/c3&gt;, &lt;c4&gt;$1&lt;/c4&gt;, &lt;c5&gt;$2&lt;/c5&gt;, etc., are aliases into the &lt;c6&gt;$/&lt;/c6&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090731Z" creationid="Toshiyuki" creationdate="20140329T090731Z">
        <seg>&lt;c3&gt;$0&lt;/c3&gt;、&lt;c4&gt;$1&lt;/c4&gt;、&lt;c5&gt;$2&lt;/c5&gt;などは&lt;c6&gt;$/&lt;/c6&gt;オブジェクトの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c3&gt;$file.lines&lt;/c3&gt; produces a list of the lines read from the file &lt;e4&gt;scores&lt;/e4&gt;, starting with the line where the previous calls to &lt;c5&gt;$file.get&lt;/c5&gt; left off, and going all the way to the end of the file.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T160226Z" creationid="Toshiyuki" creationdate="20131026T102103Z">
        <seg>&lt;c3&gt;$file.lines&lt;/c3&gt;はファイル&lt;e4&gt;scores&lt;/e4&gt;から読み込まれる行のリストを生成します。前の&lt;c5&gt;$file.get&lt;/c5&gt;の呼び出しで読み込んだ行は捨てられ、ファイルの終わりまでいきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;!=&lt;/c4&gt; returns &lt;c5&gt;True&lt;/c5&gt; if the two objects differ in their numerical value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T124742Z" creationid="Toshiyuki" creationdate="20131028T124742Z">
        <seg>&lt;c4&gt;!=&lt;/c4&gt;は、もし2つのオブジェクトが数値で異なるなら&lt;c5&gt;True&lt;/c5&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;"hello" === "hello"&lt;/c4&gt; is true because both strings are immutable and have the same value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T125701Z" creationid="Toshiyuki" creationdate="20131027T125701Z">
        <seg>&lt;c4&gt;"hello" === "hello"&lt;/c4&gt;は真です。なぜなら両方の文字列は不変で同じ値を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;.value&lt;/c4&gt; returns the value of the current pair, &lt;c5&gt;($unit * .value)&lt;/c5&gt; multiplies that values with &lt;c6&gt;$unit&lt;/c6&gt;, and &lt;c7&gt;'X' x ($unit * .value)&lt;/c7&gt; returns as that many &lt;c8&gt;X&lt;/c8&gt; characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T033457Z" creationid="Toshiyuki" creationdate="20131027T103608Z">
        <seg>&lt;c4&gt;.value&lt;/c4&gt;は現在のペアの値を返します。&lt;c5&gt;($unit * .value)&lt;/c5&gt;は値と&lt;c6&gt;$unit&lt;/c6&gt;の積、そして&lt;c7&gt;'X' x ($unit * .value)&lt;/c7&gt;はたくさんの&lt;c8&gt;X&lt;/c8&gt;文字を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;@scores».key&lt;/c4&gt; is a list of all the keys of the pair objects in &lt;c5&gt;@scores&lt;/c5&gt;, and &lt;c6&gt;@scores».key».chars&lt;/c6&gt; is a list of the length of all keys in &lt;c7&gt;@scores&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T124637Z" creationid="Toshiyuki" creationdate="20140313T124637Z">
        <seg>&lt;c4&gt;@scores».key&lt;/c4&gt;は&lt;c5&gt;@scores&lt;/c5&gt;の中のペアオブジェクトのすべてのキーのリスト、そして&lt;c6&gt;@scores».key».chars&lt;/c6&gt;は&lt;c7&gt;@scores&lt;/c7&gt;の中の全てのキーの長さのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;@scoresｻ.key&lt;/c4&gt; is a list of all the keys of the pair objects in &lt;c5&gt;@scores&lt;/c5&gt;, and &lt;c6&gt;@scoresｻ.keyｻ.chars&lt;/c6&gt; is a list of the length of all keys in &lt;c7&gt;@scores&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T085819Z" creationid="Toshiyuki" creationdate="20140308T085819Z">
        <seg>&lt;c4&gt;@scores».key&lt;/c4&gt;は&lt;c5&gt;@scores&lt;/c5&gt;内の全てのペアオブジェクトのキーのリストです。そして&lt;c6&gt;@scores».key».chars&lt;/c6&gt;は&lt;c7&gt;@scores&lt;/c7&gt;内のキーの長さのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;@scores�.key&lt;/c4&gt; is a list of all the keys of the pair objects in &lt;c5&gt;@scores&lt;/c5&gt;, and &lt;c6&gt;@scores�.key�.chars&lt;/c6&gt; is a list of the length of all keys in &lt;c7&gt;@scores&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T063449Z" creationid="Toshiyuki" creationdate="20131027T063449Z">
        <seg>&lt;c4&gt;@scores».key&lt;/c4&gt;は&lt;c5&gt;@scores&lt;/c5&gt;の中のペアオブジェクトのすべてのキーのリスト、そして&lt;c6&gt;@scores».key».chars&lt;/c6&gt;は&lt;c7&gt;@scores&lt;/c7&gt;の中の全てのキーの長さのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;dup&lt;/c4&gt; also has a subrule called &lt;c5&gt;word&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T041306Z" creationid="Toshiyuki" creationdate="20140222T015745Z">
        <seg>&lt;c4&gt;dup&lt;/c4&gt;は&lt;c5&gt;word&lt;/c5&gt;と呼ばれるサブルールも持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;words&lt;/c4&gt; is also a method, called on the string returned from &lt;c5&gt;get&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T073746Z" creationid="Toshiyuki" creationdate="20131026T073746Z">
        <seg>&lt;c4&gt;words&lt;/c4&gt;もメソッドです。&lt;c5&gt;get&lt;/c5&gt;から返される文字列に対して呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c5&gt;Nil.so&lt;/c5&gt; also returns &lt;c6&gt;False&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140331T113625Z" creationid="Toshiyuki" creationdate="20140331T113625Z">
        <seg>&lt;c5&gt;Nil.so&lt;/c5&gt;も&lt;c6&gt;False&lt;/c6&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c5&gt;Nil&lt;/c5&gt; also indicates a failed match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132843Z" creationid="Toshiyuki" creationdate="20140327T132843Z">
        <seg>&lt;c5&gt;Nil&lt;/c5&gt;は失敗したマッチも示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c5&gt;\w+&lt;/c5&gt; gives up one character to match &lt;c6&gt;oxe&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130839Z" creationid="Toshiyuki" creationdate="20140222T021748Z">
        <seg>&lt;c5&gt;\w+&lt;/c5&gt;は1つの文字をマッチ&lt;c6&gt;oxe&lt;/c6&gt;にゆずります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c5&gt;decode&lt;/c5&gt; goes the other direction.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020622Z" creationid="Toshiyuki" creationdate="20140301T050157Z">
        <seg>&lt;c5&gt;decode&lt;/c5&gt;は他の命令に行きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c6&gt;words&lt;/c6&gt; decomposes its &lt;e7&gt;invocant&lt;/e7&gt;--the string on which it operates--into a list of words, which here means strings without whitespace.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T074229Z" creationid="Toshiyuki" creationdate="20131026T073911Z">
        <seg>&lt;c6&gt;words&lt;/c6&gt;はその&lt;e7&gt;インボカント&lt;/e7&gt;を分解し、文字列を空白を含まない単語のリストにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c7&gt;Nil.ACCEPTS&lt;/c7&gt; always returns &lt;c8&gt;Nil&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140331T113637Z" creationid="Toshiyuki" creationdate="20140331T113637Z">
        <seg>&lt;c7&gt;Nil.ACCEPTS&lt;/c7&gt;は常に&lt;c8&gt;Nil&lt;/c8&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c7&gt;en&lt;/c7&gt; still can't match, so the &lt;c8&gt;\w+&lt;/c8&gt; group again gives up one character and now matches &lt;c9&gt;ox&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T045526Z" creationid="Toshiyuki" creationdate="20140222T021830Z">
        <seg>&lt;c7&gt;en&lt;/c7&gt;はまだマッチすることができないので、&lt;c8&gt;\w+&lt;/c8&gt;グループは再び1つの文字をあきらめて、現在&lt;c9&gt;ox&lt;/c9&gt;にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c9&gt;Nil.perl&lt;/c9&gt; and &lt;c10&gt;Nil.gist&lt;/c10&gt; return &lt;c11&gt;'Nil'&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140331T113649Z" creationid="Toshiyuki" creationdate="20140331T113649Z">
        <seg>&lt;c9&gt;Nil.perl&lt;/c9&gt;と&lt;c10&gt;Nil.gist&lt;/c10&gt;は&lt;c11&gt;'Nil'&lt;/c11&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Precedence rules&lt;/e0&gt; govern how a parser will parse this line.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T112713Z" creationid="Toshiyuki" creationdate="20131027T112713Z">
        <seg>&lt;e0&gt;優先順位規則&lt;/e0&gt;はパーサーがこの行を解析する方法を制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;1.&lt;/s0&gt; The input format of the example program is redundant: the first line containing the name of all players is not necessary, because you can find out which players participated in the tournament by looking at their names in the subsequent rows.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T165758Z" creationid="Toshiyuki" creationdate="20131026T165359Z">
        <seg>&lt;s0&gt;1.&lt;/s0&gt; プログラム例の入力フォーマットは冗長です：後の列で彼らの名前を見ることによってどのプレイヤーがトーナメントに参加したのか知ることができるので、全てのプレイヤーの名前を含む最初の行は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;1.&lt;/s0&gt; The method &lt;c1&gt;add-dependency&lt;/c1&gt; in &lt;c2&gt;Task&lt;/c2&gt; permits the creation of &lt;e3&gt;cycles&lt;/e3&gt; in the dependency graph.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T152613Z" creationid="Toshiyuki" creationdate="20140112T172507Z">
        <seg>&lt;s0&gt;1.&lt;/s0&gt;&lt;c2&gt;Task&lt;/c2&gt;のメソッド&lt;c1&gt;add-dependency&lt;/c1&gt;は従属グラフの中で&lt;e3&gt;循環&lt;/e3&gt;を許します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;2.&lt;/s0&gt; Instead of removing the redundancy, you can also use it to warn if a player appears that wasn't mentioned in the first line, for example due to a typo.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T170627Z" creationid="Toshiyuki" creationdate="20131026T170627Z">
        <seg>&lt;s0&gt;2.&lt;/s0&gt; 冗長性を取り除く代わりに、最初の行で言及されなかったプレーヤーが現れた場合に、それを警告するために（たとえばtypoのため）使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;2.&lt;/s0&gt; Is there a way to detect the presence of a cycle during the course of a &lt;c1&gt;perform&lt;/c1&gt; call?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110915Z" creationid="Toshiyuki" creationdate="20140112T174244Z">
        <seg>&lt;s0&gt;2.&lt;/s0&gt; &lt;c1&gt;perform&lt;/c1&gt;呼び出し中に循環の存在を見つける方法がありますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;3.&lt;/s0&gt; How could &lt;c1&gt;Task&lt;/c1&gt; objects execute their dependencies in parallel?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T111834Z" creationid="Toshiyuki" creationdate="20140112T180719Z">
        <seg>&lt;s0&gt;3.&lt;/s0&gt;&lt;c1&gt;Task&lt;/c1&gt;オブジェクトはどのように並列に彼らの従属物を実行することができますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;Answer:&lt;/s0&gt; Enabling parallelism is easy; change the line &lt;c1&gt;.perform() for @!dependencies;&lt;/c1&gt; into &lt;c2&gt;@!dependencies».perform()&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T213500Z" creationid="Toshiyuki" creationdate="20140314T213500Z">
        <seg>&lt;s0&gt;答え：&lt;/s0&gt;並列化を有効にするのは簡単です；&lt;c1&gt;.perform() for @!dependencies;&lt;/c1&gt;の行を&lt;c2&gt;@!dependencies».perform()&lt;/c2&gt;に変えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;Answer:&lt;/s0&gt; Introduce another hash with the names of the legitimate players as keys, and look in this hash when the name of a player is read:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T041820Z" creationid="Toshiyuki" creationdate="20131027T041820Z">
        <seg>&lt;s0&gt;答え：&lt;/s0&gt;プレイヤーの名前が読み込まれるとき、キーとして正当なプレイヤーの名前で別のハッシュを導入して、このハッシュを見てください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;Answer:&lt;/s0&gt; Remove the line &lt;c1&gt;my @names = $file.get.words;&lt;/c1&gt;, and change:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T170034Z" creationid="Toshiyuki" creationdate="20131026T170034Z">
        <seg>&lt;s0&gt;答え：&lt;/s0&gt;&lt;c1&gt;my @names = $file.get.words;&lt;/c1&gt;の行を取除き、次のように変えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;Answer:&lt;/s0&gt; To detect the presence of a cycle during a &lt;c1&gt;perform&lt;/c1&gt; call, keep track of which &lt;c2&gt;Task&lt;/c2&gt;s have started; prevent a &lt;c3&gt;Task&lt;/c3&gt; from starting twice before finishing:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T152747Z" creationid="Toshiyuki" creationdate="20140112T174950Z">
        <seg>&lt;s0&gt;答え：&lt;/s0&gt;&lt;c1&gt;perform&lt;/c1&gt;呼び出しの間、循環の存在を見つけるために、&lt;c2&gt;Task&lt;/c2&gt;が始まったトラックを保ってください；&lt;c3&gt;Task&lt;/c3&gt;が以下を終える前に二回始まるのを防いでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;Answer:&lt;/s0&gt; You can create two tasks, and then "short-circuit" them with &lt;c1&gt;add-dependency&lt;/c1&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T173604Z" creationid="Toshiyuki" creationdate="20140112T173604Z">
        <seg>&lt;s0&gt;答え：&lt;/s0&gt;あなたは2つのタスクを作ることができ、そして&lt;c1&gt;add-dependency&lt;/c1&gt;によって「短縮させます」：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;CATCH&lt;/c0&gt; block handles only "bad" exceptions, and lets control exceptions pass unhindered.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125424Z" creationid="Toshiyuki" creationdate="20130816T125424Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロックは「悪い」例外だけ扱う。そして制御例外を妨げられないようにパスさせる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;CATCH&lt;/c0&gt; block is just a trait of the closure containing it, and is automatically called at the appropriate moment.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T075013Z" creationid="Toshiyuki" creationdate="20130818T075013Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロックはそれを含むクロージャのただのトレイトだ。そして適切な時に自動的に呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;CATCH&lt;/c0&gt; block sees the lexical scope in which it was defined, but its caller is the dynamic location that threw the exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115433Z" creationid="Toshiyuki" creationdate="20130814T115433Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロックはそれが定義されたレキシカルスコープをみる。しかしその呼び出し元は例外を投げたダイナミックロケーションだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;Str&lt;/c0&gt; is a Unicode string object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T131121Z" creationid="Toshiyuki" creationdate="20140328T131121Z">
        <seg>&lt;c0&gt;Str&lt;/c0&gt;はユニコード文字列オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;gather&lt;/c0&gt; is not considered a loop, but it is easy to combine with a loop statement as in the examples above.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T040719Z" creationid="Toshiyuki" creationdate="20130811T040719Z">
        <seg>&lt;c0&gt;gather&lt;/c0&gt;はループと見なされないが、上述した例におけるループ文に結合するのは簡単だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;return&lt;/c0&gt; always exits from the lexically surrounding sub or method definition (that is, from a function officially declared with the &lt;c1&gt;sub&lt;/c1&gt;, &lt;c2&gt;method&lt;/c2&gt;, or &lt;c3&gt;submethod&lt;/c3&gt; keywords).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T044152Z" creationid="Toshiyuki" creationdate="20130817T044152Z">
        <seg>&lt;c0&gt;return&lt;/c0&gt;は常にレキシカルに囲っているsubまたはメソッドの定義から抜け出る（すなわち、&lt;c1&gt;sub&lt;/c1&gt;、&lt;c2&gt;method&lt;/c2&gt;、または&lt;c3&gt;submethod&lt;/c3&gt;キーワードで正式に定義されている機能から）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;return&lt;/c0&gt;, for example, is considered a form of abnormal control flow, since it can jump out of multiple levels of closures to the end of the scope of the current subroutine definition.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T124607Z" creationid="Toshiyuki" creationdate="20130816T124306Z">
        <seg>例えば&lt;c0&gt;return&lt;/c0&gt;はアブノーマルな制御フローの形式と見なされる。だからそれは多数のレベルのクロージャから現在のサブルーチンの定義のスコープの終端までジャンプできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c2&gt;Hash&lt;/c2&gt; is an unordered collection of key-value pairs.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T155004Z" creationid="Toshiyuki" creationdate="20131026T093717Z">
        <seg>&lt;c2&gt;Hash&lt;/c2&gt;はキーと値のペアの無順序のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c3&gt;do&lt;/c3&gt; is unnecessary immediately after any opening bracket as the syntax inside brackets is a semicolon-separated list of statements, so the above can in fact be written:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T125042Z" creationid="Toshiyuki" creationdate="20130810T125042Z">
        <seg>&lt;c3&gt;do&lt;/c3&gt;はブラケット内のセミコロンで分けられたリスト文の文法として開始ブラケットの後に直ちには必要ない。なので上述したものは実際は書き直すことができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c3&gt;once&lt;/c3&gt; runs separately for each clone, so separate clones can keep separate state variables:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030938Z" creationid="Toshiyuki" creationdate="20130822T030712Z">
        <seg>&lt;c3&gt;once&lt;/c3&gt;はそれぞれの複製で別々に実行するので、別々の複製は異なるstate変数を保持できる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c7&gt;token&lt;/c7&gt; declares a regex that does not backtrack by default, so that when a partial pattern match fails, the regex engine will not go back up and try another alternative (this is equivalent to using the &lt;c8&gt;:ratchet&lt;/c8&gt; modifier).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134937Z" creationid="Toshiyuki" creationdate="20140222T131101Z">
        <seg>&lt;c7&gt;token&lt;/c7&gt;はデフォルトでバックトラックしない正規表現を宣言します。そのため、部分マッチが失敗するとき、正規表現エンジンは上に戻らないで別の選択肢を試します（これは&lt;c8&gt;:ratchet&lt;/c8&gt;修飾子を使用することと同等です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c7&gt;when&lt;/c7&gt; statement implicitly does a "smart match" between the current topic (&lt;c8&gt;$_&lt;/c8&gt;) and the argument of the &lt;c9&gt;when&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T130150Z" creationid="Toshiyuki" creationdate="20130811T130150Z">
        <seg>&lt;c7&gt;when&lt;/c7&gt;文は現在のトピック（&lt;c8&gt;$_&lt;/c8&gt;）と&lt;c9&gt;when&lt;/c9&gt;の引数の間で暗黙に「スマートマッチ」を行う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c9&gt;rule&lt;/c9&gt; will also not backtrack by default, additionally, sequences of whitespace are deemed significant and will match actual whitespace within the string using the built-in &lt;c10&gt;&lt;ws&gt;&lt;/c10&gt; rule (this is equivalent to using the &lt;c11&gt;:sigspace&lt;/c11&gt; modifier).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T140213Z" creationid="Toshiyuki" creationdate="20140222T131340Z">
        <seg>&lt;c9&gt;rule&lt;/c9&gt;もデフォルトでバックトラックしません。さらに、空白文字のシーケンスは重要であるとみなして、ビルトイン&lt;c10&gt;&lt;ws&gt;&lt;/c10&gt;ルール（これは&lt;c11&gt;:sigspace&lt;/c11&gt;修飾子を使用することと同等です）を用いた文字列の中で実際の空白文字にマッチするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;quantifier&lt;/e0&gt; specifies how often something has to occur.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T030032Z" creationid="Toshiyuki" creationdate="20140117T183309Z">
        <seg>&lt;e0&gt;数量詞&lt;/e0&gt;は、何かがどれくらい起こらなければならないかについて指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;role&lt;/e0&gt; is a standalone, named, and reusable unit of behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121901Z" creationid="Toshiyuki" creationdate="20140113T080215Z">
        <seg>&lt;e0&gt;role&lt;/e0&gt;はスタンドアロンで、名前をつけられて、再使用できる振る舞いの単位です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;statement&lt;/e0&gt; ends with a semicolon or a curly bracket at the end of a line:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T024724Z" creationid="Toshiyuki" creationdate="20131026T020740Z">
        <seg>&lt;e0&gt;ステートメント&lt;/e0&gt;は行末のセミコロン、またはカーリーブラケットで終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;subroutine&lt;/e0&gt; is a piece of code that performs a specific task.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T130733Z" creationid="Toshiyuki" creationdate="20131029T130733Z">
        <seg>&lt;e0&gt;サブルーチン&lt;/e0&gt;は特定の仕事をこなすコードの断片です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;i0&gt;name&lt;/i0&gt; is anything that is a legal part of a variable name (not counting the sigil).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T093723Z" creationid="Toshiyuki" creationdate="20140329T093723Z">
        <seg>&lt;i0&gt;名前&lt;/i0&gt;は変数名（シギルは数えない）の有効な部分なら何でもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;i0&gt;statement&lt;/i0&gt; ends with a semicolon or a curly bracket at the end of a line:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140306T125914Z" creationid="Toshiyuki" creationdate="20140306T125914Z">
        <seg>ステートメントは、行の終わりにセミコロンまたはカーリーブラケットで終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Boolean value is either &lt;c0&gt;True&lt;/c0&gt; or &lt;c1&gt;False&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021153Z" creationid="Toshiyuki" creationdate="20140322T021153Z">
        <seg>真偽値は&lt;c0&gt;True&lt;/c0&gt;か&lt;c1&gt;False&lt;/c1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Pair stores a key and a value; the key is on the left-hand side of the &lt;c3&gt;=&gt;&lt;/c3&gt; operator, the value on the right.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T045812Z" creationid="Toshiyuki" creationdate="20131027T045812Z">
        <seg>Pairはキーと値を保存します；キーは&lt;c3&gt;=&gt;&lt;/c3&gt;演算子の左側にあり、値は右側です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Perl 6 program consists of zero or more statements.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T153711Z" creationid="Toshiyuki" creationdate="20131026T020137Z">
        <seg>Perl 6プログラムは1つ以上のステートメントから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Perl 6 version might be:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T073349Z" creationid="Toshiyuki" creationdate="20140113T073349Z">
        <seg>Perl 6バージョンはこうなるはずです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Word on Precedence</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T110613Z" creationid="Toshiyuki" creationdate="20131027T105235Z">
        <seg>優先順位のワード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bare &lt;c0&gt;die&lt;/c0&gt;/&lt;c1&gt;fail&lt;/c1&gt; takes &lt;c2&gt;$!&lt;/c2&gt; as the default argument specifying the exception to be thrown or propagated outward to the caller's &lt;c3&gt;$!&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T165331Z" creationid="Toshiyuki" creationdate="20130817T165331Z">
        <seg>裸の&lt;c0&gt;die&lt;/c0&gt;/&lt;c1&gt;fail&lt;/c1&gt;はスローされるか外側に伝搬される呼び出し元の&lt;c3&gt;$!&lt;/c3&gt;を明示する&lt;c2&gt;$!&lt;/c2&gt;をデフォルトの引数としてとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bare closure (except the block associated with a conditional statement) without placeholder arguments that uses &lt;c0&gt;$_&lt;/c0&gt; (either explicitly or implicitly) is treated as though &lt;c1&gt;$_&lt;/c1&gt; were a formal parameter:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T125517Z" creationid="Toshiyuki" creationdate="20130729T125517Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;（明示的か暗黙的かどちらか）を使うプレースホルダー引数無しの裸のクロージャ（条件付きの文に関連付けられているブロックは除く）は&lt;c1&gt;$_&lt;/c1&gt;が仮パラメータかのように扱われる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A block is a self-contained piece of Perl 6 code with an optional signature (the &lt;c3&gt;-&gt; $line&lt;/c3&gt; part).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T144534Z" creationid="Toshiyuki" creationdate="20131026T144534Z">
        <seg>ブロックはオプションのシグネチャ（&lt;c3&gt;-&gt; $line&lt;/c3&gt;の部分）を伴う独立したPerl 6コードの断片です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A block is any part of the code enclosed between curly braces { }.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T153758Z" creationid="Toshiyuki" creationdate="20131026T031805Z">
        <seg>ブロックとはブレース{ }で囲まれたあらゆる部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call like &lt;c4&gt;to-json(2)&lt;/c4&gt; has &lt;e5&gt;two&lt;/e5&gt; matching candidates--&lt;c6&gt;Int&lt;/c6&gt; and &lt;c7&gt;Any&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T225428Z" creationid="Toshiyuki" creationdate="20140113T043627Z">
        <seg>&lt;c4&gt;to-json(2)&lt;/c4&gt;のような呼び出しは、マッチする&lt;e5&gt;2つ&lt;/e5&gt;の候補 ― &lt;c6&gt;Int&lt;/c6&gt;と&lt;c7&gt;Any&lt;/c7&gt; ― を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call may also be partially applied (primed) by using the &lt;c1&gt;.assuming&lt;/c1&gt; method:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T083749Z" creationid="Toshiyuki" creationdate="20140329T083749Z">
        <seg>呼び出しは&lt;c1&gt;.assuming&lt;/c1&gt;メソッドを用いて部分的に適用される（満たされる）こともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call such as &lt;c0&gt;to-json(Bool::True)&lt;/c0&gt; invokes the first candidate.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T183702Z" creationid="Toshiyuki" creationdate="20140112T183702Z">
        <seg>&lt;c0&gt;to-json(Bool::True)&lt;/c0&gt;のような呼び出しは最初の候補を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A capture preserves the two array arguments, so that the final callee's signature may determine how to bind them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T042006Z" creationid="Toshiyuki" creationdate="20140110T162829Z">
        <seg>キャプチャーは2つの配列引数を保存します、そのため、最終的な呼び出し先のシグネチャーはそれらを結びつける方法を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class is a module and thus can export stuff, but a class adds even more behavior to support Perl 6's standard class-based OO.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131700Z" creationid="Toshiyuki" creationdate="20140329T131700Z">
        <seg>クラスはモジュールなのでものをエクスポートすることができます。しかしPerl 6の標準のクラスベースのOOをサポートするためにより多くの動作をクラスは追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class is a module declared with the &lt;c0&gt;class&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131120Z" creationid="Toshiyuki" creationdate="20140329T131120Z">
        <seg>クラスは&lt;c0&gt;class&lt;/c0&gt;キーワードで宣言されるモジュールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure returning the default value</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044326Z" creationid="Toshiyuki" creationdate="20140322T044326Z">
        <seg>デフォルト値を返すクロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A colon &lt;c0&gt;:&lt;/c0&gt; switches off backtracking for the previous quantifier or alternation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T050319Z" creationid="Toshiyuki" creationdate="20140222T022441Z">
        <seg>コロン&lt;c0&gt;:&lt;/c0&gt;は、前の数量詞または論理和のためにバックトラックのスイッチを切ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A common writing error is to duplicate a word by accident.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T021924Z" creationid="Toshiyuki" creationdate="20140115T143435Z">
        <seg>一般の文書エラーは、偶然にワードが重複することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constructor is anything that returns an instance of the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T140821Z" creationid="Toshiyuki" creationdate="20140111T193158Z">
        <seg>コンストラクタは、クラスのインスタンスを返すものなら何でもそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A grammar contains various named regex.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134736Z" creationid="Toshiyuki" creationdate="20140222T095110Z">
        <seg>グラマーは様々な名前の正規表現を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A leading exclamation mark negates the meaning, such that the lookahead must &lt;e0&gt;not&lt;/e0&gt; find the regex fragment.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T084242Z" creationid="Toshiyuki" creationdate="20140222T024330Z">
        <seg>先読みが正規表現の断片を見つけてはならないように、先行するエクスクラメーションマークは意味を否定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A line ending with a closing brace "&lt;c0&gt;}&lt;/c0&gt;", followed by nothing but whitespace or comments, will terminate a statement if an end of statement can occur there.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T031036Z" creationid="Toshiyuki" creationdate="20130803T031036Z">
        <seg>閉じ括弧&lt;c0&gt;}&lt;/c0&gt;で終わり、次に何も続かない行末（空白文字とコメントは除く）は文の終了を発生させることができるなら文を終了する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A list of zero or more comma-separated objects may be grouped together by parentheses into a "parenthesis cell", or &lt;c0&gt;Parcel&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073616Z" creationid="Toshiyuki" creationdate="20140329T073616Z">
        <seg>0以上のコンマで区切られたオブジェクトは括弧によって“括弧セル”または&lt;c0&gt;Parcel&lt;/c0&gt;にグループ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A named argument of the form &lt;c0&gt;:name&lt;/c0&gt; with no value has an implicit value of &lt;c1&gt;Bool::True&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T154419Z" creationid="Toshiyuki" creationdate="20140104T154419Z">
        <seg>値のない名前付き引数の&lt;c0&gt;:name&lt;/c0&gt;という形式は暗黙に&lt;c1&gt;Bool::True&lt;/c1&gt;を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nested signature to bind the argument against</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044352Z" creationid="Toshiyuki" creationdate="20140322T044352Z">
        <seg>引数をバインドするネストしたシグネチャー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nominal type is an actual class or role, as opposed to additional constraints in the form of code blocks.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T223924Z" creationid="Toshiyuki" creationdate="20140112T222750Z">
        <seg>コードブロック形式の更なる制約とは対照的に、名目の型は、実際のクラスまたはロールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pair consists of a string key and a value, so the action method constructs a Perl 6 pair with the &lt;c0&gt;=&gt;&lt;/c0&gt; operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T012203Z" creationid="Toshiyuki" creationdate="20140226T142132Z">
        <seg>ペアは文字列キーと値から成るので、アクションメソッドは&lt;c0&gt;=&gt;&lt;/c0&gt;演算子でPerl 6ペアを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A possible candidate:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T063348Z" creationid="Toshiyuki" creationdate="20140113T063348Z">
        <seg>可能な候補：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A question mark &lt;c1&gt;?&lt;/c1&gt; makes the preceding unit (be it a letter, a character class, or something more complicated) optional, meaning it can either be present either zero or one times.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T030443Z" creationid="Toshiyuki" creationdate="20140117T183415Z">
        <seg>疑問符&lt;c1&gt;?&lt;/c1&gt;はすぐ前の単位（文字、文字クラスまたはより複雑な何か）を任意にさせます。0または1回存在することができるという意味です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A regex on the right hand side of the &lt;c1&gt;~~&lt;/c1&gt; smart match operator applies against the string on the left hand side.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T022558Z" creationid="Toshiyuki" creationdate="20140115T143637Z">
        <seg>&lt;c1&gt;~~&lt;/c1&gt;スマートマッチ演算子の右側の正規表現は、左側の文字列に対して適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role contains the methods and attributes required to provide a named, reusable unit of behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T012231Z" creationid="Toshiyuki" creationdate="20140115T101703Z">
        <seg>ロールは、名前付きの再利用可能な振る舞いの単位の提供を必要とされるメソッドと属性を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role is another type of package.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122022Z" creationid="Toshiyuki" creationdate="20140113T105638Z">
        <seg>ロールはパッケージの別の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A routine can choose to delegate its work to other candidates in that list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121103Z" creationid="Toshiyuki" creationdate="20140113T075657Z">
        <seg>ルーチンはそのリストでその作業を他の候補に委任するほうを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar can even contain a compound object like an &lt;c3&gt;Array&lt;/c3&gt; or a &lt;c4&gt;Hash&lt;/c4&gt;; the &lt;c5&gt;$&lt;/c5&gt; sigil signifies that it should be treated as a single value, even in a context that expects multiple values (as with an &lt;c6&gt;Array&lt;/c6&gt; or &lt;c7&gt;Hash&lt;/c7&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T025427Z" creationid="Toshiyuki" creationdate="20131026T100048Z">
        <seg>スカラーは&lt;c3&gt;Array&lt;/c3&gt;または&lt;c4&gt;Hash&lt;/c4&gt;のような複合オブジェクトさえ含むことができます；複数の値（&lt;c6&gt;Array&lt;/c6&gt;または&lt;c7&gt;Hash&lt;/c7&gt;と同様に）を期待するコンテキストでも、&lt;c5&gt;$&lt;/c5&gt;シギルはそれが1つの値とみなされるべきことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A scalar uses the &lt;c0&gt;$&lt;/c0&gt; sigil and implies no constraints.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131221T003806Z" creationid="Toshiyuki" creationdate="20131221T003806Z">
        <seg>&lt;c0&gt;$&lt;/c0&gt;シギルを使うスカラーは制約がないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A signature object (&lt;c0&gt;Signature&lt;/c0&gt;) may be created with colon-prefixed parens:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082134Z" creationid="Toshiyuki" creationdate="20140329T082134Z">
        <seg>シグネチャーオブジェクト（&lt;c0&gt;Signature&lt;/c0&gt;）はコロンを前につけた括弧で作成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A similar approach might generate a command line interface along with some basic usage instructions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T134230Z" creationid="Toshiyuki" creationdate="20140111T074424Z">
        <seg>類似したアプローチは、若干の基本的な使用命令とともにコマンドラインインターフェースを生み出すかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single &lt;c1&gt;$&lt;/c1&gt; in a signature identifies an anonymous scalar variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115054Z" creationid="Toshiyuki" creationdate="20140113T050209Z">
        <seg>シグネチャーの一つの&lt;c1&gt;$&lt;/c1&gt;は、匿名のスカラー変数を識別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single caret &lt;c0&gt;^&lt;/c0&gt; anchors the regex to the start of the string and a dollar sign &lt;c1&gt;$&lt;/c1&gt; to the end.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232237Z" creationid="Toshiyuki" creationdate="20140221T232237Z">
        <seg>シングルキャレット&lt;c0&gt;^&lt;/c0&gt;は文字列の開始、ドル記号&lt;c1&gt;$&lt;/c1&gt;は終わりに正規表現を固定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string is a piece of text, and a string literal is a string which appears directly in the program.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154415Z" creationid="Toshiyuki" creationdate="20131026T040448Z">
        <seg>文字列はテキストの断片です。そして文字列リテラルはプログラム中に直接現れる文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subroutine can also return multiple values:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T222103Z" creationid="Toshiyuki" creationdate="20140104T222103Z">
        <seg>サブルーチンは複数の値を返すこともできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subroutine declaration consists of several parts.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131500Z" creationid="Toshiyuki" creationdate="20131029T131500Z">
        <seg>サブルーチンの宣言はいくつかのパーツから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subroutine signature performs two tasks.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T035416Z" creationid="Toshiyuki" creationdate="20131126T123022Z">
        <seg>サブルーチンシグネチャーは2つのタスクを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A successfully evaluated constraint makes a match narrower than a similar signature without a constraint.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113911Z" creationid="Toshiyuki" creationdate="20140113T044551Z">
        <seg>うまく評価された制約は、マッチを制約のない類似したシグネチャーより制限されたようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch statement is a means of topicalizing, so the switch keyword is the English topicalizer, &lt;c0&gt;given&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125000Z" creationid="Toshiyuki" creationdate="20130811T125000Z">
        <seg>switch文はトピカライズの手段だ。そういうわけで、switchキーワードは英語のトピカライザー、&lt;c0&gt;given&lt;/c0&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A term can be a literal like &lt;c2&gt;8&lt;/c2&gt; or &lt;c3&gt;'Dave'&lt;/c3&gt;, or a combination of other terms and operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T084407Z" creationid="Toshiyuki" creationdate="20131027T050755Z">
        <seg>項は&lt;c2&gt;8&lt;/c2&gt;または&lt;c3&gt;'Dave'&lt;/c3&gt;のようなリテラル、または他の項と演算子の組み合わせが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A term can have zero or more prefix operators, so you can actually write &lt;c5&gt;say 4 + -5&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T060322Z" creationid="Toshiyuki" creationdate="20131027T060322Z">
        <seg>項はゼロまたはそれより多くの接頭辞演算子を持つことができるので、実は&lt;c5&gt;say 4 + -5&lt;/c5&gt;と書くことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A third option is to allow labeled &lt;c14&gt;gather&lt;/c14&gt;/&lt;c15&gt;take&lt;/c15&gt; for such a situation, and dynamic &lt;c16&gt;take&lt;/c16&gt; must match the &lt;c17&gt;gather&lt;/c17&gt;'s label (or lack thereof) exactly.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T162628Z" creationid="Toshiyuki" creationdate="20130810T162628Z">
        <seg>三つ目の選択はラベル付き&lt;c14&gt;gather&lt;/c14&gt;/&lt;c15&gt;take&lt;/c15&gt;をそのような状況のために許可すること、そしてダイナミックな&lt;c16&gt;take&lt;/c16&gt;は&lt;c17&gt;gather&lt;/c17&gt;のラベル（またはそれの欠如）に完全に一致する必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A token with the &lt;c0&gt;:sigspace&lt;/c0&gt; modifier is a &lt;c1&gt;rule&lt;/c1&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T053218Z" creationid="Toshiyuki" creationdate="20140222T023030Z">
        <seg>&lt;c0&gt;:sigspace&lt;/c0&gt;修飾子によるトークンは、&lt;c1&gt;rule&lt;/c1&gt;です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A twigil forms part of the name of the variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182643Z" creationid="Toshiyuki" creationdate="20140111T182643Z">
        <seg>twigilは、変数の名前の一部をなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A typical use case for three-way comparison is sorting.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T034141Z" creationid="Toshiyuki" creationdate="20131029T123825Z">
        <seg>三者間の比較の典型的使用例はソートです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable may itself be bound to a container type that specifies how the container works, without specifying what kinds of things it contains.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132445Z" creationid="Toshiyuki" creationdate="20140327T132445Z">
        <seg>どんな種類のものを含むか指定することなく、どのように機能するか指定しているコンテナ型に変数がバインドされている場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable name begins with a &lt;e0&gt;sigil&lt;/e0&gt;, which is a non-alpha-numeric symbol such as &lt;c1&gt;$&lt;/c1&gt;, &lt;c2&gt;@&lt;/c2&gt;, &lt;c3&gt;%&lt;/c3&gt;, or &lt;c4&gt;&amp;&lt;/c4&gt;--or occasionally the double colon &lt;c5&gt;::&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T153853Z" creationid="Toshiyuki" creationdate="20131026T032505Z">
        <seg>変数名は&lt;e0&gt;シギル&lt;/e0&gt;（&lt;c1&gt;$&lt;/c1&gt;、&lt;c2&gt;@&lt;/c2&gt;、&lt;c3&gt;%&lt;/c3&gt;または&lt;c4&gt;&amp;&lt;/c4&gt;のような非英語シンボル）― または時々2つのコロン&lt;c5&gt;::&lt;/c5&gt;で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable's sigil indicates its intended use.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131221T001724Z" creationid="Toshiyuki" creationdate="20131221T001724Z">
        <seg>変数のシギルはその使用の意図を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable's type is a constraint indicating what sorts of values the variable may contain.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132054Z" creationid="Toshiyuki" creationdate="20140327T132054Z">
        <seg>変数の型は、どんな種類の値を含むかについて示している制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variant of &lt;c0&gt;do&lt;/c0&gt; is &lt;c1&gt;gather&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152335Z" creationid="Toshiyuki" creationdate="20130810T152335Z">
        <seg>&lt;c0&gt;do&lt;/c0&gt;の変形は&lt;c1&gt;gather&lt;/c1&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstract and Concrete Parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T130831Z" creationid="Toshiyuki" creationdate="20140110T130831Z">
        <seg>抽象と具体的パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to S12, properties are actually implemented by a kind of mixin mechanism, and such mixins are accomplished by the generation of an individual anonymous class for the object (unless an identical anonymous class already exists and can safely be shared).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132615Z" creationid="Toshiyuki" creationdate="20140326T132615Z">
        <seg>S12によると、プロパティは実際のところ一種のミックスインメカニズムで実現されます。そのようなミックスインは個々のオブジェクト（同一の匿名クラスが既に存在し、安全に共有できるのでなければ）のための匿名クラスの生成によって達成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding 1 to it leaves space for a single blank space between the name of the longest player and the left edge of the bars.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T065107Z" creationid="Toshiyuki" creationdate="20131027T065107Z">
        <seg>バーの端と最も長い名前のプレーヤーの間には1つ離れた空白を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding Constraints</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140106T133534Z" creationid="Toshiyuki" creationdate="20140106T133534Z">
        <seg>制約を追加する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding Signatures</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T035413Z" creationid="Toshiyuki" creationdate="20131126T122924Z">
        <seg>シグネチャーを追加する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding to an entry that is not in the hash yet will cause that entry to spring into existence just-in-time, with a value starting at zero.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T141500Z" creationid="Toshiyuki" creationdate="20131026T140758Z">
        <seg>まだハッシュにないエントリーを追加すると、ジャストインタイムで値がゼロで始まって存在するようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, it requires that the first positional parameter be an indexable item--anything that would match the &lt;c1&gt;@&lt;/c1&gt; sigil.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T120106Z" creationid="Toshiyuki" creationdate="20140113T073440Z">
        <seg>その上それは、最初のポジションのパラメータがインデックス可能なアイテム ― &lt;c1&gt;@&lt;/c1&gt;にシギルに合うものを見つけるどんなものも ― であることを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the &lt;c0&gt;:_&lt;/c0&gt; adverb allows either defined or undefined values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T132607Z" creationid="Toshiyuki" creationdate="20140110T132607Z">
        <seg>さらに、&lt;c0&gt;:_&lt;/c0&gt;副詞は定義済みか未定義の値を許します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the &lt;c0&gt;try&lt;/c0&gt; block or statement implicitly enforces a &lt;c1&gt;use fatal&lt;/c1&gt; context such that failures are immediately thrown as exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T123525Z" creationid="Toshiyuki" creationdate="20130813T123525Z">
        <seg>加えて、&lt;c0&gt;try&lt;/c0&gt;ブロックまたは文は暗黙的に失敗が例外として即時にスローされるように&lt;c1&gt;use fatal&lt;/c1&gt;コンテキストを強要する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, they also allow you to explicitly specify the return type of a subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T221352Z" creationid="Toshiyuki" creationdate="20131126T125525Z">
        <seg>その上、サブルーチンの戻り値の型を明示的に指定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all of the dependencies have completed, it's time to perform the current &lt;c0&gt;Task&lt;/c0&gt;'s task by invoking the &lt;c1&gt;&amp;!callback&lt;/c1&gt; attribute directly; this is the purpose of the parentheses.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T140645Z" creationid="Toshiyuki" creationdate="20140111T192539Z">
        <seg>全ての依存が完了した後は、現在の&lt;c0&gt;Task&lt;/c0&gt;の仕事を&lt;c1&gt;&amp;!callback&lt;/c1&gt;属性を直接起動して実行するときです；これは括弧の目的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After composition, the class appears as if those attributes and methods had been declared in the class's declaration itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T013742Z" creationid="Toshiyuki" creationdate="20140115T135526Z">
        <seg>合成の後、そのクラスはまるでそれらの属性とメソッドがクラス自身の宣言そのものにおいて宣言されたように発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After creating a class, you can create instances of the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141612Z" creationid="Toshiyuki" creationdate="20140112T090546Z">
        <seg>クラスを作成した後に、あなたはクラスのインスタンスを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After it finishes its work, it can delegate to its parent class meethod by calling &lt;c2&gt;nextsame&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121405Z" creationid="Toshiyuki" creationdate="20140113T080036Z">
        <seg>作業を終えたあと、それは&lt;c2&gt;nextsame&lt;/c2&gt;を呼ぶことによって親クラスメソッドにデリゲートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After matching the anchor at the start of the string, the regex attempts to match either an &lt;c3&gt;&lt;array&gt;&lt;/c3&gt; or an &lt;c4&gt;&lt;object&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T141225Z" creationid="Toshiyuki" creationdate="20140222T132234Z">
        <seg>文字列の始まりでアンカーにマッチした後に、正規表現は&lt;c3&gt;&lt;array&gt;&lt;/c3&gt;か&lt;c4&gt;&lt;object&gt;&lt;/c4&gt;にマッチしようと試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After optional spaces, two slashes &lt;c1&gt;'//'&lt;/c1&gt; introduce a comment, after which must follow an arbitrary number of non- newline characters, and then a newline.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T225502Z" creationid="Toshiyuki" creationdate="20140223T104156Z">
        <seg>任意の空白の後、2つのスラッシュ&lt;c1&gt;'//'&lt;/c1&gt;はコメントを導入します。それの後には任意の数の非改行文字、そして改行文字が続かなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After processing the first line of the file, the variables contain the values:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T004106Z" creationid="Toshiyuki" creationdate="20131026T115800Z">
        <seg>ファイルの最初の行を処理した後に、変数は次の値を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After processing the first line, &lt;c0&gt;$pairing&lt;/c0&gt; will hold the string &lt;c1&gt;Ana Dave&lt;/c1&gt; and &lt;c2&gt;$result&lt;/c2&gt; &lt;c3&gt;3:0&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T103647Z" creationid="Toshiyuki" creationdate="20131026T103647Z">
        <seg>最初の行を処理した後、&lt;c0&gt;$pairing&lt;/c0&gt;は文字列&lt;c1&gt;Ana Dave&lt;/c1&gt;、 &lt;c2&gt;$result&lt;/c2&gt;は&lt;c3&gt;3:0&lt;/c3&gt;を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the &lt;c6&gt;+&lt;/c6&gt; (an infix operator), the compiler expects a term, so as to interpret the &lt;c7&gt;-&lt;/c7&gt; as a prefix operator to the term &lt;c8&gt;5&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T060624Z" creationid="Toshiyuki" creationdate="20131027T060607Z">
        <seg>&lt;c6&gt;+&lt;/c6&gt;（接中辞演算子）の後にコンパイラは項を期待するので、&lt;c7&gt;-&lt;/c7&gt;を項&lt;c8&gt;5&lt;/c8&gt;の接頭辞演算子と解釈します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the called routine has done its work, the callee can continue its work.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121138Z" creationid="Toshiyuki" creationdate="20140113T075823Z">
        <seg>呼び出されるルーチンが作用を及ぼしたあと、呼び出し先はその作業を続けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the first sorting step, the names are in the order &lt;c0&gt;Beth Charlie Dave Ana&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T150254Z" creationid="Toshiyuki" creationdate="20131026T150254Z">
        <seg>最初のソートステップの後、名前の順序は&lt;c0&gt;Beth Charlie Dave Ana&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the second sorting step, it's still the same, because no one has won fewer matches but more sets than someone else.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T151032Z" creationid="Toshiyuki" creationdate="20131026T151032Z">
        <seg>第2のソートステップの後、セット数以外で誰も他の誰かより多くの試合に勝っていないので、それはまだ同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the sigil comes an &lt;e6&gt;identifier&lt;/e6&gt;, which may consist of letters, digits and the underscore.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T034010Z" creationid="Toshiyuki" creationdate="20131026T034010Z">
        <seg>シギルの後に来るのは&lt;e6&gt;識別子&lt;/e6&gt;で、それは文字、数値、アンダースコアから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After these two lines have run for the first time, &lt;c2&gt;%sets&lt;/c2&gt; contains &lt;c3&gt;'Ana' =&gt; 3, 'Dave' =&gt; 0&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T141604Z" creationid="Toshiyuki" creationdate="20131026T141604Z">
        <seg>これらの2行が初めて実行された後、&lt;c2&gt;%sets&lt;/c2&gt;は&lt;c3&gt;'Ana' =&gt; 3, 'Dave' =&gt; 0&lt;/c3&gt;を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After this postcircumfix operator is an ordinary &lt;e5&gt;postfix&lt;/e5&gt; operator with name &lt;c6&gt;++&lt;/c6&gt;, which increments the value it qualifies.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T054044Z" creationid="Toshiyuki" creationdate="20131027T054044Z">
        <seg>この後置接周辞演算子の後は&lt;c6&gt;++&lt;/c6&gt;という名前の、値を修飾してインクリメントする普通の&lt;e5&gt;接尾辞&lt;/e5&gt;演算子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After working through this book, you should have a solid grasp of the basics of Perl 6 sufficient to solve your own problems with Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T001902Z" creationid="Toshiyuki" creationdate="20131025T223054Z">
        <seg>この本で勉強した後に、あなたはPerl 6に関するあなた自身の問題を解決するのに十分なPerl 6の基本を、しっかり把握しているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All abnormal control flow is, in the general case, handled by the exception mechanism (which is likely to be optimized away in specific cases.) Here "abnormal" means any transfer of control outward that is not just falling off the end of a block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T124319Z" creationid="Toshiyuki" creationdate="20130816T124219Z">
        <seg>全てのアブノーマルな制御フローは、一般の場合、例外メカニズムによって扱われる（それはたぶん特定のケースに最適化される）。ここで「アブノーマル」は何か一つの外側への制御の転送を意味する。そしてそれはブロックの終端から離れるだけではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All calls build a capture on the caller side and unpack it according to the signature on the callee side (footnote: An optimizing Perl 6 compiler may, of course, be able to optimize away part or all of this process, depending on what it knows at compilation time.).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T041827Z" creationid="Toshiyuki" creationdate="20140110T161834Z">
        <seg>全ての呼び出しは呼び出し側でキャプチャーを構築し、呼び出された側のシグネチャーでアンパックします（注釈：最適化されたPerl 6コンパイラは、もちろん、このプロセスを最適化できます。コンパイル時に何かを知ることに従って）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All numbers except zero evaluate to &lt;c0&gt;True&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021439Z" creationid="Toshiyuki" creationdate="20140322T021439Z">
        <seg>ゼロを除く全ての数は&lt;c0&gt;True&lt;/c0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the examples in this book will run with the &lt;e0&gt;Rakudo Perl 6&lt;/e0&gt; Compiler, but they are in no way specific to Rakudo--any sufficiently advanced Perl 6 implementation can run them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T002413Z" creationid="Toshiyuki" creationdate="20131025T231655Z">
        <seg>この本の例はすべて&lt;e0&gt;Rakudo Perl 6&lt;/e0&gt;コンパイラで動作します。しかし、それらは決してRakudoに特有ではありません ― 十分に先進なPerl 6実装ならなんでもそれらを動作させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the three operators above are &lt;e0&gt;infix&lt;/e0&gt; operators, which means they stand between two &lt;e1&gt;terms&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T084304Z" creationid="Toshiyuki" creationdate="20131027T050530Z">
        <seg>上の3つの演算子は全て&lt;e0&gt;中置演算子&lt;/e0&gt;です。そしてそれは2つの&lt;e1&gt;項&lt;/e1&gt;の間に立つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other characters may have a special meaning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124323Z" creationid="Toshiyuki" creationdate="20140115T143744Z">
        <seg>他の文字は特別な意味を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other names (including implicit names of operators) are looked up in the lexical scope of the caller when we actually know who the caller is at run time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T072619Z" creationid="Toshiyuki" creationdate="20130811T065634Z">
        <seg>全ての他の名前（演算子の暗黙の名前を含む）は我々が実行時に呼び出し元が誰か実際に知っている時、呼び出し元のレキシカルスコープで探索される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other strings evaluate to &lt;c2&gt;True&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021420Z" creationid="Toshiyuki" creationdate="20140322T021420Z">
        <seg>他のすべての文字列は&lt;c2&gt;True&lt;/c2&gt;と評価する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All possible roles are equal in role composition.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T020707Z" creationid="Toshiyuki" creationdate="20140115T140059Z">
        <seg>すべての使用可能なロールは、ロール合成において平等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also current implementations have problems with dumping cyclic data structures this way, but they are expected to be handlded correctly by &lt;c2&gt;.perl&lt;/c2&gt; at some point.), it is very useful for debugging simple objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110210Z" creationid="Toshiyuki" creationdate="20140322T110013Z">
        <seg>また、現在の実装は循環したデータ構造のダンプに問題を抱えています。しかしそれらは&lt;c2&gt;.perl&lt;/c2&gt;によっていくつかの点で正しく扱われると思われます）。単純なオブジェクトをデバッグするのに非常に有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, &lt;c0&gt;!$!done&lt;/c0&gt; is unnecessarily hard to read if you see !</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T111127Z" creationid="Toshiyuki" creationdate="20140112T175523Z">
        <seg>また、&lt;c0&gt;!$!done&lt;/c0&gt;は読むのは必要以上に難しいです！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, &lt;e2&gt;currying&lt;/e2&gt; or &lt;e3&gt;partial application&lt;/e3&gt;?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T043853Z" creationid="Toshiyuki" creationdate="20140111T043853Z">
        <seg>また、&lt;e2&gt;カリー&lt;/e2&gt;または&lt;e3&gt;パーシャルアプリケーション&lt;/e3&gt;？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the description of scoping may be subtle here.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T132236Z" creationid="Toshiyuki" creationdate="20131029T132236Z">
        <seg>また、スコーピングの説明はここでは捉えがたいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, the return type may be specified within the signature:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T230312Z" creationid="Toshiyuki" creationdate="20140328T230312Z">
        <seg>あるいは、戻り値の型はシグネチャで指定可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternative Named Argument Syntaxes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T012740Z" creationid="Toshiyuki" creationdate="20140104T133444Z">
        <seg>名前付き引数の代替文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although a bare block occurring as a single statement is no longer a do-once loop, it still executes immediately as in Perl 5, as if it were immediately dereferenced with a &lt;c0&gt;.()&lt;/c0&gt; postfix, so within such a block &lt;c1&gt;CALLER::&lt;/c1&gt; refers to the dynamic scope associated with the lexical scope surrounding the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T150749Z" creationid="Toshiyuki" creationdate="20130810T150749Z">
        <seg>とはいえ、単独の文として生じる裸のブロックはもはやdo-onceループではない。 それはまだPerl 5のように実行される。まるで&lt;c0&gt;.()&lt;/c0&gt;接尾辞でただちにデリファレンスされるかのように。それゆえ、そのようなブロック内の&lt;c1&gt;CALLER::&lt;/c1&gt;はブロックを囲んでいるレキシカルスコープに関連付けられているダイナミックスコープ参照する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the rules and action methods live in different namespaces (and in a real-world project probably even in separate files), here they are adjacent to demonstrate their correspondence:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T001511Z" creationid="Toshiyuki" creationdate="20140224T162737Z">
        <seg>ルールとアクションメソッドは異なる名前空間（そして、実際のプロジェクトではおそらく別々のファイル）に存在しますが、ここでは、それらの対応関係を示すために隣接しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ampersand and invocation</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082723Z" creationid="Toshiyuki" creationdate="20140329T082723Z">
        <seg>アンパサンドと起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;array&lt;/c0&gt; contains &lt;c1&gt;value&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T132438Z" creationid="Toshiyuki" creationdate="20140222T132438Z">
        <seg>&lt;c0&gt;array&lt;/c0&gt;は&lt;c1&gt;value&lt;/c1&gt;を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;of&lt;/c0&gt; type on an array or hash specifies the type stored by each element:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T222144Z" creationid="Toshiyuki" creationdate="20140328T222144Z">
        <seg>配列またはハッシュでの&lt;c0&gt;of&lt;/c0&gt;型は個々の要素で保存される型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c1&gt;of&lt;/c1&gt; type is given as a prefix or with the &lt;c2&gt;of&lt;/c2&gt; keyword:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T213135Z" creationid="Toshiyuki" creationdate="20140328T213135Z">
        <seg>&lt;c1&gt;of&lt;/c1&gt;型は接頭辞または&lt;c2&gt;of&lt;/c2&gt;キーワードで与えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c2&gt;INIT&lt;/c2&gt; only runs once for all copies of a cloned closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030538Z" creationid="Toshiyuki" creationdate="20130822T030538Z">
        <seg>&lt;c2&gt;INIT&lt;/c2&gt;は全ての複製されたクロージャで1回だけ実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;i0&gt;identifier&lt;/i0&gt; is composed of an alphabetic character followed by any sequence of alphanumeric characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T092032Z" creationid="Toshiyuki" creationdate="20140329T092032Z">
        <seg>&lt;i0&gt;識別子&lt;/i0&gt;は英数字のシーケンスが続く英字で構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An abstract syntax tree, or AST, is a data structure which represents the parsed version of the text.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T000745Z" creationid="Toshiyuki" creationdate="20140224T162530Z">
        <seg>抽象構文木またはASTは、テキストのパースされたバージョンを表すデータ構造です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative way to resolve a conflict is to write a method with the same name in the class body itself:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T021212Z" creationid="Toshiyuki" creationdate="20140115T140305Z">
        <seg>競合を解決する代わりの方法は、同じ名前のメソッドをクラス本体自体に書くことです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array's &lt;c0&gt;sort&lt;/c0&gt; method returns a sorted version of the array's contents.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T143024Z" creationid="Toshiyuki" creationdate="20131026T143024Z">
        <seg>配列の&lt;c0&gt;sort&lt;/c0&gt;メソッドは配列の内容が並べ替えられたバージョンを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An earlier section explained that declaring the class &lt;c0&gt;Task&lt;/c0&gt; installed a type object in the namespace.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141736Z" creationid="Toshiyuki" creationdate="20140112T090833Z">
        <seg>以前のセクションで、クラス&lt;c0&gt;Task&lt;/c0&gt;を宣言することが名前空間に型オブジェクトをインストールすると説明しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An equivalent explanation applies to &lt;c4&gt;ne&lt;/c4&gt; and &lt;c5&gt;!eq&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T140557Z" creationid="Toshiyuki" creationdate="20131028T140557Z">
        <seg>等しい説明は&lt;c4&gt;ne&lt;/c4&gt;と&lt;c5&gt;!eq&lt;/c5&gt;にも当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example is the &lt;c1&gt;-&lt;/c1&gt; operator, which negates the following numeric value, as in &lt;c2&gt;my $x = -4&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T054505Z" creationid="Toshiyuki" creationdate="20131027T054505Z">
        <seg>例は&lt;c1&gt;-&lt;/c1&gt;演算子です。それは後に続く数値を負数にします。&lt;c2&gt;my $x = -4&lt;/c2&gt;のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An exception handler is just a switch statement on an implicit topic that happens to be the current exception to be dealt with.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T130151Z" creationid="Toshiyuki" creationdate="20130813T130151Z">
        <seg>例外ハンドラは分配されて現在の例外になるために起こるトピックで暗黙に文をただスイッチする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An explicit placeholder may also be used:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T084207Z" creationid="Toshiyuki" creationdate="20130804T084207Z">
        <seg>明示的なプレースホルダーも使われる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier may also contain isolated apostrophes or hyphens provided the next character is alphabetic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T093347Z" creationid="Toshiyuki" creationdate="20140329T093347Z">
        <seg>識別子は次が英字になっている独立したアポストロフィーまたはハイフンも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An idiomatic duplicate word searcher might be:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T052229Z" creationid="Toshiyuki" creationdate="20140222T022949Z">
        <seg>慣用的な重複のワードサーチャーは、以下の通りになるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anchor</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232447Z" creationid="Toshiyuki" creationdate="20140221T232447Z">
        <seg>アンカー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anchors</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T231831Z" creationid="Toshiyuki" creationdate="20140221T231831Z">
        <seg>アンカー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124223Z" creationid="Toshiyuki" creationdate="20130811T124223Z">
        <seg>そして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another approach is to stop cycles from forming during &lt;c0&gt;add-dependency&lt;/c0&gt; by checking whether there's already a dependency running in the other direction.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T153515Z" creationid="Toshiyuki" creationdate="20140112T180329Z">
        <seg>別のアプローチは、すでに従属物が他の方向で実行されているかどうかチェックすることで&lt;c0&gt;add-dependency&lt;/c0&gt;の間にフォーミングからの循環を止めることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another consequence of this is that any block just inside a left parenthesis is immediately called like a bare block, so a multidimensional list comprehension may be written using a block with multiple parameters fed by a &lt;c0&gt;for&lt;/c0&gt; modifier:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T125832Z" creationid="Toshiyuki" creationdate="20130810T125832Z">
        <seg>これのもう一つの結果は、左括弧内のどんなブロックも裸のブロックのように直ちに呼び出されるので、多次元リストの理解力は&lt;c0&gt;for&lt;/c0&gt;修飾子で与えられた複数パラメータ付きのブロックを使うことで書き直せる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another novelty is the declaration of a &lt;e0&gt;proto token&lt;/e0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T145403Z" creationid="Toshiyuki" creationdate="20140222T133534Z">
        <seg>別の目新しさは、&lt;e0&gt;proto token&lt;/e0&gt;宣言です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another operator type is the &lt;e0&gt;prefix&lt;/e0&gt; operator, which occurs before a term.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T084628Z" creationid="Toshiyuki" creationdate="20131027T054229Z">
        <seg>別の演算子タイプは&lt;e0&gt;接頭辞&lt;/e0&gt;演算子です。そして、それは項の前に出現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another regex called &lt;c1&gt;dup&lt;/c1&gt; (short for &lt;e2&gt;duplicate&lt;/e2&gt;) contains a word boundary anchor.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T014749Z" creationid="Toshiyuki" creationdate="20140222T014749Z">
        <seg>&lt;c1&gt;dup&lt;/c1&gt;と呼ばれる別の正規表現（&lt;e2&gt;duplicate&lt;/e2&gt;の省略）は単語境界アンカーを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another variant is:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T024341Z" creationid="Toshiyuki" creationdate="20140222T024341Z">
        <seg>別の異形は以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Perl 6 compiler is free to optimize away type checks it knows will succeed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T224433Z" creationid="Toshiyuki" creationdate="20140112T224433Z">
        <seg>どのPerl 6でも、型チェックが成功するだろうということを知っている最適化を行うのは自由です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any block object can be used, not just labels, so to return a value from this iteration of the current block you can say:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T102511Z" creationid="Toshiyuki" creationdate="20130806T102511Z">
        <seg>ラベルだけでなく任意のオブジェクトを使える。それゆえ、現在のブロックのこのイテレーションから値を返すためにあなたは次のように書くことができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any conflicts will occur at this point.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T161050Z" creationid="Toshiyuki" creationdate="20140115T142823Z">
        <seg>どんな競合でもこの点で生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any further type constraints</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044110Z" creationid="Toshiyuki" creationdate="20140322T044110Z">
        <seg>型の制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any implementation that passes the official test suite can call itself "Perl 6".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T023754Z" creationid="Toshiyuki" creationdate="20131025T231313Z">
        <seg>公式テストスイートを通る実装ならなんでも「Perl 6」を名乗ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any missing methods will cause runtime errors (barring the use of something like &lt;c0&gt;AUTOMETH&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T040338Z" creationid="Toshiyuki" creationdate="20140115T141957Z">
        <seg>見落としているメソッドは何でも、実行時エラー（&lt;c0&gt;AUTOMETH&lt;/c0&gt;のような何かの使用を妨げる）を引き起こすでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any other use of the &lt;c5&gt;Failure&lt;/c5&gt; object to extract a normal value will throw its associated exception immediately.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T155735Z" creationid="Toshiyuki" creationdate="20130817T155735Z">
        <seg>通常の値を取り出すための何か他の&lt;c5&gt;Failure&lt;/c5&gt;オブジェクトの使用はそれに関連付けられた例外を即座にスローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any parcels in the returned list are normally flattened when bound into flat context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T204319Z" creationid="Toshiyuki" creationdate="20130810T204319Z">
        <seg>返されたリストのどんなパーセルでも、フラットコンテキストにバインドされた時に通常は平坦化される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any parts of the string which match but not as part of captures will not appear in the values that &lt;c1&gt;caps&lt;/c1&gt; returns.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T115550Z" creationid="Toshiyuki" creationdate="20140222T025500Z">
        <seg>文字列にマッチしても、キャプチャーの一部ではない部分は何であれ&lt;c1&gt;caps&lt;/c1&gt;の返す値には現れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any remaining special variables will be lexically scoped.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090525Z" creationid="Toshiyuki" creationdate="20140329T090525Z">
        <seg>残りの特殊変数はレキシカルスコープになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any rule used within the grammar will be looked for first in the grammar in which it was used, then within its parent(s).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T225235Z" creationid="Toshiyuki" creationdate="20140223T103702Z">
        <seg>グラマーの範囲内で使ったルールなら何でも、それが使われたグラマーのものが最初に見られ、それからその親の範囲内で見られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name in rvalue context is parsed as a single type value and expects no arguments following it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140401T115822Z" creationid="Toshiyuki" creationdate="20140401T115822Z">
        <seg>rvalueコンテキストの型名は単独の型の値としてパースされ、なんの引数も期待しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name used as a value is the undefined prototype object of that type, or &lt;i0&gt;type object&lt;/i0&gt; for short.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T134127Z" creationid="Toshiyuki" creationdate="20140327T134127Z">
        <seg>値として使われる型名は何でもその型の未定義のプロトタイプオブジェクト、略して&lt;i0&gt;型オブジェクト&lt;/i0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any undefined method call on &lt;c16&gt;Nil&lt;/c16&gt; returns &lt;c17&gt;Nil&lt;/c17&gt;, so that &lt;c18&gt;Nil&lt;/c18&gt; propagates down method call chains.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140331T130233Z" creationid="Toshiyuki" creationdate="20140331T130233Z">
        <seg>&lt;c16&gt;Nil&lt;/c16&gt;のどんな未定義のメソッド呼び出しも&lt;c17&gt;Nil&lt;/c17&gt;を返します。なので&lt;c18&gt;Nil&lt;/c18&gt;はメソッドコールチェインを伝搬します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any value can coerce to a boolean in boolean context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021226Z" creationid="Toshiyuki" creationdate="20140322T021226Z">
        <seg>真偽値コンテキストではどんな値も真偽値に自動型変換できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any variable mentioned in a capture exists in the capture as a &lt;e0&gt;reference&lt;/e0&gt; to the variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T125825Z" creationid="Toshiyuki" creationdate="20140110T160023Z">
        <seg>キャプチャーの中に記載された変数は何でも変数への&lt;e0&gt;リファレンス&lt;/e0&gt;として存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything may bind to it, even if it could also bind to an object with one of the other sigils.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T010050Z" creationid="Toshiyuki" creationdate="20131221T004308Z">
        <seg>たとえそれが他のシギルでもバインドできるとしても、何でもバインドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from &lt;c0&gt;CATCH&lt;/c0&gt; and &lt;c1&gt;CONTROL&lt;/c1&gt;, which can only occur once, most of these can occur multiple times within the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093455Z" creationid="Toshiyuki" creationdate="20130818T093455Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;と&lt;c1&gt;CONTROL&lt;/c1&gt;は別として、それは一回だけ起こる。それらの大部分はブロック内で複数回発生できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apostrophe separator</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000056Z" creationid="Toshiyuki" creationdate="20140329T000056Z">
        <seg>アポストロフィーセパレーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Append a &lt;c0&gt;!&lt;/c0&gt; to make a named parameter mandatory.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T011913Z" creationid="Toshiyuki" creationdate="20131231T225717Z">
        <seg>名前が付けられたパラメータを必須にするには&lt;c0&gt;!&lt;/c0&gt;を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Appending a question mark to a quantifier makes it non-greedy (footnote: The non-greedy general quantifier is &lt;c1&gt;$thing **?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T230200Z" creationid="Toshiyuki" creationdate="20140221T230200Z">
        <seg>数量詞にクエスチョンマークを追加すると非貪欲にします。（脚注：非貪欲な一般的な数量詞は&lt;c1&gt;$thing **?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Are these functions also methods?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015906Z" creationid="Toshiyuki" creationdate="20140322T015906Z">
        <seg>これらの関数もメソッドですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments bound to the formal parameters of a pointy block are by default readonly within the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112434Z" creationid="Toshiyuki" creationdate="20130810T112434Z">
        <seg>ポインティブロックの仮パラメータにバインドされた引数はブロック内ではデフォルトで読み取り専用だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array and List would work, but are hard to get right.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113741Z" creationid="Toshiyuki" creationdate="20140113T044152Z">
        <seg>ArrayとListは動作しますが、正しくするのは難しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays store ordered lists.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154850Z" creationid="Toshiyuki" creationdate="20131026T083220Z">
        <seg>配列は順序リストを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays within curly braces are interpolated with a single space character between each item.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T153858Z" creationid="Toshiyuki" creationdate="20131026T153858Z">
        <seg>ブレースの中の配列は、各々のアイテムの間に一つの空白文字が差し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a general rule, only the simplest subroutines benefit from implicit &lt;c1&gt;return&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T062706Z" creationid="Toshiyuki" creationdate="20140104T223235Z">
        <seg>一般に、最も単純なサブルーチンだけが暗黙の&lt;c1&gt;return&lt;/c1&gt;の恩恵を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a shortcut, &lt;c0&gt;$/[0]&lt;/c0&gt; is also available under the name &lt;c1&gt;$0&lt;/c1&gt;, &lt;c2&gt;$/[1]&lt;/c2&gt; as &lt;c3&gt;$1&lt;/c3&gt;, and so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T010414Z" creationid="Toshiyuki" creationdate="20140222T010414Z">
        <seg>ショートカットとして&lt;c0&gt;$/[0]&lt;/c0&gt;は名前&lt;c1&gt;$0&lt;/c1&gt;でも利用できます。同様に&lt;c2&gt;$/[1]&lt;/c2&gt;は&lt;c3&gt;$1&lt;/c3&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a side note, Perl 6 uses the C3 algorithm to linearize the multiple inheritance hierarchies, which is a significant improvement over Perl 5's approach to handling multiple inheritance.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T134000Z" creationid="Toshiyuki" creationdate="20140112T134000Z">
        <seg>傍注として、Perl 6は多重継承階層を線形化するためにC3アルゴリズムを使用します。そして、それは多重継承を取り扱うPerl 5のアプローチについての重要な改善です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As compile-time verification is an important feature of roles, it's best to mark your dependencies.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T040416Z" creationid="Toshiyuki" creationdate="20140115T142011Z">
        <seg>コンパイル時の検証はロールの重要な機能で、あなたの従属物をマークすることは最善です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As demonstrated, the &lt;c0&gt;defined(...)&lt;/c0&gt; function can be used to check if there is a value or not.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T010932Z" creationid="Toshiyuki" creationdate="20131230T042215Z">
        <seg>上に示したように、&lt;c0&gt;defined(...)&lt;/c0&gt;関数は値があるかどうか調べるのに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in C, the parentheses are required if you supply the 3-part spec; however, the 3-part loop spec may be entirely omitted to write an infinite loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060500Z" creationid="Toshiyuki" creationdate="20130810T060138Z">
        <seg>C言語における3部構成の仕様を与えるなら括弧が要求される；けれども、3部構成の仕様は無限ループを書くためには完全に省略できるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Perl 5, "&lt;c0&gt;our $foo&lt;/c0&gt;" introduces a lexically scoped alias for a variable in the current package.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T131442Z" creationid="Toshiyuki" creationdate="20130802T131442Z">
        <seg>Perl 5における&lt;c0&gt;our $foo&lt;/c0&gt;は現在のパッケージに変数のためのレキシカルスコープな別名をもたらす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Perl 5, it is possible to &lt;c4&gt;goto&lt;/c4&gt; into a lexical scope, but only for lexical scopes that require no special initialization of parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T142000Z" creationid="Toshiyuki" creationdate="20130817T142000Z">
        <seg>Perl 5におけるレキシカルスコープへの&lt;c4&gt;goto&lt;/c4&gt;は可能だ。しかし特別なパラメータの初期化を必要としないレキシカルスコープのみだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Perl 5, many built-in functions simply return an undefined value when you ask for a value out of range, or the function fails somehow.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T151040Z" creationid="Toshiyuki" creationdate="20130817T151040Z">
        <seg>Perl 5にあるようなたくさんのビルトイン関数は、あなたが値が範囲外か問い合わせるか関数がなぜか失敗するときに単純に未定義値を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in many other programming languages, you can use &lt;c5&gt;++&lt;/c5&gt; as a prefix.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T142628Z" creationid="Toshiyuki" creationdate="20131026T142628Z">
        <seg>多くの他のプログラミング言語のように、あなたは接頭辞として&lt;c5&gt;++&lt;/c5&gt;を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned before, a class can inherit from multiple classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T125536Z" creationid="Toshiyuki" creationdate="20140112T125536Z">
        <seg>前記したように、クラスは複数のクラスから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned earlier, the loop variable is named by passing a parameter to the closure:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T061134Z" creationid="Toshiyuki" creationdate="20130810T061134Z">
        <seg>前に簡単に述べたように、ループ変数はクロージャにパラメータを渡すことで名前が付けられる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As well, Perl is syncretic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T231024Z" creationid="Toshiyuki" creationdate="20131025T231024Z">
        <seg>また、Perlは語形融合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with an ordinary &lt;c0&gt;while&lt;/c0&gt;, you may optionally bind the result of the conditional expression to a parameter of the block:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T054928Z" creationid="Toshiyuki" creationdate="20130810T054928Z">
        <seg>通常の&lt;c0&gt;while&lt;/c0&gt;のように、条件式の結果をブロックのパラメータに任意に結びつけるなら：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with calls to &lt;c0&gt;return&lt;/c0&gt;, the warning control exception is an abstraction that the compiler is free to optimize away (along with the associated continuation) when the compiler or runtime can determine that the semantics would be preserved by merely printing out the error and going on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T124211Z" creationid="Toshiyuki" creationdate="20130817T124211Z">
        <seg>&lt;c0&gt;return&lt;/c0&gt;の呼び出しのように、警告制御例外はコンパイラが自由に最適化して取り除く抽象化だ（関連付けられた継続と一緒に）コンパイラかランタイムが決定できるとき、そのセマンティクスは単にエラーと進行をプリントするために保存される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with conditionals, you may optionally bind the result of the conditional expression to a parameter of the block:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T144106Z" creationid="Toshiyuki" creationdate="20130809T144106Z">
        <seg>条件文のように、条件付きの式の結果をブロックのパラメータに任意にバインドするなら：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with modules, the public storage, interface, and name of the class is represented by a package and its name, which is usually (but not necessarily) a global name.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131404Z" creationid="Toshiyuki" creationdate="20140329T131404Z">
        <seg>モジュールと同様に、パブリックストレージ、インターフェース、クラス名はパッケージとその名前によって表され、それは通常（しかし必ずではなく）グローバル名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with ordinary loop controls, the label is searched for first lexically within the current subroutine, then dynamically outside of it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T131653Z" creationid="Toshiyuki" creationdate="20130817T131653Z">
        <seg>普通のループ制御のように、ラベルは最初に現在のサブルーチン内レキシカルに検索される。その時はそれの外側をダイナミックに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with other statement prefixes, these value-producing constructs may be placed in front of either a block or a statement:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T082956Z" creationid="Toshiyuki" creationdate="20130818T082956Z">
        <seg>他の文接頭辞の様に、それらの値を出す構造はブロックか文の前に配置することもできる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the &lt;c7&gt;.leave&lt;/c7&gt; method, there is also a &lt;c8&gt;.succeed&lt;/c8&gt; method to break from a labelled block functioning as a switch:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120642Z" creationid="Toshiyuki" creationdate="20130813T120642Z">
        <seg>&lt;c7&gt;.leave&lt;/c7&gt;メソッドのように、switchとして機能するラベル付きブロックから抜けるための&lt;c8&gt;.succeed&lt;/c8&gt;メソッドもある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning &lt;c0&gt;Nil&lt;/c0&gt; to any entire composite container (such as an &lt;c1&gt;Array&lt;/c1&gt; or &lt;c2&gt;Hash&lt;/c2&gt;) empties the container, resetting it back to an uninitialized state.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140401T115508Z" creationid="Toshiyuki" creationdate="20140401T115508Z">
        <seg>&lt;c0&gt;Nil&lt;/c0&gt;全体の複合コンテナ（&lt;c1&gt;Array&lt;/c1&gt;や&lt;c2&gt;Hash&lt;/c2&gt;のような）に割り当てることはコンテナを空にし、未初期化状態にリセットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning &lt;c0&gt;Nil&lt;/c0&gt; to any scalar container causes the container to throw out any contents and restore itself to an uninitialized state (after which it will appear to contain an object appropriate to the declared default of the container, where &lt;c1&gt;Any&lt;/c1&gt; is the default default; the element may be simply deleted if that's how the default can be represented in the structure).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140401T114927Z" creationid="Toshiyuki" creationdate="20140401T114927Z">
        <seg>&lt;c0&gt;Nil&lt;/c0&gt;を何かのスカラーコンテナに割り当てると、その内容を捨てて初期化されていない状態に戻します（その後コンテナで定義されたデフォルトの適切なオブジェクトを含み、&lt;c1&gt;Any&lt;/c1&gt;はデフォルトのデフォルトです；デフォルトが構造で表されるなら、要素は単純に削除されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assume that users should be able to enter a list of moves (perhaps on a dance pad or other exotic input device).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131030T143909Z" creationid="Toshiyuki" creationdate="20131030T143909Z">
        <seg>ユーザーが動き（おそらくダンスパッドまたは他のエキゾチックな入力デバイスで）のリストを入力することができると仮定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At run time, &lt;c7&gt;succeed&lt;/c7&gt; uses a control exception to scan up the dynamic chain to find the call frame belonging to that same outer block, and when it has found that frame, it does a &lt;c8&gt;.leave&lt;/c8&gt; on it to unwind the call frames.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114158Z" creationid="Toshiyuki" creationdate="20130813T114158Z">
        <seg>実行時に、&lt;c7&gt;succeed&lt;/c7&gt;は同じ外側のブロックに属するコールフレームを探すためのダイナミックチェインをスキャンするために制御例外を使う。そしてそのフレームが見つかった時、コールフレームを巻き戻すために&lt;c8&gt;.leave&lt;/c8&gt;を行う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the time of writing, only Rakudo supports this..</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T075532Z" creationid="Toshiyuki" creationdate="20140113T075532Z">
        <seg>書く時点で、Rakudoだけはこれをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Audience</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T221545Z" creationid="Toshiyuki" creationdate="20131025T221545Z">
        <seg>読者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid writing code like this in anything other than example code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113401Z" creationid="Toshiyuki" creationdate="20140322T113401Z">
        <seg>例のコード以外のどんなものにもこのようなコードを書くことは避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backtracking control</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T021421Z" creationid="Toshiyuki" creationdate="20140222T021421Z">
        <seg>バックトラック制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T064648Z" creationid="Toshiyuki" creationdate="20140106T125549Z">
        <seg>基本型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be wary of relying on this: when the flow of control within a subroutine is sufficiently complex, adding an explicit &lt;c0&gt;return&lt;/c0&gt; will clarify the code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T062640Z" creationid="Toshiyuki" creationdate="20140104T222916Z">
        <seg>これに頼るのは注意してください：サブルーチンの制御フローが十分に複雑な場合は、&lt;c0&gt;return&lt;/c0&gt;を明示的に加える事はコードを明快にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;gather&lt;/c0&gt; evaluates its block or statement in sink context, this typically causes the &lt;c1&gt;take&lt;/c1&gt; function to be evaluated in sink context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T210403Z" creationid="Toshiyuki" creationdate="20130810T210403Z">
        <seg>&lt;c0&gt;gather&lt;/c0&gt;はそのブロックか文をsinkコンテキストで評価するので、これは典型的には&lt;c1&gt;take&lt;/c1&gt;関数がsinkコンテキストで評価されることを引き起こす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;when&lt;/c0&gt; statements are executed in order, the default must come last.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133337Z" creationid="Toshiyuki" creationdate="20130811T133337Z">
        <seg>なぜなら&lt;c0&gt;when&lt;/c0&gt;文は順番に実行されるので、defaultは最後に来なければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c1&gt;Int&lt;/c1&gt; is a type that conforms to &lt;c2&gt;Any&lt;/c2&gt;, it is a &lt;e3&gt;narrower&lt;/e3&gt; match for an integer.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T225632Z" creationid="Toshiyuki" creationdate="20140113T044317Z">
        <seg>&lt;c1&gt;Int&lt;/c1&gt;が&lt;c2&gt;Any&lt;/c2&gt;に従う型であるので、それは整数により&lt;e3&gt;狭い&lt;/e3&gt;匹敵するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c2&gt;$a&lt;/c2&gt; and &lt;c3&gt;$b&lt;/c3&gt; are dependencies of each other, none of them would ever get around to calling their callbacks.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110910Z" creationid="Toshiyuki" creationdate="20140112T173838Z">
        <seg>&lt;c2&gt;$a&lt;/c2&gt;と&lt;c3&gt;$b&lt;/c3&gt;が互いに従属物であるので、それらのどれもコールバックを呼んで歩き回ることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is possible to go to a label that is after the operation, and because Perl 6 does one-pass parsing, any &lt;c0&gt;goto&lt;/c0&gt; to a label that has not been yet declared (or is declared outside the outward lexical scope of the &lt;c1&gt;goto&lt;/c1&gt;) must enclose the label in quotes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T145112Z" creationid="Toshiyuki" creationdate="20130817T145112Z">
        <seg>なぜなら演算の後のラベルに行くことが可能で、Perl 6はワンパス解析を行うので、まだ定義されていない（または&lt;c1&gt;goto&lt;/c1&gt;の外側のレキシカルスコープの外に定義された）ラベルへのどれか一つの&lt;c0&gt;goto&lt;/c0&gt;はラベルをクオートで囲まなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of smart matching, ordinary &lt;c2&gt;when&lt;/c2&gt; statements are sufficiently powerful to pattern match the current exception against classes or patterns or numbers without any special syntax for exception handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T134345Z" creationid="Toshiyuki" creationdate="20130813T134345Z">
        <seg>スマートマッチングにより、通常の&lt;c2&gt;when&lt;/c2&gt;文は現在のクラスまたはパターンまたは例外ハンドラのための何らかの特別な文法のない数字に対する例外にマッチするために十分にパワフルだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because subroutine declarations are expressions, not statements, this is now invalid:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T032106Z" creationid="Toshiyuki" creationdate="20130803T032106Z">
        <seg>サブルーチンの宣言は式であり文ではないので、これは今では無効だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the bodies of the subs here do not use the parameters, there's no reason to force the programmer to name them; they're &lt;e0&gt;anonymous parameters&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114941Z" creationid="Toshiyuki" creationdate="20140113T050149Z">
        <seg>ここのsubの本体がパラメータを使わないので、それらに名をつけることをプログラマーに強制する理由はありません；それらは匿名のパラメータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the calculation is meaningful only for non-negative area values, the parameter includes a constraint which returns &lt;c0&gt;True&lt;/c0&gt; for non-negative values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T070911Z" creationid="Toshiyuki" creationdate="20140106T134354Z">
        <seg>計算は負の数でない範囲の値だけで意味があるので、パラメータは負の数でない値に&lt;c0&gt;True&lt;/c0&gt;を返す制約を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the dispatcher will see the &lt;c0&gt;cook&lt;/c0&gt; method on &lt;c1&gt;Baker&lt;/c1&gt; before it moves up to the parent class the &lt;c2&gt;Baker&lt;/c2&gt;'s &lt;c3&gt;cook&lt;/c3&gt; method will be called.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144534Z" creationid="Toshiyuki" creationdate="20140112T125402Z">
        <seg>ディスパッチャーは親クラスの前に&lt;c1&gt;Baker&lt;/c1&gt;の&lt;c0&gt;cook&lt;/c0&gt;メソッドを見るので、&lt;c2&gt;Baker&lt;/c2&gt;の&lt;c3&gt;cook&lt;/c3&gt;メソッドが呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before these two lines execute, &lt;c0&gt;%sets&lt;/c0&gt; is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T135604Z" creationid="Toshiyuki" creationdate="20131026T135604Z">
        <seg>これら2行を実行する前、&lt;c0&gt;%sets&lt;/c0&gt;は空です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before you get too happy about this pragma, note that Perl 6 contains various parallel processing primitives that will tend to get blown up prematurely by thrown exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T172058Z" creationid="Toshiyuki" creationdate="20130817T172058Z">
        <seg>このプラグマでハッピーになる前に、Perl 6はスローされた例外によって早まって爆発しがちな様々な並行処理プリミティブを含むので注意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides calling them, you can learn things about them, including the details of their parameters:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043633Z" creationid="Toshiyuki" creationdate="20140111T071654Z">
        <seg>それらを呼ぶ他に、あなたはパラメータの詳細も含めてそれらについて調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides operators, other syntactic elements coerce their elements: &lt;c0&gt;if&lt;/c0&gt; and &lt;c1&gt;while&lt;/c1&gt; coerce to truth values (&lt;c2&gt;Bool&lt;/c2&gt;), &lt;c3&gt;for&lt;/c3&gt; views things as lists, and so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T135825Z" creationid="Toshiyuki" creationdate="20140226T143153Z">
        <seg>演算子の他に、他の構文要素はそれらの要素を自動型変換します：&lt;c0&gt;if&lt;/c0&gt;と&lt;c1&gt;while&lt;/c1&gt;は真偽値（&lt;c2&gt;Bool&lt;/c2&gt;）に自動型変換し、&lt;c3&gt;for&lt;/c3&gt;はものをリストとして見るなどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Between letters you can also use a dash &lt;c7&gt;-&lt;/c7&gt; or an apostrophe &lt;c8&gt;'&lt;/c8&gt;, so &lt;c9&gt;isn't&lt;/c9&gt; and &lt;c10&gt;double-click&lt;/c10&gt; are valid identifiers.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154022Z" creationid="Toshiyuki" creationdate="20131026T034400Z">
        <seg>文字の間にダッシュ（&lt;c7&gt;-&lt;/c7&gt;）またはアポストロフィ（&lt;c8&gt;'&lt;/c8&gt;）を使うこともできます。したがって「&lt;c9&gt;isn't&lt;/c9&gt;」と「&lt;c10&gt;double-click&lt;/c10&gt;」は識別子として有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beyond this, traits (traits) allow you to associate extra data with parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T074558Z" creationid="Toshiyuki" creationdate="20140111T074558Z">
        <seg>これの他に、トレイトは追加のデータをパラメータと結びつけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bindability checks</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115434Z" creationid="Toshiyuki" creationdate="20140113T063405Z">
        <seg>バインド可能性のチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binding of &lt;c2&gt;Nil&lt;/c2&gt; with &lt;c3&gt;:=&lt;/c3&gt; simply puts Nil in the container.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140401T115007Z" creationid="Toshiyuki" creationdate="20140401T115007Z">
        <seg>&lt;c2&gt;Nil&lt;/c2&gt;を&lt;c3&gt;:=&lt;/c3&gt;てバインドすることは単純にコンテナにNilを置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binding this node to a function could use the appropriate parameter syntax to work with various children and attributes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T130844Z" creationid="Toshiyuki" creationdate="20140110T161238Z">
        <seg>このノードを関数に結びつけることは、いろいろな子と属性で動作に適切なパラメータ構文を使うことができるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blocks are delimited by curlies, or by the beginning and end of the current compilation unit (either the current file or the current &lt;c0&gt;eval&lt;/c0&gt; string).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T121446Z" creationid="Toshiyuki" creationdate="20130729T121446Z">
        <seg>ブロックはカーリーブラケットか、現在のコンパイル単位によって区切られる（現在のファイルか現在の&lt;c0&gt;eval&lt;/c0&gt;文字列）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both Perl 5 and Perl 6 have active developer communities which mold the languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T225532Z" creationid="Toshiyuki" creationdate="20131025T225532Z">
        <seg>Perl 5とPerl 6には、言語を形作る活発な開発者コミュニティがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both Perl 5 and Perl 6 share these attributes to varying degrees.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T230949Z" creationid="Toshiyuki" creationdate="20131025T230949Z">
        <seg>Perl 5とPerl 6は、これらの特質を共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both have a named capture.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T002220Z" creationid="Toshiyuki" creationdate="20140224T162930Z">
        <seg>両者とも、名前付きキャプチャーを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these design techniques appear in the example code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T012502Z" creationid="Toshiyuki" creationdate="20140115T101737Z">
        <seg>これらのデザインテクニックは両方とも、コード例で出現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both players independently select a symbol (rock, paper, or scissors).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T045743Z" creationid="Toshiyuki" creationdate="20140113T045743Z">
        <seg>両方のプレーヤーは、シンボル（岩、紙またははさみ）を独立して選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both the &lt;c0&gt;AnswerToAll&lt;/c0&gt; and &lt;c1&gt;AnswerIfTalkedTo&lt;/c1&gt; roles provide a method named &lt;c2&gt;process&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T015702Z" creationid="Toshiyuki" creationdate="20140115T135928Z">
        <seg>&lt;c0&gt;AnswerToAll&lt;/c0&gt;と&lt;c1&gt;AnswerIfTalkedTo&lt;/c1&gt;ロールは両方とも&lt;c2&gt;process&lt;/c2&gt;という名前のメソッドを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bracketing Characters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053433Z" creationid="Toshiyuki" creationdate="20140330T053433Z">
        <seg>ブラケット文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Building a class out of roles uses a safe mechanism called &lt;e0&gt;flattening composition&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122604Z" creationid="Toshiyuki" creationdate="20140115T101716Z">
        <seg>クラスをロールから構築することは、&lt;e0&gt;平坦化合成&lt;/e0&gt;と呼ばれる安全なメカニズムを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-In Data Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140325T141352Z" creationid="Toshiyuki" creationdate="20140325T141352Z">
        <seg>ビルトインデータ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-in types, operators and methods</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T024950Z" creationid="Toshiyuki" creationdate="20140226T142334Z">
        <seg>組み込みの型、演算子、メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But &lt;c0&gt;state&lt;/c0&gt; automatically applies "once" semantics to any initializer, so this also works:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T031051Z" creationid="Toshiyuki" creationdate="20130822T031051Z">
        <seg>しかし&lt;c0&gt;state&lt;/c0&gt;はどんなイニシャライザにも自動的に「once」セマンティクスを適用するので、これも動作する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But as always, you must use them all:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152144Z" creationid="Toshiyuki" creationdate="20130810T152144Z">
        <seg>しかしいつも通り、それらを全て使う必要がある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But beware that parenthesis directly after an identifier -- without any whitespace between -- are always parsed as the argument list, so</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T134216Z" creationid="Toshiyuki" creationdate="20131027T121553Z">
        <seg>しかし識別子の後にくる直接の括弧 ― 間に空白のない ― は常に引数リストとしてパースされます。そのため</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But generally that means you should refactor instead.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115447Z" creationid="Toshiyuki" creationdate="20130813T115447Z">
        <seg>しかし一般には代わりにリファクターするべきだということを意味する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But there are other applications too: a routine that serializes objects to a bunch of bytes needs to know the attributes of that object, which it can find out via introspection.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110443Z" creationid="Toshiyuki" creationdate="20140112T164306Z">
        <seg>しかし、他の適用もあります：多くのバイトにオブジェクトをシリアライズするルーチンはそのオブジェクトの属性を知っている必要があり、そしてそれはイントロスペクションを通して発見することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But these two are valid:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T032204Z" creationid="Toshiyuki" creationdate="20130803T032204Z">
        <seg>しかしこれら二つは有効だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But to do that, it may eventually have to peel back any number of layers of dynamic call frames internal to the subroutine's current call frame.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T003645Z" creationid="Toshiyuki" creationdate="20130728T003645Z">
        <seg>それを行うためには、結局は皮をむき、ダイナミックコールフレーム内部のたくさんのレイヤーからサブルーチンの現在のコールフレームへ戻らなければならないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But use of a &lt;c2&gt;default&lt;/c2&gt; block is good documentation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133703Z" creationid="Toshiyuki" creationdate="20130811T133703Z">
        <seg>しかし&lt;c2&gt;default&lt;/c2&gt;ブロックの使用はよいドキュメンテーションだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast, a &lt;e4&gt;mutable&lt;/e4&gt; object may be changed after being created.) to a parameter that has the &lt;c5&gt;is rw&lt;/c5&gt; trait, the binding will fail at the time of the call and throw an exception:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T001120Z" creationid="Toshiyuki" creationdate="20131205T104329Z">
        <seg>対照的に、&lt;e4&gt;可変&lt;/e4&gt;オブジェクトは作成後に変更することができます。）に&lt;c5&gt;is rw&lt;/c5&gt;トレイトをつけて渡すと、呼び出し時にバインディングが失敗して例外をスローします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast, the &lt;c0&gt;:U&lt;/c0&gt; adverb can be used to indicate that the parameter requires an undefined or &lt;e1&gt;abstract&lt;/e1&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T132513Z" creationid="Toshiyuki" creationdate="20140110T132513Z">
        <seg>対照的に、&lt;c0&gt;:U&lt;/c0&gt;副詞はパラメータが未定義か&lt;e1&gt;抽象&lt;/e1&gt;オブジェクトを必要とすることを示すのに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default the innermost call frame matching the selection criteria will be exited.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T073639Z" creationid="Toshiyuki" creationdate="20130817T073639Z">
        <seg>デフォルトでは選択基準にマッチする最も深いコールフレームは抜けだされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default the second declaration will get a compiler warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T130008Z" creationid="Toshiyuki" creationdate="20130730T130008Z">
        <seg>デフォルトでは、二回目の宣言はコンパイラーの警告が出るだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, &lt;c0&gt;subst&lt;/c0&gt; performs a single match and stops.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131316Z" creationid="Toshiyuki" creationdate="20140222T023233Z">
        <seg>デフォルトで&lt;c0&gt;subst&lt;/c0&gt;は一つのマッチを実行して止まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, subroutines are lexically scoped, just like any variable declared with &lt;c0&gt;my&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T000220Z" creationid="Toshiyuki" creationdate="20131029T132405Z">
        <seg>デフォルトでは&lt;c0&gt;my&lt;/c0&gt;で宣言された変数のように、サブルーチンはレキシカルスコープです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, whitespace inside the regex is irrelevant for the matching, so writing the regex as &lt;c2&gt;m/ perl /&lt;/c2&gt;, &lt;c3&gt;m/perl/&lt;/c3&gt; or &lt;c4&gt;m/ p e rl/&lt;/c4&gt; all produce the exact same semantics--although the first way is probably the most readable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T022839Z" creationid="Toshiyuki" creationdate="20140115T143716Z">
        <seg>デフォルトでは正規表現の内側の空白文字はマッチに無関係で、&lt;c2&gt;m/ perl /&lt;/c2&gt;、&lt;c3&gt;m/perl/&lt;/c3&gt;または&lt;c4&gt;m/ p e rl/&lt;/c4&gt;のように正規表現を書くとすべて同じ意味となります ― しかし、最初が多分最も読みやすいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calculations involving &lt;c1&gt;Num&lt;/c1&gt; numbers are usually quite fast, though subject to limited precision.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014133Z" creationid="Toshiyuki" creationdate="20140226T143732Z">
        <seg>限られた精度の影響を受けるけれども、&lt;c1&gt;Num&lt;/c1&gt;を含んでいる計算は通常はかなり速いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling &lt;c2&gt;make $thing&lt;/c2&gt; in an action method sets the &lt;c3&gt;ast&lt;/c3&gt; attribute of the current match object to &lt;c4&gt;$thing&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T000713Z" creationid="Toshiyuki" creationdate="20140224T162506Z">
        <seg>アクションメソッドでの&lt;c2&gt;make $thing&lt;/c2&gt;の呼び出しは、現在のマッチオブジェクトの&lt;c3&gt;ast&lt;/c3&gt;属性を&lt;c4&gt;$thing&lt;/c4&gt;にセットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling all candidates</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140115T141040Z" creationid="Toshiyuki" creationdate="20140115T141040Z">
        <seg>すべての候補を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the &lt;c1&gt;swap&lt;/c1&gt; routine with an immutable value (for example a number literal) will fail.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T035057Z" creationid="Toshiyuki" creationdate="20140113T063535Z">
        <seg>&lt;c1&gt;swap&lt;/c1&gt;ルーチンを不変の値（たとえば数値リテラル）で呼ぶことは失敗するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling this script without command line arguments leaves all three parameters at their default values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T085722Z" creationid="Toshiyuki" creationdate="20140111T085722Z">
        <seg>コマンドライン引数なしにスクリプトを呼び出すと、3つのパラメータはデフォルト値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Candidate signatures may contain any number of positional and named arguments, both explicit and slurpy.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114314Z" creationid="Toshiyuki" creationdate="20140113T045308Z">
        <seg>候補シグネチャーは、多くの前後関係に依存して名をつけられた引数（明確で大食いな）を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Candidates can specify more complex signatures:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T184336Z" creationid="Toshiyuki" creationdate="20140112T184336Z">
        <seg>候補はより複雑なシグネチャを指定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Captures</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T132819Z" creationid="Toshiyuki" creationdate="20140110T132819Z">
        <seg>キャプチャー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Captures In Signatures</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T041809Z" creationid="Toshiyuki" creationdate="20140110T161459Z">
        <seg>シグネチャー内のキャプチャー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Captures have both positional and named parts which act like lists and hashes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T172950Z" creationid="Toshiyuki" creationdate="20140110T140140Z">
        <seg>キャプチャーはリストとハッシュのように振る舞う位置依存と名前付きの部分を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cases where an arbitrary number of arguments are allowed are handled with slurpy parameters instead:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T035636Z" creationid="Toshiyuki" creationdate="20140113T063903Z">
        <seg>任意の数の引数が許可されるケースは、その代わりにslurpyなパラメータで取り扱われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes to run-time properties are done via mixin instead, so that the compiler can optimize based on declared traits.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T102243Z" creationid="Toshiyuki" creationdate="20140330T102243Z">
        <seg>実行時のプロパティの変化は代わりにミックスインで行われます。そのためコンパイラは宣言されたトレイトを元に最適化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter 2 demonstrated simple subroutines.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131231Z" creationid="Toshiyuki" creationdate="20131029T131231Z">
        <seg>第2章は単純なサブルーチンを示しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter &lt;a0&gt;link&lt;/a0&gt; showed how to use nested signatures to look deeper into data structures and extract parts of them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T040919Z" creationid="Toshiyuki" creationdate="20140315T040919Z">
        <seg>章の&lt;a0&gt;リンク&lt;/a0&gt;はデータ構造の中により深く見て、それらの部分を抜き出すために入れ子になったシグネチャを使用する方法を示しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose them carefully!</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140101T053507Z" creationid="Toshiyuki" creationdate="20140101T053507Z">
        <seg>それらは慎重に選んでください！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class declarations frozen at compilation time are often sufficient, but sometimes it's useful to add new behaviors to individual objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T040513Z" creationid="Toshiyuki" creationdate="20140115T142111Z">
        <seg>コンパイル時で凍結されるクラス宣言はしばしば十分ですが、新しい振る舞いを個々のオブジェクトに加えることは時々有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131047Z" creationid="Toshiyuki" creationdate="20140329T131047Z">
        <seg>クラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and Objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T174234Z" creationid="Toshiyuki" creationdate="20140111T174234Z">
        <seg>クラスとオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code that is generated at run time can still fire off &lt;c0&gt;CHECK&lt;/c0&gt; and &lt;c1&gt;INIT&lt;/c1&gt; phasers, though of course those phasers can't do things that would require travel back in time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T092236Z" creationid="Toshiyuki" creationdate="20130818T092236Z">
        <seg>実行時に生成されるコードは&lt;c0&gt;CHECK&lt;/c0&gt;と&lt;c1&gt;INIT&lt;/c1&gt;　phasersをまだ発射できる。けれどももちろんそれらのphasersは時間内に行ったり来たりすることを要求することができない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coercive type declarations</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053600Z" creationid="Toshiyuki" creationdate="20140330T053600Z">
        <seg>制約型宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparisons and Smart Matching</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T125014Z" creationid="Toshiyuki" creationdate="20131027T125014Z">
        <seg>比較とスマートマッチング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compile Time Composition</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122629Z" creationid="Toshiyuki" creationdate="20140115T101943Z">
        <seg>コンパイル時合成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computer scientists call this a &lt;e1&gt;stable sort&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T145600Z" creationid="Toshiyuki" creationdate="20131026T145600Z">
        <seg>コンピューターサイエンスの専門家はこれを&lt;e1&gt;ステーブルソート&lt;/e1&gt;と呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional statement modifiers work as in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T103406Z" creationid="Toshiyuki" creationdate="20130804T103406Z">
        <seg>条件付き文の修飾子はPerl 5のように動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T042318Z" creationid="Toshiyuki" creationdate="20130803T042318Z">
        <seg>条件付きの文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider a module that provided the example from the "Optional Parameters" section:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T044037Z" creationid="Toshiyuki" creationdate="20140111T044037Z">
        <seg>「オプションのパラメータ」セクションで提供されている例のモジュールを考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider quicksort.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T073307Z" creationid="Toshiyuki" creationdate="20140113T073307Z">
        <seg>クイックソートを考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the class definition:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140115T135834Z" creationid="Toshiyuki" creationdate="20140115T135834Z">
        <seg>クラス定義についてよく考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the second method, &lt;c1&gt;add-dependency&lt;/c1&gt;, which adds a new task to this task's dependency list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185123Z" creationid="Toshiyuki" creationdate="20140111T185103Z">
        <seg>第2のメソッドを考慮してください、&lt;c1&gt;add-dependency&lt;/c1&gt;は新しい仕事をこの仕事の依存リストに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the table tennis example from the previous chapter.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T044216Z" creationid="Toshiyuki" creationdate="20131027T044216Z">
        <seg>前の章の卓球の例を考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants (and enums) default to &lt;c1&gt;our&lt;/c1&gt; scoping so they can be accessed from outside the package.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T132343Z" creationid="Toshiyuki" creationdate="20130802T132127Z">
        <seg>定数（と列挙型）は&lt;c1&gt;our&lt;/c1&gt;スコープで初期化されるので、外側のパッケージからアクセスできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constraint checking occurs next, and only if the constraint check of the narrowest candidate fails, other candidates are tried that are lass narrow by nominal type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114136Z" creationid="Toshiyuki" creationdate="20140113T044901Z">
        <seg>チェックしている制約は次に出現します。そして最も制限された候補失敗の制約チェックがある場合だけ、名目上の型によって制限された娘である他の候補は裁判にかけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constraints</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T184316Z" creationid="Toshiyuki" creationdate="20140112T184316Z">
        <seg>制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constraints and container types can be used together:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132506Z" creationid="Toshiyuki" creationdate="20140327T132506Z">
        <seg>制約とコンテナ型は一緒に使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructors</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T193050Z" creationid="Toshiyuki" creationdate="20140111T193050Z">
        <seg>コンストラクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructs marked with a &lt;c0&gt;*&lt;/c0&gt; have a run-time value, and if evaluated earlier than their surrounding expression, they simply save their result for use in the expression later when the rest of the expression is evaluated:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T082758Z" creationid="Toshiyuki" creationdate="20130818T082758Z">
        <seg>&lt;c0&gt;*&lt;/c0&gt;でマークされた構造は実行時の値を持つ。そしてそれらを囲う文より早く評価されたら、それらは文の残りが評価された時に後で文で使うために単純に結果を保存する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructs such as &lt;c0&gt;if&lt;/c0&gt; automatically evaluate their conditions in boolean context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021636Z" creationid="Toshiyuki" creationdate="20140322T021636Z">
        <seg>&lt;c0&gt;if&lt;/c0&gt;のような構造はそれらを自動的にブール値コンテキストで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consuming our class</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141603Z" creationid="Toshiyuki" creationdate="20140112T090531Z">
        <seg>自分のクラスを使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Container Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132156Z" creationid="Toshiyuki" creationdate="20140327T132156Z">
        <seg>コンテナ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Container types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224446Z" creationid="Toshiyuki" creationdate="20140328T224446Z">
        <seg>コンテナ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Container types such as lists and hashes evaluate to &lt;c0&gt;False&lt;/c0&gt; if they are empty, and to &lt;c1&gt;True&lt;/c1&gt; if they contain at least one value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021548Z" creationid="Toshiyuki" creationdate="20140322T021548Z">
        <seg>リストとハッシュのようなコンテナ型はそれらが空なら&lt;c0&gt;False&lt;/c0&gt;、少なくとも1つの値を含んでいれば&lt;c1&gt;True&lt;/c1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Containers enforce type safety on setting, whereas subroutines enforce type safety on return.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T223645Z" creationid="Toshiyuki" creationdate="20140328T223645Z">
        <seg>コンテナはセット時に型安全を強制するのに対し、サブルーチンはreturn時に型安全を強制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contents</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T004127Z" creationid="Toshiyuki" creationdate="20140309T004127Z">
        <seg>内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control exceptions may be caught with a &lt;c1&gt;CONTROL&lt;/c1&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125447Z" creationid="Toshiyuki" creationdate="20130816T125447Z">
        <seg>制御例外は&lt;c1&gt;CONTROL&lt;/c1&gt;ブロックでキャッチできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, &lt;c2&gt;$x.substr&lt;/c2&gt; implies conversion to a string or buffer type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T233548Z" creationid="Toshiyuki" creationdate="20140328T233548Z">
        <seg>反対に、&lt;c2&gt;$x.substr&lt;/c2&gt;は文字列かバッファー型への変換を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating And Using A Capture</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T140402Z" creationid="Toshiyuki" creationdate="20140110T140402Z">
        <seg>キャプチャーの作成と使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currying</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T043631Z" creationid="Toshiyuki" creationdate="20140111T043631Z">
        <seg>カリー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currying gives you a shortcut for these exact cases; it creates a new sub from an existing sub, with parameters already filled in.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T053446Z" creationid="Toshiyuki" creationdate="20140111T053446Z">
        <seg>カリーはこれらの例に対してショートカットを与えます；それは存在するサブルーチンからパラメータがすでに満たされた状態で新しいサブルーチンを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarators generally make the colon optional:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082408Z" creationid="Toshiyuki" creationdate="20140329T082408Z">
        <seg>宣言文は一般にコロンを任意にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring a Subroutine</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131425Z" creationid="Toshiyuki" creationdate="20131029T131425Z">
        <seg>サブルーチンの宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring a class creates a &lt;e0&gt;type object&lt;/e0&gt; which, by default, is installed into the current package (just like a variable declared with &lt;c1&gt;our&lt;/c1&gt; scope).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T181132Z" creationid="Toshiyuki" creationdate="20140111T181132Z">
        <seg>クラスの宣言は&lt;e0&gt;型オブジェクト&lt;/e0&gt;を作ります。それはデフォルトでは現在のパッケージに設置されます（ちょうど&lt;c1&gt;our&lt;/c1&gt;スコープで変数を宣言するように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring a custom constructor provides a simple way of declaring tasks along with their dependencies.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141645Z" creationid="Toshiyuki" creationdate="20140112T090658Z">
        <seg>カスタムコンストラクタを宣言することは、それらの従属物とともにタスクを宣言するシンプルな方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a container type is the Perl 6 equivalent to tying a variable in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224736Z" creationid="Toshiyuki" creationdate="20140328T224736Z">
        <seg>コンテナ型を定義することはPerl 5のタイ変数のPerl 6の同等物です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Description</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T160007Z" creationid="Toshiyuki" creationdate="20140104T160007Z">
        <seg>説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Differences from compile time composition</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140317T124816Z" creationid="Toshiyuki" creationdate="20140115T142623Z">
        <seg>コンパイル時合成との違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disabling backtracking makes &lt;c2&gt;\w+&lt;/c2&gt; always match a full word:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T051057Z" creationid="Toshiyuki" creationdate="20140222T022622Z">
        <seg>バックトラックを無効にすることは、常に&lt;c2&gt;\w+&lt;/c2&gt;をフルワードにマッチさせます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do the latter by installing a &lt;e2&gt;proto&lt;/e2&gt; routine:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T043451Z" creationid="Toshiyuki" creationdate="20140113T074954Z">
        <seg>&lt;e2&gt;proto&lt;/e2&gt;ルーチンをインストールすることによって、後者をしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Double quoted strings in Perl 6 can interpolate variables with the &lt;c0&gt;$&lt;/c0&gt; sigil as well as blocks of code in curly braces.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T153451Z" creationid="Toshiyuki" creationdate="20131026T153451Z">
        <seg>Perl 6のダブルクォート付きの文字列は&lt;c0&gt;$&lt;/c0&gt;シギルと同様にブレース内のコードのブロックを変数展開できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the first iteration, &lt;c0&gt;$line&lt;/c0&gt; will contain the string &lt;c1&gt;Ana Dave | 3:0&lt;/c1&gt;; during the second, &lt;c2&gt;Charlie Beth | 3:1&lt;/c2&gt;, and so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T003923Z" creationid="Toshiyuki" creationdate="20131026T102259Z">
        <seg>最初の繰り返しの間、&lt;c0&gt;$line&lt;/c0&gt;は文字列&lt;c1&gt;Ana Dave | 3:0&lt;/c1&gt;を含みます；2番目以降は&lt;c2&gt;Charlie Beth | 3:1&lt;/c2&gt;などのようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each alternative has a name of the form &lt;c2&gt;token value:sym&lt;thing&gt;&lt;/c2&gt;, which can be read as &lt;e3&gt;alternative of &lt;c4&gt;value&lt;/c4&gt; with parameter &lt;c5&gt;sym&lt;/c5&gt; set to &lt;c6&gt;thing&lt;/c6&gt;&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T151216Z" creationid="Toshiyuki" creationdate="20140223T094736Z">
        <seg>各々の選択肢は&lt;c2&gt;token value:sym&lt;thing&gt;&lt;/c2&gt;という形式の名前を持っています。それはパラメータ&lt;c5&gt;sym&lt;/c5&gt;に&lt;c6&gt;thing&lt;/c6&gt;にセットする&lt;c4&gt;value&lt;/c4&gt;の選択肢と解釈されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each chapter opens with a reasonably complete example that illustrates the topic of the chapter.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T223423Z" creationid="Toshiyuki" creationdate="20131025T223423Z">
        <seg>各々の章は、章の主題を例示する適度に完成した例で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each iteration's value is returned as a single "argument" object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T131157Z" creationid="Toshiyuki" creationdate="20130808T131157Z">
        <seg>それぞれの反復の値は一つの「引数」オブジェクトとして返される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each line will contain a key, followed by a tab character, then the value associated with that key, and finally a newline.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T154156Z" creationid="Toshiyuki" creationdate="20131026T154156Z">
        <seg>それぞれの行はタブ文字が続くキーを含むでしょう。そしてそのキーに結びついている値、最後に改行文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each match object has a slot called &lt;c0&gt;ast&lt;/c0&gt; (short for &lt;e1&gt;abstract syntax tree&lt;/e1&gt;) for a payload object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T001047Z" creationid="Toshiyuki" creationdate="20140224T162423Z">
        <seg>各々のマッチオブジェクトは、ペイロード（データ本体）オブジェクトのために&lt;c0&gt;ast&lt;/c0&gt;（&lt;e1&gt;抽象構文木&lt;/e1&gt;の略）と呼ばれるスロットを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each multi dispatch builds a list of candidates, all of which satisfy the nominal type constraints.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T120937Z" creationid="Toshiyuki" creationdate="20140113T075601Z">
        <seg>各々のマルチディスパッチは候補のリストを構築します。そしてその全ては名目型制約を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of the &lt;c4&gt;token&lt;/c4&gt; and &lt;c5&gt;rule&lt;/c5&gt; declarations are just &lt;c6&gt;regex&lt;/c6&gt; declarations with special default behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T135638Z" creationid="Toshiyuki" creationdate="20140222T130950Z">
        <seg>&lt;c4&gt;token&lt;/c4&gt;と&lt;c5&gt;rule&lt;/c5&gt;宣言の各々は、特別なデフォルト動作によるただの&lt;c6&gt;regex&lt;/c6&gt;宣言です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of these objects describes one parameter in detail.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T074118Z" creationid="Toshiyuki" creationdate="20140111T074118Z">
        <seg>これらのオブジェクトの各々は、詳細に1つのパラメータを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each subsequent clone gets an initial state that is one higher than the previous, and each clone maintains its own state of &lt;c0&gt;$x&lt;/c0&gt;, because that's what &lt;c1&gt;state&lt;/c1&gt; variables do.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T031421Z" creationid="Toshiyuki" creationdate="20130822T031421Z">
        <seg>それぞれの後に続く複製は前よりも1高い初期stateを得る。そしてそれぞれのクローンは独自の&lt;c0&gt;$x&lt;/c0&gt;のstateを&lt;c1&gt;state&lt;/c1&gt;変数がするように扱う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded Comments</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053453Z" creationid="Toshiyuki" creationdate="20140330T053453Z">
        <seg>埋め込みコメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty strings and &lt;c0&gt;"0"&lt;/c0&gt; evaluate to &lt;c1&gt;False&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021400Z" creationid="Toshiyuki" creationdate="20140322T021400Z">
        <seg>空文字列と&lt;c0&gt;"0"&lt;/c0&gt;は&lt;c1&gt;False&lt;/c1&gt;と評価する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enclosing a regex name in angle brackets causes the regex engine to attempt to match a regex by that name within the same grammar.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T142126Z" creationid="Toshiyuki" creationdate="20140222T132300Z">
        <seg>正規表現名をアングルブラケットで囲むことは、正規表現エンジンに同じ文法の範囲内でその名前によって正規表現にマッチしようとさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent Assertion</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T085431Z" creationid="Toshiyuki" creationdate="20140321T085431Z">
        <seg>同等のアサーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if the two arrays &lt;c1&gt;@a&lt;/c1&gt; and &lt;c2&gt;@b&lt;/c2&gt; &lt;e3&gt;contain&lt;/e3&gt; the same values, if their containers are two separate array objects, they will have different identities and will &lt;e4&gt;not&lt;/e4&gt; be equivalent when compared with &lt;c5&gt;===&lt;/c5&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T135116Z" creationid="Toshiyuki" creationdate="20131028T123334Z">
        <seg>もし2つの配列&lt;c1&gt;@a&lt;/c1&gt;と&lt;c2&gt;@b&lt;/c2&gt;が同じ値を&lt;e3&gt;含む&lt;/e3&gt;としても、コンテナが2つの別々の配列オブジェクトであるならば、それらは異なる同一性を持ち、&lt;c5&gt;===&lt;/c5&gt;で比較されるとき&lt;e4&gt;等しくない&lt;/e4&gt;でしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even in the absence of closure cloning, &lt;c0&gt;INIT&lt;/c0&gt; runs before the mainline code, while &lt;c1&gt;once&lt;/c1&gt; puts off the initialization till the last possible moment, then runs exactly once, and caches its value for all subsequent calls (assuming it wasn't called in sink context, in which case the &lt;c2&gt;once&lt;/c2&gt; is evaluated once only for its side effects).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130825T072119Z" creationid="Toshiyuki" creationdate="20130825T072119Z">
        <seg>クロージャの複製なしでも、&lt;c0&gt;INIT&lt;/c0&gt;はメインラインコードの前に実行する。&lt;c1&gt;once&lt;/c1&gt;が最後の可能な時まで延期する間、一度実行し、後の呼び出しのために値をキャッシュする（sinkコンテキストで呼ばれないと仮定し、&lt;c2&gt;once&lt;/c2&gt;が副作用のために1回だけ評価される場合）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even releases will contain some amount of &lt;c0&gt;TODO&lt;/c0&gt; comments prior to the printing of the book.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T022340Z" creationid="Toshiyuki" creationdate="20140322T022340Z">
        <seg>リリースでさえ、本をプリントするまえに&lt;c0&gt;TODO&lt;/c0&gt;コメントをいくらか含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even so, &lt;c0&gt;$/.caps&lt;/c0&gt; follows the ordering of the string, not of the regex.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134621Z" creationid="Toshiyuki" creationdate="20140222T025437Z">
        <seg>それでも&lt;c0&gt;$/.caps&lt;/c0&gt;は正規表現ではなく文字列の順位付けに従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even so, we pray the reader's indulgence and understanding.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T022713Z" creationid="Toshiyuki" creationdate="20140322T022639Z">
        <seg>それでも、我々は読者の寛大さと理解を願います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though they share a name, the methods perform semantically different--and conflicting--behaviors.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T020022Z" creationid="Toshiyuki" creationdate="20140115T135945Z">
        <seg>たとえそれらが名前を共有するとしても、そのメソッドは意味論的に異なり ― そして競合する ― 振る舞いを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every Perl 6 program should begin with &lt;c0&gt;use v6;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T024429Z" creationid="Toshiyuki" creationdate="20131026T015841Z">
        <seg>あらゆるPerl 6プログラムは&lt;c0&gt;use v6;&lt;/c0&gt;で始まるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every block is a closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T115438Z" creationid="Toshiyuki" creationdate="20130729T115438Z">
        <seg>全てのブロックはクロージャだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every candidate resembles:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T183446Z" creationid="Toshiyuki" creationdate="20140112T183446Z">
        <seg>すべての候補は似ています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every object can produce a "WHICH" value that uniquely identifies the object for hashing and other value-based comparisons.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T122046Z" creationid="Toshiyuki" creationdate="20140328T122046Z">
        <seg>全てのオブジェクトはハッシュと他の値ベースの比較のためにオブジェクトをユニークに識別する“WHICH”値を生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every regex match returns an object of type &lt;c0&gt;Match&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T085527Z" creationid="Toshiyuki" creationdate="20140222T024639Z">
        <seg>すべての正規表現マッチは&lt;c0&gt;Match&lt;/c0&gt;型のオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every subsequent line records a result of a match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T153440Z" creationid="Toshiyuki" creationdate="20131026T015512Z">
        <seg>以降のすべての行は試合の結果を記録しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Everything else within a lift is assumed to mean something in the caller's linguistic context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T074637Z" creationid="Toshiyuki" creationdate="20130811T074637Z">
        <seg>liftの中の他のすべてのものは呼び出し元の言語のコンテキストの何かを意味すると仮定される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example calls to this script:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121629Z" creationid="Toshiyuki" creationdate="20140322T121629Z">
        <seg>スクリプトの呼び出し例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121726Z" creationid="Toshiyuki" creationdate="20131027T121726Z">
        <seg>例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except for such formal parameter declarations, all lexically scoped declarations are visible from the point of declaration to the end of the enclosing block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T130432Z" creationid="Toshiyuki" creationdate="20130729T130432Z">
        <seg>このような仮パラメータ宣言を除いて、すべてのレキシカルスコープの宣言は宣言の時点から取り囲むブロックの終了ま可視だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception handlers</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121138Z" creationid="Toshiyuki" creationdate="20130813T121138Z">
        <seg>例外ハンドラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception handlers are supposed to reduce uncertainty, not increase it.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T091632Z" creationid="Toshiyuki" creationdate="20130818T091632Z">
        <seg>例外ハンドラは不確実に減らすと思われる。増加ではない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exceptions are not resumable in Perl 6 unless the exception object does the &lt;c1&gt;Resumable&lt;/c1&gt; role.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T114557Z" creationid="Toshiyuki" creationdate="20130817T114557Z">
        <seg>例外オブジェクトが&lt;c1&gt;Resumable&lt;/c1&gt;ロールを行わない限り例外はPerl 6で再開可能ではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exercises</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T165221Z" creationid="Toshiyuki" creationdate="20131026T165221Z">
        <seg>練習問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit types are optional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T165359Z" creationid="Toshiyuki" creationdate="20140328T165359Z">
        <seg>型の明示は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressing requirements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140115T141652Z" creationid="Toshiyuki" creationdate="20140115T141652Z">
        <seg>必要条件を表す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions inside the signature are parsed as parameter declarations rather than ordinary expressions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082234Z" creationid="Toshiyuki" creationdate="20140329T082234Z">
        <seg>シグネチャーの中の式は普通の式よりもパラメータ宣言としてパースされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extracting data</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T230426Z" creationid="Toshiyuki" creationdate="20140223T104939Z">
        <seg>データを抜き出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failing to pass something that matches this constraint will cause the call to fail:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T005730Z" creationid="Toshiyuki" creationdate="20131221T002455Z">
        <seg>渡した何かが制約のマッチに失敗すると呼び出しに失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally &lt;c0&gt;$o.^methods(:local)&lt;/c0&gt; produces a list of methods that can be called on &lt;c1&gt;$o&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T151752Z" creationid="Toshiyuki" creationdate="20140112T153139Z">
        <seg>最後に&lt;c0&gt;$o.^methods(:local)&lt;/c0&gt;は&lt;c1&gt;$o&lt;/c1&gt;で呼び出すことができるメソッドのリストを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the &lt;c0&gt;,&lt;/c0&gt; operator constructs a &lt;c1&gt;Parcel&lt;/c1&gt;, which is a sequence of objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T050244Z" creationid="Toshiyuki" creationdate="20131027T050244Z">
        <seg>最後に、&lt;c0&gt;,&lt;/c0&gt;演算子は&lt;c1&gt;Parcel&lt;/c1&gt;を構築します。それは連続したオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the &lt;c0&gt;perform&lt;/c0&gt; method call recursively calls the &lt;c1&gt;perform&lt;/c1&gt; method on the various other dependencies in order, giving the output:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T092751Z" creationid="Toshiyuki" creationdate="20140112T092751Z">
        <seg>最後に&lt;c0&gt;perform&lt;/c0&gt;メソッドは&lt;c1&gt;perform&lt;/c1&gt;メソッドを様々な従属オーダーに対して呼び出し、出力を得ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the method sets the &lt;c2&gt;$!done&lt;/c2&gt; attribute to &lt;c3&gt;True&lt;/c3&gt;, so that subsequent invocations of &lt;c4&gt;perform&lt;/c4&gt; on this object (if this &lt;c5&gt;Task&lt;/c5&gt; is a dependency of another &lt;c6&gt;Task&lt;/c6&gt;, for example) will not repeat the task.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T050133Z" creationid="Toshiyuki" creationdate="20140111T192928Z">
        <seg>最後にメソッドは&lt;c2&gt;$!done&lt;/c2&gt;属性に&lt;c3&gt;True&lt;/c3&gt;をセットします。そのためこのオブジェクトの以降の&lt;c4&gt;perform&lt;/c4&gt;の実行（例えばもしこの&lt;c5&gt;Task&lt;/c5&gt;が他の&lt;c6&gt;Task&lt;/c6&gt;の依存だったら)は仕事を繰り返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, this list gets stored in the array &lt;c0&gt;@names&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T081145Z" creationid="Toshiyuki" creationdate="20131026T081145Z">
        <seg>最後に、このリストは配列&lt;c0&gt;@names&lt;/c0&gt;に格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, to pass an existing &lt;c0&gt;Pair&lt;/c0&gt; object to a subroutine by position, not name, either put it in parentheses (like &lt;c1&gt;(:$thing)&lt;/c1&gt;), or use the &lt;c2&gt;=&gt;&lt;/c2&gt; operator with a quoted string on the left-hand side: &lt;c3&gt;"thing" =&gt; $thing&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T013653Z" creationid="Toshiyuki" creationdate="20140104T161049Z">
        <seg>最後に、存在する&lt;c0&gt;Pair&lt;/c0&gt;オブジェクトを名前ではなく位置で渡すために、それを括弧の中に置くか（&lt;c1&gt;(:$thing)&lt;/c1&gt;のように）、&lt;c2&gt;=&gt;&lt;/c2&gt;演算子をクオートされた文字列で左側に置きます：&lt;c3&gt;"thing" =&gt; $thing&lt;/c3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, declaring this routine as a method adds it to the list of methods for the current class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185257Z" creationid="Toshiyuki" creationdate="20140111T185257Z">
        <seg>1番目に、このルーチンをメソッドと宣言することは、現在のクラスのためにそれをメソッドのリストに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it checks if the task has already completed by checking the &lt;c0&gt;$!done&lt;/c0&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T190640Z" creationid="Toshiyuki" creationdate="20140111T190640Z">
        <seg>最初に、それは仕事がすでに終わっているか&lt;c0&gt;$!done&lt;/c0&gt;属性を調べて確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it declares the arguments which callers may or must pass to the subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131126T123809Z" creationid="Toshiyuki" creationdate="20131126T123630Z">
        <seg>1つ目に、呼び出し元がサブルーチンに渡すことができる、または渡さなければならない引数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, the subroutine declarator &lt;c0&gt;sub&lt;/c0&gt; indicates that you are starting a subroutine declaration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131601Z" creationid="Toshiyuki" creationdate="20131029T131601Z">
        <seg>最初に、サブルーチン宣言&lt;c0&gt;sub&lt;/c0&gt;はあなたがサブルーチン宣言を始めていることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First-class subroutines can help you solve complex problems.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T133543Z" creationid="Toshiyuki" creationdate="20131029T133543Z">
        <seg>ファーストクラスサブルーチンは複雑な問題を解決するのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Perl 6 we have to make this preference for lexotic behavior explicit.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T081915Z" creationid="Toshiyuki" creationdate="20130817T081915Z">
        <seg>Perl 6ではこの優先傾向を明示的なレギゾチックな振る舞いのために作る必要がある。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a container, however, use of a coercion type as the &lt;c0&gt;of&lt;/c0&gt; coerces upon setting rather than returning the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224441Z" creationid="Toshiyuki" creationdate="20140328T224441Z">
        <seg>コンテナについては、&lt;c0&gt;of&lt;/c0&gt;としての型の強制の使用は値を返すよりもセットする方に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a normal sub or method call, the dispatcher invokes the first candidate which passes any additional constraint checks.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121054Z" creationid="Toshiyuki" creationdate="20140113T075632Z">
        <seg>通常のサブまたはメソッド呼び出しのために、ディスパッチャーはさらなる制約チェックを渡す最初の候補を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all builtin operations, all &lt;c0&gt;Str&lt;/c0&gt; positions are reported as position objects, not integers.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T133559Z" creationid="Toshiyuki" creationdate="20140328T133559Z">
        <seg>全ての組み込み演算のために、全ての&lt;c0&gt;Str&lt;/c0&gt;の位置は整数ではなく位置オブジェクトとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For any statement, prefixing with a &lt;c0&gt;do&lt;/c0&gt; allows you to return the value of that statement and use it in an expression:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T121351Z" creationid="Toshiyuki" creationdate="20130810T121351Z">
        <seg>どんな文でも、&lt;c0&gt;do&lt;/c0&gt;を前につけるとその値を返し、式として使えるようになる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each combination of chosen symbols for which Player One wins there's a candidate of the form:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114827Z" creationid="Toshiyuki" creationdate="20140113T050058Z">
        <seg>選ばれたPlayer Oneが勝つシンボルの組合せごとに候補の形式があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each item, the program uses the &lt;c2&gt;printf&lt;/c2&gt; built-in function to print both the name of the player and a bar.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T070925Z" creationid="Toshiyuki" creationdate="20131027T070925Z">
        <seg>それぞれのアイテムでプログラムは&lt;c2&gt;printf&lt;/c2&gt;組み込み関数を使い、プレーヤーの名前とバーを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each matching rule, the grammar engine calls an action method to populate the &lt;c0&gt;ast&lt;/c0&gt; slot of the match object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T135627Z" creationid="Toshiyuki" creationdate="20140224T162633Z">
        <seg>各々のマッチングルールで、グラマーエンジンはマッチオブジェクトの&lt;c0&gt;ast&lt;/c0&gt;スロットにデータを読み込むためにアクションメソッドを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c0&gt;'a' lt 'b'&lt;/c0&gt; is true, and likewise &lt;c1&gt;'a' lt 'aa'&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T125409Z" creationid="Toshiyuki" creationdate="20131028T125409Z">
        <seg>例えば、&lt;c0&gt;'a' lt 'b'&lt;/c0&gt;は真、&lt;c1&gt;'a' lt 'aa'&lt;/c1&gt;も同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c1&gt;$a + $b&lt;/c1&gt; will convert a copy of both &lt;c2&gt;$a&lt;/c2&gt; and &lt;c3&gt;$b&lt;/c3&gt; to numbers (unless they are numbers already).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T013445Z" creationid="Toshiyuki" creationdate="20140226T142601Z">
        <seg>たとえば、&lt;c1&gt;$a + $b&lt;/c1&gt;は&lt;c2&gt;$a&lt;/c2&gt;と&lt;c3&gt;$b&lt;/c3&gt;のコピーを（それらが既に数でない限り）数に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c27&gt;180.sin(Degrees)&lt;/c27&gt; is approximately &lt;c28&gt;0&lt;/c28&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020246Z" creationid="Toshiyuki" creationdate="20140322T020246Z">
        <seg>例えば&lt;c27&gt;180.sin(Degrees)&lt;/c27&gt;はおよそ&lt;c28&gt;0&lt;/c28&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c4&gt;~&lt;/c4&gt; (tilde) is the string concatenation operator; to append some text to the end of a string, you can write &lt;c5&gt;$string ~= "text"&lt;/c5&gt;, which is equivalent to &lt;c6&gt;$string = $string ~ "text"&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T045601Z" creationid="Toshiyuki" creationdate="20131027T045601Z">
        <seg>例えば、&lt;c4&gt;~&lt;/c4&gt;（チルダ）は文字列連結演算子です：何かのテキストを文字列の終わりに追加するために、&lt;c5&gt;$string ~= "text"&lt;/c5&gt;と書くことができます。これは&lt;c6&gt;$string = $string ~ "text"&lt;/c6&gt;と同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Perl forces generic &lt;c0&gt;eq&lt;/c0&gt; to coerce to string comparison, like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T074009Z" creationid="Toshiyuki" creationdate="20130811T074009Z">
        <seg>例えば、Perlはジェネリックな&lt;c0&gt;eq&lt;/c0&gt;を文字列の比較に強制する。以下のように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a subroutine that performs numeric calculations on its parameters could require that its arguments are of the type &lt;c0&gt;Numeric&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140106T130122Z" creationid="Toshiyuki" creationdate="20140106T130122Z">
        <seg>例えば、パラメータで数値計算を実行するサブルーチンは&lt;c0&gt;Numeric&lt;/c0&gt;型の引数を必要とするはずです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the caller passes two arrays, they would flatten into &lt;c1&gt;@pos&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T162611Z" creationid="Toshiyuki" creationdate="20140110T162611Z">
        <seg>例えば、呼び出し元が2つの配列を渡したらそれらは&lt;c1&gt;@pos&lt;/c1&gt;にフラット化されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131908Z" creationid="Toshiyuki" creationdate="20131029T131908Z">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it is possible to accept arguments in a certain range by writing:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140106T140952Z" creationid="Toshiyuki" creationdate="20140106T140952Z">
        <seg>例えば、次のように書くことで引数が特定のレンジを受け入れるようにすることが可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, regex matches have both positional and named matches--&lt;c0&gt;Match&lt;/c0&gt; objects themselves are a type of capture.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T130737Z" creationid="Toshiyuki" creationdate="20140110T160446Z">
        <seg>例えば、正規表現は位置と名前付き両方にマッチします ― &lt;c0&gt;Match&lt;/c0&gt;オブジェクト自身はキャプチャー型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c0&gt;@&lt;/c0&gt; sigil checks that the object passed does the &lt;c1&gt;Positional&lt;/c1&gt; role (a role which includes types like &lt;c2&gt;Array&lt;/c2&gt; and &lt;c3&gt;List&lt;/c3&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T005647Z" creationid="Toshiyuki" creationdate="20131221T002329Z">
        <seg>例えば、&lt;c0&gt;@&lt;/c0&gt;シギルはオブジェクトが&lt;c1&gt;Positional&lt;/c1&gt;ロール（&lt;c2&gt;Array&lt;/c2&gt;や&lt;c3&gt;List&lt;/c3&gt;のような型を含むロール）をするかチェックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following Perl 5 code:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T071413Z" creationid="Toshiyuki" creationdate="20140309T071413Z">
        <seg>例えば次のPerl 5コード：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to make a little ASCII art dancing figure, you could build up a hash where the keys are names of the dance moves, and the values are anonymous subroutines.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131030T135321Z" creationid="Toshiyuki" creationdate="20131030T135303Z">
        <seg>たとえば、ちょっとしたアスキーアート・ダンス・フィギュアを製作するために、あなたはキーがダンスの動作の名前であるハッシュを構築することができます。そして、値は匿名のサブルーチンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, types such as &lt;c2&gt;Int&lt;/c2&gt; and &lt;c3&gt;Str&lt;/c3&gt; refer to the type object of one of the Perl 6 built- in classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045033Z" creationid="Toshiyuki" creationdate="20140111T181352Z">
        <seg>例えば&lt;c2&gt;Int&lt;/c2&gt;と&lt;c3&gt;Str&lt;/c3&gt;のような型はPerl 6の組み込みクラスの一つの型オブジェクトを参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when populating a hash:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T160423Z" creationid="Toshiyuki" creationdate="20140104T160423Z">
        <seg>例えば、ハッシュにデータを読み込むとき：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can parse HTML very badly (footnote: Using a proper stateful parser is always more accurate.) with the code:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T230539Z" creationid="Toshiyuki" creationdate="20140221T230539Z">
        <seg>たとえば、あなたは非常にひどくHTMLを解析することができます（脚注：適切なステートフル構文解析器を使うことは、常により正確です。）次のコードで：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you could build a web form generator that knew how to get input from a user, validate it, and then call a routine with it based upon the information obtained through introspection.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044415Z" creationid="Toshiyuki" creationdate="20140111T074353Z">
        <seg>たとえば、あなたは、ユーザーからの入力を得る方法を知っているウェブフォームジェネレーターを構築することができて、それを確認して、そして、イントロスペクションから得られる情報をベースにしてルーチンを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T071641Z" creationid="Toshiyuki" creationdate="20140309T071641Z">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For finer-grained control of which iterations return values, use &lt;c0&gt;gather&lt;/c0&gt; and &lt;c1&gt;take&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T141605Z" creationid="Toshiyuki" creationdate="20130809T141605Z">
        <seg>値を返す反復のきめ細かな制御のために、&lt;c0&gt;gather&lt;/c0&gt;と&lt;c1&gt;take&lt;/c1&gt;を使え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For immutable objects (footnote: Objects whose values &lt;e1&gt;can not&lt;/e1&gt; be changed; literal values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T125506Z" creationid="Toshiyuki" creationdate="20131027T125506Z">
        <seg>不変のオブジェクト（値が変化できないオブジェクト；リテラル値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, &lt;c0&gt;$x.abs&lt;/c0&gt; implies conversion to an appropriate numeric type if &lt;c1&gt;$x&lt;/c1&gt; is "cool" but doesn't already support a method of that name.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T233441Z" creationid="Toshiyuki" creationdate="20140328T233441Z">
        <seg>例えば、もし&lt;c1&gt;$x&lt;/c1&gt;が“cool”だが既にその名前のメソッドをサポートしない場合、&lt;c0&gt;$x.abs&lt;/c0&gt;は適切な数値型への変換を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, &lt;c0&gt;next&lt;/c0&gt; with a label will prefer to exit a loop lexotically, but if there is no loop with an appropriate label in the lexical context, it will then scan upward dynamically through the call frames for any loop with the appropriate label, even though that loop will not be lexically visible.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T053246Z" creationid="Toshiyuki" creationdate="20130728T053246Z">
        <seg>例えばラベルと一緒の&lt;c0&gt;next&lt;/c0&gt;はレギゾチックにループを抜ける方を好む。しかしループのないレキシカルコンテキストでラベルが割り当てられているなら、それはコールフレームを通ってラベルの割り当てられたどんなループでも動的に上方へスキャンするだろう。しかしながらループはレキシカルな可視ではないだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, &lt;c3&gt;JSON::Tiny::Grammar.parse($tester, :rule&lt;object&gt;)&lt;/c3&gt; will start parsing at the regex named &lt;c4&gt;object&lt;/c4&gt; ).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T134746Z" creationid="Toshiyuki" creationdate="20140222T095643Z">
        <seg>例えば、&lt;c3&gt;JSON::Tiny::Grammar.parse($tester, :rule&lt;object&gt;)&lt;/c3&gt;は&lt;c4&gt;object&lt;/c4&gt;という名前の正規表現でパースを始めるでしょう）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a &lt;c0&gt;return&lt;/c0&gt; statement always returns from the lexically scoped subroutine that surrounds it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T001641Z" creationid="Toshiyuki" creationdate="20130727T170533Z">
        <seg>例えば&lt;c0&gt;return&lt;/c0&gt;文は常にそれを囲むレキシカルスコープなサブルーチンから戻ってくる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a &lt;c2&gt;CHECK&lt;/c2&gt; block is called at the end of compiling a compilation unit.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T080355Z" creationid="Toshiyuki" creationdate="20130818T080355Z">
        <seg>例えば、&lt;c2&gt;CHECK&lt;/c2&gt;ブロックはコンパイル単位をコンパイルする終端で呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the literal &lt;c2&gt;7&lt;/c2&gt; will always and forever be just a &lt;c3&gt;7&lt;/c3&gt;.), this is an ordinary value comparison.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T125608Z" creationid="Toshiyuki" creationdate="20131027T125608Z">
        <seg>例えば、リテラルの&lt;c2&gt;7&lt;/c2&gt;は常に、いつまでも&lt;c3&gt;7&lt;/c3&gt;です。）これは普通の値比較です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, there is a rule to match alphabetic characters (&lt;c3&gt;&lt;alpha&gt;&lt;/c3&gt;), and another to match digits (&lt;c4&gt;&lt;digit&gt;&lt;/c4&gt;), and another to match whitespace (&lt;c5&gt;&lt;ws&gt;&lt;/c5&gt;), etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T224038Z" creationid="Toshiyuki" creationdate="20140223T101810Z">
        <seg>たとえば、英字（&lt;c3&gt;&lt;alpha&gt;&lt;/c3&gt;）、数字（&lt;c4&gt;&lt;digit&gt;&lt;/c4&gt;）、空白（&lt;c5&gt;&lt;ws&gt;&lt;/c5&gt;）にマッチするルールなどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, unlike normal lexically scope variables, dynamic variables search up the dynamic call stack for a variable of a particular name, but at each "stop" along the way, they are actually looking in the lexical "pad" associated with that particular dynamic scope's call frame.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T155130Z" creationid="Toshiyuki" creationdate="20130727T155130Z">
        <seg>例えば通常のレキシカルなスコープの変数と違い、ダイナミックな変数は特定の名前の変数のためにダイナミックコールスタックをそれぞれの「ストップ」まで道々探すけれども、実際は特定のダイナミックスコープのコールフレームに関連付けられたレキシカル「パッド」を見ている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on roles see &lt;a0&gt;link&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T145933Z" creationid="Toshiyuki" creationdate="20140314T145933Z">
        <seg>ロールの詳細については&lt;a0&gt;リンク&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For mutable objects, &lt;c0&gt;===&lt;/c0&gt; compares their identities.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T125838Z" creationid="Toshiyuki" creationdate="20131027T125838Z">
        <seg>可変のオブジェクトでは、&lt;c0&gt;===&lt;/c0&gt;はそれらの同一性を比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For numbers, the comparison operator is &lt;c7&gt;&lt;=&gt;&lt;/c7&gt; and for strings it's &lt;c8&gt;leg&lt;/c8&gt; (from &lt;e9&gt;l&lt;/e9&gt;esser, &lt;e10&gt;e&lt;/e10&gt;qual, &lt;e11&gt;g&lt;/e11&gt;reater).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T141628Z" creationid="Toshiyuki" creationdate="20131028T141628Z">
        <seg>数値のための比較演算子は&lt;c7&gt;&lt;=&gt;&lt;/c7&gt;です。そして文字列では&lt;c8&gt;leg&lt;/c8&gt;です（&lt;e9&gt;l&lt;/e9&gt;esser、&lt;e10&gt;e&lt;/e10&gt;qual、&lt;e11&gt;g&lt;/e11&gt;reaterから来ています）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For optimal re-use, classes should be small, but in order to represent a complex entity with many behaviors, classes tend to grow large.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122459Z" creationid="Toshiyuki" creationdate="20140115T101551Z">
        <seg>最適な再利用のためにクラスは小さいべきです。しかし、多くの振る舞いで複雑な実体を表すために、クラスは大きくなる傾向があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For plotting the names of the players and bar charts, the program needs to know how much space to allocate for the player names.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T090152Z" creationid="Toshiyuki" creationdate="20131027T064638Z">
        <seg>プレーヤーと棒グラフの名前をプロットするために、プログラムはどれくらいのスペースをプレーヤー名に割り当てるべきか知っている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For safety, perform your compositions at compile time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T161302Z" creationid="Toshiyuki" creationdate="20140115T142858Z">
        <seg>安全のために、コンパイル時であなたの合成を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the lexotic return of &lt;c2&gt;next&lt;/c2&gt;, the control exception will contain the identity of the loop scope to be exited (since the label was already "used up" to discover that identity), but for the dynamic fallback, the exception will contain only the loop label to be matched dynamically.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T115017Z" creationid="Toshiyuki" creationdate="20130729T115017Z">
        <seg>レギゾチックなリターンの&lt;c2&gt;next&lt;/c2&gt;では、制御例外は終了されるループスコープの識別子を含んでいるだろう。しかしダイナミックなフォールバックでは、その例外は動的にマッチされるループラベルだけが含まれているだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, rationals with large denominators automatically degrade to &lt;c3&gt;Num&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014447Z" creationid="Toshiyuki" creationdate="20140228T185911Z">
        <seg>この理由から、大きな分母による有理数は、&lt;c3&gt;Num&lt;/c3&gt;に自動的にデグレードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Format of this book</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T223306Z" creationid="Toshiyuki" creationdate="20131025T223306Z">
        <seg>この本の形式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Frequent users of the UNIX shells might have noticed a symmetry between postional and named arguments to routines on the one hand, and argument and options on the command line on the other hand.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T134738Z" creationid="Toshiyuki" creationdate="20140111T082259Z">
        <seg>UNIXシェルの常習的なユーザーは、コマンドライン引数と、ルーチンの引数とオプションに対する前後関係に依存して名をつけられた引数の間で、対称性があることに気がついたかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the output of this program, you can observe that doing the YMCA dance in ASCII art looks just as bad as in real life.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T220652Z" creationid="Toshiyuki" creationdate="20131126T122903Z">
        <seg>このプログラムの出力から、アスキーアートの中でYMCAダンスをしているのに気づくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From there it continues to scan outward to find the innermost block outside the &lt;c3&gt;when&lt;/c3&gt; that defines &lt;c4&gt;$_&lt;/c4&gt;, either explicitly or implicitly.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T114431Z" creationid="Toshiyuki" creationdate="20130812T114431Z">
        <seg>そこからそれは&lt;c4&gt;$_&lt;/c4&gt;を定義する&lt;c3&gt;when&lt;/c3&gt;の外側の最も深いブロックを探すために外側にスキャンを続ける。明示的か暗黙的に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From this point on, &lt;c7&gt;$self&lt;/c7&gt; now has all of the methods from the role, in addition to all of the ones that it had before.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T113403Z" creationid="Toshiyuki" creationdate="20140115T142543Z">
        <seg>今後、それが前に持っていたもののすべてに加えて、&lt;c7&gt;$self&lt;/c7&gt;は現在ロールからのメソッドのすべてを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further call frames up the caller stack may be located by use of the &lt;c0&gt;callframe&lt;/c0&gt; function:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T073303Z" creationid="Toshiyuki" creationdate="20130817T073303Z">
        <seg>呼び出し元のスタックより上のコールフレームは&lt;c0&gt;callframe&lt;/c0&gt;関数の使用によって配置することもできる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further compounding the difficulty is that every dynamic scope's outer call frame is associated with a lexical scope somewhere, so you can't just consider one kind of scoping or the other in isolation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T152246Z" creationid="Toshiyuki" creationdate="20130727T152246Z">
        <seg>それ以上に難しさをより一層ひどくするのは、それぞれのダイナミックスコープの外側のコールフレームがレキシカルスコープの何処かに関連付けられていることだ。そういう訳で、あなたは一種類のスコープどちらかだけを分離して考えることはできない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, constructors are ordinary methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T193208Z" creationid="Toshiyuki" creationdate="20140111T193208Z">
        <seg>さらにまた、コンストラクタは普通のメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, the type declaration on this attribute indicates that the array may only hold instances of the &lt;c1&gt;Task&lt;/c1&gt; class (or some subclass of it).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045530Z" creationid="Toshiyuki" creationdate="20140111T183110Z">
        <seg>さらにまた、この属性の上の型宣言は、配列が&lt;c1&gt;Task&lt;/c1&gt;クラス（またはそれの若干のサブクラス）のインスタンスをだけを持つことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally you don't need to worry about this unless you're defining a control construct.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125602Z" creationid="Toshiyuki" creationdate="20130816T125602Z">
        <seg>一般に、あなたが制御構造を定義するのでなければこれに関して心配する必要はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T232202Z" creationid="Toshiyuki" creationdate="20140328T232202Z">
        <seg>ジェネリック型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given &lt;c0&gt;sink&lt;/c0&gt;, there's no need for an "else" clause on Perl 6's loops, and the &lt;c1&gt;sink&lt;/c1&gt; construct works in any list, not just &lt;c2&gt;for&lt;/c2&gt; loops.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T080818Z" creationid="Toshiyuki" creationdate="20140329T080818Z">
        <seg>&lt;c0&gt;sink&lt;/c0&gt;があればPerl 6のループで“else”節は必要なく、&lt;c1&gt;sink&lt;/c1&gt;構造は&lt;c2&gt;for&lt;/c2&gt;ループだけでなくどんなリストでも動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an object &lt;c0&gt;$p&lt;/c0&gt;, and the class definitions from the previous sections, we can ask it a few questions:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T150205Z" creationid="Toshiyuki" creationdate="20140112T135528Z">
        <seg>オブジェクト&lt;c0&gt;$p&lt;/c0&gt;と前のセクションからのクラス定義を与えられたとすると、我々はそれに少しの質問を尋ねることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given two types &lt;c4&gt;A&lt;/c4&gt; and &lt;c5&gt;B&lt;/c5&gt;, where &lt;c6&gt;A&lt;/c6&gt; conforms to &lt;c7&gt;B&lt;/c7&gt; (&lt;c8&gt;A ~~ B&lt;/c8&gt;, in Perl 6 code), an object which conforms to &lt;c9&gt;A&lt;/c9&gt; does so more narrowly than to &lt;c10&gt;B&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113852Z" creationid="Toshiyuki" creationdate="20140113T044501Z">
        <seg>2つの型&lt;c4&gt;A&lt;/c4&gt;と&lt;c5&gt;B&lt;/c5&gt;があれば、&lt;c6&gt;A&lt;/c6&gt;が&lt;c7&gt;B&lt;/c7&gt;（Perl 6コードで&lt;c8&gt;A ~~ B&lt;/c8&gt;）に適合する所で&lt;c9&gt;A&lt;/c9&gt;に適合するオブジェクトは&lt;c10&gt;B&lt;/c10&gt;により間近でそうします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good idea, but Positive Integer would be a subset type, which doesn't count as a narrower nominal type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113718Z" creationid="Toshiyuki" creationdate="20140113T044125Z">
        <seg>良い考えはPositive Integer以外のサブセット型です。そしてそれはより狭い名目型とされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Good luck and--as the Perl 6 community often says--have fun!</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T002438Z" creationid="Toshiyuki" creationdate="20131025T231740Z">
        <seg>幸運を祈ります。そして ― Perl 6コミュニティがよく言うように ― 楽しんでください！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar Inheritance</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T135247Z" creationid="Toshiyuki" creationdate="20140223T095719Z">
        <seg>グラマーの継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammars</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T132534Z" creationid="Toshiyuki" creationdate="20140321T132534Z">
        <seg>グラマー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammars organize regexes, just like classes organize methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T132528Z" creationid="Toshiyuki" creationdate="20140222T094709Z">
        <seg>クラスがメソッドを編成するように、グラマーは正規表現を編成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handled exceptions break out past this implicit rethrow.) Hence, &lt;c7&gt;CATCH&lt;/c7&gt; is unlike all other switch statements in that it treats code inside a &lt;c8&gt;default&lt;/c8&gt; block differently from code that's after all the &lt;c9&gt;when&lt;/c9&gt; blocks but not in a &lt;c10&gt;default&lt;/c10&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T105620Z" creationid="Toshiyuki" creationdate="20130814T105620Z">
        <seg>扱われる例外は暗黙の再スローを過ぎて抜けだす。）その後、&lt;c7&gt;CATCH&lt;/c7&gt;は他のすべてのswitch文と違って&lt;c8&gt;default&lt;/c8&gt;ブロック内のコードを違うように扱う。結局&lt;c9&gt;when&lt;/c9&gt;ブロックで&lt;c10&gt;default&lt;/c10&gt;ブロックではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hashes within curly braces are interpolated as a series of lines.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T153933Z" creationid="Toshiyuki" creationdate="20131026T153933Z">
        <seg>ブレースの中のハッシュは、一連の行として差し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence numeric coercions such as &lt;c2&gt;+"42foo"&lt;/c2&gt; can be forced to return &lt;c3&gt;42&lt;/c3&gt; after issuing a warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T074800Z" creationid="Toshiyuki" creationdate="20130818T074800Z">
        <seg>その後、&lt;c2&gt;+"42foo"&lt;/c2&gt;のような数値強制は警告を出す後に&lt;c3&gt;42&lt;/c3&gt;を返すように強要できる。 after issuing a warning.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence these declare the same variables with the same scope as the preceding example, but run the statements as a whole at the indicated time:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T084908Z" creationid="Toshiyuki" creationdate="20130818T084908Z">
        <seg>その後、それらはすぐ前の例と同じスコープと同じ値を宣言する。しかし示された時に全体として文を実行する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the &lt;c0&gt;leave&lt;/c0&gt; function:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T072226Z" creationid="Toshiyuki" creationdate="20130817T072226Z">
        <seg>それゆえに、&lt;c0&gt;leave&lt;/c0&gt;関数は：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here &lt;c0&gt;\w+&lt;/c0&gt; matches a word, and &lt;c1&gt;[\w+]+ % [\,\s*]&lt;/c1&gt; matches at least one word, where several words are separated by a comma and an arbitrary amount of whitespace.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T033855Z" creationid="Toshiyuki" creationdate="20140221T230938Z">
        <seg>ここでは&lt;c0&gt;\w+&lt;/c0&gt;はワードにマッチします。そして&lt;c1&gt;[\w+]+ % [\,\s*]&lt;/c1&gt;は少なくとも1つのワードにマッチします。いくつかのワードはコンマと任意の数の空白文字で区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the multi dispatcher selects the routine based on the value of the first argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121647Z" creationid="Toshiyuki" creationdate="20140113T080137Z">
        <seg>ここでは、マルチディスパッチャーは最初の引数の値に基づくルーチンを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here you can find an implementation that turns Perl 6 data structures to JSON.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112332Z" creationid="Toshiyuki" creationdate="20140112T182629Z">
        <seg>ここであなたは、Perl 6データ構造をJSONに作り出す実装を見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's one way to solve that problem in Perl 6:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T015701Z" creationid="Toshiyuki" creationdate="20131026T015701Z">
        <seg>Perl 6でその問題を解決する1つの方法はこうなります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the &lt;c0&gt;@tasks&lt;/c0&gt; array will end up containing two &lt;c1&gt;Capture&lt;/c1&gt;s, each of which contains two positional arguments and one named argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T143255Z" creationid="Toshiyuki" creationdate="20140110T143255Z">
        <seg>ここで、&lt;c0&gt;@tasks&lt;/c0&gt;配列は2つの&lt;c1&gt;Capture&lt;/c1&gt;を含んで終わり、それぞれは2つの位置引数と1つの名前付き引数を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hierarchical types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T225105Z" creationid="Toshiyuki" creationdate="20140328T225105Z">
        <seg>階層型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hint: &lt;c0&gt;%hash.keys&lt;/c0&gt; returns a list of all keys stored in &lt;c1&gt;%hash&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T124250Z" creationid="Toshiyuki" creationdate="20131026T165937Z">
        <seg>ヒント：&lt;c0&gt;%hash.keys&lt;/c0&gt;は&lt;c1&gt;%hash&lt;/c1&gt;に保存されている全てのキーのリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How can you change the program if the first input line is omitted?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T124230Z" creationid="Toshiyuki" creationdate="20131026T165831Z">
        <seg>最初の入力行が省略されるならば、あなたはどのようにプログラムを変えますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How can you maintain a variable list of custom behaviors, allow user input, and restrict that input to a safe set of behaviors?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131030T144428Z" creationid="Toshiyuki" creationdate="20131030T144428Z">
        <seg>あなたはどのようにしてカスタマイズした振る舞いのリストを保守し、ユーザーの入力を可能にし、入力を安全な振る舞いのセットに制限しますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How would you modify your program to achieve that?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T170712Z" creationid="Toshiyuki" creationdate="20131026T170712Z">
        <seg>それを達成するために、あなたはプログラムをどのように修正するでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However &lt;c1&gt;T&lt;/c1&gt; &lt;e2&gt;is&lt;/e2&gt; a constraint for the second parameter which accounts for as many steps of narrowness as the number of inheritance steps between &lt;c3&gt;T&lt;/c3&gt; and &lt;c4&gt;Any&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115324Z" creationid="Toshiyuki" creationdate="20140113T063242Z">
        <seg>しかし&lt;c1&gt;T&lt;/c1&gt;は、&lt;c3&gt;T&lt;/c3&gt;と&lt;c4&gt;Any&lt;/c4&gt;の間の継承ステップの数と同じくらい多くの狭さのステップの原因である第二パラメータのための制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However Ana and Dave have both won two matches.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T144928Z" creationid="Toshiyuki" creationdate="20131026T144928Z">
        <seg>しかしAnaとDaveは両方とも2試合勝ちました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However only positional parameters contribute to the narrowness of a match:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114339Z" creationid="Toshiyuki" creationdate="20140113T045358Z">
        <seg>しかし位置依存のパラメータだけは、マッチの狭さに寄与します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, &lt;c0&gt;JSON::Tiny::Grammar&lt;/c0&gt; only implicitly matches whitespace through the use of &lt;e1&gt;rules&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T224504Z" creationid="Toshiyuki" creationdate="20140223T102844Z">
        <seg>しかし、&lt;c0&gt;JSON::Tiny::Grammar&lt;/c0&gt;はルールを用いて空白に暗黙のうちにマッチするだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a &lt;c2&gt;take&lt;/c2&gt; function that is not in sink context gathers its return objects &lt;i3&gt;en passant&lt;/i3&gt; and also returns them unchanged.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T213004Z" creationid="Toshiyuki" creationdate="20130810T213004Z">
        <seg>しかしながら、sinkコンテキストでない&lt;c2&gt;take&lt;/c2&gt;関数はリターンオブジェクトを&lt;i3&gt;ついでに&lt;/i3&gt;集め、そしてそれらを不変で返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a &lt;c3&gt;CATCH&lt;/c3&gt; must not behave that way, so we say that a &lt;c4&gt;CATCH&lt;/c4&gt; block never attempts to handle any exception thrown within its own dynamic scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T120608Z" creationid="Toshiyuki" creationdate="20130814T120608Z">
        <seg>しかしながら、&lt;c3&gt;CATCH&lt;/c3&gt;はそのように振舞ってはならない。それゆえ、&lt;c4&gt;CATCH&lt;/c4&gt;ブロックは決して独自のダイナミックスコープの範囲内で投げられた何か一つの例外をハンドルしようとしないといえる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a matching constraint always contributes less to narrowness than a more specific match in the nominal type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114028Z" creationid="Toshiyuki" creationdate="20140113T044620Z">
        <seg>しかしマッチする制約は常に名目型で、狭さより特定のマッチに貢献します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a role cannot stand on its own; you cannot instantiate a role.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122031Z" creationid="Toshiyuki" creationdate="20140113T105729Z">
        <seg>しかしロールは単独では有効でありません；あなたは、ロールをインスタンス化することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a type object responds to the function call interface, so you may use the name of a type with parentheses as if it were a function, and any argument supplied to the call is coerced to the type indicated by the type object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140401T125821Z" creationid="Toshiyuki" creationdate="20140401T125821Z">
        <seg>しかし型オブジェクトは関数呼び出しインターフェースに応答するので型の名前を括弧で関数であるかのように使用でき、呼び出しに供給された引数は型オブジェクトで示された型に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, binding &lt;c4&gt;Nil&lt;/c4&gt; to a parameter (&lt;c5&gt;::=&lt;/c5&gt; semantics) works more like assignment; passing &lt;c6&gt;Nil&lt;/c6&gt; to a parameter with a default causes that parameter to be set to its default value rather than an undefined value, as if the argument had not been supplied.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140401T115317Z" creationid="Toshiyuki" creationdate="20140401T115317Z">
        <seg>しかし、&lt;c4&gt;Nil&lt;/c4&gt;をパラメーターにバインドすることは（&lt;c5&gt;::=&lt;/c5&gt;セマンティクス）より割り当てに近いです；&lt;c6&gt;Nil&lt;/c6&gt;をデフォルトでパラメータに渡すと、それは未定義値よりもデフォルト値をセットします。まるで引数が供給されなかったように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in some cases it is useful to do so, and therefore Perl allows you to manipulate captures directly.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T172921Z" creationid="Toshiyuki" creationdate="20140110T135917Z">
        <seg>しかしながら、いくつかのケースでそうすることは役に立ちます。ゆえにPerlはキャプチャーを直接操作することを可能にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in that case &lt;c5&gt;&amp;foo&lt;/c5&gt; by itself is not sufficient to uniquely name a specific function.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T083442Z" creationid="Toshiyuki" creationdate="20140329T083429Z">
        <seg>しかし、その場合&lt;c5&gt;&amp;foo&lt;/c5&gt;自身は特定の関数にユニークに名前を付けるのに十分ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in this case it is specifying the full set of arguments for the call, including both named and positional arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T155721Z" creationid="Toshiyuki" creationdate="20140110T155721Z">
        <seg>しかし、この場合それは呼び出しのための引数のフルセット、名前付きと位置引数を含んでいることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is immediately consumed by the call.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T140544Z" creationid="Toshiyuki" creationdate="20140110T140544Z">
        <seg>しかし、それは呼び出しによって直ちに消費されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it may allow the compiler to perform certain optimizations depending on which Perl 6 implementation you are using.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T063754Z" creationid="Toshiyuki" creationdate="20140105T064837Z">
        <seg>しかし、それはあなたが使用しているPerl 6の実装に依存してコンパイラが特定の最適化を行うのを可能にするかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's not an error when prefixed by a &lt;c0&gt;do&lt;/c0&gt;, or when followed by a statement modifier:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T151708Z" creationid="Toshiyuki" creationdate="20130810T151708Z">
        <seg>けれども、&lt;c0&gt;do&lt;/c0&gt;によって前に付けられる時、または文修飾子が続く時はエラーではない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, named parameters have no such restriction.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T054831Z" creationid="Toshiyuki" creationdate="20140104T181609Z">
        <seg>しかし、名前付きパラメータにそのような制限はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, recursive calls to the same clone use the same state variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133530Z" creationid="Toshiyuki" creationdate="20130802T133530Z">
        <seg>しかしながら、同一のクローンの再帰的呼び出しは同じstate変数を使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, that's likely to be visually confused with a following &lt;c0&gt;while&lt;/c0&gt; loop at the best of times, so it's also allowed to put the loop conditional at the front, with the same meaning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T053609Z" creationid="Toshiyuki" creationdate="20130809T152726Z">
        <seg>しかしながら、&lt;c0&gt;while&lt;/c0&gt;ループが続くのは多分視覚的にわかりにくいので、同じ意味でループ条件を前に置くことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the default sort on an array sorts by its contents.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T143127Z" creationid="Toshiyuki" creationdate="20131026T143127Z">
        <seg>しかし、配列でのデフォルトのソートはその内容によって並べ替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the example code does not seem to have a regex named &lt;c0&gt;TOP&lt;/c0&gt;; it has a &lt;e1&gt;rule&lt;/e1&gt; named &lt;c2&gt;TOP&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T135238Z" creationid="Toshiyuki" creationdate="20140222T114302Z">
        <seg>しかし、コード例は&lt;c0&gt;TOP&lt;/c0&gt;という名前の正規表現を持っていないようです；それは&lt;c2&gt;TOP&lt;/c2&gt;という名前の&lt;e1&gt;ルール&lt;/e1&gt;を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the labeled forms can use method call syntax: &lt;c3&gt;LABEL.next&lt;/c3&gt;, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T042110Z" creationid="Toshiyuki" creationdate="20130806T042110Z">
        <seg>しかし、ラベル付きの形式はメソッド呼び出し文法を使用出来る：&lt;c3&gt;LABEL.next&lt;/c3&gt;など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the name is introduced into the scope of the declaration itself, so it may be used to call itself recursively:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021832Z" creationid="Toshiyuki" creationdate="20140329T021832Z">
        <seg>しかし名前は宣言自体に導入されているので、自分自身を再帰的に呼び出すのに使えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the new semantics of autothrowing when sink eats a Failure means we won't have many unthrown exceptions waiting around to be handled at the end of the block anymore.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T153700Z" creationid="Toshiyuki" creationdate="20130817T153700Z">
        <seg>しかしながら、sinkがFailureを食べるときの自動スローの新しいセマンティクスは我々がたくさんのブロックの終端で待つハンドルされるスローされない例外を持ちたくないことを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are two important differences.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185217Z" creationid="Toshiyuki" creationdate="20140111T185217Z">
        <seg>しかし2つの重要な違いがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there have to be some culturally enforced standards on which constructs capture which exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080123Z" creationid="Toshiyuki" creationdate="20130817T080123Z">
        <seg>けれども、構造がその例外を捕らえるいくつかの文化的に強要された標準がある必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there may be race conditions in the case of diamond dependencies, wherein &lt;c3&gt;Task&lt;/c3&gt;s &lt;c4&gt;A&lt;/c4&gt; starts &lt;c5&gt;B&lt;/c5&gt; and &lt;c6&gt;C&lt;/c6&gt; in parallel, and both start a copy of &lt;c7&gt;D&lt;/c7&gt;, making &lt;c8&gt;D&lt;/c8&gt; run twice.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T111954Z" creationid="Toshiyuki" creationdate="20140314T213900Z">
        <seg>しかし、ダイアモンド従属物で競合状態がある場合に&lt;c3&gt;Task&lt;/c3&gt; &lt;c4&gt;A&lt;/c4&gt;は &lt;c5&gt;B&lt;/c5&gt;と&lt;c6&gt;C&lt;/c6&gt;を平行に開始し、そして両方が&lt;c7&gt;D&lt;/c7&gt;のコピーを開始して&lt;c8&gt;D&lt;/c8&gt;を2度実行させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they only scratch the surface of what's possible.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131412Z" creationid="Toshiyuki" creationdate="20131029T131412Z">
        <seg>しかし、それらは可能であるものの表面をひっかくだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this attribute represents an array of items, so it requires the &lt;c0&gt;@&lt;/c0&gt; sigil.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182936Z" creationid="Toshiyuki" creationdate="20140111T182936Z">
        <seg>しかし、この属性は配列のアイテムを表すので、&lt;c0&gt;@&lt;/c0&gt;シギルを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this does not mean that Perl 5 is going away.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T023602Z" creationid="Toshiyuki" creationdate="20131025T225438Z">
        <seg>しかし、これはPerl 5が無くなるという意味ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this is likely to fail on autochomped filehandles, so use the &lt;c0&gt;for&lt;/c0&gt; loop instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063749Z" creationid="Toshiyuki" creationdate="20130810T063749Z">
        <seg>しかしながら、これは自動でchompされたファイルハンドルではおそらく失敗するので、代わりに&lt;c0&gt;for&lt;/c0&gt;ループを使え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, use of &lt;c0&gt;$_&lt;/c0&gt; with a conditional or conditionally repeating statement's block is &lt;i1&gt;not&lt;/i1&gt; considered sufficiently explicit to turn a 0-ary block into a 1-ary function, so all these methods use the same invocant:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T095940Z" creationid="Toshiyuki" creationdate="20130804T095940Z">
        <seg>しかしながら、0のブロックを1の関数に変えるために&lt;c0&gt;$_&lt;/c0&gt;を条件付きまたは条件付きで繰り返すブロックで使うことは十分に明白とは見なされない。だから全てのこれらのメソッドは同じインボカントを使う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can explicitly specify that a parameter is required by appending a &lt;c0&gt;!&lt;/c0&gt; to it:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T011134Z" creationid="Toshiyuki" creationdate="20131231T192500Z">
        <seg>しかし&lt;c0&gt;!&lt;/c0&gt;を付け加えることでパラメータが必要であることを明示することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you may omit the parentheses on the conditional:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T044327Z" creationid="Toshiyuki" creationdate="20130803T044327Z">
        <seg>けれども、括弧は条件付きで省略できる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I could use a table or figure here to illustrate the hierarchy of narrowing.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114225Z" creationid="Toshiyuki" creationdate="20140113T044929Z">
        <seg>私は狭くなる階層を例示するために、テーブルまたはフィギュアをここで使うことができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I have the temptation to write "And this is a great way to implement the guts of a compiler, as Perl 6 itself does!"</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T041738Z" creationid="Toshiyuki" creationdate="20140110T161448Z">
        <seg>私は「これはPerl 6自身がするようにコンパイラの中身を実装する素晴らしい方法だ！」と書く誘惑に駆られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I've explained this as a form of context in the Modern Perl book; it may work here too.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T013829Z" creationid="Toshiyuki" creationdate="20140226T143228Z">
        <seg>私はModern Perl本のコンテキストの形式としてこれを説明しました；それはここでも働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I've tried to clarify.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T012826Z" creationid="Toshiyuki" creationdate="20140104T133614Z">
        <seg>分かりやすくなるように努力しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c0&gt;$r1&lt;/c0&gt; has a larger value than &lt;c1&gt;$r2&lt;/c1&gt;, &lt;c2&gt;%matches{$p1}&lt;/c2&gt; increments by one.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T141824Z" creationid="Toshiyuki" creationdate="20131026T141824Z">
        <seg>&lt;c0&gt;$r1&lt;/c0&gt;が&lt;c1&gt;$r2&lt;/c1&gt;よりも大きな値を持つならば、&lt;c2&gt;%matches{$p1}&lt;/c2&gt; は1インクリメントします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c3&gt;$r1&lt;/c3&gt; is not larger than &lt;c4&gt;$r2&lt;/c4&gt;, &lt;c5&gt;%matches{$p2}&lt;/c5&gt; increments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T025747Z" creationid="Toshiyuki" creationdate="20131026T142018Z">
        <seg>&lt;c3&gt;$r1&lt;/c3&gt;が&lt;c4&gt;$r2&lt;/c4&gt;よりも小さいならば、&lt;c5&gt;%matches{$p2}&lt;/c5&gt;をインクリメントします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c4&gt;$label-area-width&lt;/c4&gt; is 8, the format string is &lt;c5&gt;"%- 8s%s\n"&lt;/c5&gt;, which means a string (&lt;c6&gt;'s'&lt;/c6&gt;) filled to 8 spaces (&lt;c7&gt;' 8'&lt;/c7&gt;) and left-justified (&lt;c8&gt;'-'&lt;/c8&gt;), followed by another string and a newline.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T074444Z" creationid="Toshiyuki" creationdate="20131027T074444Z">
        <seg>もし&lt;c4&gt;$label-area-width&lt;/c4&gt;が8なら、書式文字列は&lt;c5&gt;"%- 8s%s\n"&lt;/c5&gt;になります。それは文字列（&lt;c6&gt;'s'&lt;/c6&gt;）が8スペース（&lt;c7&gt;' 8'&lt;/c7&gt;）で左揃え（&lt;c8&gt;'-'&lt;/c8&gt;）、他の文字列と改行が続くという意味です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a method does exist, the grammar engine passes the current match object as a positional argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T232834Z" creationid="Toshiyuki" creationdate="20140224T162357Z">
        <seg>メソッドが存在するならば、グラマーエンジンは現在のマッチオブジェクトを位置依存の引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a quantifier has several ways to match, Perl will choose the longest one.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T225828Z" creationid="Toshiyuki" creationdate="20140221T225828Z">
        <seg>数量詞がマッチするいくつかの方法を持っているならば、Perlは最も長いものを選ぶでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a set of regexes were to call each other recursively without progressing in the string, the recursion could go on infinitely and never proceed to other parts of the grammar.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T142449Z" creationid="Toshiyuki" creationdate="20140222T133008Z">
        <seg>一組の正規表現が文字列を進行することなく互いに再帰的な呼び出しであるならば、再帰は無限に続くことができて、グラマーの他の部分まで決して進行することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an option does not require a parameter, the parameter in the MAIN signature needs to be marked as being of &lt;c0&gt;Bool&lt;/c0&gt; type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044758Z" creationid="Toshiyuki" creationdate="20140111T173936Z">
        <seg>オプションがパラメータを必要としないならば、MAINシグネチャーのパラメータは&lt;c0&gt;Bool&lt;/c0&gt;型であるとマークされる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any arguments are supplied to the &lt;c9&gt;succeed&lt;/c9&gt; function, they are passed out via the &lt;c10&gt;leave&lt;/c10&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114350Z" creationid="Toshiyuki" creationdate="20130813T114350Z">
        <seg>何か一つの引数が&lt;c9&gt;succeed&lt;/c9&gt;関数に与えられたら、それらは&lt;c10&gt;leave&lt;/c10&gt;メソッド経由で渡される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any exceptions are returned as not handled, the exception thrower keeps looking for a higher dynamic scope for a spot to unwind to.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T112836Z" creationid="Toshiyuki" creationdate="20130814T112836Z">
        <seg>もし何か一つの例外がハンドルされないとして返されるなら、例外を投げるものはスポットして巻き戻すためにより高いダイナミックスコープを探し続ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both players select the same item, it's a draw.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T045925Z" creationid="Toshiyuki" creationdate="20140113T045925Z">
        <seg>両方のプレーヤーが同じアイテムを選ぶならば、それはドローです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If continuations are used, the &lt;c0&gt;.resume&lt;/c0&gt; call will simply goto the continuation in question, and the lambda's callframe is abandoned.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T114130Z" creationid="Toshiyuki" creationdate="20130814T114130Z">
        <seg>もし継続が使われたら、&lt;c0&gt;.resume&lt;/c0&gt;呼び出しは単純に問題の継続に飛び、 そのlambdaのコールフレームは破棄される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If either part is &lt;c1&gt;NaN&lt;/c1&gt;, then the entire number may possibly be &lt;c2&gt;NaN&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014742Z" creationid="Toshiyuki" creationdate="20140228T190205Z">
        <seg>どちらの部分でも&lt;c1&gt;NaN&lt;/c1&gt;なら、全体の数はおそらく&lt;c2&gt;NaN&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If followed by a block it does not parse as a list operator or even as a prefix unary; it will never look for any additional expression following the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124145Z" creationid="Toshiyuki" creationdate="20130811T124145Z">
        <seg>もしブロックが続くリスト演算子か単項の接頭辞としてパースしないなら；ブロックに続く追加のどんな式も探さないだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If instead of the above you say:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T074109Z" creationid="Toshiyuki" creationdate="20130817T074109Z">
        <seg>上述の代わりに次のように書くなら：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If instead the users of this object should be able to reset a task's completion state (perhaps to perform it again), you can change the attribute declaration:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184737Z" creationid="Toshiyuki" creationdate="20140111T184737Z">
        <seg>その代わりにこのオブジェクトのユーザーが仕事の完成状態（おそらく再びそれを実行するために）をリセットすることができるべきであるならば、あなたは属性宣言を変えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If more than one &lt;c4&gt;on-message&lt;/c4&gt; multi candidate matches, Perl will call all of them, whether found by multiple dispatch, searching the inheritance hierarchy, or both.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T033027Z" creationid="Toshiyuki" creationdate="20140115T141344Z">
        <seg>1つ以上の&lt;c4&gt;on-message&lt;/c4&gt;マルチ候補がマッチするならば、マルチディスパッチによって、継承階層を捜して、または両方で、見つかるかどうかにかかわらず、Perlはそれらのすべてを呼び出すでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If multiple parameters have type constraints, each argument must fulfill the type constraint of the parameter to which it binds.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140106T133529Z" creationid="Toshiyuki" creationdate="20140106T133529Z">
        <seg>複数のパラメータが型制約を持っているなら、それぞれの引数はパラメータがバインドする型制約を満たさなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no &lt;c3&gt;on-message&lt;/c3&gt; multi candidates match, the call will not produce an error.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T032808Z" creationid="Toshiyuki" creationdate="20140115T141311Z">
        <seg>&lt;c3&gt;on-message&lt;/c3&gt;マルチ候補にマッチがない場合、呼び出しはエラーを出さないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no argument is passed, an undefined value will be bound to the parameter.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131230T041549Z" creationid="Toshiyuki" creationdate="20131230T041549Z">
        <seg>引数が渡されなかったら、未定義値がパラメータにバインドされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no explicit handler handles it, the implicit outermost exception handler will eventually decide to abort and print all unhandled exceptions passed in as its current &lt;c0&gt;@!&lt;/c0&gt; list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T073531Z" creationid="Toshiyuki" creationdate="20130818T073531Z">
        <seg>もし明示的なハンドラがそれをハンドルしないなら、暗黙の最も外側の例外ハンドラは結局無視して現在の&lt;c0&gt;@!&lt;/c0&gt;リストとして渡される全てのハンドルされない例外をプリントすると決定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no such method exists, the grammar engine continues parsing the rest of the grammar.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T232748Z" creationid="Toshiyuki" creationdate="20140224T162346Z">
        <seg>そのようなメソッドが存在しないなら、グラマーエンジンは残りを解析し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If none of the cases in the &lt;c3&gt;CATCH&lt;/c3&gt; handles the exception, the exception will be rethrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T134608Z" creationid="Toshiyuki" creationdate="20130813T134608Z">
        <seg>&lt;c3&gt;CATCH&lt;/c3&gt;の例外を扱うケースがないなら、例外は再スローされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one of the objects is not numeric, Perl will do its best to make it numeric before doing the comparison.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T124216Z" creationid="Toshiyuki" creationdate="20131028T124216Z">
        <seg>オブジェクトの1つが数でないなら、Perlは比較する前にそれを数にするために全力を尽くすでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If read-only binding is too limiting, you can relax this restriction by applying the &lt;c0&gt;is rw&lt;/c0&gt; ("rw" being short for &lt;e1&gt;read/write&lt;/e1&gt;) trait to a parameter.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T035614Z" creationid="Toshiyuki" creationdate="20131129T150406Z">
        <seg>読み取り専用のバインディングが制限的すぎるなら、&lt;c0&gt;is rw&lt;/c0&gt;トレイトをパラメータに適用することで制限を緩めることができます。（“rw”は&lt;e1&gt;read/write&lt;/e1&gt;の略）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If so, there's nothing to do.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T190659Z" creationid="Toshiyuki" creationdate="20140111T190659Z">
        <seg>もしそうなら、することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If some of your users are British and others are Americans, you might write:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T133128Z" creationid="Toshiyuki" creationdate="20140104T133128Z">
        <seg>もし何人かのユーザーがイギリス人で、他がアメリカ人なら、あなたは次のように書くかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If somebody forgets to add that whitespace, a regex can clean up after the lazy writer:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131734Z" creationid="Toshiyuki" creationdate="20140222T024028Z">
        <seg>誰かがその空白文字を加えるのを忘れたならば、正規表現は怠惰な作家の後片付けをすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If such use can't be detected because it is hidden in an eval, then it is erroneous, since the &lt;c2&gt;eval()&lt;/c2&gt; compiler might bind to either &lt;c3&gt;$OUTER::x&lt;/c3&gt; or the subsequently declared "&lt;c4&gt;my $x&lt;/c4&gt;".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T131140Z" creationid="Toshiyuki" creationdate="20130802T131140Z">
        <seg>もしevalに隠されてそのような使用が発見できないならそれは誤りだ。だから&lt;c2&gt;eval()&lt;/c2&gt;コンパイラは&lt;c3&gt;$OUTER::x&lt;/c3&gt;かその後に宣言された「&lt;c4&gt;my $x&lt;/c4&gt;」にバインドするかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that check succeeds, it calls the code block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T224013Z" creationid="Toshiyuki" creationdate="20140112T222801Z">
        <seg>そのチェックが成功するならば、それはコードブロックを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c0&gt;(::T, T)&lt;/c0&gt; candidate matches, the type capture in the first parameter does not contribute any narrowness--it is not a constraint, after all.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T022121Z" creationid="Toshiyuki" creationdate="20140113T063159Z">
        <seg>もし&lt;c0&gt;(::T, T)&lt;/c0&gt;候補がマッチするなら、最初のパラメータの型キャプチャは狭さに貢献しません ― 結局、それは制約ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c0&gt;(Scissors, Paper)&lt;/c0&gt; candidate matches the supplied argument list, it is two steps narrower than the &lt;c1&gt;(Any, Any)&lt;/c1&gt; fallback, because both &lt;c2&gt;Scissors&lt;/c2&gt; and &lt;c3&gt;Paper&lt;/c3&gt; are direct subtypes of &lt;c4&gt;Any&lt;/c4&gt;, so both contribute one step.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T020825Z" creationid="Toshiyuki" creationdate="20140113T051138Z">
        <seg>&lt;c0&gt;(Scissors, Paper)&lt;/c0&gt;候補が供給された引数リストにマッチするならば、&lt;c2&gt;Scissors&lt;/c2&gt;と&lt;c3&gt;Paper&lt;/c3&gt;が&lt;c4&gt;Any&lt;/c4&gt;の直接のサブタイプであるので、それは&lt;c1&gt;(Any, Any)&lt;/c1&gt;の代替より2歩制限されているので、双方とも1歩に寄与します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c7&gt;gather&lt;/c7&gt; contains no &lt;c8&gt;take&lt;/c8&gt; lexically, it by definition cannot be the lexotic target of any &lt;c9&gt;take&lt;/c9&gt;, so it can only harvest dynamic &lt;c10&gt;take&lt;/c10&gt; calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T160429Z" creationid="Toshiyuki" creationdate="20130810T160429Z">
        <seg>&lt;c7&gt;gather&lt;/c7&gt;が&lt;c8&gt;take&lt;/c8&gt;をレキシカルに含んでいないなら、定義によってどんな&lt;c9&gt;take&lt;/c9&gt;のレギゾチックターゲットにもなれない。なので動的な&lt;c10&gt;take&lt;/c10&gt;呼び出しだけ収納できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the class provides a method of the same name that is also multi, then all methods defined in the role and the class will combine into a set of multi candidates.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T023734Z" creationid="Toshiyuki" creationdate="20140115T140756Z">
        <seg>クラスがマルチでもある同じ名前のメソッドを提供するならば、ロールとクラスで定義したすべてのメソッドは一組のマルチ候補に統合するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the conditional does not execute any branch, the return value is &lt;c0&gt;()&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T050026Z" creationid="Toshiyuki" creationdate="20130803T050026Z">
        <seg>もし条件がいずれの分岐も実行しないなら、返り値は&lt;c0&gt;()&lt;/c0&gt;になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the failure throws its exception and the exception resumes, the thrower by default returns the null string (&lt;c0&gt;''&lt;/c0&gt;) to whatever caused the failure to throw its exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T074133Z" creationid="Toshiyuki" creationdate="20130818T074133Z">
        <seg>もし失敗が例外をスローして例外が再開するなら、スロー元はデフォルトで例外をスローするための失敗を引き起こすならなんでもnull文字列（&lt;c0&gt;''&lt;/c0&gt;）を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the object is of that class, or of an inheriting class, it returns true.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T105031Z" creationid="Toshiyuki" creationdate="20140112T135810Z">
        <seg>オブジェクトがそのクラスの、または継承しているクラスであれば、それは真を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the role composer detects a method with the same name in the class body, it will then disregard all of the (possibly conflicting) ones from the roles.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T022258Z" creationid="Toshiyuki" creationdate="20140115T140350Z">
        <seg>ロールコンポーザーがクラス本体に同じ名前のメソッドを見つけたら、それはロールからのもの（おそらく競合する）すべてを無視するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the smart match fails, control proceeds the next statement normally, which may or may not be a &lt;c0&gt;when&lt;/c0&gt; statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T132125Z" creationid="Toshiyuki" creationdate="20130811T132125Z">
        <seg>もしスマートマッチが失敗したら、制御は通常通り次の文へ進み、そしてそれは&lt;c0&gt;when&lt;/c0&gt;文になるかどうかわからない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the smart match succeeds, &lt;c10&gt;when&lt;/c10&gt;'s associated block is executed, and the innermost surrounding block that has &lt;c11&gt;$_&lt;/c11&gt; as one of its formal parameters (either explicit or implicit) is automatically broken out of.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T130833Z" creationid="Toshiyuki" creationdate="20130811T130833Z">
        <seg>もしスマートマッチが成功したら、&lt;c10&gt;when&lt;/c10&gt;に関連付けられたブロックは実行され、&lt;c11&gt;$_&lt;/c11&gt;を仮パラメータ（明示的か暗黙的）の一つとして持つ最も深い部分を囲うブロックは自動的に切り離される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type of the operands differs from the type of the operand, Perl will make copies of the operands and convert them to the needed types.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T013317Z" creationid="Toshiyuki" creationdate="20140226T142528Z">
        <seg>オペランドの型と型が異なるならば、Perlはオペランドのコピーを作成して、それらを必要とされる型に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the warning exception supports the &lt;c2&gt;.resume_value&lt;/c2&gt; method, that will be the value of the failure after it has resumed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130811Z" creationid="Toshiyuki" creationdate="20130817T130811Z">
        <seg>もし警告例外が&lt;c2&gt;.resume_value&lt;/c2&gt;メソッドをサポートするなら、それが再開された後に失敗の値になるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the wide type is omitted, &lt;c1&gt;Any&lt;/c1&gt; is assumed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140407T125007Z" creationid="Toshiyuki" creationdate="20140407T125007Z">
        <seg>広い型が省略されると&lt;c1&gt;Any&lt;/c1&gt;とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are any unhandled &lt;c1&gt;@!&lt;/c1&gt; exceptions, or if any exceptions were caught by the inner SIMPLECATCH (which does nothing but runs its push code, which should not produce any exceptions), then the CATCH block returns them to the exception thrower.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T111820Z" creationid="Toshiyuki" creationdate="20130814T111820Z">
        <seg>もしハンドルされない&lt;c1&gt;@!&lt;/c1&gt;例外があるなら、または何か一つの例外が内側のSIMPLECATCHにキャッチされるなら（それは何もしないがプッシュコードを実行する。そしてそれはどんな例外も引き起こすべきではない）、CATCHブロックは例外を投げるものにそれを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no overlapping captures (as occurs from look-around assertions), the concatenation of all the pair values that &lt;c3&gt;chunks&lt;/c3&gt; returns is the same as the matched part of the string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T120145Z" creationid="Toshiyuki" creationdate="20140222T094634Z">
        <seg>重なり合うキャプチャー（look-aroundアサーションから生じる）がないならば、&lt;c3&gt;chunks&lt;/c3&gt;が返すすべてのペアの値の連結は文字列のマッチされた部分と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no statements in the block at all, the result is also &lt;c1&gt;()&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T022654Z" creationid="Toshiyuki" creationdate="20130803T022654Z">
        <seg>ブロックに文が全くないなら、その結果も&lt;c1&gt;()&lt;/c1&gt;になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no argument in the parentheses, the type object returns itself:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140401T125848Z" creationid="Toshiyuki" creationdate="20140401T125848Z">
        <seg>括弧に引数がなければ、型オブジェクトは自身を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no good way to convert an object to a number, Perl will use the default of &lt;c1&gt;0&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T124312Z" creationid="Toshiyuki" creationdate="20131028T124312Z">
        <seg>オブジェクトを数に変えるいい方法がないなら、Perlはデフォルトの&lt;c1&gt;0&lt;/c1&gt;を使うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no such lexically scoped outer loop in the current subroutine, then a fallback search is made outward through the dynamic scopes in the same way Perl 5 does.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T081114Z" creationid="Toshiyuki" creationdate="20130817T081114Z">
        <seg>もし現在のサブルーチンにそのようなレキシカルスコープの外側のループがないなら、フォールバックの検索はダイナミックスコープを通して外側にPerl 5と同じ方法で行われる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there's no enclosing block, it's visible throughout the remainder of the file.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T025420Z" creationid="Toshiyuki" creationdate="20131026T025420Z">
        <seg>囲んでいるブロックがないならば、それはファイルの残り全体を通して見えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there's no further work to do, the routine can decide to hand control completely to the next candidate by calling &lt;c0&gt;nextsame&lt;/c0&gt; or &lt;c1&gt;nextwith&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121349Z" creationid="Toshiyuki" creationdate="20140113T075845Z">
        <seg>更にする作業がなければ、ルーチンは&lt;c0&gt;nextsame&lt;/c0&gt;または&lt;c1&gt;nextwith&lt;/c1&gt;を呼ぶことによって次の候補へのハンドコントロールを完全に決めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this constraint returns a false value, the type check will fail when something calls this subroutine (footnote: note that the nominal type is now &lt;c1&gt;Real&lt;/c1&gt; instead of &lt;c2&gt;Numeric&lt;/c2&gt;, because not all &lt;c3&gt;Numeric&lt;/c3&gt; values can be compared for positiveness).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T071040Z" creationid="Toshiyuki" creationdate="20140106T140108Z">
        <seg>もし制約が偽を返すなら、何かがサブルーチンを呼ぶときに型チェックが失敗します（注釈：名目型は&lt;c2&gt;Numeric&lt;/c2&gt;の代わりに&lt;c1&gt;Real&lt;/c1&gt;です。なぜなら全ての&lt;c3&gt;Numeric&lt;/c3&gt;値が正の数と比較できるわけではないからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this were all that roles provided, they'd have few advantages over inheritance or mixins.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T015257Z" creationid="Toshiyuki" creationdate="20140115T135746Z">
        <seg>これがロールが提供する全てなら、継承やミックスインに勝るほとんど利点がないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you &lt;i2&gt;don't&lt;/i2&gt; deal with the failures as data, then sink context will automatically throw any unhandled &lt;c3&gt;Failure&lt;/c3&gt; that you try to discard.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T175500Z" creationid="Toshiyuki" creationdate="20130817T175500Z">
        <seg>もしデータとして失敗に対処しないなら、 あなたが破棄しようと試みるハンドルされないどれか一つの&lt;c3&gt;Failure&lt;/c3&gt;をsinkコンテキストは自動的にスローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you attempt to pass a literal value, a constant, or some other type of immutable object (footnote: An &lt;e3&gt;immutable&lt;/e3&gt; object is an object whose state cannot be changed after it has been created.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T001008Z" creationid="Toshiyuki" creationdate="20131205T104026Z">
        <seg>もしあなたがリテラル値、定数、または他の型の不変オブジェクト（脚注：&lt;e3&gt;不変&lt;/e3&gt;オブジェクトは、作成された後に状態を変更できないオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you declare a lexical twice in the same scope, it is the same lexical:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125859Z" creationid="Toshiyuki" creationdate="20130730T125859Z">
        <seg>もしもあなたがレキシカルを同じスコープで二回定義したら、それは同じレキシカルだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a &lt;c5&gt;CATCH&lt;/c5&gt; block within the &lt;c6&gt;try&lt;/c6&gt;, it replaces the default &lt;c7&gt;CATCH&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T122130Z" creationid="Toshiyuki" creationdate="20130813T122130Z">
        <seg>もし&lt;c5&gt;CATCH&lt;/c5&gt;ブロックを&lt;c6&gt;try&lt;/c6&gt;内に定義すると、デフォルトの&lt;c7&gt;CATCH&lt;/c7&gt;を差し替える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not make explicit the methods on which your role depends, the role composer will not verify their existence at compilation time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T034108Z" creationid="Toshiyuki" creationdate="20140115T141941Z">
        <seg>あなたがロールが依存するメソッドを明確にしないならば、ロールコンポーザーはコンパイル時にそれらの存在を検証しないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not wish to accidentally return a list from the final loop statement in a subroutine, place an explicit return statement after it, or use a &lt;c0&gt;sink&lt;/c0&gt; statement prefix on the loop itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T142659Z" creationid="Toshiyuki" creationdate="20130809T142659Z">
        <seg>もしサブルーチンの最後のループ文から偶然にリストを返すことを望まないなら、明白なリターン分をその後に配置するか、&lt;c0&gt;sink&lt;/c0&gt;文接頭辞をループ自身に使え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you exclude the &lt;c0&gt;return&lt;/c0&gt; statement, then the value produced by the last statement run inside the subroutine will be returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T062022Z" creationid="Toshiyuki" creationdate="20140104T222614Z">
        <seg>もし&lt;c0&gt;return&lt;/c0&gt;文を取り除くと、サブルーチン内で最後に実行されたステートメントによって生成された値が返されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a switch that is the main block of a &lt;c0&gt;for&lt;/c0&gt; loop that uses &lt;c1&gt;$_&lt;/c1&gt; as its loop variable, and you break out of the switch either implicitly or explicitly (that is, the switch "succeeds"), control merely goes to the end of that block, and thence on to the next iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115936Z" creationid="Toshiyuki" creationdate="20130813T115936Z">
        <seg>もし&lt;c1&gt;$_&lt;/c1&gt;をループ変数として使っている&lt;c0&gt;for&lt;/c0&gt;ループのメインブロックとなっているswitchを持っており、switchを暗黙か明示的に抜けるなら（すなわち、switchが「成功する」）、制御は単にブロックの終わりに行き、そこから次のループの反復に行く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you pass a &lt;c6&gt;Rock&lt;/c6&gt; as the first argument, &lt;c7&gt;T&lt;/c7&gt; acts as an alias for &lt;c8&gt;Rock&lt;/c8&gt; inside the rest of the signature and the body of the routine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114630Z" creationid="Toshiyuki" creationdate="20140113T050638Z">
        <seg>あなたが最初の引数として&lt;c6&gt;Rock&lt;/c6&gt;を渡すならば、&lt;c7&gt;T&lt;/c7&gt;は残りのシグネチャーの中の&lt;c8&gt;Rock&lt;/c8&gt;とルーチンの本体の別名の働きをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you pass it to the multi &lt;c2&gt;a&lt;/c2&gt;, the second candidate, which is specific to &lt;c3&gt;Int&lt;/c3&gt; wins, because nominal types are checked first.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114255Z" creationid="Toshiyuki" creationdate="20140113T045056Z">
        <seg>あなたがマルチ&lt;c2&gt;a&lt;/c2&gt;にそれを渡すならば名目型が最初にチェックされるので、第二候補&lt;c3&gt;Int&lt;/c3&gt;が勝利します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you quantify a capture, the corresponding entry in the match object is a list of other match objects:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T125851Z" creationid="Toshiyuki" creationdate="20140221T233725Z">
        <seg>あなたがキャプチャーを数量化するならば、マッチオブジェクトの対応するエントリは他のマッチオブジェクトのリストです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you rely on &lt;c0&gt;$_&lt;/c0&gt; as the implicit parameter to a block, then &lt;c1&gt;$_&lt;/c1&gt; is considered read/write by default.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113936Z" creationid="Toshiyuki" creationdate="20130810T113936Z">
        <seg>もし&lt;c0&gt;$_&lt;/c0&gt;をブロックの暗黙のパラメータとして当てにするなら、&lt;c1&gt;$_&lt;/c1&gt;はデフォルトでread/writeと見なされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you run that code, you'll discover that the &lt;c0&gt;Int&lt;/c0&gt; candidate gets called.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T225602Z" creationid="Toshiyuki" creationdate="20140113T044247Z">
        <seg>そのコードを実行するならば、あなたは&lt;c0&gt;Int&lt;/c0&gt;候補が呼ばれるということを発見するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you take multiple items in a comma list (since it is, after all, a list operator), they will be wrapped up in a &lt;c0&gt;Parcel&lt;/c0&gt; object for return as the next argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T201027Z" creationid="Toshiyuki" creationdate="20130810T201027Z">
        <seg>もしコンマリストで複数のアイテムをとるなら（だから、結局、リスト演算子）、それらは次の引数として返すために&lt;c0&gt;Parcel&lt;/c0&gt;オブジェクトにラップされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you test a &lt;c0&gt;Failure&lt;/c0&gt; for &lt;c1&gt;.defined&lt;/c1&gt; or &lt;c2&gt;.Bool&lt;/c2&gt;, the &lt;c3&gt;Failure&lt;/c3&gt; marks itself as &lt;i4&gt;handled&lt;/i4&gt;; the exception acts as a relatively harmless undefined value thereafter.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T155554Z" creationid="Toshiyuki" creationdate="20130817T155554Z">
        <seg>もし&lt;c0&gt;Failure&lt;/c0&gt;を&lt;c1&gt;.defined&lt;/c1&gt;または&lt;c2&gt;.Bool&lt;/c2&gt;のためにテストするなら、 &lt;c3&gt;Failure&lt;/c3&gt;はそれ自身を&lt;i4&gt;handled&lt;/i4&gt;としてマークする；例外はその後は相対的に無害な未定義値としてふるまう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a &lt;c0&gt;for&lt;/c0&gt; loop with a parameter named &lt;c1&gt;$_&lt;/c1&gt; (either explicitly or implicitly), that parameter can function as the topic of any &lt;c2&gt;when&lt;/c2&gt; statements within the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T111358Z" creationid="Toshiyuki" creationdate="20130812T111358Z">
        <seg>もし&lt;c0&gt;for&lt;/c0&gt;ループを名前付きパラメータ&lt;c1&gt;$_&lt;/c1&gt;（明示的か暗黙的）と共に使うなら、そのパラメータはループ内のどんな&lt;c2&gt;when&lt;/c2&gt;文のトピックとしても機能できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a variable to create a pair, you can reuse the variable name as the key of the pair.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T013108Z" creationid="Toshiyuki" creationdate="20140104T154559Z">
        <seg>もしペアを作るために変数を使うなら、変数名をペアのキーに流用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use the &lt;c0&gt;:sigspace&lt;/c0&gt; modifier, every continuous piece of whitespace calls the built-in rule &lt;c1&gt;&lt;.ws&gt;&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131609Z" creationid="Toshiyuki" creationdate="20140222T023920Z">
        <seg>あなたが&lt;c0&gt;:sigspace&lt;/c0&gt;修飾子を使用するならば、空白文字のすべての連続的部分は組み込みルール&lt;c1&gt;&lt;.ws&gt;&lt;/c1&gt;を呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you used &lt;c0&gt;order-burger&lt;/c0&gt; repeatedly, but often with a side of french fries, you might wish that the author had also provided a &lt;c1&gt;order-burger-and-fries&lt;/c1&gt; sub.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T045933Z" creationid="Toshiyuki" creationdate="20140111T045933Z">
        <seg>もしあなたが&lt;c0&gt;order-burger&lt;/c0&gt;を繰り返し使い、しかししばしばサイドでフライドポテトを使うなら、作成者が&lt;c1&gt;order-burger-and-fries&lt;/c1&gt;も提供することを願うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want it to be available, you must rewrite it as an explicit block using curlies:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T115013Z" creationid="Toshiyuki" creationdate="20130810T115013Z">
        <seg>もし使用できるようにしたいなら、カーリーブラケットを使って明白なブロックとして書き直す必要がある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to continue the expression after the statement, or if you want to attach multiple statements, you must either use the curly form or surround the entire expression in brackets of some sort:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T122313Z" creationid="Toshiyuki" creationdate="20130810T121937Z">
        <seg>もし文の後に式を続けたい、または複数の文を付け加えたいなら、カーリー形式か全体の式をブラケットで囲むかしなければならない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to force a different parsing precedence, surround an expression with parentheses, so that this new group has the tightest possible precedence:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121327Z" creationid="Toshiyuki" creationdate="20131027T121327Z">
        <seg>あなたが異なるパースの優先順位を強制したいならば、括弧で式を囲んでください、そうすると、この新しいグループは最も厳しい優先順位を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to search for a comma, an asterisk, or another non-word character, you must quote or escape it (footnote: To search for a literal string--without using the pattern matching features of regex--consider using &lt;c0&gt;index&lt;/c0&gt; or &lt;c1&gt;rindex&lt;/c1&gt; instead.):</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T023404Z" creationid="Toshiyuki" creationdate="20140321T023304Z">
        <seg>もしコンマ、アスタリスク、他の非ワード文字を検索したいなら、それを必ずエスケープしなければなりません（脚注：リテラル文字列 ― 正規表現のパターンマッチ機能を使わないもの ― を検索するなら、代わりに&lt;c0&gt;index&lt;/c0&gt;か&lt;c1&gt;rindex&lt;/c1&gt;の使用を検討してください）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to apply multiple roles at a time, list them all with &lt;c0&gt;does&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T160832Z" creationid="Toshiyuki" creationdate="20140115T142750Z">
        <seg>あなたが一度に複数のロールを適用したいと思うなら、&lt;c0&gt;does&lt;/c0&gt;でそれらのすべてをリストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to return a closure from a function, you must use an explicit prefix such as &lt;c0&gt;return&lt;/c0&gt; or &lt;c1&gt;sub&lt;/c1&gt; or &lt;c2&gt;-&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T150911Z" creationid="Toshiyuki" creationdate="20130810T150911Z">
        <seg>もし関数からクロージャを返したければ、&lt;c0&gt;return&lt;/c0&gt;または&lt;c1&gt;sub&lt;/c1&gt;または&lt;c2&gt;-&gt;&lt;/c2&gt;のような明白な接頭辞を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you write a literal that consists only of digits, such as &lt;c1&gt;12&lt;/c1&gt;, it is an &lt;c2&gt;Int&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014047Z" creationid="Toshiyuki" creationdate="20140226T143515Z">
        <seg>あなたが数字（例えば&lt;c1&gt;12&lt;/c1&gt;）だけから成るリテラルを書くならば、それは&lt;c2&gt;Int&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're passing a boolean value, you may omit the value portion of the pair:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T154225Z" creationid="Toshiyuki" creationdate="20140104T154225Z">
        <seg>もしあなたがブール値を渡すなら、ペアの値の部分を省略できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you've referred to &lt;c0&gt;$x&lt;/c0&gt; prior to the first declaration, and the compiler tentatively bound it to &lt;c1&gt;$OUTER::x&lt;/c1&gt;, then it's an error to declare it, and the compiler is required to complain at that point.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T131017Z" creationid="Toshiyuki" creationdate="20130730T131017Z">
        <seg>もしあなたが最初の宣言の前に&lt;c0&gt;$x&lt;/c0&gt;を参照し、コンパイラがそれを仮に&lt;c1&gt;$OUTER::x&lt;/c1&gt;にバインドしたら、それを宣言することはエラーであり、コンパイラがその時点で文句を言う必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your operating system (footnote: Ubuntu 10.4: In System/Preferences/Keyboard/Layouts/Options/Compose Key position select one of the keys to be the "Compose" key.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T032811Z" creationid="Toshiyuki" creationdate="20140322T032811Z">
        <seg>もしあなたのオペレーティングシステム(footnote: Ubuntu 10.4: In System/Preferences/Keyboard/Layouts/Options/Compose Key position select one of the keys to be the "Compose" key.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your personal order is always vegetarian, you might instead wish for a &lt;c0&gt;order-the-usual&lt;/c0&gt; sub.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T050126Z" creationid="Toshiyuki" creationdate="20140111T050126Z">
        <seg>あなた個人のオーダーが常にベジタリアンなら、代わりに&lt;c0&gt;order-the-usual&lt;/c0&gt;を望むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If, instead of throwing a warning directly, the program calls &lt;c1&gt;fail()&lt;/c1&gt; with a resumable exception, the throwing of the warning is delayed until first use (or the caller's policy) requires it to be thrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130550Z" creationid="Toshiyuki" creationdate="20130817T130550Z">
        <seg>もし代わりに例外を直接スルーするなら、プログラムは&lt;c1&gt;fail()&lt;/c1&gt;を再開可能な例外と共に呼ぶ。警告のスローは最初の使用（または呼び出し元のポリシー）がスローを要求するまで延ばされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If, instead, you want a local copy of the argument to work with inside the subroutine - leaving the caller's variable untouched - use the &lt;c0&gt;is copy&lt;/c0&gt; trait:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T001238Z" creationid="Toshiyuki" creationdate="20131206T220330Z">
        <seg>代わりに、サブルーチン内で作業するためのローカルコピーが欲しいなら ― 呼び出し元の変数を触らない ― &lt;c0&gt;is copy&lt;/c0&gt;トレイトを使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignore the &lt;c0&gt;new&lt;/c0&gt; method temporarily; it's a special type of method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185008Z" creationid="Toshiyuki" creationdate="20140111T185008Z">
        <seg>&lt;c0&gt;new&lt;/c0&gt;メソッドは一旦無視してください；それは特別なタイプのメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit whitespace is matched with the inherited regex &lt;c2&gt;&lt;ws&gt;&lt;/c2&gt;, so the simplest approach to enable single- line comments is to override that named regex:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T224732Z" creationid="Toshiyuki" creationdate="20140223T103137Z">
        <seg>暗黙の空白は継承された正規表現&lt;c2&gt;&lt;ws&gt;&lt;/c2&gt;でマッチされるので、シングルラインコメントを利用可能にする最も単純なアプローチは、その名前付き正規表現をオーバーライドすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In &lt;c2&gt;JSON::Tiny::Grammar&lt;/c2&gt;, &lt;c3&gt;A&lt;/c3&gt; is &lt;c4&gt;'{'&lt;/c4&gt;, &lt;c5&gt;B&lt;/c5&gt; is &lt;c6&gt;'}'&lt;/c6&gt; and &lt;c7&gt;C&lt;/c7&gt; is &lt;c8&gt;&lt;pairlist&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T143412Z" creationid="Toshiyuki" creationdate="20140222T133322Z">
        <seg>&lt;c2&gt;JSON::Tiny::Grammar&lt;/c2&gt;内で、&lt;c3&gt;A&lt;/c3&gt;は&lt;c4&gt;'{'&lt;/c4&gt;、&lt;c5&gt;B&lt;/c5&gt;は&lt;c6&gt;'}'&lt;/c6&gt;、そして&lt;c7&gt;C&lt;/c7&gt;は&lt;c8&gt;&lt;pairlist&gt;&lt;/c8&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 5, a bare block is deemed to be a do-once loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T120255Z" creationid="Toshiyuki" creationdate="20130810T120255Z">
        <seg>Perl 5では、裸のブロックはdo-onceループと判断される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, although the specific syntax used to describe the patterns is different from PCRE (footnote: &lt;s1&gt;P&lt;/s1&gt;erl &lt;s2&gt;C&lt;/s2&gt;ompatible &lt;s3&gt;R&lt;/s3&gt;egular &lt;s4&gt;E&lt;/s4&gt;xpressions) and POSIX (footnote: &lt;s5&gt;P&lt;/s5&gt;ortable &lt;s6&gt;O&lt;/s6&gt;perating &lt;s7&gt;S&lt;/s7&gt;ystem &lt;s8&gt;I&lt;/s8&gt;nterface for Uni&lt;s9&gt;x&lt;/s9&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T021311Z" creationid="Toshiyuki" creationdate="20140115T143421Z">
        <seg>Perl 6では、パターンを記述するのに用いられる特定の構文は、PCREやPOSIXと異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, control flow is designed to do what the user expects most of the time, but this implies that we must consider the declarative nature of labels and blocks and combine those with the dynamic nature of the call stack.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T170258Z" creationid="Toshiyuki" creationdate="20130727T170258Z">
        <seg>Perl 6では制御フローはユーザーが殆どの場合期待する通りにデザインされているが、これは宣言的な性質のラベルとブロックとコールスタックの動的な性質とそれらを結びつけることについて我々が考えなければならないことを伴う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, curry with the &lt;c0&gt;.assuming&lt;/c0&gt; method:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043359Z" creationid="Toshiyuki" creationdate="20140111T053513Z">
        <seg>Perl 6では&lt;c0&gt;.assuming&lt;/c0&gt;メソッドでカリー化してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, the bare block is not a do-once.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T120317Z" creationid="Toshiyuki" creationdate="20130810T120317Z">
        <seg>Perl 6では裸のブロックはdo-onceではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, the variables in a subroutine's signature are read-only references to the passed arguments by default.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T035442Z" creationid="Toshiyuki" creationdate="20131129T150052Z">
        <seg>Perl 6のデフォルトでは、サブルーチンシグネチャーの変数は渡された引数の読み取り専用の参照です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a boolean context, a Hash object is true if there are any pairs in the hash.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090056Z" creationid="Toshiyuki" creationdate="20140329T090056Z">
        <seg>ブールコンテキストでは、ハッシュに何らかのペアがあればハッシュオブジェクトは真です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a sense, the operators described in chapter 3 are also subroutines that Perl 6 parses in interesting ways.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131335Z" creationid="Toshiyuki" creationdate="20131029T131321Z">
        <seg>ある意味では、第3章で記述される演算子は、Perl 6が興味深い方法で解析するサブルーチンでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a signature, a variable's sigil also acts as a constraint on the type of argument that can be passed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T035500Z" creationid="Toshiyuki" creationdate="20131221T002039Z">
        <seg>シグネチャーでは、変数のシギルは引数に渡すことができる型の制約としても機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to &lt;c0&gt;next&lt;/c0&gt;, &lt;c1&gt;last&lt;/c1&gt;, and &lt;c2&gt;redo&lt;/c2&gt;, Perl 6 also supports &lt;c3&gt;goto&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T131449Z" creationid="Toshiyuki" creationdate="20130817T131449Z">
        <seg>&lt;c0&gt;next&lt;/c0&gt;、&lt;c1&gt;last&lt;/c1&gt;、&lt;c2&gt;redo&lt;/c2&gt;に加えてPerl 6は&lt;c3&gt;goto&lt;/c3&gt;もサポートする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to collecting all of the values, a slurpy parameter will also flatten any arrays that it collects, so that you end up with a single, flat list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T060112Z" creationid="Toshiyuki" creationdate="20140104T195756Z">
        <seg>すべての値を集めるのに加えて、slurpyパラメータは値を集める配列をフラットにします。そのため、単一のフラットなリストになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, all formal parameters are the equivalent of &lt;c0&gt;my&lt;/c0&gt; variables within the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T125913Z" creationid="Toshiyuki" creationdate="20130729T125913Z">
        <seg>いずれにせよ、全ての仮パラメータはブロック内の&lt;c0&gt;my&lt;/c0&gt;変数と同等だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, the overriding design principle here is that no unhandled exception is ever dropped on the floor, but propagated outward until it is handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T182231Z" creationid="Toshiyuki" creationdate="20130817T182231Z">
        <seg>いずれにせよ、ここでのオーバーライドのデザイン原理は、ハンドルされない例外は常に床に落ちる。しかしハンドルされるまで外側に伝搬される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In boolean context, a match object returns &lt;c1&gt;True&lt;/c1&gt; for successful matches and &lt;c2&gt;False&lt;/c2&gt; for failed ones.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T085704Z" creationid="Toshiyuki" creationdate="20140222T024706Z">
        <seg>ブール値コンテキストでは、マッチオブジェクトは成功マッチなら&lt;c1&gt;True&lt;/c1&gt;、そして失敗なら&lt;c2&gt;False&lt;/c2&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In boolean contexts, a true value is returned if and only if there are any elements in the container.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022628Z" creationid="Toshiyuki" creationdate="20140329T022628Z">
        <seg>ブール値コンテキストでは何らかの要素がコンテナにあれば真を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case this sets the &lt;c0&gt;of&lt;/c0&gt; property of the container to &lt;c1&gt;Dog&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T213252Z" creationid="Toshiyuki" creationdate="20140328T213252Z">
        <seg>いずれもコンテナの&lt;c0&gt;of&lt;/c0&gt;プロパティに&lt;c1&gt;Dog&lt;/c1&gt;をセットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, a grammar is a class which by default inherits from &lt;c0&gt;Grammar&lt;/c0&gt; instead of &lt;c1&gt;Any&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T223728Z" creationid="Toshiyuki" creationdate="20140223T101632Z">
        <seg>実際、グラマーはデフォルトで&lt;c1&gt;Any&lt;/c1&gt;の代わりに&lt;c0&gt;Grammar&lt;/c0&gt;を継承するクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, most of these phasers will take either a block or a thunk (known as a &lt;i0&gt;blast&lt;/i0&gt; in the vernacular).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T083300Z" creationid="Toshiyuki" creationdate="20130818T083300Z">
        <seg>実際は、大部分のphasersはブロックかサンク（固有の言葉で&lt;i0&gt;blast&lt;/i0&gt;として知られる）をとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, quite the opposite.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T225453Z" creationid="Toshiyuki" creationdate="20131025T225453Z">
        <seg>実際は正反対です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, this construct would be relatively useless if you could bind only boolean values as parameters, since within the closure you already know whether it evaluated to true or false.) Binding within an &lt;c1&gt;else&lt;/c1&gt; automatically binds the value tested by the previous &lt;c2&gt;if&lt;/c2&gt; or &lt;c3&gt;elsif&lt;/c3&gt;, which, while known to be false, might nevertheless be an &lt;i4&gt;interesting&lt;/i4&gt; value of false.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T084044Z" creationid="Toshiyuki" creationdate="20130804T084044Z">
        <seg>実際は、もしあなたがブール値をパラメータとしてしかバインドしないなら、この構成物は相対的に役に立たない。だから、あなたはクロージャの範囲内でそれが真か偽で評価されるかすでに知っている。&lt;c1&gt;else&lt;/c1&gt;のバインドは値を前にテストした&lt;c2&gt;if&lt;/c2&gt;か&lt;c3&gt;elsif&lt;/c3&gt;に自動的にバインドし、偽と判明している間、&lt;i4&gt;面白い&lt;/i4&gt;偽の値にも関わらず。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, for most iterated solutions you should consider using a &lt;c2&gt;for&lt;/c2&gt; loop instead (see below).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T145855Z" creationid="Toshiyuki" creationdate="20130809T145855Z">
        <seg>一般に、最も繰り返される解決法のためにあなたは&lt;c2&gt;for&lt;/c2&gt;ループを代わりに使うことを検討すべきだ（下記参照）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, initializing phasers execute in order declared, while finalizing phasers execute in the opposite order.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130820T124713Z" creationid="Toshiyuki" creationdate="20130820T124713Z">
        <seg>一般にphasersの初期化は宣言順に実行し、ファイナライズは逆順に実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In item context, variables such as &lt;c3&gt;@array&lt;/c3&gt; and &lt;c4&gt;%hash&lt;/c4&gt; simply return themselves as &lt;c5&gt;Array&lt;/c5&gt; and &lt;c6&gt;Hash&lt;/c6&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022325Z" creationid="Toshiyuki" creationdate="20140329T022325Z">
        <seg>アイテムコンテキストでは&lt;c3&gt;@array&lt;/c3&gt;と&lt;c4&gt;%hash&lt;/c4&gt;のような変数は単にそれら自身を&lt;c5&gt;Array&lt;/c5&gt;と&lt;c6&gt;Hash&lt;/c6&gt;のオブジェクトとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its simplest form, a signature is a comma separated list of variable names to which to bind incoming arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T035433Z" creationid="Toshiyuki" creationdate="20131126T132400Z">
        <seg>最も単純な形では、シグネチャーは入ってくる引数をバインドする変数名をコンマで区切ったリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many ways, this looks a lot like a &lt;c0&gt;sub&lt;/c0&gt; declaration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185203Z" creationid="Toshiyuki" creationdate="20140111T185203Z">
        <seg>様々な点でこれは&lt;c0&gt;sub&lt;/c0&gt;宣言に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most interesting programs the dynamic scopes are nested quite differently from the lexical scopes, so it's important to distinguish carefully which kind of scoping we're talking about.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T145648Z" creationid="Toshiyuki" creationdate="20130727T145648Z">
        <seg>最も興味深いプログラムでは、ダイナミックスコープはレキシカルスコープと全く違うように入れ子になっている。そういうわけで、我々が話しているようなスコープとは注意深く区別することが大切だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In normal English text, you always place a whitespace after a comma.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T063129Z" creationid="Toshiyuki" creationdate="20140222T024014Z">
        <seg>通常の英語テキストでは、あなたは常にコンマの後に空白文字を置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric context (i.e. when cast into &lt;c0&gt;Int&lt;/c0&gt; or &lt;c1&gt;Num&lt;/c1&gt;), a &lt;c2&gt;Hash&lt;/c2&gt; object becomes the number of pairs contained in the hash.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090003Z" creationid="Toshiyuki" creationdate="20140329T090003Z">
        <seg>数値コンテキスト（すなわち&lt;c0&gt;Int&lt;/c0&gt;または&lt;c1&gt;Num&lt;/c1&gt;にキャストする時）では、&lt;c2&gt;Hash&lt;/c2&gt;オブジェクトはハッシュに含まれるペアの数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric contexts, the number of elements in the container is returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022543Z" creationid="Toshiyuki" creationdate="20140329T022543Z">
        <seg>数値コンテキストではコンテナの要素数が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to do this, add an array parameter to the signature, placing the &lt;e0&gt;slurpy&lt;/e0&gt; prefix (&lt;c1&gt;*&lt;/c1&gt;) before it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T055040Z" creationid="Toshiyuki" creationdate="20140104T192243Z">
        <seg>こうするために、シグネチャの配列パラメータの前に&lt;e0&gt;slurpy&lt;/e0&gt;接頭辞（ &lt;c1&gt;*&lt;/c1&gt;）を置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other object systems, classes perform two tasks.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122041Z" creationid="Toshiyuki" creationdate="20140113T175427Z">
        <seg>他のオブジェクトシステムでは、クラスは2つの仕事を果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other programming languages, such as C/C++ and Scheme, this evaluation strategy is known as &lt;e0&gt;pass-by-value&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131206T220525Z" creationid="Toshiyuki" creationdate="20131206T220501Z">
        <seg>C/C++やSchemeのような他のプログラミング言語では、この評価方法は&lt;e0&gt;値渡し&lt;/e0&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, it first tries this form:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080933Z" creationid="Toshiyuki" creationdate="20130817T080933Z">
        <seg>言い換えれば、最初にこの形式を試す：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular,</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124152Z" creationid="Toshiyuki" creationdate="20130811T124152Z">
        <seg>特に、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, this means that &lt;c3&gt;once&lt;/c3&gt; can make use of any parameters passed in on the first call, whereas &lt;c4&gt;INIT&lt;/c4&gt; cannot.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130825T072440Z" creationid="Toshiyuki" creationdate="20130825T072440Z">
        <seg>特に、&lt;c3&gt;once&lt;/c3&gt;は最初の呼び出しで任意のパラメータを使えるようにするのに対し、&lt;c4&gt;INIT&lt;/c4&gt;はできない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, we now generally use &lt;c3&gt;for&lt;/c3&gt; to iterate filehandles.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T150043Z" creationid="Toshiyuki" creationdate="20130809T150043Z">
        <seg>特に、我々は現在一般的に&lt;c3&gt;for&lt;/c3&gt;をファイルハンドルを反復するために使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In place of &lt;c1&gt;$n&lt;/c1&gt; it prints the contents of the variable &lt;c2&gt;$n&lt;/c2&gt;-- the names of players stored in &lt;c3&gt;$n&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T083709Z" creationid="Toshiyuki" creationdate="20131026T152653Z">
        <seg>&lt;c1&gt;$n&lt;/c1&gt;の代わりに変数&lt;c2&gt;$n&lt;/c2&gt;の内容 ― &lt;c3&gt;$n&lt;/c3&gt;に保存されたプレイヤーの名前を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, using &lt;c1&gt;:_&lt;/c1&gt; is a bit redundant.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T132654Z" creationid="Toshiyuki" creationdate="20140110T132654Z">
        <seg>実際には&lt;c1&gt;:_&lt;/c1&gt;の使用は少し冗長です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In prose, the comment starts with &lt;c2&gt;'//'&lt;/c2&gt; and extends to the rest of the line.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T225727Z" creationid="Toshiyuki" creationdate="20140223T104315Z">
        <seg>要するにコメントは&lt;c2&gt;'//'&lt;/c2&gt;から始まり、行の残りまで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In string contexts, lists and list-like objects automatically stringify to appropriate (white-space separated) string values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022516Z" creationid="Toshiyuki" creationdate="20140329T022516Z">
        <seg>文字列コンテキストでは、リストとリストのようなオブジェクトは自動的に適切な（空白で区切られた）文字列値に文字列化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, use the &lt;c3&gt;but&lt;/c3&gt; operator, which clones the object, performs the role composition with the clone, and returns the clone.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T163505Z" creationid="Toshiyuki" creationdate="20140115T143053Z">
        <seg>その場合には、&lt;c3&gt;but&lt;/c3&gt;演算子（それはオブジェクトのクローンをつくります）がクローンでロール合成を実行します。そしてそのクローンを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, you may also call the callable parameter without the &lt;c6&gt;&amp;&lt;/c6&gt; sigil:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131221T003707Z" creationid="Toshiyuki" creationdate="20131221T003707Z">
        <seg>その場合、呼び出し可能なパラメータを&lt;c6&gt;&amp;&lt;/c6&gt;シギル無しで呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the absence of explicit control flow terminating the block early, the return value of a block is the value of its final statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T165145Z" creationid="Toshiyuki" creationdate="20130802T165145Z">
        <seg>ブロックを早期に終える明白な制御フローがない場合、ブロックの返り値は最後の文の値だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of multi dispatch, the narrowest match always wins.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113902Z" creationid="Toshiyuki" creationdate="20140113T044534Z">
        <seg>マルチディスパッチの場合、最も制限されたマッチは常に勝ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of the JSON parser, the payload is the data structure that the JSON string represents.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T135548Z" creationid="Toshiyuki" creationdate="20140224T162614Z">
        <seg>JSONパーサーの場合、ペイロードはJSON文字列が表すデータ構造です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113935Z" creationid="Toshiyuki" creationdate="20140322T113935Z">
        <seg>この場合：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case where you want all your parameters to default to &lt;c0&gt;rw&lt;/c0&gt;, you may use the visually suggestive double-ended arrow to indicate that values flow both ways:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113722Z" creationid="Toshiyuki" creationdate="20130810T113722Z">
        <seg>このケースで全てのパラメータを&lt;c0&gt;rw&lt;/c0&gt;としたいなら、値の流れを視覚的に表す両頭矢印を使ってもよい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of a role, this means that any class which composes this role must somehow provide a method named &lt;c0&gt;bot-nick&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T033835Z" creationid="Toshiyuki" creationdate="20140115T141749Z">
        <seg>ロールのコンテキストでは、このロールを合成するクラスは何でも&lt;c0&gt;bot-nick&lt;/c0&gt;という名前のメソッドをどうにかして提供しなければならないということを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of multiple dispatch, nested signatures take on a second task: they act as constraints to distinguish between the candidates.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115723Z" creationid="Toshiyuki" creationdate="20140113T073129Z">
        <seg>複数のディスパッチの文脈では、入れ子になったシグネチャーは第二タスクを引き受けます：それらは、候補を区別する制約の働きをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the course of matching a regex against a string, the regex engine may reach a point where an alternation has matched a particular branch or a quantifier has greedily matched all it can, but the final portion of the regex fails to match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T042727Z" creationid="Toshiyuki" creationdate="20140222T021530Z">
        <seg>文字列に対して正規表現をマッチする間、正規表現エンジンは論理和が特定の分岐にマッチした、または数量詞がすべてそれに可能な貪欲に合うものを見つけたポイントに到達します。しかし正規表現の最終的な部分はマッチに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the current Rakudo implementation, the second line with &lt;c1&gt;say&lt;/c1&gt; will print a higher number than the first.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T224553Z" creationid="Toshiyuki" creationdate="20140112T224522Z">
        <seg>現在のRakudo実装では、&lt;c1&gt;say&lt;/c1&gt;による第二行は、最初より高い数を出力するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first call of &lt;c0&gt;a(3)&lt;/c0&gt;, the nominal types alone already determine the best candidate match, so the where block never executes and the first &lt;c1&gt;$counter&lt;/c1&gt; output is always &lt;c2&gt;0&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T224805Z" creationid="Toshiyuki" creationdate="20140112T224637Z">
        <seg>&lt;c0&gt;a(3)&lt;/c0&gt;の最初の呼び出しで、名目型は最善の候補マッチをすでに決定します。なのでブロックは実行されず、最初の&lt;c1&gt;$counter&lt;/c1&gt;出力は常に&lt;c2&gt;0&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first iteration &lt;c2&gt;%sets{$p1}&lt;/c2&gt; is not yet set, so it defaults to a special value called &lt;c3&gt;Any&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T135147Z" creationid="Toshiyuki" creationdate="20131026T135147Z">
        <seg>最初の繰り返しにおいて、&lt;c2&gt;%sets{$p1}&lt;/c2&gt;はまだセットされていないので、それはデフォルトで&lt;c3&gt;Any&lt;/c3&gt;と呼ばれる特別な値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the line:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T110722Z" creationid="Toshiyuki" creationdate="20131027T110722Z">
        <seg>行の中で：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the previous example, &lt;c0&gt;$&lt;dup&gt;&lt;/c0&gt; is a shortcut for &lt;c1&gt;$/&lt;dup&gt;&lt;/c1&gt; or &lt;c2&gt;$/{ 'dup' }&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T091804Z" creationid="Toshiyuki" creationdate="20140222T025211Z">
        <seg>前の例の&lt;c0&gt;$&lt;dup&gt;&lt;/c0&gt;は&lt;c1&gt;$/&lt;dup&gt;&lt;/c1&gt;または$/{ 'dup' }のためのショートカットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the previous example, the &lt;c0&gt;line-and-column&lt;/c0&gt; function determines the line number in which the match occurred by extracting the string up to the match position (&lt;c1&gt;$m.orig.substr(0, $m.from)&lt;/c1&gt;), splitting it by newlines, and counting the elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T091300Z" creationid="Toshiyuki" creationdate="20140222T025001Z">
        <seg>前の例で&lt;c0&gt;line-and-column&lt;/c0&gt;関数は文字列をマッチ位置（&lt;c1&gt;$m.orig.substr(0, $m.from)&lt;/c1&gt;）まで抽出し、改行文字で分割し、要素を数えることで行数を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the previous examples, the comparisons are numeric, string, and range, respectively.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T125423Z" creationid="Toshiyuki" creationdate="20131029T125423Z">
        <seg>前の例にはそれぞれ、比較は数字、文字列とレンジです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the score counting program, &lt;c0&gt;%matches&lt;/c0&gt; stores the number of matches each player has won.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T155404Z" creationid="Toshiyuki" creationdate="20131026T094519Z">
        <seg>スコア計算プログラムでは、&lt;c0&gt;%matches&lt;/c0&gt;は各々のプレーヤーが勝った試合の数を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In theory, any user-defined control construct can catch any control exception it likes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T075745Z" creationid="Toshiyuki" creationdate="20130817T075735Z">
        <seg>理論的には、どれか一つのユーザー定義の制御構造はそれのように制御例外をキャッチできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these cases, it makes sense to restrict the types of parameters, such that attempts to pass incorrect values as arguments will cause Perl to raise an error at the time of calling the subroutine, or even at the compile time, if the compiler is smart enough to catch that (footnote: at the time of writing, Rakudo recognizes type mismatches for literals and explicitly typed variables).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T064643Z" creationid="Toshiyuki" creationdate="20140106T125540Z">
        <seg>これらの場合、パラメータの方を制限することは不正な値を引数として渡した時にPerlがサブルーチン呼び出し時かコンパイル時にエラーを起こすのに十分スマートなコンパイラであるときに意味をなします（注釈：これを書いている時点ではRakudoはリテラルと明示的に型指定した変数の方の不一致を認識します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case the captures occur in the same order as they are in the regex, but quantifiers can change that.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134613Z" creationid="Toshiyuki" creationdate="20140222T025416Z">
        <seg>この場合、キャプチャーはそれらの正規表現と同じ順序で起こります。しかし数量詞はそれを変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case the objects are pairs.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T050318Z" creationid="Toshiyuki" creationdate="20131027T050318Z">
        <seg>この場合、オブジェクトはペアです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, it is often easier to pass the arguments by name.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T011344Z" creationid="Toshiyuki" creationdate="20131231T201057Z">
        <seg>このような場合、大抵は引数を名前で渡すと簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, it is possible to mark the parameter as optional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T010814Z" creationid="Toshiyuki" creationdate="20131230T040828Z">
        <seg>この場合、パラメータを任意としてマークすることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, it makes little sense to compose both of the roles into a class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T020909Z" creationid="Toshiyuki" creationdate="20140115T140216Z">
        <seg>この場合、それは両方のロールをクラスに合成するために小さく意味をなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the &lt;c3&gt;!&lt;/c3&gt; twigil emphasizes that this attribute is private to the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182723Z" creationid="Toshiyuki" creationdate="20140111T182723Z">
        <seg>この場合、&lt;c3&gt;!&lt;/c3&gt; twigilは属性がクラスにプライベートであることを強調します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the amount and types of the function's arguments help to distinguish between the variants of a function.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112146Z" creationid="Toshiyuki" creationdate="20140112T181845Z">
        <seg>この場合、関数の引数の量と型は関数の異形を区別するのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the regex engine backs up and attempts to match another alternative or matches one fewer character of the quantified portion to see if the overall regex succeeds.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T044818Z" creationid="Toshiyuki" creationdate="20140222T021546Z">
        <seg>この場合、正規表現エンジンはバックして、全ての正規表現が成功するか見るために他の選択肢にマッチするか、数量化された1つ少ない文字の部分にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the slurpy should come last.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T061034Z" creationid="Toshiyuki" creationdate="20140104T204928Z">
        <seg>その場合、slurpyは最後にくるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, you may add an additional &lt;e0&gt;constraint&lt;/e0&gt; to the parameter with a &lt;c1&gt;where&lt;/c1&gt; block:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140106T133725Z" creationid="Toshiyuki" creationdate="20140106T133725Z">
        <seg>この場合、更なる&lt;e0&gt;制約&lt;/e0&gt;を&lt;c1&gt;where&lt;/c1&gt;ブロックで追加できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, &lt;c0&gt;dup&lt;/c0&gt; calls the &lt;c1&gt;word&lt;/c1&gt; regex, then matches at least one non-word character, and then matches the same string as previously matched by the regex &lt;c2&gt;word&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130422Z" creationid="Toshiyuki" creationdate="20140222T015217Z">
        <seg>この例では、&lt;c0&gt;dup&lt;/c0&gt;は&lt;c1&gt;word&lt;/c1&gt;正規表現を呼び、そして少なくとも1つの非語文字にマッチし、そして前もって正規表現&lt;c2&gt;word&lt;/c2&gt;によってマッチした同じ文字列とマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the &lt;c0&gt;TOP&lt;/c0&gt; rule anchors the match to the start (with &lt;c1&gt;^&lt;/c1&gt;) and end of the string (with &lt;c2&gt;$&lt;/c2&gt;), so that the whole string has to be in valid JSON format for the match to succeed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T141133Z" creationid="Toshiyuki" creationdate="20140222T132109Z">
        <seg>この例では&lt;c0&gt;TOP&lt;/c0&gt;ルールは文字列の始まり（&lt;c1&gt;^&lt;/c1&gt;）と終わり（&lt;c2&gt;$&lt;/c2&gt;）にマッチを固定するので、全部の文字列はマッチに成功するために有効なJSONフォーマットでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this game, that fourth candidate matches only for two objects of the same type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114650Z" creationid="Toshiyuki" creationdate="20140113T050925Z">
        <seg>このゲームにおいて、その第4候補は同じ型の2つのオブジェクトとマッチするだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this grammar, a call to &lt;c0&gt;&lt;value&gt;&lt;/c0&gt; matches either one of the newly added alternatives, or any of the old alternatives from the parent grammar &lt;c1&gt;JSON::Tiny::Grammar&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T230338Z" creationid="Toshiyuki" creationdate="20140223T104446Z">
        <seg>このグラマーにおいて&lt;c0&gt;&lt;value&gt;&lt;/c0&gt;の呼び出しは、新しく追加された選択肢、または親グラマー&lt;c1&gt;JSON::Tiny::Grammar&lt;/c1&gt;からの古い選択肢のどれかにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this line, it's the argument provided to &lt;c2&gt;open&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154450Z" creationid="Toshiyuki" creationdate="20131026T040751Z">
        <seg>この行では、それは&lt;c2&gt;open&lt;/c2&gt;に与えられる引数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this minimal JSON grammar, whitespace is never mandatory, so &lt;c0&gt;ws&lt;/c0&gt; can match nothing at all.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T225332Z" creationid="Toshiyuki" creationdate="20140223T103920Z">
        <seg>この最小のJSONグラマーにおいて空白は決して必須でないので、&lt;c0&gt;ws&lt;/c0&gt;はまったく何にもマッチすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In those situations, the order of inheritance or mixin decides which method wins.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T020609Z" creationid="Toshiyuki" creationdate="20140115T140046Z">
        <seg>それらの状況では、継承またはミックスインの順序がどのメソッドが勝つかについて決めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In turn a &lt;c2&gt;value&lt;/c2&gt; can be an &lt;c3&gt;array&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T142315Z" creationid="Toshiyuki" creationdate="20140222T132803Z">
        <seg>一方で&lt;c2&gt;value&lt;/c2&gt;は&lt;c3&gt;array&lt;/c3&gt;でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheritance</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T092803Z" creationid="Toshiyuki" creationdate="20140112T092803Z">
        <seg>継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inherited grammars may also add variants to proto tokens:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T225812Z" creationid="Toshiyuki" creationdate="20140223T104347Z">
        <seg>継承されたグラマーは、可変要素もプロトトークンに加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside a character class, non-word characters do not need to be escaped, and generally lose their special meaning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T025850Z" creationid="Toshiyuki" creationdate="20140117T182954Z">
        <seg>文字クラスの中で非ワード文字はエスケープされる必要はなく、通常はそれらの特別な意味を失います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the &lt;c0&gt;CATCH&lt;/c0&gt; block, the exception in question is bound to &lt;c1&gt;$_&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T130230Z" creationid="Toshiyuki" creationdate="20130813T130230Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロック内部で、問題の例外は&lt;c1&gt;$_&lt;/c1&gt;にバインドされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the method, that happens:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140115T142306Z" creationid="Toshiyuki" creationdate="20140115T142306Z">
        <seg>メソッド内でそれは起きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead &lt;c0&gt;do {...}&lt;/c0&gt; is the do-once loop (which is another reason you can't put a statement modifier on it; use &lt;c1&gt;repeat&lt;/c1&gt; for a test-at-the-end loop).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T121058Z" creationid="Toshiyuki" creationdate="20130810T121058Z">
        <seg>代わりに&lt;c0&gt;do {...}&lt;/c0&gt;はdo-onceループだ（それは文修飾子を置くことができないもう一つの理由だ；&lt;c1&gt;repeat&lt;/c1&gt;をtest-at-the-endループのために使え）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead it redispatches to overloadable multi methods.).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T075444Z" creationid="Toshiyuki" creationdate="20140113T075444Z">
        <seg>代わりにそれはオーバーロード可能なマルチメソッドを再ディスパッチします）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of applying multiple roles to an instance, compose them into a new role at compile time and apply that role to the instance.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T161458Z" creationid="Toshiyuki" creationdate="20140115T142911Z">
        <seg>複数のロールをインスタンスに適用する代わりに、それらをコンパイル時に新しいロールに合成し、そのロールをインスタンスに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of binding to an array parameter, it instead &lt;e0&gt;unpacks&lt;/e0&gt; its arguments into several parameters--in this case, a scalar for the first element and an array for the rest.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T132553Z" creationid="Toshiyuki" creationdate="20140110T172630Z">
        <seg>配列パラメータにバインドする代わりに、それはいくつかのパラメータに引数を&lt;e0&gt;アンパック&lt;/e0&gt;します ― この場合、最初のスカラーと残りが配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of the &lt;c2&gt;!&lt;/c2&gt; twigil, this twigil is &lt;c3&gt;.&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T183241Z" creationid="Toshiyuki" creationdate="20140111T183241Z">
        <seg>&lt;c2&gt;!&lt;/c2&gt; twigilの代わりにこのtwigilは&lt;c3&gt;.&lt;/c3&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of writing &lt;c0&gt;eat(@food[0], @food[1], @food[2], ...)&lt;/c0&gt; and so on, you can &lt;e1&gt;flatten&lt;/e1&gt; them into the argument list by prepending it with the vertical bar or "pipe" character (&lt;c2&gt;|&lt;/c2&gt;): &lt;c3&gt;eat(|@food)&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T010419Z" creationid="Toshiyuki" creationdate="20131230T040143Z">
        <seg>&lt;c0&gt;eat(@food[0], @food[1], @food[2], ...)&lt;/c0&gt;のように書く代わりに、その引数リストの前に「パイプ」文字（&lt;c2&gt;|&lt;/c2&gt;）をつけることによって&lt;e1&gt;フラット化&lt;/e1&gt;できます：&lt;c3&gt;eat(|@food)&lt;/c3&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the candidates from all of the roles will combine during role composition.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T135103Z" creationid="Toshiyuki" creationdate="20140115T140738Z">
        <seg>その代わりに、ロールからのすべての候補はロール合成の間で組み合わさるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, use a &lt;c1&gt;NEXT&lt;/c1&gt; block within the body of the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130901Z" creationid="Toshiyuki" creationdate="20130808T130901Z">
        <seg>代わりに、&lt;c1&gt;NEXT&lt;/c1&gt;ブロックをループの本体内で使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you should write the more Pascal-like &lt;c0&gt;repeat&lt;/c0&gt; loop:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T151411Z" creationid="Toshiyuki" creationdate="20130809T151411Z">
        <seg>代わりとして、よりパスカル的な&lt;c0&gt;repeat&lt;/c0&gt;ループを書くべきだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolating Arrays and Hashes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131221T004335Z" creationid="Toshiyuki" creationdate="20131221T004335Z">
        <seg>配列とハッシュの展開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introspection</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043536Z" creationid="Toshiyuki" creationdate="20140322T043536Z">
        <seg>イントロスペクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introspection is the process of gathering information about some objects in your program, not by reading the source code, but by querying the object (or a controlling object) for some properties, like its type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T050723Z" creationid="Toshiyuki" creationdate="20140112T135453Z">
        <seg>イントロスペクションはソースコードを読むことによってでなく、いくつかのプロパティ（その型のような）のためにオブジェクト（またはコントロールしているオブジェクト）に問い合わせることによって、あなたのプログラムのいくつかのオブジェクトに関する情報を収集するプロセスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introspection is very useful for debugging, and for learning the language and new libraries.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110329Z" creationid="Toshiyuki" creationdate="20140112T160539Z">
        <seg>イントロスペクションはデバッギングのために、そして言語と新しいライブラリを学ぶために非常に有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invariant sigils</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021914Z" creationid="Toshiyuki" creationdate="20140329T021914Z">
        <seg>不変のシギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invert the sense of each of these backslash sequences by uppercasing its letter: &lt;c0&gt;\W&lt;/c0&gt; matches a character that's &lt;e1&gt;not&lt;/e1&gt; a word character and &lt;c2&gt;\N&lt;/c2&gt; matches a single character that's not a newline.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T125115Z" creationid="Toshiyuki" creationdate="20140117T182516Z">
        <seg>その文字を大文字に換えることによって、これらのバックスラッシュシーケンスの各々の意味を逆にします：&lt;c0&gt;\W&lt;/c0&gt;はワード文字でない文字にマッチします。そして&lt;c2&gt;\N&lt;/c2&gt;は改行文字でない一つの文字にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Is that necessary?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T043816Z" creationid="Toshiyuki" creationdate="20140111T043816Z">
        <seg>それは必要ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Is there a rephrasing that's more correct?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045302Z" creationid="Toshiyuki" creationdate="20140322T045302Z">
        <seg>より正しい言い直しはありますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Is there a way to prevent cycles from ever forming through &lt;c2&gt;add-dependency&lt;/c2&gt;?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110921Z" creationid="Toshiyuki" creationdate="20140112T174333Z">
        <seg>循環が&lt;c2&gt;add-dependency&lt;/c2&gt;を通して形をなすのを防ぐ方法がありますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Is this a little too cute?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T132644Z" creationid="Toshiyuki" creationdate="20140111T043145Z">
        <seg>これは少しばかりかわいいですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It accesses the match object that the regex &lt;c3&gt;dup&lt;/c3&gt; produced.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T041207Z" creationid="Toshiyuki" creationdate="20140222T015534Z">
        <seg>それは正規表現&lt;c3&gt;dup&lt;/c3&gt;が作り出したマッチオブジェクトにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also fixes the subsequent example.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113712Z" creationid="Toshiyuki" creationdate="20140113T044043Z">
        <seg>それも以降の例を解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also includes tests and documentation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T221422Z" creationid="Toshiyuki" creationdate="20140314T221422Z">
        <seg>テストとドキュメントも含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also makes the &lt;c8&gt;try&lt;/c8&gt; keyword redundant, because any block can function as a &lt;c9&gt;try&lt;/c9&gt; block if you put a &lt;c10&gt;CATCH&lt;/c10&gt; block within it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T122339Z" creationid="Toshiyuki" creationdate="20130813T122339Z">
        <seg>それはまた&lt;c8&gt;try&lt;/c8&gt;キーワードを冗長にさせる。なぜならどんなブロックでも&lt;c10&gt;CATCH&lt;/c10&gt;ブロックを中に置けば&lt;c9&gt;try&lt;/c9&gt;ブロックとして機能できるからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It begins harmlessly with a variable declaration &lt;c0&gt;my $label-area-width&lt;/c0&gt; and an assignment.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T060956Z" creationid="Toshiyuki" creationdate="20131027T060956Z">
        <seg>それは当り障りのない変数宣言&lt;c0&gt;my $label-area-width&lt;/c0&gt;と割り当てで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It binds the nominal type of the first argument to &lt;c5&gt;T&lt;/c5&gt;, which can then act as a type constraint.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115158Z" creationid="Toshiyuki" creationdate="20140113T050524Z">
        <seg>それは最初の引数の名目タイプをTに結びつけます。それからそれは型制約の働きをすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It calculates the column by searching backwards from the match position and calculating the difference to the match position.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T091529Z" creationid="Toshiyuki" creationdate="20140222T025015Z">
        <seg>それはマッチ位置から後方に検索し、マッチ位置との違いを計算することで列を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It contained the statement &lt;c0&gt;%matches{$p1}++;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T084424Z" creationid="Toshiyuki" creationdate="20131027T050845Z">
        <seg>それはステートメント&lt;c0&gt;%matches{$p1}++;&lt;/c0&gt;を含んでいました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It contains no type definition, in which case the type of the parameter defaults to &lt;c0&gt;Any&lt;/c0&gt;, the root of the normal branch of the type hierarchy.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T223250Z" creationid="Toshiyuki" creationdate="20140112T184438Z">
        <seg>それは型定義を含まず、その場合にはパラメータの型はデフォルトで&lt;c0&gt;Any&lt;/c0&gt;（型階層の通常の分岐の根元）になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does so by tracking its numerator and denominator as integers, so mathematical operations on &lt;c2&gt;Rat&lt;/c2&gt;s with large components can become quite slow.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014511Z" creationid="Toshiyuki" creationdate="20140228T185811Z">
        <seg>それは分子と分母を整数としてトラッキングすることによって行うので、大きな構成要素による&lt;c2&gt;Rat&lt;/c2&gt;の数値演算はかなり遅くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does this again by recursing into &lt;c1&gt;to-json&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T222959Z" creationid="Toshiyuki" creationdate="20140314T222959Z">
        <seg>それは&lt;c1&gt;to-json&lt;/c1&gt;の再帰によって再び行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn't matter where in the capture the named arguments appear, because they are passed by name, not by position.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T143416Z" creationid="Toshiyuki" creationdate="20140110T143416Z">
        <seg>名前付き引数がどこにあるか気にする必要はありません。なぜならそれは位置ではなく名前で渡されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It either returns an unthrown exception, or throws the exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T170453Z" creationid="Toshiyuki" creationdate="20130817T170453Z">
        <seg>それはスローされない例外または例外をスローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It embraces several paradigms like procedural, object oriented, and functional programming, and offers powerful tools for parsing text.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T221250Z" creationid="Toshiyuki" creationdate="20131025T221250Z">
        <seg>それは手続き的で、オブジェクト指向で、関数プログラミングのようないくつかのパラダイムを受け入れて、テキストを解析することに対して強力なツールを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It ends with another word boundary.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T015226Z" creationid="Toshiyuki" creationdate="20140222T015226Z">
        <seg>それは、別の語境界で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has dependent tasks:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T091854Z" creationid="Toshiyuki" creationdate="20140112T091854Z">
        <seg>それは、従属する仕事を持っています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a little bit like the empty &lt;c1&gt;()&lt;/c1&gt; list, insofar as both represent an absence of values, except that &lt;c2&gt;()&lt;/c2&gt; is defined and means "there are 0 arguments here if you're counting that low".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T103837Z" creationid="Toshiyuki" creationdate="20140330T103837Z">
        <seg>それは両方が値の欠如を表す限りにおいて空の&lt;c1&gt;()&lt;/c1&gt;リストに少し似ています。&lt;c2&gt;()&lt;/c2&gt;は定義されていて“引数はない”という意味を表すのを除いて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a series of tutorials, not a comprehensive reference.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T222127Z" creationid="Toshiyuki" creationdate="20131025T222127Z">
        <seg>それは一連のチュートリアルで、包括的なリファレンスではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also a Unicode character.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T062900Z" creationid="Toshiyuki" creationdate="20131027T062900Z">
        <seg>それはUnicode文字でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to write a signature that binds the capture itself into a variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T041852Z" creationid="Toshiyuki" creationdate="20140110T161908Z">
        <seg>変数にキャプチャー自体を結びつけるシグネチャーを書くことも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is called every time the script is run, and its signature counts as a specification for command line arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044456Z" creationid="Toshiyuki" creationdate="20140111T083755Z">
        <seg>それはスクリプトが動かされるたびに呼ばれます。そして、そのシグネチャーはコマンドライン引数のための仕様とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is given as a trait of the variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224539Z" creationid="Toshiyuki" creationdate="20140328T224539Z">
        <seg>それは変数のトレイトとして与えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is hard to catch such errors by re-reading your own text, but Perl can do it for you using &lt;c0&gt;regex&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124222Z" creationid="Toshiyuki" creationdate="20140115T143452Z">
        <seg>自身のテキストを再読することによってそのようなエラーを捕えることは難しいです。しかしPerlは&lt;c0&gt;regex&lt;/c0&gt;を用いてそれをすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is illegal to return from the closure if that &lt;c0&gt;Routine&lt;/c0&gt; no longer owns a call frame in the current call stack.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T045817Z" creationid="Toshiyuki" creationdate="20130817T045817Z">
        <seg>&lt;c0&gt;Routine&lt;/c0&gt;が現在のコールスタックでもうコールフレームを所持していないならクロージャから戻るのは不当だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is part of the libary &lt;c0&gt;JSON::Tiny&lt;/c0&gt;, which is available from http://github.com/moritz/json/.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T221406Z" creationid="Toshiyuki" creationdate="20140314T221406Z">
        <seg>それは&lt;c0&gt;JSON::Tiny&lt;/c0&gt;ライブラリの一部で、http://github.com/moritz/json/から入手可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to fail with a resumable exception, such as a warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T073634Z" creationid="Toshiyuki" creationdate="20130818T073634Z">
        <seg>警告のように、再開可能な例外と共に失敗することが可能だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the same as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T063611Z" creationid="Toshiyuki" creationdate="20131027T063611Z">
        <seg>それは以下と同じになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may either be provided by the class itself, by another role, or by a parent class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T033913Z" creationid="Toshiyuki" creationdate="20140115T141759Z">
        <seg>それはクラス自体によって、別のロールによって、または親クラスによって提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may operate on provided data (&lt;e1&gt;arguments&lt;/e1&gt;) and may produce results (&lt;e2&gt;return values&lt;/e2&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T130908Z" creationid="Toshiyuki" creationdate="20131029T130908Z">
        <seg>それは供給されたデータ（&lt;e1&gt;引数&lt;/e1&gt;）に作用することができて、結果（&lt;e2&gt;返り値&lt;/e2&gt;）を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It means "there is no value here".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132653Z" creationid="Toshiyuki" creationdate="20140327T132653Z">
        <seg>それは「ここに値はない」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It merely assigns an undefined &lt;c2&gt;Dog&lt;/c2&gt; prototype object to &lt;c3&gt;$spot&lt;/c3&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133740Z" creationid="Toshiyuki" creationdate="20140327T133728Z">
        <seg>それは単に未定義の&lt;c2&gt;Dog&lt;/c2&gt;プロトタイプオブジェクトを&lt;c3&gt;$spot&lt;/c3&gt;に割り当てるだけです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It must bind the two arguments as &lt;c0&gt;rw&lt;/c0&gt;--both readable and writable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115543Z" creationid="Toshiyuki" creationdate="20140113T063510Z">
        <seg>それは&lt;c0&gt;rw&lt;/c0&gt; ― 読み書き可能で ― として2つの引数を結びつけなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It represents a major break in syntactic and semantic compatibility from Perl 5, thus the increase from 5 to 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T023539Z" creationid="Toshiyuki" creationdate="20131025T225320Z">
        <seg>それはPerl 5の構文と意味論の互換性との大きな決別を表しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns &lt;c10&gt;True&lt;/c10&gt; for handled exceptions and for all non-&lt;c11&gt;Failure&lt;/c11&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161809Z" creationid="Toshiyuki" creationdate="20130817T161809Z">
        <seg>それはハンドルされる例外と全ての非&lt;c11&gt;Failure&lt;/c11&gt;オブジェクトのために&lt;c10&gt;True&lt;/c10&gt;を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns both the captured and the non-captured part of the matched string, in the same format as &lt;c1&gt;caps&lt;/c1&gt;, but with a tilde &lt;c2&gt;~&lt;/c2&gt; as key.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T120037Z" creationid="Toshiyuki" creationdate="20140222T030033Z">
        <seg>それはマッチした文字列のキャプチャーされた部分とされない部分両方を&lt;c1&gt;caps&lt;/c1&gt;と同じフォーマットで返します。しかし&lt;c2&gt;~&lt;/c2&gt;がキーに付きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It showcases custom constructors, private and public attributes, methods and various aspects of signatures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044921Z" creationid="Toshiyuki" creationdate="20140111T175137Z">
        <seg>それは、シグネチャーのカスタムコンストラクタ、プライベートとパブリック属性、メソッドといろいろな側面を公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It stores sign, mantissa, and exponent, each with a fixed width.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014104Z" creationid="Toshiyuki" creationdate="20140226T143657Z">
        <seg>それは、符号、仮数と指数（固定幅による各々）を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It supports arrays, hashes, numbers, strings, boolean values, and &lt;c1&gt;null&lt;/c1&gt;, the undefined value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112316Z" creationid="Toshiyuki" creationdate="20140112T182505Z">
        <seg>それは配列、ハッシュ、数、文字列、ブール値と&lt;c1&gt;null&lt;/c1&gt;（未定義値）をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It takes a format string, which specifies how to print the following parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T071059Z" creationid="Toshiyuki" creationdate="20131027T071059Z">
        <seg>それは書式文字列を受け取り、以下のパラメータをどのように出力するか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It takes a string on the left-hand side and a number on the right-hand side, and sticks the strings together as many times as the number specifies, so &lt;c2&gt;'ab' x 3&lt;/c2&gt; returns the string &lt;c3&gt;'ababab'&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T074757Z" creationid="Toshiyuki" creationdate="20131027T074757Z">
        <seg>それは左側に文字列、右側に数値を取り、指定回数の文字列を繰り返します。なので&lt;c2&gt;'ab' x 3&lt;/c2&gt;は文字列&lt;c3&gt;'ababab'&lt;/c3&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It takes no parameters, working instead with the object's attributes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T190552Z" creationid="Toshiyuki" creationdate="20140111T190552Z">
        <seg>それはパラメータをとりません。そして、オブジェクトの属性でその代わりに作業します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It turns the single string &lt;c8&gt;'Beth Ana Charlie Dave'&lt;/c8&gt; into the list of strings &lt;c9&gt;'Beth', 'Ana', 'Charlie', 'Dave'&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154647Z" creationid="Toshiyuki" creationdate="20131026T081110Z">
        <seg>それは1つの文字列&lt;c8&gt;'Beth Ana Charlie Dave'&lt;/c8&gt;を文字列のリスト&lt;c9&gt;'Beth', 'Ana', 'Charlie', 'Dave'&lt;/c9&gt;に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It works exactly like &lt;c3&gt;temp&lt;/c3&gt;, except that the value will be restored only if the current block exits unsuccessfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T134934Z" creationid="Toshiyuki" creationdate="20130802T134934Z">
        <seg>現在のブロックを失敗して抜ける場合だけ値が復元されることを除き、ちょうど&lt;c3&gt;temp&lt;/c3&gt;のよに動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's a $ sandwich.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T175558Z" creationid="Toshiyuki" creationdate="20140112T175558Z">
        <seg>それは$サンドイッチです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also ok to have a method call between the variable name and the postcircumfix.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T165054Z" creationid="Toshiyuki" creationdate="20131026T165054Z">
        <seg>変数名と後置接周辞の間でメソッドを呼び出してもいいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's also possible to conceive of an XML node type that is a type of capture, with named attributes and positional children.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T130807Z" creationid="Toshiyuki" creationdate="20140110T160647Z">
        <seg>キャプチャー型の名前付き属性とポジショナルな子を持つXMLノード型を想像することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's always spelled &lt;c1&gt;for&lt;/c1&gt; in Perl 6, so it always takes a list as an argument:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060854Z" creationid="Toshiyuki" creationdate="20130810T060854Z">
        <seg>Perl 6では常に&lt;c1&gt;for&lt;/c1&gt;と綴られるので、常に引数としてリストを取る：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's as if you had written an anonymous subclass of the current class of the object that composed the role into it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T160037Z" creationid="Toshiyuki" creationdate="20140115T142655Z">
        <seg>それは、ロールと合成したオブジェクトの現在のクラスの匿名のサブクラスをあなたが書いていたかのようです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's as if you had written:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184235Z" creationid="Toshiyuki" creationdate="20140111T184235Z">
        <seg>それは次のように書いたかのようです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's even a bit cleverer than that: between two word characters whitespace is mandatory.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T042417Z" creationid="Toshiyuki" creationdate="20140222T021032Z">
        <seg>これはそれよりも少し巧妙です：2つのワード文字の間の空白は必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's not an error to pass parameters to such a block either:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T151941Z" creationid="Toshiyuki" creationdate="20130810T151941Z">
        <seg>そのようなブロックにパラメータを渡すのはどちらもエラーではない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's not very much code, and yet the result is interesting and, at times, useful.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044926Z" creationid="Toshiyuki" creationdate="20140111T175149Z">
        <seg>それはあまりコードでありませんが、結果は面白くて、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's only important right now to notice that the classes &lt;c0&gt;KarmaKeeper&lt;/c0&gt; and &lt;c1&gt;NothingBot&lt;/c1&gt; share some behavior by inheriting from &lt;c2&gt;IRCBot&lt;/c2&gt; and differentiate their behaviors by performing different roles.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122208Z" creationid="Toshiyuki" creationdate="20140113T105611Z">
        <seg>今重要なのはクラス&lt;c0&gt;KarmaKeeper&lt;/c0&gt;と&lt;c1&gt;NothingBot&lt;/c1&gt;が&lt;c2&gt;IRCBot&lt;/c2&gt;から継承することによっていくらかの振る舞いを共有して、異なるロールを実行することによって彼らの振る舞いを区別していることに気付くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's somewhat like virtual methods where the actual call depends on the type of the invocant, but here the "invocant" is really the lexical scope of the caller, and the virtual calls are name bindings.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T051643Z" creationid="Toshiyuki" creationdate="20130811T051643Z">
        <seg>これは実際の呼び出しがインボカントの型に依存する場所ではやや仮想メソッドのようだ。しかしここではインボカントは呼び出し元の実際のレキシカルスコープで、仮想呼び出しは名前にバインドされている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's still strong in text processing, but Perl 5 is also a powerful general-purpose programming language.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T023941Z" creationid="Toshiyuki" creationdate="20131025T232145Z">
        <seg>それはいまだにテキスト処理において強力です。しかしPerl 5は強力な多目的プログラミング言語でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's time to introduce the &lt;c0&gt;augment&lt;/c0&gt; syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T152831Z" creationid="Toshiyuki" creationdate="20140112T175101Z">
        <seg>&lt;c0&gt;augment&lt;/c0&gt;構文を導入する時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterations that return &lt;c0&gt;()&lt;/c0&gt; (such as by calling &lt;c1&gt;next&lt;/c1&gt; with no extra return arguments) return that &lt;c2&gt;()&lt;/c2&gt; as the next value, which will therefore disappear when interpolated in flat context, but will interpolate an empty &lt;c3&gt;Parcel&lt;/c3&gt; into slice context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T141044Z" creationid="Toshiyuki" creationdate="20130809T141044Z">
        <seg>&lt;c0&gt;()&lt;/c0&gt;を返す反復（&lt;c1&gt;next&lt;/c1&gt;を余分なリターン引数なしに呼ぶような）は&lt;c2&gt;()&lt;/c2&gt;を次の値として返す。それによってフラットコンテキストに保管された時に見えなくなる。しかしスライスコンテキストでは空の&lt;c3&gt;Parcel&lt;/c3&gt;を補完する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its body consists of a single &lt;c1&gt;say&lt;/c1&gt; statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T132034Z" creationid="Toshiyuki" creationdate="20131029T132034Z">
        <seg>その本体は1つの&lt;c1&gt;say&lt;/c1&gt;文から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its signature is empty.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131955Z" creationid="Toshiyuki" creationdate="20131029T131955Z">
        <seg>それのシグネチャーは空です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Javascript Object Notation (&lt;e0&gt;JSON&lt;/e0&gt;) is a simple data exchange format often used for communicating with web services.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T182406Z" creationid="Toshiyuki" creationdate="20140112T182406Z">
        <seg>Javascript Object Notation（&lt;e0&gt;JSON&lt;/e0&gt;）はウェブサービスと通信するために使われるシンプルなデータ交換形式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as Perl borrows good ideas from other languages, so Perl 5 and Perl 6 share features.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T231206Z" creationid="Toshiyuki" creationdate="20131025T231206Z">
        <seg>Perlが他の言語から良い考えを借りるちょうどその時、Perl 5とPerl 6は機能を共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as a &lt;c2&gt;my&lt;/c2&gt; variable can not be accessed from the outside of its declared scope, attributes are not accessible outside of the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182227Z" creationid="Toshiyuki" creationdate="20140111T182227Z">
        <seg>&lt;c2&gt;my&lt;/c2&gt;変数が宣言されたスコープの外側からアクセス出来ないように、属性はクラスの外からアクセスできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as in the case of &lt;c6&gt;+=&lt;/c6&gt;, if either hash value did not exist previously, it is autovivified by the increment operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T142128Z" creationid="Toshiyuki" creationdate="20131026T142128Z">
        <seg>ちょうど&lt;c6&gt;+=&lt;/c6&gt;の場合のようにどちらのハッシュ値も前もって存在しないならば、それはインクリメント演算子によって自動生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as subclasses inherit methods from superclasses, so grammars inherit rules from its base grammar.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T225009Z" creationid="Toshiyuki" creationdate="20140223T103538Z">
        <seg>サブクラスがスーパークラスからメソッドを継承するように、グラマーはそのベース文法からルールを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as the &lt;c1&gt;*&lt;/c1&gt; quantifier in regexes means "zero or more", the &lt;c2&gt;.*&lt;/c2&gt; dispatch operator will call zero or more matching methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T032444Z" creationid="Toshiyuki" creationdate="20140115T141245Z">
        <seg>正規表現の&lt;c1&gt;*&lt;/c1&gt;数量詞が0以上を意味するように、&lt;c2&gt;.*&lt;/c2&gt;ディスパッチ演算子は0以上のマッチするメソッドを呼ぶでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as you rarely think of a signature as a whole--instead focusing on individual parameters--you rarely have to think about captures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T041201Z" creationid="Toshiyuki" creationdate="20140110T135005Z">
        <seg>あまり考えることのないシグネチャーの全体 ― 個々のパラメータに着目する代わりに ― キャプチャーについて考える必要があるのはまれです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like &lt;a0&gt;"Nil"&lt;/a0&gt;, type objects do not disappear in list context, but rely on something downstream to catch it or blow up.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140407T123807Z" creationid="Toshiyuki" creationdate="20140407T123807Z">
        <seg>&lt;a0&gt;"Nil"&lt;/a0&gt;のように、型オブジェクトはリストコンテキストでは消えず、下流の何かに頼って捕らえるかブローアップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like &lt;c0&gt;==&lt;/c0&gt; converts its arguments to numbers before comparing, &lt;c1&gt;eq&lt;/c1&gt; as an infix operator compares for string equality, converting its arguments to strings as necessary:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T125145Z" creationid="Toshiyuki" creationdate="20131028T125145Z">
        <seg>&lt;c0&gt;==&lt;/c0&gt;が比較の前に引数を数値に変換するように、接中辞演算子としての&lt;c1&gt;eq&lt;/c1&gt;は文字列が同等か比較します。必要なら引数を文字列に変換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like &lt;c1&gt;@variable.method&lt;/c1&gt; calls a method on &lt;c2&gt;@variable&lt;/c2&gt;, &lt;c3&gt;@array».method&lt;/c3&gt; calls a method for each item in &lt;c4&gt;@array&lt;/c4&gt; and returns the list of the return values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T000104Z" creationid="Toshiyuki" creationdate="20140309T000004Z">
        <seg>&lt;c1&gt;@variable.method&lt;/c1&gt;が&lt;c2&gt;@variable&lt;/c2&gt;でメソッドを呼ぶように、&lt;c3&gt;@array».method&lt;/c3&gt;は&lt;c4&gt;@array&lt;/c4&gt;の各々のアイテムにメソッドを呼び出して結果の値のリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like &lt;c1&gt;@variable.method&lt;/c1&gt; calls a method on &lt;c2&gt;@variable&lt;/c2&gt;, &lt;c3&gt;@arrayｻ.method&lt;/c3&gt; calls a method for each item in &lt;c4&gt;@array&lt;/c4&gt; and returns the list of the return values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T085510Z" creationid="Toshiyuki" creationdate="20140308T085123Z">
        <seg>&lt;c1&gt;@variable.method&lt;/c1&gt;が&lt;c2&gt;@variable&lt;/c2&gt;に対してメソッドを呼び出すのと同様に、&lt;c3&gt;@array».method&lt;/c3&gt;は&lt;c4&gt;@array&lt;/c4&gt;の各々のアイテムに対してメソッド を呼び出し、返り値のリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like &lt;c1&gt;@variable.method&lt;/c1&gt; calls a method on &lt;c2&gt;@variable&lt;/c2&gt;, &lt;c3&gt;@array�.method&lt;/c3&gt; calls a method for each item in &lt;c4&gt;@array&lt;/c4&gt; and returns the list of the return values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T062801Z" creationid="Toshiyuki" creationdate="20131027T062801Z">
        <seg>&lt;c1&gt;@variable.method&lt;/c1&gt;が&lt;c2&gt;@variable&lt;/c2&gt;でメソッドを呼ぶように、&lt;c3&gt;@array».method&lt;/c3&gt;は&lt;c4&gt;@array&lt;/c4&gt;の各々のアイテムにメソッドを呼び出して結果の値のリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keep in mind that the number of times the subtype checks blocks execute is specific to any particular implementation of Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T225051Z" creationid="Toshiyuki" creationdate="20140112T225024Z">
        <seg>サブタイプがブロックが実行することを確認する回数がPerl 6の何の特定の実装に特有なことを心にとめておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Large projects written in such systems often have complex interactions and workarounds for classes which want to reuse code but do not want to take on additional unnecessary capabilities.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T011819Z" creationid="Toshiyuki" creationdate="20140115T101625Z">
        <seg>しばしばそのようなシステムで書かれる大きなプロジェクトでは、クラスのために複雑な対話処理と回避方法を持っています。そのクラスは再利用したいが、さらなる不必要な機能を引き受けたくはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lastly, the &lt;c0&gt;:T&lt;/c0&gt; adverb can be used to indicate that the parameter may only be given as a type object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T132807Z" creationid="Toshiyuki" creationdate="20140110T132807Z">
        <seg>最後に、&lt;c0&gt;:T&lt;/c0&gt;副詞はパラメータが型オブジェクトだけであることを示すのに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Less obviously, so does a &lt;c3&gt;gather&lt;/c3&gt;; if a &lt;c4&gt;gather&lt;/c4&gt; lexically contains any &lt;c5&gt;take&lt;/c5&gt; calls, it is marked as lexotic-only, and it will be invisible to a dynamic &lt;c6&gt;take&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T160003Z" creationid="Toshiyuki" creationdate="20130810T160003Z">
        <seg>あまり明らかでない、それゆえ&lt;c3&gt;gather&lt;/c3&gt;を行う；もし&lt;c4&gt;gather&lt;/c4&gt;が何か一つの&lt;c5&gt;take&lt;/c5&gt;呼び出しをレキシカルに含んでいるなら、それはlexotic-onlyとしてマークされる。そしてダイナミックな&lt;c6&gt;take&lt;/c6&gt;には不可視になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexical Conventions</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053423Z" creationid="Toshiyuki" creationdate="20140330T053423Z">
        <seg>レキシカルの規則</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexical variables are visible only in the current block from the point of declaration to the end of the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T153626Z" creationid="Toshiyuki" creationdate="20131026T024936Z">
        <seg>レキシカル変数は、現在のブロック内で宣言した場所からブロックの終端までしか見えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexicals may not "leak" from a block to any other external scope (at least, not without some explicit aliasing action on the part of the block, such as exportation of a symbol from a module).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T124829Z" creationid="Toshiyuki" creationdate="20130730T124829Z">
        <seg>レキシカルはブロックから他の外部スコープへは「リーク」しない（少なくともモジュールからのシンボルのエクスポートのような、ブロック部分のいくつかの明示的なエイリアシングが無い場合）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexotic operators in Perl 6 include:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T010307Z" creationid="Toshiyuki" creationdate="20130728T010307Z">
        <seg>Perl 6のレギゾチック演算子は以下を含む：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like &lt;c2&gt;do&lt;/c2&gt;, it is followed by a statement or block, and executes it once.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152531Z" creationid="Toshiyuki" creationdate="20130810T152531Z">
        <seg>&lt;c2&gt;do&lt;/c2&gt;のように、それには文かブロックが続き、一回実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like arrays and hashes, a &lt;c0&gt;Capture&lt;/c0&gt; can be flattened into an argument list using &lt;c1&gt;|&lt;/c1&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T143523Z" creationid="Toshiyuki" creationdate="20140110T143523Z">
        <seg>配列やハッシュのように、&lt;c0&gt;Capture&lt;/c0&gt;は&lt;c1&gt;|&lt;/c1&gt;を使って引数リストにフラット化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like classes, a role can contain methods (including named regexes) and attributes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T045258Z" creationid="Toshiyuki" creationdate="20140113T105654Z">
        <seg>クラスのように、ロールはメソッド（名前付き正規表現を含む）と属性を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like most other modern programming languages, Perl 6 gives you the option of explicitly specifying the return type of a subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T232634Z" creationid="Toshiyuki" creationdate="20140104T232634Z">
        <seg>現代の大部分の他のプログラミング言語のように、Perl 6はあなたにサブルーチンの戻り値の型をはっきりと指定する選択権を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like other languages that have adopted a similar syntax to C, Perl 6 allows for a shorthand way to write certain assignments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T084051Z" creationid="Toshiyuki" creationdate="20131027T045222Z">
        <seg>C言語に類似した構文を採用した他の言語のように、Perl 6は特定の割当てを書くための短縮形を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise any subscripting operation on &lt;c19&gt;Nil&lt;/c19&gt; returns &lt;c20&gt;Nil&lt;/c20&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140331T130238Z" creationid="Toshiyuki" creationdate="20140327T133123Z">
        <seg>同様に&lt;c19&gt;Nil&lt;/c19&gt;での添字付け演算子も&lt;c20&gt;Nil&lt;/c20&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise you can unpack a hash by using &lt;c0&gt;%(...)&lt;/c0&gt; instead of square brackets, but you must access named parameters instead of positional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T132633Z" creationid="Toshiyuki" creationdate="20140111T043051Z">
        <seg>同様に、あなたはブラケットの代わりに&lt;c0&gt;%(...)&lt;/c0&gt;を用いてハッシュを取り出すことができます。しかし、位置依存パラメータの代わりに名前付きパラメータにアクセスしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, temporization is never needed for &lt;c1&gt;statement_control:&lt;for&gt;&lt;/c1&gt; because it always calls a closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T120043Z" creationid="Toshiyuki" creationdate="20130810T120043Z">
        <seg>同様に、&lt;c1&gt;statement_control:&lt;for&gt;&lt;/c1&gt;のためにテンポラリー化は決して必要ない。なぜならそれは常にクロージャを呼び出すからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, there is a data structure that holds a collection of arguments, named a &lt;c1&gt;Capture&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T041149Z" creationid="Toshiyuki" creationdate="20140110T134542Z">
        <seg>同様に引数のコレクションを持つデータ構造があり、&lt;c1&gt;Capture&lt;/c1&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, we can just remember the gather's result parcel by binding and later coercing it:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T040204Z" creationid="Toshiyuki" creationdate="20130811T040204Z">
        <seg>同様に、我々はちょうどgatherの結果のパーセルをバインドと後での強制によって覚えることができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, you can interpolate hashes into named arguments:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T010449Z" creationid="Toshiyuki" creationdate="20131230T040257Z">
        <seg>同様に、名前付き引数でハッシュを展開できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, you can write &lt;c0&gt;[+]&lt;/c0&gt; to get the sum of a list of values, &lt;c1&gt;[*]&lt;/c1&gt; for the product, and &lt;c2&gt;[&lt;=]&lt;/c2&gt; to check if a list is ordered by ascending values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T062326Z" creationid="Toshiyuki" creationdate="20131027T062326Z">
        <seg>同様に&lt;c0&gt;[+]&lt;/c0&gt;をリストの値の合計を得るため、&lt;c1&gt;[*]&lt;/c1&gt;は積、&lt;c2&gt;[&lt;=]&lt;/c2&gt;をリストが昇順に並んでいるか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Link to &lt;c0&gt;Any&lt;/c0&gt; discussion.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T223114Z" creationid="Toshiyuki" creationdate="20140314T223114Z">
        <seg>&lt;c0&gt;Any&lt;/c0&gt;の議論と関連付けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Link to exporting section.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T034726Z" creationid="Toshiyuki" creationdate="20131029T132124Z">
        <seg>エクスポートセクションと関連付けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Link to traits section.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044427Z" creationid="Toshiyuki" creationdate="20140111T074457Z">
        <seg>トレイトセクションと関連付けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List of names a named parameter can be passed as</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044240Z" creationid="Toshiyuki" creationdate="20140322T044240Z">
        <seg>渡すことができる名前付きパラメータのリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List stringification</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022409Z" creationid="Toshiyuki" creationdate="20140329T022409Z">
        <seg>リストの文字列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lists and Hashes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021445Z" creationid="Toshiyuki" creationdate="20140322T021445Z">
        <seg>リストとハッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literals</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T120105Z" creationid="Toshiyuki" creationdate="20140329T120105Z">
        <seg>リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Long form</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T155952Z" creationid="Toshiyuki" creationdate="20140104T155952Z">
        <seg>長い形式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Look at the &lt;c0&gt;KarmaKeeper&lt;/c0&gt; class declaration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T063250Z" creationid="Toshiyuki" creationdate="20140115T102004Z">
        <seg>&lt;c0&gt;KarmaKeeper&lt;/c0&gt;クラス宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking at the grammar, you'll also note that there are also &lt;c3&gt;token&lt;/c3&gt; declarations as well.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T135440Z" creationid="Toshiyuki" creationdate="20140222T114342Z">
        <seg>グラマーを見て、あなたは同様に&lt;c3&gt;token&lt;/c3&gt;宣言がある点にも注意するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop commands like &lt;c1&gt;next&lt;/c1&gt; are abnormal, but looping because you hit the end of the block is not.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125031Z" creationid="Toshiyuki" creationdate="20130816T125031Z">
        <seg>&lt;c1&gt;next&lt;/c1&gt;のようなループコマンドはアブノーマルだ。しかしあなたがブロックの終端をヒットするルーピングは違う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop modifiers &lt;c0&gt;next&lt;/c0&gt;, &lt;c1&gt;last&lt;/c1&gt;, and &lt;c2&gt;redo&lt;/c2&gt; also work much as in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T041904Z" creationid="Toshiyuki" creationdate="20130806T041904Z">
        <seg>ループ修飾子&lt;c0&gt;next&lt;/c0&gt;、&lt;c1&gt;last&lt;/c1&gt;、&lt;c2&gt;redo&lt;/c2&gt;もPerl 5と同様に動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130805T161445Z" creationid="Toshiyuki" creationdate="20130805T161445Z">
        <seg>ループ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looping statement modifiers are the same as in Perl 5 except that, for ease of writing list comprehensions, a looping statement modifier is allowed to contain a single conditional statement modifier:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T041823Z" creationid="Toshiyuki" creationdate="20130806T041823Z">
        <seg>ループ文修飾子はPerl 5と同様だ。リストを書く可読性のために、ループ文修飾子はひとつの条件文修飾子を含むことが許可されることを除けば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many constructs define a particular interplay of lexical and dynamic features.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T153018Z" creationid="Toshiyuki" creationdate="20130727T153018Z">
        <seg>多くの構成物がレキシカルとダイナミックの機能の特定の相互作用を定義する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of the special variables of Perl 5 are going away.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090305Z" creationid="Toshiyuki" creationdate="20140329T090305Z">
        <seg>Perl 5の多くの特殊変数は無くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many operators work on a particular &lt;e0&gt;type&lt;/e0&gt; of data.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T013159Z" creationid="Toshiyuki" creationdate="20140226T142509Z">
        <seg>多くの演算子はデータの特定の&lt;e0&gt;型&lt;/e0&gt;で機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many subroutines cannot meaningfully work with arbitrary parameters, but require that the parameters support certain methods or have other properties.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T064542Z" creationid="Toshiyuki" creationdate="20140105T065301Z">
        <seg>多くのサブルーチンは不定のパラメータでは意味のある動作ができず、特定のメソッドをサポートするか他のプロパティを持つパラメータを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T024614Z" creationid="Toshiyuki" creationdate="20140222T024614Z">
        <seg>マッチオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matching a string against that regex searches for that string:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T022431Z" creationid="Toshiyuki" creationdate="20140115T143522Z">
        <seg>その正規表現と文字列をマッチングすることは、その文字列を捜します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Meaning</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232450Z" creationid="Toshiyuki" creationdate="20140221T232450Z">
        <seg>意味</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method/function</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020826Z" creationid="Toshiyuki" creationdate="20140322T020826Z">
        <seg>メソッド／関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184849Z" creationid="Toshiyuki" creationdate="20140111T184849Z">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods on Arrays</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T141203Z" creationid="Toshiyuki" creationdate="20140327T141203Z">
        <seg>配列のメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifiers</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T015922Z" creationid="Toshiyuki" creationdate="20140222T015922Z">
        <seg>修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More abstractly, any declarations associated with those textual blocks are also considered to be part of the lexical scope, and this is where the term earns the "lexical" part of its name, in the sense that lexical scoping actually does define the "lexicon" for the current chunk of code, insofar as the definitions of variables and routines create a local domain-specific language.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T140658Z" creationid="Toshiyuki" creationdate="20130727T140145Z">
        <seg>より抽象的には、それらのテキストブロックに関連付けられた宣言は全てレキシカルスコープの一部とみなされ、そしてこれは名前のレキシカル部分を得る場所でもある。という訳で、変数とルーチンの定義が局所的なドメイン固有言語を創造する限りにおいて、レキシカルスコープは現在のコードのチャンクのための辞書を実際に定義する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More interestingly, the &lt;c1&gt;where {!defined $d}&lt;/c1&gt; clause is a &lt;e2&gt;constraint&lt;/e2&gt;, which defines a so-called &lt;e3&gt;subset type&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T223504Z" creationid="Toshiyuki" creationdate="20140314T223504Z">
        <seg>より面白いことに、&lt;c1&gt;where {!defined $d}&lt;/c1&gt;という節は&lt;e3&gt;サブセット型&lt;/e3&gt;と呼ばれる&lt;e2&gt;制約&lt;/e2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More precisely, it first scans outward (lexically) for the innermost containing &lt;c2&gt;when&lt;/c2&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T113612Z" creationid="Toshiyuki" creationdate="20130812T113612Z">
        <seg>より正確には、それは最初に&lt;c2&gt;when&lt;/c2&gt;ブロックを含む最も深い部分を外側へ（レキシカルに）スキャンする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More precisely, it's a promise that the object or objects contained in the variable are capable of responding to the methods of the indicated "role".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T102514Z" creationid="Toshiyuki" creationdate="20140330T102514Z">
        <seg>より正確には、オブジェクトまたは変数に含まれるオブジェクトが指示された“ロール”のメソッドに反応することができるという約束です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More specifically, when you write:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T105641Z" creationid="Toshiyuki" creationdate="20130814T105641Z">
        <seg>より明白には、あなたが次のように書くとき：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most list contexts are flat rather than sliced, so the boundaries between individual &lt;c2&gt;take&lt;/c2&gt; calls usually disappear.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T205908Z" creationid="Toshiyuki" creationdate="20130810T205908Z">
        <seg>最も多いリストコンテキストはスライスよりもフラットなので、個々の&lt;c2&gt;take&lt;/c2&gt;呼び出しの間の境界は普通は見えなくなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most mathematical functions are available both as methods and functions, so you can write both &lt;c0&gt;(-5).abs&lt;/c0&gt; and &lt;c1&gt;abs(-5)&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015533Z" creationid="Toshiyuki" creationdate="20140301T050003Z">
        <seg>大部分の数学関数はメソッドと関数として使えるので、あなたは&lt;c0&gt;(-5).abs&lt;/c0&gt;と&lt;c1&gt;abs(-5)&lt;/c1&gt;の両方を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most modern regular expression facilities are more powerful than traditional regular expressions due to the influence of languages such as Perl, but the short-hand term &lt;c0&gt;regex&lt;/c0&gt; has stuck and continues to mean "regular expression-like pattern matching".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T022244Z" creationid="Toshiyuki" creationdate="20140115T143304Z">
        <seg>多くのモダンな正規表現機能は、Perlのような言語の影響により従来の正規表現より強力です。しかし速記用語&lt;c0&gt;regex&lt;/c0&gt;は定着して、「正規表現のようなパターンマッチ」を意味し続けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the non-value-producing phasers may also be so used:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085336Z" creationid="Toshiyuki" creationdate="20130818T085336Z">
        <seg>大部分の値を出さないphasersも使うことができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most properties are only interesting after successful matches.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T085727Z" creationid="Toshiyuki" creationdate="20140222T024725Z">
        <seg>大部分のプロパティは、成功したマッチの後だけで興味深いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Much like &lt;c0&gt;return&lt;/c0&gt; may only return from an "official" subroutine or method, a loop exit like &lt;c1&gt;next&lt;/c1&gt; should be caught by the construct the user expects it to be caught by.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080353Z" creationid="Toshiyuki" creationdate="20130817T080353Z">
        <seg>とても似ている&lt;c0&gt;return&lt;/c0&gt;は「公式な」サブルーチンかメソッドからだけ戻れる。&lt;c1&gt;next&lt;/c1&gt;のようなループの脱出はユーザーがキャッチされると期待する構造にキャッチされるべきだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi methods with the same name from different roles will not conflict with each other.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T023614Z" creationid="Toshiyuki" creationdate="20140115T140727Z">
        <seg>異なるロールからの同じ名前によるマルチメソッドは、互いに競合しないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-methods and composition</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T023428Z" creationid="Toshiyuki" creationdate="20140115T140612Z">
        <seg>マルチメソッドと合成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiline Comments</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053441Z" creationid="Toshiyuki" creationdate="20140330T053441Z">
        <seg>複数行コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple Inheritance</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T125409Z" creationid="Toshiyuki" creationdate="20140112T125409Z">
        <seg>多重継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple MAIN subs</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T080046Z" creationid="Toshiyuki" creationdate="20140113T080046Z">
        <seg>マルチMAINサブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple arguments</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T045106Z" creationid="Toshiyuki" creationdate="20140113T045106Z">
        <seg>複数の引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple inheritance and mixin mechanisms rarely provide this degree of conflict resolution.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T020253Z" creationid="Toshiyuki" creationdate="20140115T140034Z">
        <seg>多重継承とミックスインメカニズムは、この程度の競合解消をめったに提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple parameters may be passed, in which case the list is traversed more than one element at a time:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T061613Z" creationid="Toshiyuki" creationdate="20130810T061613Z">
        <seg>複数のパラメータが渡されるようなら、その場合はリストは一度に一つ以上の要素を横断される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Name</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121730Z" creationid="Toshiyuki" creationdate="20131027T121730Z">
        <seg>名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Name Equivalence of Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053537Z" creationid="Toshiyuki" creationdate="20140330T053537Z">
        <seg>型の名前同一性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named Arguments and Parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131231T195133Z" creationid="Toshiyuki" creationdate="20131231T195133Z">
        <seg>名前付き引数とパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named arguments are actually &lt;c0&gt;Pair&lt;/c0&gt;s (of keys and values).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T012854Z" creationid="Toshiyuki" creationdate="20140104T144217Z">
        <seg>名前付き引数は実際は&lt;c0&gt;Pair&lt;/c0&gt;（のキーと値）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named arguments can be provided with the &lt;c0&gt;--name=value&lt;/c0&gt; syntax common to many GNU tools, and positional arguments just by their value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T173836Z" creationid="Toshiyuki" creationdate="20140111T173836Z">
        <seg>名前付き引数は多くのGNUツールと共通の&lt;c0&gt;--name=value&lt;/c0&gt;構文で提供されることができます。そして位置引数は丁度それらの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named regex that match within the grammar may be accessed via the &lt;c2&gt;Match&lt;/c2&gt; object similar to a hash where the keys are the regex names and the values are the &lt;c3&gt;Match&lt;/c3&gt; object that represents that part of the overall regex match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T231216Z" creationid="Toshiyuki" creationdate="20140224T160918Z">
        <seg>グラマー内でマッチする名前付き正規表現は&lt;c2&gt;Match&lt;/c2&gt;オブジェクトとしてアクセスされ、それはキーが正規表現の名前、値が正規表現の全体のマッチ部分を表す&lt;c3&gt;Match&lt;/c3&gt;オブジェクトであるハッシュに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named regexes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T014049Z" creationid="Toshiyuki" creationdate="20140222T014049Z">
        <seg>名前付き正規表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named regexes make it easy to organize complex regexes by building them up from smaller pieces.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T041425Z" creationid="Toshiyuki" creationdate="20140222T015917Z">
        <seg>名前をつけられた正規表現は、より小さな部分からそれらを構築することによって複雑な正規表現を編成することを容易にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T091745Z" creationid="Toshiyuki" creationdate="20140329T091745Z">
        <seg>名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names and Variables</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000030Z" creationid="Toshiyuki" creationdate="20140329T000030Z">
        <seg>名前と変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names may also be declared in the signature of a function.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021445Z" creationid="Toshiyuki" creationdate="20140329T021445Z">
        <seg>名前は関数のシグネチャーでも宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Narrowness</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113441Z" creationid="Toshiyuki" creationdate="20140322T113441Z">
        <seg>狭さ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nearly all Perl 6 built-in functions and operators export a proto definition, which prevents accidental overriding of built-ins (footnote: One of the very rare exceptions is the smart match operator &lt;c0&gt;infix:&lt;~~&gt;&lt;/c0&gt; which is not easily overloadable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T120840Z" creationid="Toshiyuki" creationdate="20140113T075400Z">
        <seg>ほとんど全てのPerl 6組み込み関数と演算子はプロト定義をエクスポートします。そして、それは組み込みを偶然に越えることを防ぎます（注釈：非常に珍しい例外の1つは、スマートマッチ演算子接中辞&lt;c0&gt;infix:&lt;~~&gt;&lt;/c0&gt;で、簡単にはオーバーロードできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested Signatures in Multi-dispatch</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115710Z" creationid="Toshiyuki" creationdate="20140113T063926Z">
        <seg>マルチディスパッチのネストしたシグネチャー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next comes a simple numeric addition, &lt;c1&gt;1 + ...&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T061038Z" creationid="Toshiyuki" creationdate="20131027T061038Z">
        <seg>次は単純な数値の加算、&lt;c1&gt;1 + ...&lt;/c1&gt;が来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next comes an optional name and an optional signature.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131632Z" creationid="Toshiyuki" creationdate="20131029T131632Z">
        <seg>次はオプションの名前とオプションのシグネチャーが来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next comes the expression &lt;c0&gt;@scores».key».chars&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T235929Z" creationid="Toshiyuki" creationdate="20140308T235929Z">
        <seg>次に式&lt;c0&gt;@scores».key».chars&lt;/c0&gt;が来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next comes the expression &lt;c0&gt;@scoresｻ.keyｻ.chars&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T085057Z" creationid="Toshiyuki" creationdate="20140308T085057Z">
        <seg>次に式&lt;c0&gt;@scores».key».chars&lt;/c0&gt;が来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next comes the expression &lt;c0&gt;@scores�.key�.chars&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T062458Z" creationid="Toshiyuki" creationdate="20131027T062458Z">
        <seg>次に式&lt;c0&gt;@scores».key».chars&lt;/c0&gt;が来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, the regex captures a word (&lt;c1&gt;(\w+)&lt;/c1&gt;), followed by at least one non-word character &lt;c2&gt;\W+&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T013721Z" creationid="Toshiyuki" creationdate="20140222T013721Z">
        <seg>次に、正規表現はワードをキャプチャーし（&lt;c1&gt;(\w+)&lt;/c1&gt;）、少なくともひとつの非ワード文字&lt;c2&gt;\W+&lt;/c2&gt;が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No additional context is applied by the &lt;c1&gt;take&lt;/c1&gt; operator, since all context is lazy in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T201307Z" creationid="Toshiyuki" creationdate="20130810T201307Z">
        <seg>&lt;c1&gt;take&lt;/c1&gt;演算子によって追加のコンテキストが何も適用されないので、Perl 6では全てのコンテキストはレイジーだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No temporization is necessary with the explicit form since &lt;c0&gt;$_&lt;/c0&gt; is a formal parameter to the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T115601Z" creationid="Toshiyuki" creationdate="20130810T115601Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;をブロックの仮パラメータにしてから明白な形式でテンポラリー化は必要ない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal flat list context ignores parcel boundaries and flattens the list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T135641Z" creationid="Toshiyuki" creationdate="20130808T131930Z">
        <seg>通常のフラットリストコンテキストはパーセルの境界を無視し、リストを平坦化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal names and variables are declared using a &lt;i0&gt;scope declarator&lt;/i0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021409Z" creationid="Toshiyuki" creationdate="20140329T021409Z">
        <seg>通常の名前と変数は&lt;i0&gt;スコープ宣言&lt;/i0&gt;で宣言されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal objects just use their location as their identity, but if a class wishes to behave as a value type, it can define a &lt;c0&gt;.WHICH&lt;/c0&gt; method that makes different objects look like the same object if they happen to have the same contents.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T122356Z" creationid="Toshiyuki" creationdate="20140328T122344Z">
        <seg>通常のオブジェクトはそれらの識別としてロケーションを使うだけですが、もしクラスが値型として振る舞いたいのであれば、同じ内容を持っている場合に異なるオブジェクトを同じように見せる&lt;c0&gt;.WHICH&lt;/c0&gt;メソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that Perl 5's special rule causing</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T111901Z" creationid="Toshiyuki" creationdate="20130810T111627Z">
        <seg>次のことにも注意。Perl 5の特別な規則で</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T163309Z" creationid="Toshiyuki" creationdate="20130817T163309Z">
        <seg>ただし注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;c0&gt;$x&lt;/c0&gt; is also initialized to the &lt;c1&gt;Int&lt;/c1&gt; type object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132547Z" creationid="Toshiyuki" creationdate="20140327T132547Z">
        <seg>&lt;c0&gt;$x&lt;/c0&gt;は&lt;c1&gt;Int&lt;/c1&gt;型オブジェクトにも初期化されるので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that any &lt;c0&gt;die&lt;/c0&gt; in the catch lambda eventually rethrows outside the lambda as a new exception, but not until the current exception handler has a chance to handle all exceptions that came in via &lt;c1&gt;@!&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T113621Z" creationid="Toshiyuki" creationdate="20130814T113621Z">
        <seg>catch lambdaのどれかひとつの&lt;c0&gt;die&lt;/c0&gt;がlambdaを新しい例外として結局外側に再スローする。しかし現在の例外ハンドラが&lt;c1&gt;@!&lt;/c1&gt;を経て入るすべての例外をハンドルする機会を持つまでではない。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that any construct in the statement_prefix category defines special syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T121430Z" creationid="Toshiyuki" creationdate="20130811T121430Z">
        <seg>statement_prefixカテゴリーのどんな構成物も特別な文法を定義するので注意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in each piece of lifted code there are references to variables defined in the multi, such as &lt;c0&gt;$a&lt;/c0&gt;, &lt;c1&gt;$b&lt;/c1&gt;, and &lt;c2&gt;&amp;f&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T074218Z" creationid="Toshiyuki" creationdate="20130811T074218Z">
        <seg>リフトされたコードのそれぞれの断片はマルチに定義された変数を参照する。&lt;c0&gt;$a&lt;/c0&gt;、 &lt;c1&gt;$b&lt;/c1&gt;、&lt;c2&gt;&amp;f&lt;/c2&gt;のような。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it's impolite to die if a &lt;c10&gt;Task&lt;/c10&gt; has started but not yet finished, because this time it might be due to parallelism rather than cycles:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112040Z" creationid="Toshiyuki" creationdate="20140314T214515Z">
        <seg>&lt;c10&gt;Task&lt;/c10&gt;が開始したがまだ終わらなかったなら、dieするのは無作法なので注意してください。なぜなら循環よりも並列の期限が来ているかもしれないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that temporizations that are undone upon scope exit must be prepared to be redone if a continuation within that scope is taken.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T155653Z" creationid="Toshiyuki" creationdate="20130802T155653Z">
        <seg>スコープの終了でなされないテンポライゼーションは、そのスコープ内の継続が取られるならやり直すために準備されなければならないことに注意しろ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &lt;c0&gt;take&lt;/c0&gt; itself is in sink context in this example because the &lt;c1&gt;for&lt;/c1&gt; loop is in the sink context provided inside the gather.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T040458Z" creationid="Toshiyuki" creationdate="20130811T040458Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;自体はこの例ではsinkコンテキストにある。なぜならgather内に与えられた&lt;c1&gt;for&lt;/c1&gt;ループがsinkコンテキストにあるからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value being evaluated for truth and subsequently bound is not necessarily a value of type &lt;c0&gt;Bool&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T070604Z" creationid="Toshiyuki" creationdate="20130804T070604Z">
        <seg>真偽のために評価される、そしてその後に続いてバインドされる値は&lt;c0&gt;Bool&lt;/c0&gt;型である必要性はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is not like declaring a public attribute, as some languages allow; you really get &lt;e0&gt;both&lt;/e0&gt; a private storage location and a method, without having to write the method by hand.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045857Z" creationid="Toshiyuki" creationdate="20140111T184503Z">
        <seg>これはいくつかの言語が許すようなパブリックな属性を宣言するものではないので注意してください；あなたは手でメソッドを書くことなく、本当に&lt;e0&gt;両方の&lt;/e0&gt;プライベートな記録場所とメソッドを得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that using the &lt;c0&gt;.&lt;/c0&gt; twigil has created a method that will provide with readonly access to the attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184701Z" creationid="Toshiyuki" creationdate="20140111T184701Z">
        <seg>&lt;c0&gt;.&lt;/c0&gt; twigilを使うと属性への読み取り専用アクセスのメソッドを作るので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the use of &lt;c0&gt;rx/ ... /&lt;/c0&gt; rather than &lt;c1&gt;m/ ... /&lt;/c1&gt; to construct the regex.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131334Z" creationid="Toshiyuki" creationdate="20140222T023347Z">
        <seg>正規表現を構築するために&lt;c0&gt;rx/ ... /&lt;/c0&gt;よりも&lt;c1&gt;m/ ... /&lt;/c1&gt;の使用に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the use of &lt;c2&gt;»&lt;/c2&gt; and &lt;c3&gt;[||]&lt;/c3&gt; to write succinctly what would otherwise have involved looping over all the dependencies of the &lt;c4&gt;Task&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T111729Z" creationid="Toshiyuki" creationdate="20140322T111729Z">
        <seg>一方の&lt;c4&gt;Task&lt;/c4&gt;の全ての従属物がループに巻き込まれることを完結に書くために&lt;c2&gt;»&lt;/c2&gt;と&lt;c3&gt;[||]&lt;/c3&gt;の使用に注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note though that the contents of parens or brackets is parsed as a semicolon-separated list of &lt;i0&gt;statements&lt;/i0&gt;, so you can say:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130805T161405Z" creationid="Toshiyuki" creationdate="20130805T161405Z">
        <seg>丸括弧かブラケットの内容はセミコロンで分けられた&lt;i0&gt;文&lt;/i0&gt;のリストとしてパースされる。だからあなたはこう書ける：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085411Z" creationid="Toshiyuki" creationdate="20130818T085411Z">
        <seg>注意、けれども、その</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nothing is ever bound implicitly, however, and many conditionals would simply bind &lt;c0&gt;True&lt;/c0&gt; or &lt;c1&gt;False&lt;/c1&gt; in an uninteresting fashion.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T145004Z" creationid="Toshiyuki" creationdate="20130809T145004Z">
        <seg>これまでに何も暗黙にバインドされていない、どんな方法でも、そして多数の条件文が単純に&lt;c0&gt;True&lt;/c0&gt;か&lt;c1&gt;False&lt;/c1&gt;をつまらないやり方でバインドする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how the custom constructor and sensible use of whitespace allows a layout which makes task dependencies clear.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T142230Z" creationid="Toshiyuki" creationdate="20140314T142230Z">
        <seg>カスタムコンストラクタと気の利いた空白の使い方がタスクの依存を明白にレイアウトしていることに気づいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice the little smiley face attached to the parameter's type: &lt;c0&gt;:D&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T071451Z" creationid="Toshiyuki" creationdate="20140110T132133Z">
        <seg>小さなニコニコした顔がパラメータの型に付いていることに気づいてください：&lt;c0&gt;:D&lt;/c0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now all the methods made available by both the Programmer class and the Cook class are available from the GeekCook class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T134302Z" creationid="Toshiyuki" creationdate="20140112T134302Z">
        <seg>現在、ProgrammerクラスとCookクラスによって利用可能となるすべてのメソッドは、GeekCookクラスから入手可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now all the necessary informations are in place, and the chart can print:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T065507Z" creationid="Toshiyuki" creationdate="20131027T065507Z">
        <seg>現在、すべての必要な情報は使える状態です。そしてチャートは以下を出力することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now any object of type Programmer can make use of the methods and accessors defined in the Employee class as though they were from the Programmer class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T121712Z" creationid="Toshiyuki" creationdate="20140112T121542Z">
        <seg>Programmer型のオブジェクトならなんでも、Employeeクラスのメソッドとアクセサが使えます。それらがProgrammerクラスであったかのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbers</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T013833Z" creationid="Toshiyuki" creationdate="20140322T013833Z">
        <seg>数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbers in scientific notation such as &lt;c0&gt;6.022e23&lt;/c0&gt; are of type &lt;c1&gt;Num&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014201Z" creationid="Toshiyuki" creationdate="20140226T143749Z">
        <seg>&lt;c0&gt;6.022e23&lt;/c0&gt;のような科学的記数法の数は&lt;c1&gt;Num&lt;/c1&gt;型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbers in the form &lt;c0&gt;a + bi&lt;/c0&gt;, where &lt;c1&gt;bi&lt;/c1&gt; is the imaginary component, are of type &lt;c2&gt;Complex&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014921Z" creationid="Toshiyuki" creationdate="20140228T194127Z">
        <seg>&lt;c0&gt;a + bi&lt;/c0&gt;という形式（&lt;c1&gt;bi&lt;/c1&gt;は虚数成分です）の数は、&lt;c2&gt;Complex&lt;/c2&gt;型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric Comparisons</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T123917Z" creationid="Toshiyuki" creationdate="20131028T123917Z">
        <seg>数値の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric and boolean context of hashes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T085841Z" creationid="Toshiyuki" creationdate="20140329T085841Z">
        <seg>ハッシュの数値とブールコンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric and string conversions use these lazy warnings to allow (but not require) failsoft semantics.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T131145Z" creationid="Toshiyuki" creationdate="20130817T131145Z">
        <seg>数値と文字列の変換はフェールソフトセマンティクスを許可する（しかし要求されない）ためにlazy warningsを使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Object Oriented Programming provides the concept of inheritance as one of the mechanisms to allow for code reuse.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T142325Z" creationid="Toshiyuki" creationdate="20140112T092844Z">
        <seg>オブジェクト指向プログラミングは、コードの再利用を可能にするメカニズムの1つとして継承の概念を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, an explicit &lt;c4&gt;next&lt;/c4&gt; might be clearer than a &lt;c5&gt;succeed&lt;/c5&gt; if you really want to go directly to the next iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120420Z" creationid="Toshiyuki" creationdate="20130813T120420Z">
        <seg>当然、明示的な&lt;c4&gt;next&lt;/c4&gt;は&lt;c5&gt;succeed&lt;/c5&gt;よりもはっきりしているかもしれない。もしあなたが本当に次の反復に直接行きたいと思うなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, classes can override methods and attributes defined on ancestoral classes by defining their own.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T123903Z" creationid="Toshiyuki" creationdate="20140112T123903Z">
        <seg>もちろん、クラスはそれ自身のメソッドと属性を定義することで祖先のクラスのものをオーバーライドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often it is useful to limit the match to the start or end of a string or line or to word boundaries.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T125725Z" creationid="Toshiyuki" creationdate="20140221T232048Z">
        <seg>マッチを文字列または行の始まりまたは終わりまで、または単語境界に制限することはしばしば役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand &lt;c8&gt;'2' eqv 2&lt;/c8&gt; returns &lt;c9&gt;False&lt;/c9&gt;, because one argument is a string, the other an integer and so they are not of the same type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T123826Z" creationid="Toshiyuki" creationdate="20131028T123826Z">
        <seg>一方で&lt;c8&gt;'2' eqv 2&lt;/c8&gt;は&lt;c9&gt;False&lt;/c9&gt;を返します。なぜなら一方の引数は文字列、もう一方は整数なので、それらは同じ型ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, &lt;c6&gt;succeed&lt;/c6&gt; can take an optional argument giving the value for that iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120526Z" creationid="Toshiyuki" creationdate="20130813T120526Z">
        <seg>一方では、&lt;c6&gt;succeed&lt;/c6&gt;はループの反復のための変数を与える任意の引数をとることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if a statement_prefix is followed by a non-block statement, all nested blockless statement_prefixes will terminate at the same statement ending:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124551Z" creationid="Toshiyuki" creationdate="20130811T124551Z">
        <seg>一方では、もしstatement_prefixの後にブロックでない文が続くなら、全ての入れ子になったブロックなしのstatement_prefixesは同じ文の末端で終わるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the final atom matches, the regex engine attempts to match the goal (&lt;c12&gt;B&lt;/c12&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T144300Z" creationid="Toshiyuki" creationdate="20140222T133421Z">
        <seg>最終的なアトムが1回マッチすると、正規表現エンジンは最終目的（&lt;c12&gt;B&lt;/c12&gt;）にマッチしようと試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you have the Match object, what can you &lt;e0&gt;do&lt;/e0&gt; with it?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T231424Z" creationid="Toshiyuki" creationdate="20140224T161000Z">
        <seg>あなたがMatchオブジェクトを持っていたら、それをどうすることができますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One additional level of control is the notion of &lt;i0&gt;lazy warnings&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130107Z" creationid="Toshiyuki" creationdate="20130817T130107Z">
        <seg>制御の追加のレベルは&lt;i0&gt;lazy warnings&lt;/i0&gt;の考えだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can specify a separator with &lt;c0&gt;%&lt;/c0&gt; after the quantifier:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T033609Z" creationid="Toshiyuki" creationdate="20140221T225518Z">
        <seg>数量詞の後の&lt;c0&gt;%&lt;/c0&gt;でセパレーターを指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One candidate remains from the JSON example:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113502Z" creationid="Toshiyuki" creationdate="20140322T113502Z">
        <seg>1つの候補はJSONの例から残ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the Perl5-isms that Perl 6 eliminates is the need to verify the "definedness" of a subroutine's arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T131938Z" creationid="Toshiyuki" creationdate="20140110T131938Z">
        <seg>Perl 5の慣習の一つでPerl 6が取り除くものは、サブルーチンの引数が定義されているか確かめる必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One other difference from Perl 5 is that the default is not to undefine a variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140100Z" creationid="Toshiyuki" creationdate="20130802T140100Z">
        <seg>一つPerl 5と違うことは、デフォルトは変数を未定義にしないことだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One vertical bar between multiple parts of a regex means that the alternatives are tried in parallel and the longest matching alternative wins.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T231618Z" creationid="Toshiyuki" creationdate="20140221T231500Z">
        <seg>複数の正規表現のパーツの間の垂直バーは、選択肢が並列に試され、そして最も長い選択肢が勝つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-or-failure is very useful when dealing with per-object role application.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T033453Z" creationid="Toshiyuki" creationdate="20140115T141638Z">
        <seg>One-or-failureはオブジェクトごとにロールを適用して対処する場合に非常に有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-pass parsing</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053343Z" creationid="Toshiyuki" creationdate="20140330T053343Z">
        <seg>ワンパス構文解析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only &lt;c14&gt;Failure&lt;/c14&gt; objects need to store the actual status however; other types just return &lt;c15&gt;True&lt;/c15&gt;.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161959Z" creationid="Toshiyuki" creationdate="20130817T161959Z">
        <seg>&lt;c14&gt;Failure&lt;/c14&gt;だけが実際のステータスを格納することを必要とする；他の型はただ&lt;c15&gt;True&lt;/c15&gt;を返す。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only argumentless phasers may use the statement form.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085659Z" creationid="Toshiyuki" creationdate="20130818T085659Z">
        <seg>引数なしのphasersだけが文形式を使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only names defined in the lexical scope of the immediately surrounding routine are considered concrete.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T063505Z" creationid="Toshiyuki" creationdate="20130811T063505Z">
        <seg>すぐ近くでルーチンを囲んでいるレキシカルスコープに定義された名前だけが具体的だと見なされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only word characters, digits, and the underscore cause an exact substring search.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T022934Z" creationid="Toshiyuki" creationdate="20140115T143733Z">
        <seg>ワード文字、数字とアンダーラインだけが、正確な部分文字列検索を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015005Z" creationid="Toshiyuki" creationdate="20140322T015005Z">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T041918Z" creationid="Toshiyuki" creationdate="20131027T041918Z">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators are very short names for often used routines.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T044021Z" creationid="Toshiyuki" creationdate="20131027T044021Z">
        <seg>演算子は、しばしば使われるルーチンの非常に短い名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T010503Z" creationid="Toshiyuki" creationdate="20131230T040336Z">
        <seg>任意のパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or one could constrain arguments to those that exist as keys of a hash:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140106T141142Z" creationid="Toshiyuki" creationdate="20140106T141142Z">
        <seg>またはハッシュのキーとしてこれらが存在する引数の制約も可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Order of Parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T165830Z" creationid="Toshiyuki" creationdate="20140104T165830Z">
        <seg>パラメータの順番</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other Regex Features</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T023520Z" creationid="Toshiyuki" creationdate="20140222T023520Z">
        <seg>他の正規表現機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other kinds of phasers can be installed as well; these are automatically called at various times as appropriate, and some of them respond to various control exceptions and exit values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T081130Z" creationid="Toshiyuki" creationdate="20130818T081130Z">
        <seg>他の種類のphasersは同様にうまくインストールされる；それらは適切に様々なタイミングで自動的に呼ばれ、それらのいくつかは様々な制御例外と抜け出る値に応答する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other operators compare strings lexicographically.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T125256Z" creationid="Toshiyuki" creationdate="20131028T125256Z">
        <seg>他の演算子は文字列を辞書編集上で比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other programming languages call that a &lt;e3&gt;hash table&lt;/e3&gt;, &lt;e4&gt;dictionary&lt;/e4&gt;, or &lt;e5&gt;map&lt;/e5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T155034Z" creationid="Toshiyuki" creationdate="20131026T093819Z">
        <seg>他のプログラミング言語ではそれを&lt;e3&gt;ハッシュテーブル&lt;/e3&gt;、&lt;e4&gt;ディクショナリー&lt;/e4&gt;、または&lt;e5&gt;マップ&lt;/e5&gt;と呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other similar forms, where a keyword is followed by code to be controlled by it, may also take bare statements, including &lt;c0&gt;try&lt;/c0&gt;, &lt;c1&gt;once&lt;/c1&gt;, &lt;c2&gt;quietly&lt;/c2&gt;, &lt;c3&gt;contend&lt;/c3&gt;, &lt;c4&gt;async&lt;/c4&gt;, &lt;c5&gt;lazy&lt;/c5&gt;, and &lt;c6&gt;sink&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T080426Z" creationid="Toshiyuki" creationdate="20130811T080426Z">
        <seg>他の似ている形式で、コードが続くキーワードがそれによって制御され、裸の文をとることができる。&lt;c0&gt;try&lt;/c0&gt;、&lt;c1&gt;once&lt;/c1&gt;、&lt;c2&gt;quietly&lt;/c2&gt;、&lt;c3&gt;contend&lt;/c3&gt;、&lt;c4&gt;async&lt;/c4&gt;、&lt;c5&gt;lazy&lt;/c5&gt;、&lt;c6&gt;sink&lt;/c6&gt;を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise the value will be the null string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130827Z" creationid="Toshiyuki" creationdate="20130817T130827Z">
        <seg>さもなければ値はnull文字列になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, if the class has a method of the same name that is &lt;e0&gt;not&lt;/e0&gt; declared as a multi, then the method in the class alone--as usual--will take precedence.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T023834Z" creationid="Toshiyuki" creationdate="20140115T140817Z">
        <seg>一方、クラスがマルチと宣言されていない同じ名前のメソッドを持っているならば、クラスのメソッドだけが優位をとるでしょう ― 通常通りに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the method performs all of the task's dependencies, using the &lt;c0&gt;for&lt;/c0&gt; construct to iterate over all of the items in the &lt;c1&gt;@!dependencies&lt;/c1&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T191724Z" creationid="Toshiyuki" creationdate="20140111T191724Z">
        <seg>一方、メソッドは全ての仕事の依存を実行します。&lt;c0&gt;for&lt;/c0&gt;構造を使ってすべての&lt;c1&gt;@!dependencies&lt;/c1&gt;属性のアイテムを繰り返し実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our goal is to convey the "flavor" of writing Perl 6 programs so that the reader may proceed to write their own native Perl 6 programs rather than programs that resemble some other language (footnote: Some programmers can still write Fortran in any language, however :)).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T023401Z" creationid="Toshiyuki" creationdate="20131025T224929Z">
        <seg>我々のゴールは、読者が他の言語に似ているプログラムよりもネイティブのPerl 6プログラムを書き始めることができるようにPerl 6プログラムを記述する「特色」を伝えることです。（しかし、一部のプログラマーはまだFortranをどんな言語でも書くことができます＾＾）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Inherited Methods</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144319Z" creationid="Toshiyuki" creationdate="20140314T144319Z">
        <seg>継承したメソッドのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameter types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T230823Z" creationid="Toshiyuki" creationdate="20140328T230806Z">
        <seg>パラメーターの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters can also have multiple names.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T123749Z" creationid="Toshiyuki" creationdate="20140104T123749Z">
        <seg>パラメータは複数の名前を持つこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters may be given types, just like any other variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T230903Z" creationid="Toshiyuki" creationdate="20140328T230903Z">
        <seg>パラメータは他の変数のように型を与えられることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parcels</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073359Z" creationid="Toshiyuki" creationdate="20140329T073359Z">
        <seg>パーセル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing Arrays, Hashes and Code</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131221T001555Z" creationid="Toshiyuki" creationdate="20131221T001555Z">
        <seg>配列、ハッシュ、コードを渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing a numeric value of type &lt;c1&gt;Real&lt;/c1&gt; instead invokes the second.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112541Z" creationid="Toshiyuki" creationdate="20140112T183746Z">
        <seg>数値の&lt;c1&gt;Real&lt;/c1&gt;型を代わりに渡すと2番目を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing two &lt;c5&gt;Rock&lt;/c5&gt;s means that &lt;c6&gt;::T, T&lt;/c6&gt; is one step narrower than &lt;c7&gt;Any, Any&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T063342Z" creationid="Toshiyuki" creationdate="20140113T063342Z">
        <seg>2つの&lt;c5&gt;Rock&lt;/c5&gt;を渡すことは、&lt;c6&gt;::T, T&lt;/c6&gt;は&lt;c7&gt;Any, Any&lt;/c7&gt;よりも1ステップ狭いということを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pattern matching</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140115T143136Z" creationid="Toshiyuki" creationdate="20140115T143136Z">
        <seg>パターンマッチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pattern matching is the process of applying these patterns to actual text to look for matches.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T163801Z" creationid="Toshiyuki" creationdate="20140115T143212Z">
        <seg>パターンマッチは、マッチを探すためにこれらのパターンを実際のテキストに適用するプロセスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5 developers try to extend the language in various ways while keeping backwards compatibility with past versions of Perl.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T225712Z" creationid="Toshiyuki" creationdate="20131025T225641Z">
        <seg>Perlの過去のバージョンとの下位互換性を維持しながら、Perl 5開発者はさまざまな方法で言語を拡張しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5 will interpret it as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T111230Z" creationid="Toshiyuki" creationdate="20131027T111230Z">
        <seg>Perl 5はそれをこのように解釈するでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5's "&lt;c0&gt;local&lt;/c0&gt;" function has been renamed to &lt;c1&gt;temp&lt;/c1&gt; to better reflect what it does.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133905Z" creationid="Toshiyuki" creationdate="20130802T133905Z">
        <seg>Perl 5の&lt;c0&gt;local&lt;/c0&gt;関数は何をするのかより良く表すように&lt;c1&gt;temp&lt;/c1&gt;に名前を変更した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 allows you to do so by applying roles to individual objects at runtime.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T040547Z" creationid="Toshiyuki" creationdate="20140115T142122Z">
        <seg>Perl 6は、実行時にロールを個々のオブジェクトに適用することによってそれを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 classes retain the responsibility for modeling and managing instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T012009Z" creationid="Toshiyuki" creationdate="20140115T101639Z">
        <seg>Perl 6のクラスは、インスタンスをモデル化して管理することに対する責任を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 developers extend the language by adding new syntactic and semantic features that enable more power and expressiveness without the restriction of backward compatibility with Perl 5 or earlier versions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T225907Z" creationid="Toshiyuki" creationdate="20131025T225907Z">
        <seg>Perl 6開発者は、Perl 5または以前の版との下位互換性の制限なしでより多くのパワーと表現の豊かさを可能にする新しい構文法で意味論的な機能を加えることによって、言語を拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has &lt;c0&gt;Failure&lt;/c0&gt; objects, known as "unthrown exceptions" (though really a &lt;c1&gt;Failure&lt;/c1&gt; merely contains an unthrown exception), which know whether they have been handled or not.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T151438Z" creationid="Toshiyuki" creationdate="20130817T151438Z">
        <seg>Perl 6は&lt;c0&gt;Failure&lt;/c0&gt;オブジェクト、「スローされない例外」を持つ（実際は&lt;c1&gt;Failure&lt;/c1&gt;は単にスローされない例外を含む）。それはそれらがハンドルされたかどうか知っている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has a rich set of literal forms, many of which can be used for textual input as well.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T120253Z" creationid="Toshiyuki" creationdate="20140329T120253Z">
        <seg>Perl 6はリテラルの形式の豊富なセットを持っており、それらの多くが原文の入力に同様に使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has an optional type system that helps you write safer code that performs better.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140325T141840Z" creationid="Toshiyuki" creationdate="20140325T141556Z">
        <seg>Perl 6はより良く動作する安全なコードを書くのに役立つ任意指定の型システムを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has several numeric types which can intermix freely--such as subtracting a floating point value from an integer, as &lt;c0&gt;123 - 12.1e1&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014007Z" creationid="Toshiyuki" creationdate="20140226T143417Z">
        <seg>Perl 6は自由に混在させることができるいくつかの数値型を持っています ― &lt;c0&gt;123 - 12.1e1&lt;/c0&gt;として、整数から浮動小数点値を減算するなどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 implementations</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T231218Z" creationid="Toshiyuki" creationdate="20131025T231218Z">
        <seg>Perl 6の実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 includes a system of &lt;b0&gt;sigils&lt;/b0&gt; to mark the fundamental structural type of a variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000343Z" creationid="Toshiyuki" creationdate="20140329T000343Z">
        <seg>Perl 6は変数の基本的な構造上の型を表示するために&lt;b0&gt;シギル&lt;/b0&gt;システムを含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 intrinsically supports big integers and rationals through its system of type declarations.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130220Z" creationid="Toshiyuki" creationdate="20140328T130220Z">
        <seg>Perl 6は型宣言のシステムによって大きい整数と有理数をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is a language specification for which multiple compilers and interpreters exist in various stages of completeness.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T022023Z" creationid="Toshiyuki" creationdate="20131025T161139Z">
        <seg>Perl 6は多くコンパイラとインタープリタが網羅性の様々な過程に存在する言語仕様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is a specification.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T231230Z" creationid="Toshiyuki" creationdate="20131025T231230Z">
        <seg>Perl 6は仕様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is even better.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T232222Z" creationid="Toshiyuki" creationdate="20131025T232222Z">
        <seg>Perl 6はより強力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is rather more liberal than many languages in the area of constructors.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T140742Z" creationid="Toshiyuki" creationdate="20140111T193128Z">
        <seg>Perl 6は、コンストラクタにおいては多くの言語より自由がききます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is the newest member of the family of languages known as Perl.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T023502Z" creationid="Toshiyuki" creationdate="20131025T225043Z">
        <seg>Perl 6はPerlとして知られている言語ファミリーで最も新しいメンバーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is versatile, intuitive, and flexible.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140306T130521Z" creationid="Toshiyuki" creationdate="20131025T215610Z">
        <seg>Perl 6は多目的で、直観的で、柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 provides another alternative: &lt;e1&gt;action methods&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T231623Z" creationid="Toshiyuki" creationdate="20140224T161050Z">
        <seg>Perl 6は別の選択肢を提供します：&lt;e1&gt;アクションメソッド&lt;/e1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 provides another operator that allows you to perform comparisons that Do The Right Thing with &lt;c0&gt;~~&lt;/c0&gt;, the smart match operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T125155Z" creationid="Toshiyuki" creationdate="20131029T125155Z">
        <seg>Perl 6は&lt;c0&gt;~~&lt;/c0&gt;によって正しいものをうまく比較するスマートマッチ演算子を用意しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 regexes allow this through the use of the &lt;c1&gt;:sigspace&lt;/c1&gt; modifier (shortened to &lt;c2&gt;:s&lt;/c2&gt;):</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T041821Z" creationid="Toshiyuki" creationdate="20140222T020756Z">
        <seg>Perl 6の正規表現は、&lt;c1&gt;:sigspace&lt;/c1&gt;修飾子（&lt;c2&gt;:s&lt;/c2&gt;と省略できる）を用いることにより、これを可能にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 subroutines are objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T133105Z" creationid="Toshiyuki" creationdate="20131029T133105Z">
        <seg>Perl 6のサブルーチンはオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 supports the ability for one class to inherit from one or more classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T143758Z" creationid="Toshiyuki" creationdate="20140112T092958Z">
        <seg>Perl 6は、1つのクラスが1またはそれ以上のクラスから継承する機能をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 supports the notion of &lt;b0&gt;properties&lt;/b0&gt; on various kinds of objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131839Z" creationid="Toshiyuki" creationdate="20140326T131839Z">
        <seg>Perl 6は様々なオブジェクトで&lt;b0&gt;プロパティ&lt;/b0&gt;の概念をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6's precedence rules allow you to express many common operations naturally, without thinking about precedence at all.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121134Z" creationid="Toshiyuki" creationdate="20131027T121134Z">
        <seg>Perl 6の優先順位規則は、優先順位について考えることなく、自然に多くの一般の演算子を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6's precedence rules state that the infix &lt;c1&gt;=&gt;&lt;/c1&gt; operator binds its arguments more tightly than the infix &lt;c2&gt;,&lt;/c2&gt; operator, which in turn binds more tightly than the &lt;c3&gt;=&lt;/c3&gt; assignment operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T113733Z" creationid="Toshiyuki" creationdate="20131027T113733Z">
        <seg>Perl 6の優先順位規則は接中辞&lt;c1&gt;=&gt;&lt;/c1&gt;演算子が接中辞&lt;c2&gt;,&lt;/c2&gt;演算子よりタイトにその引数を結びつけると宣言します。そしてそれは&lt;c3&gt;=&lt;/c3&gt;割り当て演算子よりタイトに次々に結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6, like many other languages, uses the &lt;c0&gt;class&lt;/c0&gt; keyword to introduce a new class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T180049Z" creationid="Toshiyuki" creationdate="20140111T180049Z">
        <seg>Perl 6は多くの他の言語のように、新しいクラスを導入するために&lt;c0&gt;class&lt;/c0&gt;キーワードを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can also examine the contents of the arguments provided to decide which of several variants of a function--each with the same name--to call.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112129Z" creationid="Toshiyuki" creationdate="20140112T180916Z">
        <seg>Perlは関数 ― 同じ名前による各々 ― のいくつかの変形のどれを呼ぶべきかについて決めるために提供される引数の内容を調べることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl is philosophy (there's more than one way to do it; easy things should be easy, and hard things possible); Perl is custom (comprehensive testing, idioms); Perl is architectural edifice (the Comprehensive Perl Archive Network); and Perl is community (perl5-porters, perl6-language).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T231930Z" creationid="Toshiyuki" creationdate="20131025T230731Z">
        <seg>Perlは哲学です（複数のやり方があります。簡単なことは簡単で、難しいことは可能にすべきです）。Perlは慣習です（総合的なテスト、イディオム）。Perlは構造的な構成物です（Comprehensive Perl Archive Network）。そしてPerlはコミュニティです（perl5-porters、perl6-language）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl originated as a programming language intended to gather and summarize information from text files.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T232122Z" creationid="Toshiyuki" creationdate="20131025T232122Z">
        <seg>Perlはテキストファイルから情報を集めて要約する目的のプログラミング言語として始まりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl supports generic types through what are called "roles" which represent capabilities or interfaces.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T125916Z" creationid="Toshiyuki" creationdate="20140328T125750Z">
        <seg>Perlは機能またはインターフェースを表す“ロール”と呼ばれるものを通してジェネリック型をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl takes the attributes and methods defined in each role and copies them into the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T013614Z" creationid="Toshiyuki" creationdate="20140115T135459Z">
        <seg>Perlは個々のロールで定義されている属性とメソッドをクラスにコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl types with both positional and named parts also show up in various other situations.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T160327Z" creationid="Toshiyuki" creationdate="20140110T160327Z">
        <seg>位置と名前付きの両方のPerlの型はいろいろな状況で現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl usually decides which function to call based on the name of the function or the contents of a function reference.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T160447Z" creationid="Toshiyuki" creationdate="20140112T180829Z">
        <seg>Perlは通常、関数の名前か関数リファレンスの内容に基づいてどの関数を呼ぶべきかについて決めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl variables have two associated types: their "of type" and their "container type".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T165628Z" creationid="Toshiyuki" creationdate="20140328T165628Z">
        <seg>Perlの変数は2つの関連する型を持ちます：それらの“型”とそれらの“コンテナ”です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Phasers marked with a &lt;c3&gt;*&lt;/c3&gt; can be used for their return value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T081415Z" creationid="Toshiyuki" creationdate="20130818T081415Z">
        <seg>&lt;c3&gt;*&lt;/c3&gt;でマークされたPhasersはそれらの返り値として使用できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pointy blocks and bare closures are transparent to &lt;c4&gt;return&lt;/c4&gt;, in that the &lt;c5&gt;return&lt;/c5&gt; statement still means &lt;c6&gt;&amp;?ROUTINE.leave&lt;/c6&gt; from the &lt;c7&gt;Routine&lt;/c7&gt; that existed in dynamic scope when the closure was cloned.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T044655Z" creationid="Toshiyuki" creationdate="20130817T044655Z">
        <seg>ポインティブロックと裸のクロージャは&lt;c4&gt;return&lt;/c4&gt;には明白だ。&lt;c5&gt;return&lt;/c5&gt;文はまだ	クロージャが複製された時ダイナミックスコープに抜け出た&lt;c7&gt;Routine&lt;/c7&gt;から&lt;c6&gt;&amp;?ROUTINE.leave&lt;/c6&gt;することを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Positional parameters are always required by default.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T011014Z" creationid="Toshiyuki" creationdate="20131230T042347Z">
        <seg>デフォルトでは順序に依存するパラメータは常に必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preface</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T161034Z" creationid="Toshiyuki" creationdate="20131025T161034Z">
        <seg>序文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Presumably multiple dispatch could sort this out.]</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T103253Z" creationid="Toshiyuki" creationdate="20130806T103253Z">
        <seg>多分、マルチディスパッチはこれを選り分けできる。]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programming language designers often call these &lt;e0&gt;first-class subroutines&lt;/e0&gt;; they are as fundamental to the language as hashes or arrays are.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T133449Z" creationid="Toshiyuki" creationdate="20131029T133449Z">
        <seg>プログラミング言語の設計者はしばしばそれらを&lt;e0&gt;ファーストクラスサブルーチン&lt;/e0&gt;と呼びます：それらはハッシュや配列のように言語の基本となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties applied to objects constructed at compile-time, such as variables and classes, are also called &lt;b0&gt;traits&lt;/b0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132801Z" creationid="Toshiyuki" creationdate="20140326T132801Z">
        <seg>変数やクラスのように、コンパイル時に構成されるオブジェクトに適用されるプロパティは&lt;b0&gt;トレイト&lt;/b0&gt;とも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties are like object attributes, except that they're managed by the individual object rather than by the object's class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131958Z" creationid="Toshiyuki" creationdate="20140326T131958Z">
        <seg>プロパティはオブジェクト属性のようですが、それらはクラスよりもむしろ個々のオブジェクトによって管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties on Objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131852Z" creationid="Toshiyuki" creationdate="20140326T131852Z">
        <seg>オブジェクトのプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protos</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T073609Z" creationid="Toshiyuki" creationdate="20140113T073600Z">
        <seg>プロト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Put simply, methods in the class always supersede methods which a role may provide.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T022511Z" creationid="Toshiyuki" creationdate="20140115T140417Z">
        <seg>簡単に説明すると、クラスのメソッドはロールが提供するであろうメソッドを常に破棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Querying the methods of the &lt;c1&gt;KarmaKeeper&lt;/c1&gt; class through introspection will report that the class has both a &lt;c2&gt;process&lt;/c2&gt; method and an &lt;c3&gt;on-message&lt;/c3&gt; multi method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T015150Z" creationid="Toshiyuki" creationdate="20140115T135648Z">
        <seg>イントロスペクションを通して&lt;c1&gt;KarmaKeeper&lt;/c1&gt;クラスのメソッドを問い合わせると、クラスが&lt;c2&gt;process&lt;/c2&gt;メソッドと&lt;c3&gt;on-message&lt;/c3&gt;マルチメソッドを両方持っていると報告するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than listing each character in the character class individually, you may specify a range of characters by placing the range operator &lt;c0&gt;..&lt;/c0&gt; between the beginning and ending characters:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T025554Z" creationid="Toshiyuki" creationdate="20140117T182848Z">
        <seg>個々に別々の文字を文字クラスにリストするよりも、始めと終わりの文字の間にレンジ演算子&lt;c0&gt;..&lt;/c0&gt;を置くことによって文字のレンジを指定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read this code as "For each element of sorted, set &lt;c2&gt;$n&lt;/c2&gt; to the element, then execute the contents of the following block." &lt;c3&gt;say&lt;/c3&gt; prints its arguments to the standard output (the screen, normally), followed by a newline.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T152148Z" creationid="Toshiyuki" creationdate="20131026T152148Z">
        <seg>このコードはこのように読んでください。「ソートされた要素ごとに要素を&lt;c2&gt;$n&lt;/c2&gt;にセットし、以下のブロックの内容を実行しなさい。」&lt;c3&gt;say&lt;/c3&gt;はその引数を標準出力（通常はスクリーン）に出力します。そして、改行文字が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of how many times the first capture matches (and how many elements are in &lt;c3&gt;$/[0]&lt;/c3&gt;), the second capture is still available in &lt;c4&gt;$/[1]&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T010134Z" creationid="Toshiyuki" creationdate="20140222T010134Z">
        <seg>最初のキャプチャーが何回マッチしたかに関係なく（そしていくつの要素が&lt;c3&gt;$/[0]&lt;/c3&gt;に入っているかに関係なく）、2番目のキャプチャーはまだ&lt;c4&gt;$/[1]&lt;/c4&gt;で利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of the &lt;c3&gt;take&lt;/c3&gt;'s immediate context, the object returned is also added to the list of values being gathered, which is returned by the &lt;c4&gt;gather&lt;/c4&gt; as a lazy list (that is, an iterator, really), with each argument element of that list corresponding to one &lt;c5&gt;take&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T204205Z" creationid="Toshiyuki" creationdate="20130810T204205Z">
        <seg>&lt;c3&gt;take&lt;/c3&gt;の直接のコンテキストに関わらず、返されたオブジェクトも集められた値のリストに追加され、それは&lt;c4&gt;gather&lt;/c4&gt;によってレイジーリストとして返される（すなわち、本当にイテレータ）そのリストの一つの&lt;c5&gt;take&lt;/c5&gt;に対応するそれぞれの引数の要素と一緒に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regex can be very useful for &lt;e0&gt;extracting&lt;/e0&gt; information too.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T233209Z" creationid="Toshiyuki" creationdate="20140221T233209Z">
        <seg>正規表現は情報を&lt;e0&gt;抜き出す&lt;/e0&gt;ためにも役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regex names may be constructed the same as subroutine names or method names.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T132809Z" creationid="Toshiyuki" creationdate="20140222T095150Z">
        <seg>正規表現名はサブルーチン名またはメソッド名をつけるのと同じように構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regex support special (also called &lt;e0&gt;metasyntactic&lt;/e0&gt;) characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T023957Z" creationid="Toshiyuki" creationdate="20140115T143901Z">
        <seg>正規表現は、特別な（&lt;e0&gt;メタ構文&lt;/e0&gt;とも呼ばれる）文字をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regexes are also good for data manipulation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131252Z" creationid="Toshiyuki" creationdate="20140222T023101Z">
        <seg>正規表現はデータ操作にもよいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regexes can be recursive.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T132358Z" creationid="Toshiyuki" creationdate="20140222T132358Z">
        <seg>正規表現は再帰的でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regular expressions are a computer science concept where simple patterns describe the format of text.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T163659Z" creationid="Toshiyuki" creationdate="20140115T143159Z">
        <seg>正規表現は、単純なパターンがテキストのフォーマットを記述するコンピューターサイエンス概念です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Relationship between Perl 6 and Perl 5</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T224952Z" creationid="Toshiyuki" creationdate="20131025T224952Z">
        <seg>Perl 6とPerl 5の関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Relying on the side effects of type checks produces unreliable code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113435Z" creationid="Toshiyuki" creationdate="20140322T113435Z">
        <seg>型チェックの副作用に頼ることは信頼できないコードを生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember, no implicit block scopes.) It is also possible to write</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063626Z" creationid="Toshiyuki" creationdate="20130810T063626Z">
        <seg>暗黙のブロックスコープはないことを覚えておくこと。）それは次のようにも書ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remove the next paragraph when appropriate.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T022109Z" creationid="Toshiyuki" creationdate="20140322T022109Z">
        <seg>適切なら次の文節は削除してださい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Renaming Parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T011930Z" creationid="Toshiyuki" creationdate="20131231T225746Z">
        <seg>パラメータの名前を変える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replacing the &lt;c4&gt;!&lt;/c4&gt; with a &lt;c5&gt;.&lt;/c5&gt; both declares the attribute &lt;c6&gt;$!done&lt;/c6&gt; and an accessor method named &lt;c7&gt;done&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184217Z" creationid="Toshiyuki" creationdate="20140111T184217Z">
        <seg>&lt;c4&gt;!&lt;/c4&gt;を&lt;c5&gt;.&lt;/c5&gt;に置き換えると属性&lt;c6&gt;$!done&lt;/c6&gt;とアクセサメソッド&lt;c7&gt;done&lt;/c7&gt;を両方宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required Parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131230T042227Z" creationid="Toshiyuki" creationdate="20131230T042227Z">
        <seg>必須パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required parameters must always appear at the beginning of a subroutine's parameter list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131231T193833Z" creationid="Toshiyuki" creationdate="20131231T193827Z">
        <seg>必須のパラメータは常にサブルーチンのパラメータリストの始めに現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required positional parameters need to come before optional positional parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T054808Z" creationid="Toshiyuki" creationdate="20140104T181536Z">
        <seg>必須の順序依存パラメータは任意の位置依存パラメータの前にくる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resumable exceptions may also be implemented by simply marking the current exception as "resumed", in which case the original exception thrower simply returns to the code that threw the resumable exception, rather than unwinding before returning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T114629Z" creationid="Toshiyuki" creationdate="20130814T114629Z">
        <seg>再開可能な例外は現在の例外を単純に「resumed」としてマーキングして実装される。その場合に初期の例外を投げるものは再開可能な例外を投げたコードを単純に返す。返す前に巻き戻すよりも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resumable exceptions may or may not leave normally depending on the implementation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T113840Z" creationid="Toshiyuki" creationdate="20130814T113840Z">
        <seg>再開可能な例外が普通に去るかどうかは実装に依存する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T231458Z" creationid="Toshiyuki" creationdate="20140104T231458Z">
        <seg>返り値の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returning Results</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T214439Z" creationid="Toshiyuki" creationdate="20140104T214439Z">
        <seg>結果を返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Roles</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T080142Z" creationid="Toshiyuki" creationdate="20140113T080142Z">
        <seg>ロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Roles get much more interesting in the case of a conflict.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T015613Z" creationid="Toshiyuki" creationdate="20140115T135818Z">
        <seg>ロールは競合の場合にずっと興味深くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Roles handle the task of code reuse.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140115T101651Z" creationid="Toshiyuki" creationdate="20140115T101651Z">
        <seg>ロールは、コード再利用のタスクを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Roles in Perl 6 are first-class entities, just like classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T123724Z" creationid="Toshiyuki" creationdate="20140115T142350Z">
        <seg>Perl 6のロールはまるでクラスのようなファーストクラス実体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Runtime Application of Roles</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140115T142044Z" creationid="Toshiyuki" creationdate="20140115T142044Z">
        <seg>ロールの実行時適用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Runtime application differs from compile time composition in that methods in the applied role will automatically override any of the same name within the class of the object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T155058Z" creationid="Toshiyuki" creationdate="20140115T142643Z">
        <seg>適用されたロールのそのメソッドがオブジェクトのクラスの同じ名前のメソッドを自動的にオーバーライドするという点で、実行時の適用はコンパイル時の合成と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Runtime role application with &lt;c0&gt;does&lt;/c0&gt; modifies an object in place: &lt;c1&gt;$x does SomeRole&lt;/c1&gt; modifies the object stored in &lt;c2&gt;$x&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T161841Z" creationid="Toshiyuki" creationdate="20140115T143017Z">
        <seg>&lt;c0&gt;does&lt;/c0&gt;による実行時ロール適用は、その場でオブジェクトを変更します：&lt;c1&gt;$x does SomeRole&lt;/c1&gt;は、&lt;c2&gt;$x&lt;/c2&gt;に保存されるオブジェクトを変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scissors win against paper, paper wraps rock, and scissors can't cut rock, but go blunt trying.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114539Z" creationid="Toshiyuki" creationdate="20140113T045855Z">
        <seg>ハサミは紙に対して勝ち、紙は岩を包み、そしてハサミは岩を切ることができなくてなまくらになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scope declarators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021303Z" creationid="Toshiyuki" creationdate="20140329T021303Z">
        <seg>スコープ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Searching for literal strings gets boring pretty quickly.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T023850Z" creationid="Toshiyuki" creationdate="20140115T143845Z">
        <seg>リテラル文字列を捜すことは、かなり速くて退屈です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, a method places its invocant into the special variable &lt;c3&gt;self&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185538Z" creationid="Toshiyuki" creationdate="20140111T185538Z">
        <seg>第2に、メソッドはそのインボカントを特殊変数&lt;c3&gt;self&lt;/c3&gt;に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, it declares the variables in the subroutine to which the arguments are bound.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T220932Z" creationid="Toshiyuki" creationdate="20131126T123801Z">
        <seg>2つ目に、引数にバインドされたサブルーチン内の変数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a3&gt;Control Exceptions&lt;/a3&gt; below.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T115154Z" creationid="Toshiyuki" creationdate="20130729T115154Z">
        <seg>以下、&lt;a3&gt;Control Exceptions&lt;/a3&gt;を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a4&gt;link&lt;/a4&gt; for more information.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T144602Z" creationid="Toshiyuki" creationdate="20131026T144602Z">
        <seg>詳細は&lt;a4&gt;リンク&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;c0&gt;S02&lt;/c0&gt; for a long definition of argument, but in short, it's either an ordinary object or a parcel containing multiple values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T135631Z" creationid="Toshiyuki" creationdate="20130808T131659Z">
        <seg>引数の長い定義は&lt;c0&gt;S02&lt;/c0&gt;を参照。 一言で言えば、普通のオブジェクトか多数の値を含むパーセルだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See IEEE standard 1003.1-2001), we continue to call them &lt;c10&gt;regex&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T021435Z" creationid="Toshiyuki" creationdate="20140321T021435Z">
        <seg>我々はそれらを&lt;c10&gt;regex&lt;/c10&gt;と呼び続けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more on function parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T130016Z" creationid="Toshiyuki" creationdate="20130729T130016Z">
        <seg>関数のパラメータについてより詳しくはS06を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130917Z" creationid="Toshiyuki" creationdate="20130808T130917Z">
        <seg>以下を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See previous section for discussion of ways to return from catch lambdas.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T124949Z" creationid="Toshiyuki" creationdate="20130817T124949Z">
        <seg>キャッチlambdaから返す方法の議論は前のセクションを参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Separate &lt;e0&gt;alternations&lt;/e0&gt;--parts of a regex of which &lt;e1&gt;any&lt;/e1&gt; can match--with vertical bars.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T033923Z" creationid="Toshiyuki" creationdate="20140221T231340Z">
        <seg>&lt;e0&gt;選択肢&lt;/e0&gt;の分離 ― 正規表現の&lt;e1&gt;どれか&lt;/e1&gt;の部分は垂直バーでマッチできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Separate clones of the closure get separate state variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133323Z" creationid="Toshiyuki" creationdate="20130802T133323Z">
        <seg>異なるクロージャのクローンは異なるstate変数を得る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several implementations exist at various levels of maturity.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T023813Z" creationid="Toshiyuki" creationdate="20131025T231400Z">
        <seg>いくつかの実装が様々な成熟レベルに存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several other common control sequences each match a single character; you can find a list of those in &lt;a0&gt;link&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140117T182402Z" creationid="Toshiyuki" creationdate="20140117T182402Z">
        <seg>いくつかの他の共通制御シーケンスは、一つの文字に各々マッチします；あなたは、それらのリストを&lt;a0&gt;リンク&lt;/a0&gt;で見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shorthand</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T155909Z" creationid="Toshiyuki" creationdate="20140104T155909Z">
        <seg>短縮形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Should you accidentally run the file with Perl 5, you'll get a helpful error message.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T024526Z" creationid="Toshiyuki" creationdate="20131026T020039Z">
        <seg>あなたが偶然にもPerl 5でファイルを実行するならば、役に立つエラーメッセージが得られるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Show how to create a graph with cycles and explain why the &lt;c5&gt;perform&lt;/c5&gt; method of a &lt;c6&gt;Task&lt;/c6&gt; whose dependencies contain a cycle would never terminate successfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T152650Z" creationid="Toshiyuki" creationdate="20140112T172651Z">
        <seg>循環でグラフを作成する方法を示して、従属物がサイクルを含む&lt;c6&gt;Task&lt;/c6&gt;の&lt;c5&gt;perform&lt;/c5&gt;メソッドがなぜ決して終わらないかについて説明してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000155Z" creationid="Toshiyuki" creationdate="20140329T000155Z">
        <seg>シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils are now invariant.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022027Z" creationid="Toshiyuki" creationdate="20140329T021935Z">
        <seg>シギルは現在は不変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils indicate the default access method for a variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T095641Z" creationid="Toshiyuki" creationdate="20131026T095323Z">
        <seg>シギルは変数のためのデフォルトアクセス方式を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils indicate the structural interface for the variable, such as whether it should be treated as a single value, a compound value, a subroutine, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T033557Z" creationid="Toshiyuki" creationdate="20131026T033557Z">
        <seg>それが一つの値、複合値、サブルーチンなどとみなされるべきであるかどうかにかかわらず、シギルは変数のために構造上のインターフェースを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signature introspection allows you to build interfaces that can obtain and then pass the right data to a subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044401Z" creationid="Toshiyuki" creationdate="20140111T074246Z">
        <seg>シグネチャーイントロスペクションは、あなたがサブルーチンの正常なデータを得ることができて、それから渡すことができるインターフェースを構築するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signatures are not just syntax; instead, they are first-class objects that hold a list of &lt;c0&gt;Parameter&lt;/c0&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T041121Z" creationid="Toshiyuki" creationdate="20140110T133733Z">
        <seg>シグネチャーはただの文法ではありません；代わりに、それは&lt;c0&gt;Parameter&lt;/c0&gt;オブジェクトのリストを保持するファーストクラスオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, &lt;c0&gt;*%hash&lt;/c0&gt; slurps all the remaining unbound named arguments into a hash.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T061134Z" creationid="Toshiyuki" creationdate="20140104T205015Z">
        <seg>同様に、&lt;c0&gt;*%hash&lt;/c0&gt;は残り全てのバインドされていない名前付き引数をハッシュに入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, portions of the match that are captured with parentheses are available as positional elements of the &lt;c4&gt;Match&lt;/c4&gt; object (as if it were an array).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T231357Z" creationid="Toshiyuki" creationdate="20140224T160936Z">
        <seg>同様に、括弧でキャプチャーされるマッチ部分は位置依存要素の&lt;c4&gt;Match&lt;/c4&gt;オブジェクト（それが配列であるように）として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the &lt;c0&gt;%&lt;/c0&gt; sigil implies that the caller must pass an object that does the &lt;c1&gt;Associative&lt;/c1&gt; role; that is, something which allows indexing through &lt;c2&gt;&lt;...&gt;&lt;/c2&gt; or &lt;c3&gt;{...}&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131221T002848Z" creationid="Toshiyuki" creationdate="20131221T002848Z">
        <seg>同様に、&lt;c0&gt;%&lt;/c0&gt;シギルは呼び出し元が&lt;c1&gt;Associative&lt;/c1&gt;ロールをするオブジェクトを渡さなければならないことを示します；つまり、&lt;c2&gt;&lt;...&gt;&lt;/c2&gt;または&lt;c3&gt;{...}&lt;/c3&gt;によるインデクシングが可能な何かです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;c0&gt;do&lt;/c0&gt; is defined as going in front of a statement, it follows that it can always be followed by a statement label.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T130303Z" creationid="Toshiyuki" creationdate="20130810T130303Z">
        <seg>&lt;c0&gt;do&lt;/c0&gt;は文の前の出発として定義されるので、常に文ラベルが続くことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;c1&gt;when&lt;/c1&gt; statements are presumed to be executed in order like normal statements, it's not required that all the statements in a switch block be &lt;c2&gt;when&lt;/c2&gt; statements (though it helps the optimizer to have a sequence of contiguous &lt;c3&gt;when&lt;/c3&gt; statements, because then it can arrange to jump directly to the first appropriate test that might possibly match.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133157Z" creationid="Toshiyuki" creationdate="20130811T133157Z">
        <seg>&lt;c1&gt;when&lt;/c1&gt;文は通常の文のように順番に実行されると仮定されるので、switchブロックのすべての文が&lt;c2&gt;when&lt;/c2&gt;文になる必要はない（それは連続の&lt;c3&gt;when&lt;/c3&gt;のシーケンスを持つためにオプティマイザを助ける。なぜならマッチできると思われる最初の適切なテストに直接ジャンプするようにアレンジできるからだ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since a bare expression may be used as a statement, you may use &lt;c0&gt;do&lt;/c0&gt; on an expression, but its only effect is to function as an unmatched left parenthesis, much like the &lt;c1&gt;$&lt;/c1&gt; operator in Haskell.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T124326Z" creationid="Toshiyuki" creationdate="20130810T123311Z">
        <seg>裸の式は文として使われると思われるので、&lt;c0&gt;do&lt;/c0&gt;を式で使うだろう。しかしそれの唯一の効果は左括弧が対応がとれていない関数だ。Haskellの&lt;c1&gt;$&lt;/c1&gt;演算子にとても似ている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since all exception handlers run in the dynamic scope of the throw, that reduces to simply returning from the &lt;c1&gt;warn&lt;/c1&gt; function most of the time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T124718Z" creationid="Toshiyuki" creationdate="20130817T124718Z">
        <seg>全ての例外ハンドラはスローのダイナミックスコープで実行するので、それは大抵の場合&lt;c1&gt;warn&lt;/c1&gt;関数から単純に返すように変える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since any arbitrary Perl code can appear within curly braces, &lt;c1&gt;Array&lt;/c1&gt;s and &lt;c2&gt;Hash&lt;/c2&gt;es may be interpolated by placing them within curly braces.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T153753Z" creationid="Toshiyuki" creationdate="20131026T153753Z">
        <seg>どんな任意のPerlコードでもブレース内に表現できるので、&lt;c1&gt;Array&lt;/c1&gt;と&lt;c2&gt;Hash&lt;/c2&gt;をブレース内に置くことによって展開することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since bracketed expressions consider their insides to be statements, this works out consistently even where you might expect problems:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T031831Z" creationid="Toshiyuki" creationdate="20130803T031831Z">
        <seg>括弧に入れられた式はそれらの内部を文とみなすので、あなたが問題を予期している所でも一貫して上手くいく：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it is possible to pass arguments to parameters by name, the parameter names should be considered as part of a subroutine's public API.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T012130Z" creationid="Toshiyuki" creationdate="20131231T230104Z">
        <seg>引数を名前によってパラメータに渡すことが可能なので、パラメータ名はサブルーチンの公開APIの一部として考慮されるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since leaving a block is considered a successful return, breaking out of one with &lt;c11&gt;succeed&lt;/c11&gt; is also considered a successful return for the purposes of &lt;c12&gt;KEEP&lt;/c12&gt; and &lt;c13&gt;UNDO&lt;/c13&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114609Z" creationid="Toshiyuki" creationdate="20130813T114609Z">
        <seg>ブロックを去ることは成功したリターンとみなされるので、&lt;c11&gt;succeed&lt;/c11&gt;で脱出することも&lt;c12&gt;KEEP&lt;/c12&gt;と&lt;c13&gt;UNDO&lt;/c13&gt;の目的のための成功したリターンとみなされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since method calls are performed directly on any object, &lt;c0&gt;Nil&lt;/c0&gt; can respond to certain method calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140331T113520Z" creationid="Toshiyuki" creationdate="20140331T113520Z">
        <seg>メソッド呼び出しはどんなオブジェクトでも直接実行されるので、&lt;c0&gt;Nil&lt;/c0&gt;はある程度のメソッド呼び出しに反応できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the final expression in a subroutine returns its value, it's possible to accidentally return a loop's return value when you were only evaluating the loop for its side effects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T142217Z" creationid="Toshiyuki" creationdate="20130809T142217Z">
        <seg>サブルーチンの最後の式はその値を返すので、あなたがループの副作用のために評価するだけという場合に、偶然にループの返り値を返すことが起こり得る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the loop executes once before evaluating the condition, the bound parameter will be undefined that first time through the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T055600Z" creationid="Toshiyuki" creationdate="20130810T055600Z">
        <seg>条件を評価する前にループを1回実行するので、結び付けられたパラメータはループの初回に未定義にされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since warnings are processed using the standard control exception mechanism, they may be intercepted and either suppressed or fatalized anywhere within the dynamic scope by supplying a suitable &lt;c0&gt;CONTROL&lt;/c0&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T115816Z" creationid="Toshiyuki" creationdate="20130817T115816Z">
        <seg>警告は標準の制御例外メカニズムを使って処理されるので、それらは横取りされることもでき、適切な&lt;c0&gt;CONTROL&lt;/c0&gt;ブロックの供給によるダイナミックスコープ内で抑制されるかどこでも致命的にされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single quoted strings &lt;c6&gt;'...'&lt;/c6&gt; do not interpolate:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T152946Z" creationid="Toshiyuki" creationdate="20131026T152946Z">
        <seg>シングルクォート&lt;c6&gt;'...'&lt;/c6&gt;の文字列は展開しません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single-line Comments</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053448Z" creationid="Toshiyuki" creationdate="20140330T053448Z">
        <seg>ラインコメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slice context turns any parcel objects into &lt;c0&gt;Seq&lt;/c0&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T132209Z" creationid="Toshiyuki" creationdate="20130808T132209Z">
        <seg>スライスコンテキストはどんなパーセルオブジェクトでも&lt;c0&gt;Seq&lt;/c0&gt;オブジェクトに変える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slurpy Parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T181947Z" creationid="Toshiyuki" creationdate="20140104T181947Z">
        <seg>Slurpyなパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slurpy arrays and hashes allow you to pass all positional and named arguments to another routine:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T061208Z" creationid="Toshiyuki" creationdate="20140104T214357Z">
        <seg>slurpy配列とハッシュは全ての位置依存引数と名前付き引数を別のルーチンに渡すことを可能にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Smart Matching</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T124542Z" creationid="Toshiyuki" creationdate="20131029T124542Z">
        <seg>スマートマッチング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Smart match works by calling the &lt;c0&gt;ACCEPTS&lt;/c0&gt; method on the operand on the right hand side and passing it the operand on the left hand side as an argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T125953Z" creationid="Toshiyuki" creationdate="20131029T125953Z">
        <seg>スマートマッチは右側のオペランドで&lt;c0&gt;ACCEPTS&lt;/c0&gt;メソッドを呼び、左側のオペランドに引数として渡すことによって動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140105Z" creationid="Toshiyuki" creationdate="20130802T140105Z">
        <seg>つまり</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So &lt;c0&gt;/&lt;[+.*]&gt; /&lt;/c0&gt; matches a plus sign, a dot or an asterisk.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T025910Z" creationid="Toshiyuki" creationdate="20140117T183220Z">
        <seg>そのため、&lt;c0&gt;/&lt;[+.*]&gt; /&lt;/c0&gt;はプラス記号、ドットまたはアスタリスクにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So do the implicit conditionals implied by short-circuit operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130805T160823Z" creationid="Toshiyuki" creationdate="20130805T160823Z">
        <seg>このように、暗黙の条件は短絡演算子によって暗に意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far every regex could match anywhere within a string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T231901Z" creationid="Toshiyuki" creationdate="20140221T231901Z">
        <seg>これまで、すべての正規表現は文字列の中でどこでもマッチすることができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if you examine the &lt;c2&gt;ENTER&lt;/c2&gt; trait of a block, you'll find that it's really a list of phasers rather than a single phaser.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130820T124134Z" creationid="Toshiyuki" creationdate="20130820T124134Z">
        <seg>もし&lt;c2&gt;ENTER&lt;/c2&gt;ブロックのトレイトを調査するなら、あなたは単独のphaserよりも本当のphaserのリストだと気づくだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So logically, if the &lt;c1&gt;CATCH&lt;/c1&gt; block throws its own exception, you would expect the &lt;c2&gt;CATCH&lt;/c2&gt; block to catch its own exception recursively forever.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T120157Z" creationid="Toshiyuki" creationdate="20130814T120157Z">
        <seg>論理的には、もし&lt;c1&gt;CATCH&lt;/c1&gt;ブロックが独自の例外を投げるなら、あなたは&lt;c2&gt;CATCH&lt;/c2&gt;ブロックがその独自の例外を再帰的に絶えずキャッチすると期待するだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So switching behavior is actually caused by the &lt;c6&gt;when&lt;/c6&gt; statements in the block, not by the nature of the block itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T130033Z" creationid="Toshiyuki" creationdate="20130811T130033Z">
        <seg>それゆえ、switchの振る舞いは実際はブロックの&lt;c6&gt;when&lt;/c6&gt;文によって引き起こされ、ブロック自身の性質によってではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the object in question is of class &lt;c0&gt;Employee&lt;/c0&gt; or one that inherits from it, but not &lt;c1&gt;GeekCook&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T151656Z" creationid="Toshiyuki" creationdate="20140112T135850Z">
        <seg>それで、問題のオブジェクトはクラス&lt;c0&gt;Employee&lt;/c0&gt;またはそれから継承したもので、&lt;c1&gt;GeekCook&lt;/c1&gt;ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the old &lt;c6&gt;next LINE&lt;/c6&gt; syntax is still allowed but really does something like &lt;c7&gt;LINE.next(())&lt;/c7&gt; underneath.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T102156Z" creationid="Toshiyuki" creationdate="20130806T102156Z">
        <seg>それゆえ、&lt;c6&gt;next LINE&lt;/c6&gt;という文法はまだ許可される。しかし本当は表面化に&lt;c7&gt;LINE.next(())&lt;/c7&gt;のようなことをしている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So they aren't really traits, exactly--they add themselves onto a list stored in the actual trait.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093613Z" creationid="Toshiyuki" creationdate="20130818T093613Z">
        <seg>それらは実際にはトレイトでないので、まさに―それらは実際のトレイトに格納されたリストに自身を加える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So we will say that it is erroneous for a library writer to mix dynamic gather with callbacks unless those callbacks are somehow "ungathered" to the outer dynamic scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T161444Z" creationid="Toshiyuki" creationdate="20130810T161444Z">
        <seg>そういうわけでダイナミックなgatherをコールバックと混ぜるのはライブラリ作者には誤りだと我々は言う。それらのコールバックが外側のダイナミックスコープにどういうわけか「ungathered」でない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, the call to &lt;c5&gt;JSON::Tiny::Grammar.parse($tester)&lt;/c5&gt; attempts to match the regex named &lt;c6&gt;TOP&lt;/c6&gt; to the string &lt;c7&gt;$tester&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T134845Z" creationid="Toshiyuki" creationdate="20140222T100149Z">
        <seg>それで、&lt;c5&gt;JSON::Tiny::Grammar.parse($tester)&lt;/c5&gt;の呼び出しは、文字列&lt;c7&gt;$tester&lt;/c7&gt;に&lt;c6&gt;TOP&lt;/c6&gt;という名の正規表現でマッチを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some algorithms have very tidy and natural expressions with this feature, especially those which recurse to a simple base case.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115835Z" creationid="Toshiyuki" creationdate="20140113T073256Z">
        <seg>いくつかのアルゴリズムには、この特徴（特に単純なベースケースに再帰するそれら）で非常にきちんとして自然な式があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some might ask, "Why call it Perl if it's a different language?" Perl is more than the vagaries of syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T002300Z" creationid="Toshiyuki" creationdate="20131025T230214Z">
        <seg>何人かは尋ねるかもしれません。「異なる言語であるならば、なぜそれをPerlと呼ぶのですか？」Perlは構文の気まぐれ以上のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some object types can behave as value types.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T121805Z" creationid="Toshiyuki" creationdate="20140328T121805Z">
        <seg>いくつかのオブジェクト型は値型として振る舞うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the statement prefixes also behave a little bit like phasers, but they run in-line with the executable code, so they are spelled in lowercase.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T081828Z" creationid="Toshiyuki" creationdate="20130818T081828Z">
        <seg>いくつかの文接頭辞も少しphasersのようにふるまう。しかしそれらは実行可能なコードとともにインラインを実行する。なのでそれらは小文字で綴る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of these operators also fall back to a purely dynamic interpretation if the lexotic interpretation doesn't work.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T012428Z" creationid="Toshiyuki" creationdate="20130728T012428Z">
        <seg>これらの演算子の幾つかは、レギゾチックな解釈が正常に動作しない場合に純粋な動的解釈に逆戻りすることもある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of these phasers also have corresponding traits that can be set on variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093015Z" creationid="Toshiyuki" creationdate="20130818T093015Z">
        <seg>phasersのいくつかは変数にセットできる対応するトレイトも持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some parameters may have sensible default values, or may not be required for the sub-routine to operate; they merely add some extra, optional, configurability.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T010757Z" creationid="Toshiyuki" creationdate="20131230T040728Z">
        <seg>いくつかのパラメータは適切なデフォルト値を持っているか、またはサブルーチンの動作に必要ないかもしれません；それらは任意の構成可能性をいくつか加えるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some roles--&lt;e0&gt;parametric roles&lt;/e0&gt;--allow the use of specific customizations to change how they provide the features they provide.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T012921Z" creationid="Toshiyuki" creationdate="20140115T101757Z">
        <seg>いくつかのロール ― &lt;e0&gt;パラメトリックロール&lt;/e0&gt; ― は、それらが提供する機構を変更するための特定のカスタマイズを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes a type name is insufficient to describe the requirements for an argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140106T133621Z" creationid="Toshiyuki" creationdate="20140106T133621Z">
        <seg>時々、型名は引数の必要条件を記述するには不十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes coercion is transparent.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140226T143345Z" creationid="Toshiyuki" creationdate="20140226T143345Z">
        <seg>時々、自動型変換は透過的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes it may be convenient to expose a parameter with one name while binding to a variable of a different name:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T012311Z" creationid="Toshiyuki" creationdate="20140104T120947Z">
        <seg>時々、変数を異なる名前にバインドしている時にパラメータを1つの名前で公開すると便利な場合があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes it's okay to have multiple methods of the same name, provided they have different signatures such that the multidispatch mechanism can distinguish between them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T123048Z" creationid="Toshiyuki" creationdate="20140115T140700Z">
        <seg>マルチディスパッチメカニズムがそれらを区別することができるように異なるシグネチャーがあるならば、時々、メソッドが同じ名前をつけるマルチプルを持ってもいいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes this modification is not what you want.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T161848Z" creationid="Toshiyuki" creationdate="20140115T143027Z">
        <seg>時々、この修正はあなたが望むものでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you just want to peek ahead to check if the next characters fulfill some properties without actually consuming them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T063113Z" creationid="Toshiyuki" creationdate="20140222T023950Z">
        <seg>時々、あなたはちょうど次の文字がそれらを実際に消費することなくいくつかのプロパティを満たすかどうか調べるために前に覗きたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you may wish to make a &lt;c1&gt;Capture&lt;/c1&gt;, store it and then later apply a subroutine--or multiple subroutines-- to the set of arguments it contains.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T173058Z" creationid="Toshiyuki" creationdate="20140110T143107Z">
        <seg>時々あなたは&lt;c1&gt;Capture&lt;/c1&gt;を作り、それを保存して後でサブルーチン ― または複数のサブルーチン ― にそれを含む引数を適用したいと思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you need to work with only part of an array or a hash.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T131533Z" creationid="Toshiyuki" creationdate="20140110T162854Z">
        <seg>時々、あなたは配列またはハッシュの1部分だけで作業する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you want to call other regexes, but don't want them to capture the matched text.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T061632Z" creationid="Toshiyuki" creationdate="20140222T023732Z">
        <seg>時々、他の正規表現を呼びたいが、それらがマッチテキストをキャプチャすることを望みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you want to fill positional arguments from an array.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T010311Z" creationid="Toshiyuki" creationdate="20131221T014911Z">
        <seg>たまに、配列をポジショナルな引数として使いたい時があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes, you may wish to allow a subroutine to receive any number of arguments, and collect them all together into an array.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T190038Z" creationid="Toshiyuki" creationdate="20140104T190038Z">
        <seg>時々、あなたはサブルーチンに多くの引数を受け取れるようにし、それらを全て配列に集めたいと思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special variables</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090220Z" creationid="Toshiyuki" creationdate="20140329T090220Z">
        <seg>特殊変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying a dispatch candidate</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T083236Z" creationid="Toshiyuki" creationdate="20140329T083236Z">
        <seg>ディスパッチ候補を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Square brackets around an infix operator cause Perl to apply the operator to a list element by element.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T061844Z" creationid="Toshiyuki" creationdate="20131027T061755Z">
        <seg>接中辞演算子のあたりの角括弧は、Perlが演算子をリストの要素と要素に適用するようにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with class</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T180001Z" creationid="Toshiyuki" creationdate="20140111T180001Z">
        <seg>クラスで始める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String Comparisons</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T124933Z" creationid="Toshiyuki" creationdate="20131028T124933Z">
        <seg>文字列の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020250Z" creationid="Toshiyuki" creationdate="20140322T020250Z">
        <seg>文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings stored as &lt;c0&gt;Str&lt;/c0&gt; are sequences of characters, independent of character encoding.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020357Z" creationid="Toshiyuki" creationdate="20140301T050037Z">
        <seg>&lt;c0&gt;Str&lt;/c0&gt;として格納される文字列は、エンコーディングから独立している文字のシーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings, the &lt;c0&gt;Str&lt;/c0&gt; Type</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T131040Z" creationid="Toshiyuki" creationdate="20140328T131040Z">
        <seg>文字列、&lt;c0&gt;Str&lt;/c0&gt;型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines and Signatures</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T130655Z" creationid="Toshiyuki" creationdate="20131029T130655Z">
        <seg>サブルーチンとシグネチャー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines and their signatures are objects like any other.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043605Z" creationid="Toshiyuki" creationdate="20140111T071556Z">
        <seg>サブルーチンとそれらのシグネチャーは何か他のオブジェクトのようです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines can also return values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T061702Z" creationid="Toshiyuki" creationdate="20140104T214456Z">
        <seg>サブルーチンは値を返すこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T030020Z" creationid="Toshiyuki" creationdate="20140329T030020Z">
        <seg>添字付け</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts are always evaluated in list context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T031657Z" creationid="Toshiyuki" creationdate="20140329T031657Z">
        <seg>添字付けは常にリストコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsequent matches are straightforward and reflect the structure in which JSON components can appear.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T142236Z" creationid="Toshiyuki" creationdate="20140222T132338Z">
        <seg>以降のマッチは素直で、JSONコンポーネントが表れることができる構造を反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Substitutions</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T023048Z" creationid="Toshiyuki" creationdate="20140222T023048Z">
        <seg>置換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a situation is entirely possible, especially at larger tournaments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T151107Z" creationid="Toshiyuki" creationdate="20131026T151107Z">
        <seg>特により大規模なトーナメントで、そのような状況は十分にあり得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such extensibility is difficult to achieve with ordinary, &lt;c2&gt;|&lt;/c2&gt; delimited alternatives.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T230420Z" creationid="Toshiyuki" creationdate="20140223T104651Z">
        <seg>そのような拡張性は、&lt;c2&gt;|&lt;/c2&gt;で区切られた選択肢で普通に達成するのは困難です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose also you want to extend it to handle contractions such as &lt;c0&gt;doesn't&lt;/c0&gt; or &lt;c1&gt;isn't&lt;/c1&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T035736Z" creationid="Toshiyuki" creationdate="20140222T014517Z">
        <seg>また、&lt;c0&gt;doesn't&lt;/c0&gt;や&lt;c1&gt;isn't&lt;/c1&gt;のような短縮形も扱いたいと考えています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose that you host a table tennis tournament.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T023959Z" creationid="Toshiyuki" creationdate="20131025T232325Z">
        <seg>あなたが卓球トーナメントを主催すると仮定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose you found the example at the beginning of this chapter useful and want to make it available easily.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T014345Z" creationid="Toshiyuki" creationdate="20140222T014345Z">
        <seg>章の初めの例をもっと簡単に使えるようにしたいと思ったとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose you want to enhance the JSON grammar to allow single-line C++ or JavaScript comments, which begin with &lt;c0&gt;//&lt;/c0&gt; and continue until the end of the line.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T224235Z" creationid="Toshiyuki" creationdate="20140223T102050Z">
        <seg>C++またはJavaScriptのシングルラインコメントをJSON文法で可能にしたいと仮定してください。それは&lt;c0&gt;//&lt;/c0&gt;で始まり、行の終わりまで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose you want to plot the number of sets that each player won in a tournament.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T124444Z" creationid="Toshiyuki" creationdate="20131027T044300Z">
        <seg>あなたが各々のプレイヤーがトーナメントで獲得したセット数をプロットしたいと思ったとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose you want to solve a crossword puzzle.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T024334Z" creationid="Toshiyuki" creationdate="20140117T181803Z">
        <seg>あなたがクロスワードパズルを解きたいと思ったとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Surrounding part of a regex with round brackets (aka parentheses) &lt;c1&gt;(...)&lt;/c1&gt; makes Perl &lt;e2&gt;capture&lt;/e2&gt; the string it matches.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T233444Z" creationid="Toshiyuki" creationdate="20140221T233444Z">
        <seg>丸括弧で囲まれた正規表現のパーツ&lt;c1&gt;(...)&lt;/c1&gt;はPerlがマッチした文字列を&lt;e2&gt;キャプチャー&lt;/e2&gt;するようにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124621Z" creationid="Toshiyuki" creationdate="20130811T124621Z">
        <seg>Switch文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Symbol</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124718Z" creationid="Toshiyuki" creationdate="20140322T124718Z">
        <seg>シンボル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: &lt;c0&gt;Pair&lt;/c0&gt; forms and their meanings</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T154731Z" creationid="Toshiyuki" creationdate="20140104T154731Z">
        <seg>表：&lt;c0&gt;Pair&lt;/c0&gt;の形式とそれらの意味</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Backslash sequences and their meaning</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124707Z" creationid="Toshiyuki" creationdate="20140322T124707Z">
        <seg>表：バックスラッシュシーケンスとそれらの意味</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Binary numeric operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015002Z" creationid="Toshiyuki" creationdate="20140322T015002Z">
        <seg>表：2項数値演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Binary string operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020648Z" creationid="Toshiyuki" creationdate="20140322T020648Z">
        <seg>表：2項文字列演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: C&lt;p0&gt; forms and their meanings</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T013425Z" creationid="Toshiyuki" creationdate="20140309T013425Z">
        <seg>表：Pairの形式とその意味</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Contents of Variables</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T115829Z" creationid="Toshiyuki" creationdate="20131026T115829Z">
        <seg>表：変数の内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Emulation of anchors with look-around assertions</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134012Z" creationid="Toshiyuki" creationdate="20140322T134012Z">
        <seg>表：周りを見るアサーションによるアンカーのエミュレーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Mathematical functions and methods</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015544Z" creationid="Toshiyuki" creationdate="20140322T015544Z">
        <seg>表：数学関数とメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Methods in the Parameter class</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T074144Z" creationid="Toshiyuki" creationdate="20140111T074144Z">
        <seg>表：パラメータクラスのメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Operators and Comparisons</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T125313Z" creationid="Toshiyuki" creationdate="20131028T125313Z">
        <seg>表：演算子と比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Pair forms and their meanings</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T172537Z" creationid="Toshiyuki" creationdate="20140309T172537Z">
        <seg>表：Pairの形式とその意味</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Precedence table</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121636Z" creationid="Toshiyuki" creationdate="20131027T121636Z">
        <seg>表：優先順位表</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Regex anchors</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T125754Z" creationid="Toshiyuki" creationdate="20140322T125754Z">
        <seg>表：正規表現アンカー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: String methods/functions</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020819Z" creationid="Toshiyuki" creationdate="20140322T020819Z">
        <seg>表：文字列のメソッド、関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Unary numeric operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015420Z" creationid="Toshiyuki" creationdate="20140322T015420Z">
        <seg>表：単項数値演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table: Unary string operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020736Z" creationid="Toshiyuki" creationdate="20140322T020736Z">
        <seg>表：単項文字列演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That has its flaws too, but it's more concrete.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113708Z" creationid="Toshiyuki" creationdate="20140113T044040Z">
        <seg>それは欠陥も持っています。しかしそれはより具体的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is,</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060536Z" creationid="Toshiyuki" creationdate="20130810T060536Z">
        <seg>すなわち、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, if you follow dependencies, you can eventually return to the original &lt;c4&gt;Task&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T172536Z" creationid="Toshiyuki" creationdate="20140112T172536Z">
        <seg>つまり、従属物に続くならば、結局、あなたは最初の&lt;c4&gt;Task&lt;/c4&gt;に戻ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, precedence decisions do not cross a &lt;c2&gt;do&lt;/c2&gt; boundary, and the missing "right paren" is assumed at the next statement terminator or unmatched bracket.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T124306Z" creationid="Toshiyuki" creationdate="20130810T124306Z">
        <seg>すなわち、優先順位の決定は&lt;c2&gt;do&lt;/c2&gt;の境界を横切らず、欠けた「右括弧」は次の文の終止符か対応のとれていないブラケットと仮定される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the construct:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113956Z" creationid="Toshiyuki" creationdate="20130810T113956Z">
        <seg>すなわち、構成物：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the stack is not unwound until some exception handler chooses to unwind it by "handling" the exception in question.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115741Z" creationid="Toshiyuki" creationdate="20130814T115741Z">
        <seg>すなわち、そのスタックはいくつかの例外ハンドラが問題の例外を「ハンドリング」することによってそれを巻き戻すために選ばれるまで巻き戻されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, these two statements are equivalent:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T031141Z" creationid="Toshiyuki" creationdate="20130803T031141Z">
        <seg>つまり、これら二つの文は同等だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That should now be written:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112113Z" creationid="Toshiyuki" creationdate="20130810T111931Z">
        <seg>それは今は書き直されるべきだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That simple sort doesn't account for the number of sets won, which is the secondary criterion to decide who has won the tournament.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T145243Z" creationid="Toshiyuki" creationdate="20131026T145243Z">
        <seg>その単純なソートは勝ったセット数を考えません。そしてそれは誰がトーナメントに勝ったかについて決める第2の基準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That way it is easy to add separate code for each action that the script can perform.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121434Z" creationid="Toshiyuki" creationdate="20140113T080123Z">
        <seg>スクリプトが実行することができるアクションごとに別々のコードを加えることは簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's an abstract definition best explained by an example.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121817Z" creationid="Toshiyuki" creationdate="20140113T080308Z">
        <seg>それは例によって説明される抽象定義です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's okay too: declaring that a class performs a role does not require you to compose in any behavior from the role.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T022826Z" creationid="Toshiyuki" creationdate="20140115T140534Z">
        <seg>それも大丈夫です：ロールを実行するそのクラスを宣言することは、ロールからのどんな振る舞いも合成を要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's okay.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T075730Z" creationid="Toshiyuki" creationdate="20130811T075730Z">
        <seg>それはオーケーだ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That's why it's so happy!</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T132329Z" creationid="Toshiyuki" creationdate="20140110T132329Z">
        <seg>そういうわけで、それはとても幸せです！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "first-class roles" mention needs to move out of a parenthetical note.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T123716Z" creationid="Toshiyuki" creationdate="20140115T142335Z">
        <seg>“ファーストクラスロール”は、挿入句的なノートから動く必要に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "point of declaration" is the moment the compiler sees "&lt;c0&gt;my $foo&lt;/c0&gt;", not the end of the statement as in Perl 5, so</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125416Z" creationid="Toshiyuki" creationdate="20130730T125416Z">
        <seg>「宣言のポイント」はコンパイラが「&lt;c0&gt;my $foo&lt;/c0&gt;」を見る時点であり、Perl 5における文の終わりではない。つまり</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "subclass" language is slightly wrong, but I don't know if we want to get into allomorphism here.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045425Z" creationid="Toshiyuki" creationdate="20140111T182841Z">
        <seg>“サブクラス”言語はわずかに間違っています。しかし、私は我々がここで同質異形を欲しいかどうか、わかりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;$&lt;/c0&gt; sigil indicates a &lt;e1&gt;scalar&lt;/e1&gt; variable, which indicates that the variable stores a single value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154138Z" creationid="Toshiyuki" creationdate="20131026T034702Z">
        <seg>&lt;c0&gt;$&lt;/c0&gt;シギルは&lt;e1&gt;スカラー&lt;/e1&gt;変数を表し、それは変数が一つの値を保存していることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;$Package'var&lt;/c0&gt; syntax is gone.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000110Z" creationid="Toshiyuki" creationdate="20140329T000110Z">
        <seg>&lt;c0&gt;$Package'var&lt;/c0&gt;構文はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;%&lt;/c0&gt; sigil marks each variable as a &lt;c1&gt;Hash&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154921Z" creationid="Toshiyuki" creationdate="20131026T093632Z">
        <seg>&lt;c0&gt;%&lt;/c0&gt;シギルはそれぞれの変数が&lt;c1&gt;Hash&lt;/c1&gt;であることを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;%pluggables&lt;/c0&gt; hash maps names of plug-ins to Role objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T123854Z" creationid="Toshiyuki" creationdate="20140115T142428Z">
        <seg>ハッシュ&lt;c0&gt;%pluggables&lt;/c0&gt;はロールオブジェクトにプラグインの名前をマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&amp;&lt;/c0&gt; sigil followed by a subroutine name gets the object representing that subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T072927Z" creationid="Toshiyuki" creationdate="20140111T072927Z">
        <seg>サブルーチン名の前の&lt;c0&gt;&amp;&lt;/c0&gt;シギルはサブルーチンのオブジェクトを表しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&amp;&lt;/c0&gt; sigil indicates that this attribute represents something invocable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182550Z" creationid="Toshiyuki" creationdate="20140111T182550Z">
        <seg>&lt;c0&gt;&amp;&lt;/c0&gt;シギルは属性が何かを起動可能であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;-&lt;/c0&gt; operator can also mean subtraction, so &lt;c1&gt;say 5 - 4&lt;/c1&gt; will print a &lt;c2&gt;1&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T054611Z" creationid="Toshiyuki" creationdate="20131027T054611Z">
        <seg>&lt;c0&gt;-&lt;/c0&gt;演算子は減算も意味します。なので&lt;c1&gt;say 5 - 4&lt;/c1&gt;は&lt;c2&gt;1&lt;/c2&gt;を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.*&lt;/c0&gt; method calling syntax changes the semantics of the dispatch.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T032341Z" creationid="Toshiyuki" creationdate="20140115T141141Z">
        <seg>&lt;c0&gt;.*&lt;/c0&gt;メソッド呼び出し構文は、ディスパッチの意味を変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.WHAT&lt;/c0&gt; method returns the type object associated with the object &lt;c1&gt;$o&lt;/c1&gt;, which tells the exact type of &lt;c2&gt;$o&lt;/c2&gt;: in this case &lt;c3&gt;Programmer&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T140110Z" creationid="Toshiyuki" creationdate="20140112T140110Z">
        <seg>&lt;c0&gt;.WHAT&lt;/c0&gt;メソッドはオブジェクト&lt;c1&gt;$o&lt;/c1&gt;と結びつけられる型オブジェクトを返します。そして、それは&lt;c2&gt;$o&lt;/c2&gt;の正確な型を教えます：この場合は&lt;c3&gt;Programmer&lt;/c3&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.WHICH&lt;/c0&gt; Method for Value Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T121731Z" creationid="Toshiyuki" creationdate="20140328T121731Z">
        <seg>値型のための&lt;c0&gt;.WHICH&lt;/c0&gt;メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.fmt&lt;/c0&gt; method</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T025540Z" creationid="Toshiyuki" creationdate="20140329T025540Z">
        <seg>&lt;c0&gt;.fmt&lt;/c0&gt;メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.handled&lt;/c0&gt; method is &lt;c1&gt;rw&lt;/c1&gt;, so you may mark an exception as handled by assigning &lt;c2&gt;True&lt;/c2&gt; to it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T162419Z" creationid="Toshiyuki" creationdate="20130817T162419Z">
        <seg>&lt;c0&gt;.handled&lt;/c0&gt;メソッドは&lt;c1&gt;rw&lt;/c1&gt;なので、&lt;c2&gt;True&lt;/c2&gt;を割り当てることで例外がハンドルされたとマークすることもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.parse&lt;/c0&gt; method of a grammar returns a &lt;c1&gt;Match&lt;/c1&gt; object through which you can access all the relevant information of the match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T230811Z" creationid="Toshiyuki" creationdate="20140223T105046Z">
        <seg>グラマーの&lt;c0&gt;.parse&lt;/c0&gt;メソッドは、あなたがマッチのすべての関係情報にアクセスすることができる&lt;c1&gt;Match&lt;/c1&gt;オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.sort&lt;/c0&gt; method in lists can take a block or function that takes two values, compares them, and returns a value less than, equal to or, greater than 0.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T124241Z" creationid="Toshiyuki" creationdate="20131029T124241Z">
        <seg>リストの中の&lt;c0&gt;.sort&lt;/c0&gt;メソッドは2つの値をとるブロックか関数（それらを比較し、 より低いか、等しいか、より大きいか返す）を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;:ignorecase&lt;/c0&gt; or &lt;c1&gt;:i&lt;/c1&gt; modifier makes the regex insensitive to upper and lower case, so &lt;c2&gt;m/ :i perl /&lt;/c2&gt; matches &lt;c3&gt;perl&lt;/c3&gt;, &lt;c4&gt;PerL&lt;/c4&gt;, and &lt;c5&gt;PERL&lt;/c5&gt; (though who names a programming language in all uppercase letters?)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T042315Z" creationid="Toshiyuki" creationdate="20140222T021350Z">
        <seg>&lt;c0&gt;:ignorecase&lt;/c0&gt;または&lt;c1&gt;:i&lt;/c1&gt;修飾子は正規表現を大文字・小文字に無関心にするので、&lt;c2&gt;m/ :i perl /&lt;/c2&gt;は&lt;c3&gt;perl&lt;/c3&gt;、&lt;c4&gt;PerL&lt;/c4&gt;と&lt;c5&gt;PERL&lt;/c5&gt;（しかし、誰がすべて大文字でプログラミング言語に名前をつけますか？）にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;:ratchet&lt;/c0&gt; modifier disables backtracking for a whole regex, which is often desirable in a small regex called often from other regexes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131032Z" creationid="Toshiyuki" creationdate="20140222T022525Z">
        <seg>&lt;c0&gt;:ratchet&lt;/c0&gt;修飾子は全部の正規表現のためにバックトラックを無効にします。そして、それは他の正規表現から呼ばれる小さな正規表現でしばしば望ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;=&lt;/c0&gt; operator is the &lt;e1&gt;assignment operator&lt;/e1&gt;--it takes the values from the right-hand side, and stores them in the variable on the left-hand side, here &lt;c2&gt;@scores&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T083954Z" creationid="Toshiyuki" creationdate="20131027T045033Z">
        <seg>&lt;c0&gt;=&lt;/c0&gt;演算子は&lt;e1&gt;割り当て演算子です&lt;/e1&gt; ― それは右側から値を受け取り、左側にある変数に格納します。ここでは&lt;c2&gt;@scores&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;=&gt;&lt;/c0&gt; operator (the &lt;e1&gt;fat arrow&lt;/e1&gt;) constructs &lt;c2&gt;Pair&lt;/c2&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T045707Z" creationid="Toshiyuki" creationdate="20131027T045707Z">
        <seg>&lt;c0&gt;=&gt;&lt;/c0&gt;演算子（&lt;e1&gt;太い矢&lt;/e1&gt;）は&lt;c2&gt;Pair&lt;/c2&gt;オブジェクトを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Cool&lt;/c0&gt; module also contains all multisubs of last resort; these are automatically searched if normal multiple dispatch does not find a viable candidate.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T233824Z" creationid="Toshiyuki" creationdate="20140328T233824Z">
        <seg>&lt;c0&gt;Cool&lt;/c0&gt;モジュールは最後の手段の全てのマルチサブを含みます；通常のマルチディスパッチが可能な候補を見つけなければ、それらは自動的に検索されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Cool&lt;/c0&gt; type is derived from &lt;c1&gt;Any&lt;/c1&gt;, and contains all the methods that are "cool" (as in, "I'm cool with an argument of that type.").</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T232612Z" creationid="Toshiyuki" creationdate="20140328T232612Z">
        <seg>&lt;c0&gt;Cool&lt;/c0&gt;型は&lt;c1&gt;Any&lt;/c1&gt;から派生し、“cool”（“私はその型の引数にクールです”）なメソッドを全て含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Int&lt;/c0&gt; type object both conforms to &lt;c1&gt;Int&lt;/c1&gt;, but it is also an undefined value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T002215Z" creationid="Toshiyuki" creationdate="20140113T044958Z">
        <seg>&lt;c0&gt;Int&lt;/c0&gt;型オブジェクトは&lt;c1&gt;Int&lt;/c1&gt;に両方とも従います、しかし、それは未定義値でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;MAIN&lt;/c0&gt; Subroutine</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T081521Z" creationid="Toshiyuki" creationdate="20140111T081521Z">
        <seg>&lt;c0&gt;MAIN&lt;/c0&gt;サブルーチン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Plugins&lt;/c0&gt; role is at the heart of this.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T123506Z" creationid="Toshiyuki" creationdate="20140115T142149Z">
        <seg>&lt;c0&gt;Plugins&lt;/c0&gt;ロールはこれの中心にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Str&lt;/c0&gt; candidate does more work: it wraps its parameter in quotes and escapes literal characters that the JSON spec does not allow in strings--a tab character becomes &lt;c1&gt;"\t"&lt;/c1&gt;, a newline &lt;c2&gt;"\n"&lt;/c2&gt;, and so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T222245Z" creationid="Toshiyuki" creationdate="20140314T222245Z">
        <seg>&lt;c0&gt;Str&lt;/c0&gt;候補はもっと多くの仕事をします；それはパラメータをクオートし、JSONの仕様で許可されないリテラル文字をエスケープします ― タブ文字は&lt;c1&gt;"\t"&lt;/c1&gt;、改行は&lt;c2&gt;"\n"&lt;/c2&gt;などです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;StrPos&lt;/c0&gt; Type</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T133413Z" creationid="Toshiyuki" creationdate="20140328T133413Z">
        <seg>&lt;c0&gt;StrPos&lt;/c0&gt;型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;TOP&lt;/c0&gt; rule has an alternation with two branches, &lt;c1&gt;object&lt;/c1&gt; and &lt;c2&gt;array&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T002203Z" creationid="Toshiyuki" creationdate="20140224T162921Z">
        <seg>&lt;c0&gt;TOP&lt;/c0&gt;ルールは&lt;c1&gt;object&lt;/c1&gt;と&lt;c2&gt;array&lt;/c2&gt;という2つの分岐を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;[]&lt;/c0&gt; declares an empty nested signature for the first positional parameter.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T120059Z" creationid="Toshiyuki" creationdate="20140113T073409Z">
        <seg>&lt;c0&gt;[]&lt;/c0&gt;は、最初のポジションのパラメータのために空の入れ子になったシグネチャーを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;also&lt;/c0&gt; declarator is primarily intended for roles but can also be useful when creating anonymous classes or roles:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T031753Z" creationid="Toshiyuki" creationdate="20140115T141018Z">
        <seg>&lt;c0&gt;also&lt;/c0&gt;宣言子は主にロールを目的としますが、匿名のクラスまたはロールを作る場合にも有用です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;anon&lt;/c0&gt; declarator allows a declaration to provide a name that can be used in error messages, but that isn't put into any external symbol table:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021656Z" creationid="Toshiyuki" creationdate="20140329T021656Z">
        <seg>&lt;c0&gt;anon&lt;/c0&gt;宣言はエラーメッセージに使用できる名前を提供するための宣言を可能にしますが、それはどの外部のシンボルテーブルにも置かれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;but&lt;/c0&gt; operator</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T161511Z" creationid="Toshiyuki" creationdate="20140115T142924Z">
        <seg>&lt;c0&gt;but&lt;/c0&gt;演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;callsame&lt;/c0&gt; primitive calls the next candidate, passing along the arguments received.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121537Z" creationid="Toshiyuki" creationdate="20140113T075750Z">
        <seg>最初の&lt;c0&gt;callsame&lt;/c0&gt;は次の候補を呼びます。そして引数に沿ったパスが受け取られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;caps&lt;/c0&gt; method returns all captures, named and positional, in the order in which their matched text appears in the source string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T092213Z" creationid="Toshiyuki" creationdate="20140222T025304Z">
        <seg>&lt;c0&gt;caps&lt;/c0&gt;メソッドはすべてのキャプチャー（名前付きの、位置依存の）をそれらのマッチしたテキストがソース文字列で出現する順序で返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;eqv&lt;/c0&gt; operator returns &lt;c1&gt;True&lt;/c1&gt; only if two objects are of the same type &lt;e2&gt;and&lt;/e2&gt; the same structure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T123515Z" creationid="Toshiyuki" creationdate="20131028T123515Z">
        <seg>&lt;c0&gt;eqv&lt;/c0&gt;演算子はオブジェクトが同じ型で同じ構造の場合だけ&lt;c1&gt;True&lt;/c1&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;fail&lt;/c0&gt; function responds to the caller's &lt;c1&gt;use fatal&lt;/c1&gt; state.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T170326Z" creationid="Toshiyuki" creationdate="20130817T170326Z">
        <seg>&lt;c0&gt;fail&lt;/c0&gt;関数は呼び出し元の&lt;c1&gt;use fatal&lt;/c1&gt;状態に応答する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;for&lt;/c0&gt; statement</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060619Z" creationid="Toshiyuki" creationdate="20130810T060619Z">
        <seg>&lt;c0&gt;for&lt;/c0&gt;文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;gather&lt;/c0&gt; statement prefix</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152216Z" creationid="Toshiyuki" creationdate="20130810T152216Z">
        <seg>&lt;c0&gt;gather&lt;/c0&gt;文プレフィックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;if&lt;/c0&gt; and &lt;c1&gt;unless&lt;/c1&gt; statements work much as they do in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T042914Z" creationid="Toshiyuki" creationdate="20130803T042914Z">
        <seg>&lt;c0&gt;if&lt;/c0&gt;文と&lt;c1&gt;unless&lt;/c1&gt;文はPerl 5のように動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;index&lt;/c0&gt; method searches a string for another substring and returns the position of the search string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T091553Z" creationid="Toshiyuki" creationdate="20140222T025028Z">
        <seg>&lt;c0&gt;index&lt;/c0&gt;メソッドは文字列を別の部分文字列で検索して、検索文字列の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;is rw&lt;/c0&gt; trait causes the generated accessor method to return something external code can modify to change the value of the attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184845Z" creationid="Toshiyuki" creationdate="20140111T184845Z">
        <seg>&lt;c0&gt;is rw&lt;/c0&gt;トレイトは発生するアクセッサ・メソッドにコードが属性の値を変えるために修正することができる外部の何かを返させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;lift&lt;/c0&gt; statement prefix</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T041504Z" creationid="Toshiyuki" creationdate="20130811T041504Z">
        <seg>&lt;c0&gt;lift&lt;/c0&gt;文接頭辞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;loop&lt;/c0&gt; statement is the C-style &lt;c1&gt;for&lt;/c1&gt; loop in disguise:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T055854Z" creationid="Toshiyuki" creationdate="20130810T055854Z">
        <seg>&lt;c0&gt;loop&lt;/c0&gt;文はC言語スタイルの&lt;c1&gt;for&lt;/c1&gt;ループを装う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;make&lt;/c0&gt; explanation is fuzzy.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T001522Z" creationid="Toshiyuki" creationdate="20140224T162814Z">
        <seg>&lt;c0&gt;make&lt;/c0&gt;の説明はあいまいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;of&lt;/c0&gt; type specifies what kinds of values may be stored in the variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T213053Z" creationid="Toshiyuki" creationdate="20140328T213053Z">
        <seg>&lt;c0&gt;of&lt;/c0&gt;型はどのような種類の値が変数に保存されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;orig&lt;/c0&gt; method returns the string that was matched against.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T085750Z" creationid="Toshiyuki" creationdate="20140222T024749Z">
        <seg>&lt;c0&gt;orig&lt;/c0&gt;メソッドはマッチした文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;pairlist&lt;/c0&gt; rule matches multiple comma-separated pairs.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T011920Z" creationid="Toshiyuki" creationdate="20140225T144354Z">
        <seg>&lt;c0&gt;pairlist&lt;/c0&gt;ルールはコンマで区切られた複数のペアにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;perform&lt;/c0&gt; method will never terminate because the first thing the method does is to call all the &lt;c1&gt;perform&lt;/c1&gt; methods of its dependencies.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110652Z" creationid="Toshiyuki" creationdate="20140112T173706Z">
        <seg>メソッドがする最初のものがすべての従属物の&lt;c0&gt;perform&lt;/c0&gt;メソッドを呼ぶことであるので、&lt;c1&gt;perform&lt;/c1&gt;メソッドは決して終わらないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;process&lt;/c0&gt; methods of the roles &lt;c1&gt;AnswerToAll&lt;/c1&gt; and &lt;c2&gt;AnswerIfTalkedTo&lt;/c2&gt; use a modified syntax for calling methods:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T032243Z" creationid="Toshiyuki" creationdate="20140115T141116Z">
        <seg>ロール&lt;c1&gt;AnswerToAll&lt;/c1&gt;と&lt;c2&gt;AnswerIfTalkedTo&lt;/c2&gt;の&lt;c0&gt;process&lt;/c0&gt;メソッドは、メソッドを呼ぶために変更された構文を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;proto token&lt;/c0&gt; syntax indicates that &lt;c1&gt;value&lt;/c1&gt; will be a set of alternatives instead of a single regex.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T150222Z" creationid="Toshiyuki" creationdate="20140223T074750Z">
        <seg>&lt;c0&gt;proto token&lt;/c0&gt;構文は、&lt;c1&gt;value&lt;/c1&gt;が一つの正規表現の代わりに選択肢のセットであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;regex { :ratchet ... }&lt;/c0&gt; pattern is so common that it has its own shortcut: &lt;c1&gt;token { ... }&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131213Z" creationid="Toshiyuki" creationdate="20140222T022910Z">
        <seg>&lt;c0&gt;regex { :ratchet ... }&lt;/c0&gt;パターンは一般的なので、それ自身のショートカットを持っています：&lt;c1&gt;token { ... }&lt;/c1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;repeat&lt;/c0&gt; statement</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T150051Z" creationid="Toshiyuki" creationdate="20130809T150051Z">
        <seg>&lt;c0&gt;repeat&lt;/c0&gt;文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;returns&lt;/c0&gt; declarations is an alias for the &lt;c1&gt;of&lt;/c1&gt; type of a subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T223849Z" creationid="Toshiyuki" creationdate="20140328T223849Z">
        <seg>&lt;c0&gt;returns&lt;/c0&gt;宣言はサブルーチンの&lt;c1&gt;of&lt;/c1&gt;型の別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;sink&lt;/c0&gt; statement prefix will eagerly evaluate any block or statement, throw away the results, and instead return the empty &lt;c1&gt;Parcel&lt;/c1&gt; value, &lt;c2&gt;()&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T080120Z" creationid="Toshiyuki" creationdate="20140329T080120Z">
        <seg>&lt;c0&gt;sink&lt;/c0&gt;ステートメントプレフィックスは何らかのブロックまたはステートメントを評価して結果を捨て、その代わりに空の&lt;c1&gt;Parcel&lt;/c1&gt;値、&lt;c2&gt;()&lt;/c2&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;subst&lt;/c0&gt; method matches a regex against a string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T053258Z" creationid="Toshiyuki" creationdate="20140222T023131Z">
        <seg>&lt;c0&gt;subst&lt;/c0&gt;メソッドは、文字列に対して正規表現をマッチさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;take&lt;/c0&gt; function essentially has two contexts simultaneously, the context in which the &lt;c1&gt;gather&lt;/c1&gt; is operating, and the context in which the &lt;c2&gt;take&lt;/c2&gt; is operating.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T035625Z" creationid="Toshiyuki" creationdate="20130811T035625Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;関数は本質的に同時に二つのコンテキストを持つ。&lt;c1&gt;gather&lt;/c1&gt;が動作中のコンテキスト、&lt;c2&gt;take&lt;/c2&gt;が動作中のコンテキスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;take&lt;/c0&gt; function is lexotic if there is a visible outer &lt;c1&gt;gather&lt;/c1&gt;, but falls back to purely dynamic if not.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T154155Z" creationid="Toshiyuki" creationdate="20130810T154155Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;関数は、可視の外側の&lt;c1&gt;gather&lt;/c1&gt;があるならレギゾチックだ。 しかしそうでないなら純粋なダイナミックに戻る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;take&lt;/c0&gt; operation may be defined internally using resumable control exceptions, or dynamic variables, or pigeons carrying clay tablets.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T041108Z" creationid="Toshiyuki" creationdate="20130811T041108Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;の動作は再動作可能な制御例外、または動的変数、または粘土板を運ぶハトを使って内部的に定義されているだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;to-json(Array $d)&lt;/c0&gt; candidate converts all elements of the array to JSON with recursive calls to &lt;c1&gt;to-json&lt;/c1&gt;, joins them with commas, and surrounds them with square brackets.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T222442Z" creationid="Toshiyuki" creationdate="20140314T222442Z">
        <seg>&lt;c0&gt;to-json(Array $d)&lt;/c0&gt;候補は配列のすべての要素を&lt;c1&gt;to-json&lt;/c1&gt;の再帰呼び出しによって変換します。それらをコンマでつなぎ、スクエアブラケットで囲みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;unless&lt;/c0&gt; statement does not allow an &lt;c1&gt;elsif&lt;/c1&gt; or &lt;c2&gt;else&lt;/c2&gt; in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T045700Z" creationid="Toshiyuki" creationdate="20130804T045700Z">
        <seg>Perl 6では&lt;c0&gt;unless&lt;/c0&gt;文は&lt;c1&gt;elsif&lt;/c1&gt;または&lt;c2&gt;else&lt;/c2&gt;を許可しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;while&lt;/c0&gt; and &lt;c1&gt;until&lt;/c1&gt; statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T142714Z" creationid="Toshiyuki" creationdate="20130809T142714Z">
        <seg>&lt;c0&gt;while&lt;/c0&gt;と&lt;c1&gt;until&lt;/c1&gt;文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;while&lt;/c0&gt; and &lt;c1&gt;until&lt;/c1&gt; statements work as in Perl 5, except that you may leave out the parentheses around the conditional:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T143804Z" creationid="Toshiyuki" creationdate="20130809T143804Z">
        <seg>&lt;c0&gt;while&lt;/c0&gt;と&lt;c1&gt;until&lt;/c1&gt;文はPerl 5のように動作する。条件文の周囲の括弧を省略するかもしれない場合を除いて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c10&gt;en&lt;/c10&gt; literal can now match the last two characters of the string, and the overall match succeeds.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130904Z" creationid="Toshiyuki" creationdate="20140222T022012Z">
        <seg>リテラルの&lt;c10&gt;en&lt;/c10&gt;は現在文字列の最後の2つの文字にマッチすることができます。そして全体のマッチは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;!&lt;/c1&gt; character is a &lt;e2&gt;twigil&lt;/e2&gt;, or secondary sigil.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182628Z" creationid="Toshiyuki" creationdate="20140111T182628Z">
        <seg>&lt;c1&gt;!&lt;/c1&gt;文字は&lt;e2&gt;twigil&lt;/e2&gt;、または第2のシギルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;:g&lt;/c1&gt; modifier tells the substitution to work &lt;e2&gt;globally&lt;/e2&gt; to replace every possible match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T053922Z" creationid="Toshiyuki" creationdate="20140222T023259Z">
        <seg>&lt;c1&gt;:g&lt;/c1&gt;修飾子は、すべての可能なマッチを置き換えるためにグローバルに動作するよう置換に命じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;@&lt;/c1&gt; sigil marks the declared variable as an &lt;c2&gt;Array&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T002918Z" creationid="Toshiyuki" creationdate="20131026T083153Z">
        <seg>&lt;c1&gt;@&lt;/c1&gt;シギルは宣言された変数が&lt;c2&gt;Array&lt;/c2&gt;（配列）であることを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;Bool&lt;/c1&gt; candidate returns a literal string &lt;c2&gt;'true'&lt;/c2&gt; or &lt;c3&gt;'false'&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T222011Z" creationid="Toshiyuki" creationdate="20140314T222011Z">
        <seg>&lt;c1&gt;Bool&lt;/c1&gt;候補はリテラル文字列&lt;c2&gt;'true'&lt;/c2&gt;または&lt;c3&gt;'false'&lt;/c3&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;Buf&lt;/c1&gt; type is available for storing binary data.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020413Z" creationid="Toshiyuki" creationdate="20140301T050047Z">
        <seg>&lt;c1&gt;Buf&lt;/c1&gt;型は、バイナリデータの格納に利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;callwith&lt;/c1&gt; primitive calls the next candidate with different (and provided) arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121124Z" creationid="Toshiyuki" creationdate="20140113T075805Z">
        <seg>最初の&lt;c1&gt;callwith&lt;/c1&gt;は異なる（そして、提供される）引数で、次の候補を呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;from&lt;/c1&gt; and &lt;c2&gt;to&lt;/c2&gt; methods return the positions of the start and end points of the match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T085837Z" creationid="Toshiyuki" creationdate="20140222T024818Z">
        <seg>&lt;c1&gt;from&lt;/c1&gt;と&lt;c2&gt;to&lt;/c2&gt;メソッドは、マッチの始まりと終点の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;given&lt;/c1&gt; block is just one way to set the current topic, but a switch statement can be any block that sets &lt;c2&gt;$_&lt;/c2&gt;, including a &lt;c3&gt;for&lt;/c3&gt; loop (assuming one of its loop variables is bound to &lt;c4&gt;$_&lt;/c4&gt;) or the body of a method (if you have declared the invocant as &lt;c5&gt;$_&lt;/c5&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125816Z" creationid="Toshiyuki" creationdate="20130811T125816Z">
        <seg>&lt;c1&gt;given&lt;/c1&gt;ブロックは現在のトピックをセットする一つの方法だ。しかしswitch文は&lt;c2&gt;$_&lt;/c2&gt;をセットするどんなブロックにもなれる。&lt;c3&gt;for&lt;/c3&gt;ループ（ループ変数の一つが&lt;c4&gt;$_&lt;/c4&gt;にバインドされていると仮定する）またはメソッドの本体（もしインボカントを&lt;c5&gt;$_&lt;/c5&gt;として宣言しているなら）を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;rindex&lt;/c1&gt; method does the same, but searches backwards from the end of the string, so it finds the position of the final occurrence of the substring.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T091622Z" creationid="Toshiyuki" creationdate="20140222T025047Z">
        <seg>&lt;c1&gt;rindex&lt;/c1&gt;メソッドは同じようにしますが、文字列の終わりから後方に検索するので、それは部分文字列の最終的な発生位置を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;!&lt;/c2&gt; prefix negates the boolean value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021807Z" creationid="Toshiyuki" creationdate="20140322T021807Z">
        <seg>&lt;c2&gt;!&lt;/c2&gt;接頭辞はブール値を反転します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;$&lt;/c2&gt; sigil, however, indicates a general container that can hold anything and be accessed in any manner.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T003516Z" creationid="Toshiyuki" creationdate="20131026T095608Z">
        <seg>&lt;c2&gt;$&lt;/c2&gt;シギルは何でも保持することができて、どんな方法でもアクセスができる全般的なコンテナーを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;:local&lt;/c2&gt; named argument limits the returned methods to those defined in the &lt;c3&gt;Employee&lt;/c3&gt; class, and excludes the inherited methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T155918Z" creationid="Toshiyuki" creationdate="20140112T155918Z">
        <seg>&lt;c2&gt;:local&lt;/c2&gt;という名前付き引数は&lt;c3&gt;Employee&lt;/c3&gt;クラスに定義されているメソッドに限定し、継承したメソッドを除いて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;name=&amp;regex&gt;&lt;/c2&gt; syntax creates a capture named &lt;c3&gt;name&lt;/c3&gt;, which records what &lt;c4&gt;&amp;regex&lt;/c4&gt; matched in the match object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130520Z" creationid="Toshiyuki" creationdate="20140222T015124Z">
        <seg>&lt;c2&gt;&lt;name=&amp;regex&gt;&lt;/c2&gt;構文はキャプチャー名をつけられた&lt;c3&gt;name&lt;/c3&gt;を作ります。そして、それは&lt;c4&gt;&amp;regex&lt;/c4&gt;が何をマッチしたのかをマッチオブジェクトにを記録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;Grammar&lt;/c2&gt; base grammar contains broadly useful rules predefined.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T223755Z" creationid="Toshiyuki" creationdate="20140223T101703Z">
        <seg>&lt;c2&gt;Grammar&lt;/c2&gt;ベース文法は、あらかじめ定義された広く役立つルールを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;bless&lt;/c2&gt; method expects a positional parameter--the so-called "candidate"--and a set of named parameters providing the initial values for each attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141338Z" creationid="Toshiyuki" creationdate="20140112T035409Z">
        <seg>&lt;c2&gt;bless&lt;/c2&gt;メソッドは位置依存パラメータを期待します ― いわゆる「候補」 ― そしてそれぞれの属性のための初期値を提供する名前付きパラメータのセット。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;encode&lt;/c2&gt; method converts a &lt;c3&gt;Str&lt;/c3&gt; to &lt;c4&gt;Buf&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020432Z" creationid="Toshiyuki" creationdate="20140301T050106Z">
        <seg>&lt;c2&gt;encode&lt;/c2&gt;メソッドは、&lt;c3&gt;Str&lt;/c3&gt;を&lt;c4&gt;Buf&lt;/c4&gt;に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;sort&lt;/c2&gt; method's argument is a &lt;e3&gt;block&lt;/e3&gt; used to transform the array elements (the names of players) to the data by which to sort.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T143805Z" creationid="Toshiyuki" creationdate="20131026T143805Z">
        <seg>&lt;c2&gt;sort&lt;/c2&gt;メソッドの引数は配列要素（プレイヤーの名前）をソートするデータに変えるのに使われる&lt;e3&gt;ブロック&lt;/e3&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c3&gt;Nil&lt;/c3&gt; value represents the absence of a value where there &lt;i4&gt;should&lt;/i4&gt; be one, so it does not disappear in list context, but relies on something downstream to catch it or blow up.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140331T113203Z" creationid="Toshiyuki" creationdate="20140331T113203Z">
        <seg>&lt;c3&gt;Nil&lt;/c3&gt;値は&lt;i4&gt;あるべきである&lt;/i4&gt;値の欠如を表すので、リストコンテキストで消えません。しかしそれを捕らえるかブローアップする下流の何かに頼ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c3&gt;\w&lt;/c3&gt; control sequence stands for a "Word" character--a letter, digit, or an underscore.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T024704Z" creationid="Toshiyuki" creationdate="20140117T182244Z">
        <seg>&lt;c3&gt;\w&lt;/c3&gt;制御シーケンスは、ワード文字 ― 文字、数字またはアンダーライン ― を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c3&gt;does&lt;/c3&gt; operator adds this role to &lt;c4&gt;$self&lt;/c4&gt;--not the &lt;e5&gt;class&lt;/e5&gt; of &lt;c6&gt;$self&lt;/c6&gt;, but the instance itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T041324Z" creationid="Toshiyuki" creationdate="20140115T142520Z">
        <seg>&lt;c3&gt;does&lt;/c3&gt;演算子は、&lt;c4&gt;$self&lt;/c4&gt; ― &lt;c6&gt;$self&lt;/c6&gt;の&lt;e5&gt;クラス&lt;/e5&gt;でなく、インスタンス自体に ― このロールを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c3&gt;get&lt;/c3&gt; method reads and returns one line from the file, removing the line ending.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T073616Z" creationid="Toshiyuki" creationdate="20131026T073616Z">
        <seg>&lt;c3&gt;get&lt;/c3&gt;メソッドはファイルから1行を読み込んで返します。そして行末は取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&amp;&lt;/c4&gt; sigil requires the caller to pass an object that does the &lt;c5&gt;Callable&lt;/c5&gt; role such as an anonymous subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131221T003549Z" creationid="Toshiyuki" creationdate="20131221T003549Z">
        <seg>&lt;c4&gt;&amp;&lt;/c4&gt;シギルは無名サブルーチンのような&lt;c5&gt;Callable&lt;/c5&gt;ロールをするオブジェクトを渡すことを呼び出し元に要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;.next&lt;/c4&gt; and &lt;c5&gt;.last&lt;/c5&gt; methods take an optional argument giving the final value of that loop iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T101538Z" creationid="Toshiyuki" creationdate="20130806T101538Z">
        <seg>&lt;c4&gt;.next&lt;/c4&gt;と&lt;c5&gt;.last&lt;/c5&gt;メソッドはそのループのイテレーションの最終値を与える任意の引数をとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;take&lt;/c6&gt; function's signature is like that of &lt;c7&gt;return&lt;/c7&gt;; while having the syntax of a list operator, it merely returns a single item or "argument" (see &lt;c8&gt;S02&lt;/c8&gt; for definition).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T153900Z" creationid="Toshiyuki" creationdate="20130810T153900Z">
        <seg>&lt;c6&gt;take&lt;/c6&gt;関数のシグネチャーは&lt;c7&gt;return&lt;/c7&gt;のようなものだ；リスト演算子の文法を持ち、単独のアイテムか引数をただ返すだけだ（定義は&lt;c8&gt;S02&lt;/c8&gt;を参照）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;nominal&lt;/e0&gt; type is an actual type name, here &lt;c1&gt;Numeric&lt;/c1&gt;, as opposed to a type plus additional constraints, which are discussed in the next section.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140106T133406Z" creationid="Toshiyuki" creationdate="20140106T133406Z">
        <seg>&lt;e0&gt;名目の&lt;/e0&gt;型は実際の型名、ここでは&lt;c1&gt;Numeric&lt;/c1&gt;、型に加えて更なる制約は次のセクションで論じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e1&gt;postcircumfix&lt;/e1&gt; operator &lt;c2&gt;{...}&lt;/c2&gt; occurs after (&lt;e3&gt;post&lt;/e3&gt;) a term, and consists of two symbols (an opening and a closing curly bracket) which enclose (&lt;e4&gt;circumfix&lt;/e4&gt;) another term.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T053725Z" creationid="Toshiyuki" creationdate="20131027T053725Z">
        <seg>&lt;e1&gt;後置接周辞&lt;/e1&gt;演算子&lt;c2&gt;{...}&lt;/c2&gt;は項の後（&lt;e3&gt;post&lt;/e3&gt;）で起こり、他の項を囲む（&lt;e4&gt;接周辞&lt;/e4&gt;）2つのシンボル（開始と終わりのカーリーブラケット）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e3&gt;signature&lt;/e3&gt; of a subroutine is a description of any arguments it takes and any return values it produces.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T131207Z" creationid="Toshiyuki" creationdate="20131029T131207Z">
        <seg>サブルーチンの&lt;e3&gt;シグネチャー&lt;/e3&gt;は受け取る引数、生成する返り値の説明です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ASCII art dancing example from earlier in this chapter is simpler when each subroutine returns a new string:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T061751Z" creationid="Toshiyuki" creationdate="20140104T222016Z">
        <seg>この章の以前のアスキーアートダンスの例はそれぞれのサブルーチンが新しい文字列を返す場合により簡単になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Basics</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T231842Z" creationid="Toshiyuki" creationdate="20131025T231842Z">
        <seg>基本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Cool class (and package)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T232404Z" creationid="Toshiyuki" creationdate="20140328T232404Z">
        <seg>Coolクラス（とパッケージ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl 6 equivalent to Perl 5's &lt;c0&gt;eval {...}&lt;/c0&gt; is &lt;c1&gt;try {...}&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121703Z" creationid="Toshiyuki" creationdate="20130813T121703Z">
        <seg>Perl 5の&lt;c0&gt;eval {...}&lt;/c0&gt;に対するPerl 6の同等物は&lt;c1&gt;try {...}&lt;/c1&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Relationship of Blocks and Declarations</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T115332Z" creationid="Toshiyuki" creationdate="20130729T115332Z">
        <seg>ブロックと宣言の関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Relationship of Blocks and Statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T155712Z" creationid="Toshiyuki" creationdate="20130802T155712Z">
        <seg>ブロックと文の関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The action method takes the AST attached to the match object of that sub capture, and promotes it as its own AST by calling &lt;c0&gt;make&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T010535Z" creationid="Toshiyuki" creationdate="20140224T163028Z">
        <seg>アクションメソッドはサブキャプチャーのマッチオブジェクトに付属のASTを受け取り、&lt;c0&gt;make&lt;/c0&gt;を呼ぶことで自身のASTに昇格させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The action methods for proto tokens include the full name of each individual rule, including the &lt;c0&gt;sym&lt;/c0&gt; part:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T012510Z" creationid="Toshiyuki" creationdate="20140226T142237Z">
        <seg>プロトトークンのためのアクションメソッドは、個々のルール（&lt;c0&gt;sym&lt;/c0&gt;の部分を含む）のフルネームを含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The addition and incrementing operators treat &lt;c4&gt;Any&lt;/c4&gt; as a number with the value of zero; the strings get automatically converted to numbers, as addition is a numeric operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T004437Z" creationid="Toshiyuki" creationdate="20131026T135537Z">
        <seg>加算とインクリメント演算子は&lt;c4&gt;Any&lt;/c4&gt;をゼロの値の数とみなします；文字列は自動的に数値に変わり、加算は数値演算になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The appropriate regex for that is &lt;c2&gt;m/pe \w l/&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T024642Z" creationid="Toshiyuki" creationdate="20140117T182222Z">
        <seg>それのための適切な正規表現は&lt;c2&gt;m/pe \w l/&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array items are passed in through the &lt;e4&gt;topic variable&lt;/e4&gt; &lt;c5&gt;$_&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T143845Z" creationid="Toshiyuki" creationdate="20131026T143845Z">
        <seg>配列のアイテムは&lt;e4&gt;トピック変数&lt;/e4&gt;&lt;c5&gt;$_&lt;/c5&gt;を通して渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asterisk &lt;c0&gt;*&lt;/c0&gt; stands for zero or more occurrences, so &lt;c1&gt;m/z\w*o/&lt;/c1&gt; can match &lt;c2&gt;zo&lt;/c2&gt;, &lt;c3&gt;zoo&lt;/c3&gt;, &lt;c4&gt;zero&lt;/c4&gt; and so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T030642Z" creationid="Toshiyuki" creationdate="20140117T183532Z">
        <seg>アスタリスク&lt;c0&gt;*&lt;/c0&gt;は0以上の発生を表すので、&lt;c2&gt;zo&lt;/c2&gt;は&lt;c2&gt;zo&lt;/c2&gt;、&lt;c3&gt;zoo&lt;/c3&gt;、&lt;c4&gt;zero&lt;/c4&gt;などにマッチすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The atom on the left of the tilde (&lt;c9&gt;A&lt;/c9&gt;) is matched normally, but the atom to the right of the tilde (&lt;c10&gt;B&lt;/c10&gt;) is set as the goal, and then the final atom (&lt;c11&gt;C&lt;/c11&gt;) is matched.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T144130Z" creationid="Toshiyuki" creationdate="20140222T133407Z">
        <seg>チルダの左のアトム（&lt;c9&gt;A&lt;/c9&gt;）は普通にマッチされます。しかしチルダの右のアトム（&lt;c10&gt;B&lt;/c10&gt;）は最終目的としてのセットです。そして、最後のアトム（&lt;c11&gt;C&lt;/c11&gt;）がマッチされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base case is that of the empty list, which trivially sorts to the empty list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T120025Z" creationid="Toshiyuki" creationdate="20140113T073326Z">
        <seg>ベースケースはその空のリストです。それは空のリストをつまらなくソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The benefit of using this over a signature like &lt;c0&gt;:(*@pos, *%named)&lt;/c0&gt; is that these both enforce some context on the arguments, which may be premature.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T041920Z" creationid="Toshiyuki" creationdate="20140110T162531Z">
        <seg>&lt;c0&gt;:(*@pos, *%named)&lt;/c0&gt;のようなシグネチャーを使う利点は、未熟かもしれない引数をいくつかのコンテキストに強制することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The biggest difference between constructors in Perl 6 and constructors in languages such as C# and Java is that rather than setting up state on a somehow already magically created object, Perl 6 constructors actually create the object themselves.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141259Z" creationid="Toshiyuki" creationdate="20140111T193722Z">
        <seg>Perl 6とC#やJavaのような言語との間の大きな違いは、何故かすでにマジカルに作成されたオブジェクトの状態をセットするよりも、Perl 6は実際にそれら自身でオブジェクトを作成することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The block after the &lt;c0&gt;where&lt;/c0&gt; is optional; Perl performs the check by smart matching the argument against whatever follows the &lt;c1&gt;where&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140106T140906Z" creationid="Toshiyuki" creationdate="20140106T140906Z">
        <seg>&lt;c0&gt;where&lt;/c0&gt;の後のブロックは任意です；Perlは&lt;c1&gt;where&lt;/c1&gt;に続く引数ならなんでもスマートマッチングでチェックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The block that follows may contain arbitrary code, just as with any other block, but classes commonly contain state and behavior declarations.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T180245Z" creationid="Toshiyuki" creationdate="20140111T180245Z">
        <seg>続くブロックは何か他のブロックのように不定のコードを含みます。しかしクラスは一般に状態と振る舞いの宣言を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body is empty; the class defines no attributes or methods of its own.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122733Z" creationid="Toshiyuki" creationdate="20140115T102041Z">
        <seg>本体は空です；クラスは独自の属性またはメソッドを定義しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of such an alternative is a normal regex, where the call &lt;c7&gt;&lt;sym&gt;&lt;/c7&gt; matches the value of the parameter, in this example &lt;c8&gt;thing&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T151056Z" creationid="Toshiyuki" creationdate="20140223T095129Z">
        <seg>そのような選択肢のボディは通常の正規表現です。そこで、呼び出し&lt;c7&gt;&lt;sym&gt;&lt;/c7&gt;はパラメータの値にマッチします（この例では&lt;c8&gt;thing&lt;/c8&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of the subroutine follows as a block of code enclosed in curly braces.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T135411Z" creationid="Toshiyuki" creationdate="20131029T131720Z">
        <seg>サブルーチンの本体は、ブレースに入れられるコードのブロックとして後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of this function complains that it doesn't know what to do with the argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T225207Z" creationid="Toshiyuki" creationdate="20140112T225207Z">
        <seg>この関数の本体は、それが引数をどうすべきかわからないと不平を言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The brackets in the signature tell the compiler to expect a list-like argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T042114Z" creationid="Toshiyuki" creationdate="20140110T170516Z">
        <seg>シグネチャーのブラケットは、リストのような引数を予想するようコンパイラに命じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The built-in function &lt;c0&gt;open&lt;/c0&gt; opens a file, here named &lt;e1&gt;scores&lt;/e1&gt;, and returns a &lt;e2&gt;file handle&lt;/e2&gt;--an object representing that file.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154219Z" creationid="Toshiyuki" creationdate="20131026T035340Z">
        <seg>組み込み関数&lt;c0&gt;open&lt;/c0&gt;は、ここでは&lt;e1&gt;scores&lt;/e1&gt;という名前のファイルを開き、そして&lt;e2&gt;ファイルハンドル&lt;/e2&gt; ― そのファイルを表すオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The built-in function &lt;c0&gt;substr&lt;/c0&gt; can not only extract parts of strings, but also modify them:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T035149Z" creationid="Toshiyuki" creationdate="20140113T063602Z">
        <seg>組み込み関数&lt;c0&gt;substr&lt;/c0&gt;は文字列の部分を抽出することができるだけでなく、それらを修正することもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The built-in token &lt;c2&gt;&lt;alpha&gt;&lt;/c2&gt; matches an alphabetic character, so you can rewrite this example as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T073847Z" creationid="Toshiyuki" creationdate="20140222T024259Z">
        <seg>なたがこの例を書き直すことができるように、ビルトイントークン&lt;c2&gt;&lt;alpha&gt;&lt;/c2&gt;は英字にマッチします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The candidate for handling &lt;c0&gt;Real&lt;/c0&gt; is very simple; because JSON's and Perl 6's number formats coincide, the JSON converter can rely on Perl's conversion of these numbers to strings.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112617Z" creationid="Toshiyuki" creationdate="20140314T221752Z">
        <seg>&lt;c0&gt;Real&lt;/c0&gt;を取り扱う候補はとてもシンプルです；JSONとPerl 6の数値フォーマットは一致するので、JSONコンバータはこれらの数値から文字列への変換をPerlに頼ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The candidate that processes hashes turns them into the form &lt;c0&gt;{ "key1" : "value1", "key2" : [ "second", "value" ] }&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T222913Z" creationid="Toshiyuki" creationdate="20140314T222913Z">
        <seg>ハッシュを処理する候補は&lt;c0&gt;{ "key1" : "value1", "key2" : [ "second", "value" ] }&lt;/c0&gt;という形式にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The choice any particular implementation makes is specifically &lt;i1&gt;not&lt;/i1&gt; part of the definition of Perl 6, and you should not rely on it in portable code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T041448Z" creationid="Toshiyuki" creationdate="20130811T041448Z">
        <seg>どんな特定の実装の選択も明確にPerl 6の定義の一部ではない。そして移植可能なコード内でそれに頼るべきではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class inherits from &lt;c1&gt;IRCBot&lt;/c1&gt;, using the &lt;c2&gt;is&lt;/c2&gt; trait modifier--something familiar from earlier chapters--but it also uses the &lt;c3&gt;does&lt;/c3&gt; trait modifier to compose two roles into the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T013417Z" creationid="Toshiyuki" creationdate="20140115T102152Z">
        <seg>クラスは&lt;c1&gt;IRCBot&lt;/c1&gt;から継承します。&lt;c2&gt;is&lt;/c2&gt;トレイト修飾子を用いて ― 以前の章からおなじみの何か ― しかし、2つのロールをクラスに結合するために&lt;c3&gt;does&lt;/c3&gt;トレイト修飾子も使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code calls &lt;c2&gt;.join&lt;/c2&gt; to turn it into a string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T234311Z" creationid="Toshiyuki" creationdate="20140221T234311Z">
        <seg>コードはそれを文字列に変えるために&lt;c2&gt;.join&lt;/c2&gt;を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code creates a class for each possible symbol.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114905Z" creationid="Toshiyuki" creationdate="20140113T045949Z">
        <seg>コードは可能なシンボルごとにクラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code presented here is runnable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T221258Z" creationid="Toshiyuki" creationdate="20140112T182904Z">
        <seg>ここで示すコードは実行可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler has to execute the &lt;c1&gt;where&lt;/c1&gt;-block at least once to check if the third candidate is the best match, but the specification does not require the &lt;e2&gt;minimal&lt;/e2&gt; possible number of runs.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113016Z" creationid="Toshiyuki" creationdate="20140112T224801Z">
        <seg>コンパイラは第3候補が最善のマッチであるかどうかこと調べるために少なくとも一回&lt;c1&gt;where&lt;/c1&gt;ブロックを実行しなければなりません。しかし、仕様では実行の&lt;e2&gt;最小&lt;/e2&gt;の実行可能数を要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler is free to ignore &lt;c0&gt;FINAL&lt;/c0&gt; phasers compiled at run time since they're too late for the application-wide linking decisions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T092750Z" creationid="Toshiyuki" creationdate="20130818T092750Z">
        <seg>コンパイラが実行時にコンパイルされた&lt;c0&gt;FINAL&lt;/c0&gt;を無視するのは自由だ。application-wideリンクの決定の時から遅すぎる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler is free to infer what type information it can from the types you supply, but it will not complain about missing type information unless you ask it to.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140325T142047Z" creationid="Toshiyuki" creationdate="20140325T141831Z">
        <seg>コンパイラがあなたが供給できる型から型情報を推測するのは自由です。しかしあなたがそれを尋ねない限り、欠けている型情報について不満を言いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The construct &lt;c0&gt;m/ ... /&lt;/c0&gt; builds a regex.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T022503Z" creationid="Toshiyuki" creationdate="20140115T143618Z">
        <seg>&lt;c0&gt;m/ ... /&lt;/c0&gt;は正規表現を構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constructor captures these into the &lt;c1&gt;@dependencies&lt;/c1&gt; slurpy array and passes them as named parameters to &lt;c2&gt;bless&lt;/c2&gt; (note that &lt;c3&gt;:&amp;callback&lt;/c3&gt; uses the name of the variable--minus the sigil--as the name of the parameter).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141539Z" creationid="Toshiyuki" creationdate="20140112T090513Z">
        <seg>コンストラクタはそれらをslurpyな配列&lt;c1&gt;@dependencies&lt;/c1&gt;にキャプチャーし、&lt;c2&gt;bless&lt;/c2&gt;に名前付きパラメータとして渡します（&lt;c3&gt;:&amp;callback&lt;/c3&gt;は変数名を使うので注意してください ― シギル無しで ― パラメータの名前として）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The container object itself then becomes undefined.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140401T115529Z" creationid="Toshiyuki" creationdate="20140401T115529Z">
        <seg>コンテナオブジェクト自体は未定義になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The container type specifies how the variable itself is implemented.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224517Z" creationid="Toshiyuki" creationdate="20140328T224517Z">
        <seg>コンテナ型は変数自体がどのように実装されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The control lambda is logically separate from the catch lambda, though an implementation is allowed to combine them if it is careful to retain separate semantics for catch and control exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T125641Z" creationid="Toshiyuki" creationdate="20130817T125641Z">
        <seg>制御lambdaはキャッチlambdaとは論理的に異なる。けれどもキャッチと制御例外のセマンティクスを別々に注意して保持するなら実装を結合することは許可される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The curly braces for the constraint can contain arbitrary code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T222906Z" creationid="Toshiyuki" creationdate="20140112T222906Z">
        <seg>制約のためのブレースは、任意のコードを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current topic is always aliased to the special variable &lt;c0&gt;$_&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125321Z" creationid="Toshiyuki" creationdate="20130811T125321Z">
        <seg>現在のトピックは常に特殊変数&lt;c0&gt;$_&lt;/c0&gt;にエイリアスされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration and intent may seem simple at first, but look closer.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T043336Z" creationid="Toshiyuki" creationdate="20140113T043336Z">
        <seg>宣言と意図は、最初は単純なようであるが、より間近に見ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default case:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133227Z" creationid="Toshiyuki" creationdate="20130811T133227Z">
        <seg>defaultケース：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default comparison is case sensitive.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T124430Z" creationid="Toshiyuki" creationdate="20131029T124430Z">
        <seg>デフォルトの比較は大文字と小文字を区別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definitions of alphabetic and numeric include appropriate Unicode characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T092741Z" creationid="Toshiyuki" creationdate="20140329T092658Z">
        <seg>英字と数字の定義は適切なユニコード文字も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The desire to allow whitespace &lt;e0&gt;anywhere&lt;/e0&gt; in a string is common.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130618Z" creationid="Toshiyuki" creationdate="20140222T020038Z">
        <seg>文字列の&lt;e0&gt;どこでも&lt;/e0&gt;空白文字を許可したいという願望は一般的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference between the approaches is primarily one of clarity, as each alternative provides a different quoting mechanism.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T154102Z" creationid="Toshiyuki" creationdate="20140104T154102Z">
        <seg>アプローチ間の違いは第一に分かりやすさで、それぞれの選択肢は異なるクオートメカニズムを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The discussion of slurpy versus optional parameters seems out of place here; functions chapter?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T063730Z" creationid="Toshiyuki" creationdate="20140113T063730Z">
        <seg>大食いな対任意のパラメータに関する議論は、ここで不適当なようです；関数の章ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dot (&lt;c1&gt;.&lt;/c1&gt;) matches a single, arbitrary character:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T024019Z" creationid="Toshiyuki" creationdate="20140115T143925Z">
        <seg>ドット（&lt;c1&gt;.&lt;/c1&gt;）は、一つの任意の文字にマッチします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dot matched an &lt;c0&gt;l&lt;/c0&gt;, &lt;c1&gt;r&lt;/c1&gt;, and &lt;c2&gt;n&lt;/c2&gt;, but it will also match a space in the sentence &lt;e3&gt;the spectrosco&lt;s4&gt;pe l&lt;/s4&gt;acks resolution&lt;/e3&gt;--regexes ignore word boundaries by default.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124437Z" creationid="Toshiyuki" creationdate="20140117T181641Z">
        <seg>ドットは&lt;c0&gt;l&lt;/c0&gt;、&lt;c1&gt;r&lt;/c1&gt;と&lt;c2&gt;n&lt;/c2&gt;にマッチしました。しかし、それは文の&lt;e3&gt;the spectrosco&lt;s4&gt;pe l&lt;/s4&gt;acks resolution&lt;/e3&gt;にもマッチするでしょう ― 正規表現はデフォルトで単語境界を無視します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The drawing area has the width &lt;c0&gt;$screen-width - $label-area-width&lt;/c0&gt;, so for each score, it should print:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T065245Z" creationid="Toshiyuki" creationdate="20131027T065245Z">
        <seg>描画エリアは横幅&lt;c0&gt;$screen-width - $label-area-width&lt;/c0&gt;をそれぞれのスコアに持っているので、それは以下を出力するはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The duplicate word search regex had to anchor the regex to word boundaries, because &lt;c1&gt;\w+&lt;/c1&gt; would allow matching only part of a word.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T051047Z" creationid="Toshiyuki" creationdate="20140222T022557Z">
        <seg>&lt;c1&gt;\w+&lt;/c1&gt;がワードの一部だけにマッチするのを許可するので、重複する文字列検索正規表現は正規表現を語境界に固定しなければなりませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The easiest way to restrict the possible values that a subroutine accepts is by writing a type name before a parameter.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T064945Z" creationid="Toshiyuki" creationdate="20140106T125916Z">
        <seg>サブルーチンが受け入れ可能な値を制限する最も簡単な方法は、パラメータの前に型名を書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The editor in me wants to fix this example to use the serial comma.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T233825Z" creationid="Toshiyuki" creationdate="20140221T233825Z">
        <seg>私のエディタは、この例を修正したいです ― 連続コンマを使うために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effect of &lt;c0&gt;:ratchet&lt;/c0&gt; applies only to the regex in which it appears.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T051212Z" creationid="Toshiyuki" creationdate="20140222T022729Z">
        <seg>&lt;c0&gt;:ratchet&lt;/c0&gt;の影響は、それが出現する正規表現だけに適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entire type check can only succeed if the code block returns a true value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T224107Z" creationid="Toshiyuki" creationdate="20140112T222845Z">
        <seg>コードブロックが真の値を返す場合だけ、全ての型チェックは成功することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The equality sign &lt;c3&gt;=&lt;/c3&gt; &lt;e4&gt;assigns&lt;/e4&gt; that file handle to the variable on the left, which means that &lt;c5&gt;$file&lt;/c5&gt; now stores the file handle.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154324Z" creationid="Toshiyuki" creationdate="20131026T040259Z">
        <seg>等号符号&lt;c3&gt;=&lt;/c3&gt;は左の変数にそのファイルハンドルを&lt;e4&gt;割り当て&lt;/e4&gt;ます。それは現在&lt;c5&gt;$file&lt;/c5&gt;がファイルハンドルを格納していることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The eventual binding context thus determines whether to throw away or keep the groupings resulting from each individual &lt;c1&gt;take&lt;/c1&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T205608Z" creationid="Toshiyuki" creationdate="20130810T205608Z">
        <seg>最終のバインディングコンテキストはグルーピングを捨てるか保つか決める。それぞれの個々の&lt;c1&gt;take&lt;/c1&gt;呼び出しからの結果として。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example JSON grammar introduces the &lt;e0&gt;goal matching syntax&lt;/e0&gt; which can be presented abstractly as: &lt;c1&gt;A ~ B C&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T143157Z" creationid="Toshiyuki" creationdate="20140222T133140Z">
        <seg>例のJSONグラマーは、最終目的のマッチング構文を導入します。それは抽象的には&lt;c1&gt;A ~ B C&lt;/c1&gt;と表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above uses the class name &lt;c4&gt;Task&lt;/c4&gt; so that other code can refer to it later, such as to create class instances by calling the &lt;c5&gt;new&lt;/c5&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045042Z" creationid="Toshiyuki" creationdate="20140111T181518Z">
        <seg>他のコードが後でそれを参照することができるように、上の例はクラス名&lt;c4&gt;Task&lt;/c4&gt;を使います、例えば&lt;c5&gt;new&lt;/c5&gt;メソッドを呼ぶことによってクラスインスタンスを作るために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below demonstrates the &lt;c0&gt;Baker&lt;/c0&gt; class overriding the &lt;c1&gt;Cook&lt;/c1&gt;'s &lt;c2&gt;cook&lt;/c2&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144449Z" creationid="Toshiyuki" creationdate="20140112T124052Z">
        <seg>下の例は&lt;c1&gt;Cook&lt;/c1&gt;クラスの&lt;c2&gt;cook&lt;/c2&gt;メソッドをオーバーライドする&lt;c0&gt;Baker&lt;/c0&gt;クラスを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example code includes attributes (state), introduced through the &lt;c1&gt;has&lt;/c1&gt; keyword, and behaviors introduced through the &lt;c2&gt;method&lt;/c2&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T180908Z" creationid="Toshiyuki" creationdate="20140111T180908Z">
        <seg>例のコードは属性（状態）を含み、&lt;c1&gt;has&lt;/c1&gt;キーワードで導入されます。そして振る舞いは&lt;c2&gt;method&lt;/c2&gt;キーワードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example in this chapter uses this to give bots new abilities during their lifetimes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T123501Z" creationid="Toshiyuki" creationdate="20140115T142133Z">
        <seg>この章の例は、それらのライフタイムの間、ボットに新しい機能を与えるためにこれを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example's constructor turns positional arguments into named arguments, so that the class can provide a nice constructor for its users.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141436Z" creationid="Toshiyuki" creationdate="20140112T035603Z">
        <seg>例のコンストラクタは位置依存パラメータを名前付きパラメータに変換します。なのでクラスはユーザーに良いコンストラクタを提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception thrower looks up the call stack for a catch lambda that returns () to indicate all exceptions are handled, and then it is happy, and unwinds the stack to that point.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T112512Z" creationid="Toshiyuki" creationdate="20130814T112512Z">
        <seg>例外を投げるものは全ての例外がハンドルされることを示すために()を返すlambdaをキャッチするためにコールスタックを探す。そしてそのときハッピーで、その点にスタックを巻き戻す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The explanations of this example have one implication which is not entirely obvious.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T110711Z" creationid="Toshiyuki" creationdate="20131027T110711Z">
        <seg>この例の説明には、完全に明らかであるというわけではない1つの含みがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression &lt;c0&gt;[max] @scores».key».chars&lt;/c0&gt; gives the largest of these values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T124645Z" creationid="Toshiyuki" creationdate="20140313T124645Z">
        <seg>式&lt;c0&gt;[max] @scores».key».chars&lt;/c0&gt;はそれらのもっとも大きい値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression &lt;c0&gt;[max] @scoresｻ.keyｻ.chars&lt;/c0&gt; gives the largest of these values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T085916Z" creationid="Toshiyuki" creationdate="20140308T085916Z">
        <seg>式&lt;c0&gt;[max] @scores».key».chars&lt;/c0&gt;はそれらの値の最も長いものを得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression &lt;c0&gt;[max] @scores�.key�.chars&lt;/c0&gt; gives the largest of these values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T063558Z" creationid="Toshiyuki" creationdate="20131027T063558Z">
        <seg>式&lt;c0&gt;[max] @scores».key».chars&lt;/c0&gt;はそれらのもっとも大きい値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The extra verbosity of marking parameters as mutable or immutable may seem excessive at first, but as an average user, it's unlikely that you'll need to use these traits often.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T001625Z" creationid="Toshiyuki" creationdate="20131221T001523Z">
        <seg>最初のうちはパラメータに対する可変か不変かの冗長なマーキングは過剰に見えます。しかし一般ユーザーはこれらのトレイトを頻繁に使う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final candidate is a fallback for the cases not covered yet--every case in which Player Two wins.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115244Z" creationid="Toshiyuki" creationdate="20140113T051002Z">
        <seg>最終的な候補はまだカバーされない ― プレイヤー2が勝つすべてのケース ― ケースのための頼れるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first capture, &lt;c0&gt;(\w+)&lt;/c0&gt;, was quantified, so &lt;c1&gt;$/[0]&lt;/c1&gt; contains a list of words.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T125912Z" creationid="Toshiyuki" creationdate="20140221T234233Z">
        <seg>最初のキャプチャー&lt;c0&gt;(\w+)&lt;/c0&gt;は数量化されているので、&lt;c1&gt;$/[0]&lt;/c1&gt;はワードのリストを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first declaration specifies instance storage for a callback -- a bit of code to invoke in order to perform the task that an object represents:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182453Z" creationid="Toshiyuki" creationdate="20140111T182453Z">
        <seg>最初の宣言は、コールバックのためにインスタンス・ストレージを指定します－オブジェクトが表す仕事を実行するために呼び出すわずかなコード：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first extracts and stores the names of the two players in the variables &lt;c0&gt;$p1&lt;/c0&gt; and &lt;c1&gt;$p2&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T104017Z" creationid="Toshiyuki" creationdate="20131026T104017Z">
        <seg>最初は2人のプレーヤーの名前を変数&lt;c0&gt;$p1&lt;/c0&gt;と&lt;c1&gt;$p2&lt;/c1&gt;に抽出して保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first line is the list of players.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T024338Z" creationid="Toshiyuki" creationdate="20131026T015354Z">
        <seg>最初の行はプレーヤーのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first parameter is the callback (the thing to do to execute the task).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141503Z" creationid="Toshiyuki" creationdate="20140112T035629Z">
        <seg>最初のパラメータはコールバック（タスクを実行するためのもの）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first string is the name of the player and the second is the bar.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T074505Z" creationid="Toshiyuki" creationdate="20131027T074505Z">
        <seg>最初の文字列はプレーヤーの名前です。そして、第2はバーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first three lines inside the class block all declare attributes (called &lt;e0&gt;fields&lt;/e0&gt; or &lt;e1&gt;instance storage&lt;/e1&gt; in other languages).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182038Z" creationid="Toshiyuki" creationdate="20140111T182038Z">
        <seg>クラスブロック内の最初の3行は全て属性を宣言します（他の言語では&lt;e0&gt;フィールド&lt;/e0&gt;または&lt;e1&gt;インスタンスストレージ&lt;/e1&gt;と呼ばれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two lines introduce a grammar that inherits from &lt;c0&gt;JSON::Tiny::Grammar&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T224927Z" creationid="Toshiyuki" creationdate="20140223T103442Z">
        <seg>最初の2行は、&lt;c0&gt;JSON::Tiny::Grammar&lt;/c0&gt;から継承するグラマーを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two tests each smart-match against a class name.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T104937Z" creationid="Toshiyuki" creationdate="20140112T135621Z">
        <seg>最初の2つは各々のクラス名に対してスマートマッチをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flattening or slicing of any such returned parcel will be dependent on how the &lt;c2&gt;gather&lt;/c2&gt;'s return iterator is iterated (with &lt;c3&gt;.get&lt;/c3&gt; vs &lt;c4&gt;.getarg&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T201914Z" creationid="Toshiyuki" creationdate="20130810T201914Z">
        <seg>そのような返されたパーセルの平坦化またはスライシングは&lt;c2&gt;gather&lt;/c2&gt;の返したイテレータがどのように反復するかに依存している（&lt;c3&gt;.get&lt;/c3&gt;対&lt;c4&gt;.getarg&lt;/c4&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example demonstrates how to parse JSON, a data exchange format already introduced (see &lt;a0&gt;link&lt;/a0&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T132224Z" creationid="Toshiyuki" creationdate="20140222T094950Z">
        <seg>以下の例はJSON（既に広まっているデータ交換フォーマット）を解析する方法を示します。（&lt;a0&gt;リンク&lt;/a0&gt;を見みてください）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following operations are available for strings:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020637Z" creationid="Toshiyuki" creationdate="20140301T050207Z">
        <seg>以下の演算子は文字列で利用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following operators are available for all number types:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140228T194151Z" creationid="Toshiyuki" creationdate="20140228T194151Z">
        <seg>以下の演算子は、すべての数型に利用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following paragraph seems out of place.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T025302Z" creationid="Toshiyuki" creationdate="20140307T155446Z">
        <seg>（次の文節は不適切かもしれません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following program shows how a dependency handler might look in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T174417Z" creationid="Toshiyuki" creationdate="20140111T174417Z">
        <seg>以下のプログラムはPerl 6で依存ハンドラがどのように見えるか示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following treats every other value in &lt;c1&gt;@values&lt;/c1&gt; as modifiable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113118Z" creationid="Toshiyuki" creationdate="20130810T113118Z">
        <seg>次のコードは&lt;c1&gt;@values&lt;/c1&gt;の値を一つ置きに変更可能として扱う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The former constructs a regex object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131349Z" creationid="Toshiyuki" creationdate="20140222T023404Z">
        <seg>前者は正規表現オブジェクトを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The former reuses the argument list and the latter allows the use of a different argument list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121157Z" creationid="Toshiyuki" creationdate="20140113T075855Z">
        <seg>前者は引数リストを再利用します。そして後者は異なる引数リストを使用可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fourth candidate, &lt;c0&gt;multi wins(::T $, T $) { 0 }&lt;/c0&gt; uses &lt;c1&gt;::T&lt;/c1&gt;, which is a &lt;e2&gt;type capture&lt;/e2&gt; (similar to &lt;e3&gt;generics&lt;/e3&gt; or &lt;e4&gt;templates&lt;/e4&gt; in other programming languages).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115106Z" creationid="Toshiyuki" creationdate="20140113T050508Z">
        <seg>第4候補の&lt;c0&gt;multi wins(::T $, T $) { 0 }&lt;/c0&gt;は&lt;c1&gt;::T&lt;/c1&gt;を使っていますが、それは&lt;e2&gt;型キャプチャ&lt;/e2&gt;です（他の言語の&lt;e3&gt;ジェネリクス&lt;/e3&gt;または&lt;e4&gt;テンプレート&lt;/e4&gt;に似ています）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function (or listop) form always exits from the innermost block, returning its arguments as the final value of the block exactly as &lt;c1&gt;return&lt;/c1&gt; does.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T071452Z" creationid="Toshiyuki" creationdate="20130817T071429Z">
        <seg>関数（またはリスト演算子）形式は常に最も深いブロックから抜け出し、&lt;c1&gt;return&lt;/c1&gt;がするようにブロックの最後の値としてその引数を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general loop statement</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T055617Z" creationid="Toshiyuki" creationdate="20130810T055617Z">
        <seg>一般のループ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implicit break (what &lt;c2&gt;succeed&lt;/c2&gt; does explicitly) of a &lt;c3&gt;when&lt;/c3&gt; block is abnormal.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125233Z" creationid="Toshiyuki" creationdate="20130816T125233Z">
        <seg>&lt;c3&gt;when&lt;/c3&gt;ブロックの暗黙の中断（&lt;c2&gt;succeed&lt;/c2&gt;は明示的に行う）はアブノーマルだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implicit break of a normal &lt;c0&gt;when&lt;/c0&gt; block works the same way, returning the value of the entire block (normally from its last statement) via an implicit &lt;c1&gt;succeed&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114905Z" creationid="Toshiyuki" creationdate="20130813T114905Z">
        <seg>通常の&lt;c0&gt;when&lt;/c0&gt;ブロックの暗黙の脱出は同じ方法の動作で、暗黙の&lt;c1&gt;succeed&lt;/c1&gt;を経て全体のブロック（通常はその最後の文）の値を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The infix &lt;c0&gt;max&lt;/c0&gt; operator returns the greater of two values, so &lt;c1&gt;2 max 3&lt;/c1&gt; returns 3.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T061318Z" creationid="Toshiyuki" creationdate="20131027T061318Z">
        <seg>接中辞&lt;c0&gt;max&lt;/c0&gt;演算子は2つの値でより大きな値を返すもので、&lt;c1&gt;2 max 3&lt;/c1&gt;は3を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The infix &lt;c0&gt;x&lt;/c0&gt; operator, or &lt;e1&gt;repetition operator&lt;/e1&gt;, generates this bar.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T033407Z" creationid="Toshiyuki" creationdate="20131027T074609Z">
        <seg>接中辞&lt;c0&gt;x&lt;/c0&gt;演算子、または&lt;e1&gt;繰返し演算子&lt;/e1&gt;はこのバーを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The infix &lt;c12&gt;cmp&lt;/c12&gt; operator is a type sensitive three-way comparison operator which compares numbers like &lt;c13&gt;&lt;=&gt;&lt;/c13&gt;, strings like &lt;c14&gt;leg&lt;/c14&gt;, and (for example) pairs first by key, and then by value if the keys are identical:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T123752Z" creationid="Toshiyuki" creationdate="20131029T123752Z">
        <seg>接中辞&lt;c12&gt;cmp&lt;/c12&gt;演算子は型に敏感な三者間の比較演算子で、&lt;c13&gt;&lt;=&gt;&lt;/c13&gt;のように数値を比較し、&lt;c14&gt;leg&lt;/c14&gt;のように文字列を比較し、（例えば）ペアでは最初にキー、キーが同一なら値を比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializing expression is evaluated at &lt;c0&gt;BEGIN&lt;/c0&gt; time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T131959Z" creationid="Toshiyuki" creationdate="20130802T131959Z">
        <seg>初期化式は&lt;c0&gt;BEGIN&lt;/c0&gt;時に評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The input data (stored in a file called "scores") looks like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T024311Z" creationid="Toshiyuki" creationdate="20131026T015304Z">
        <seg>入力データ（“scores”という名前のファイルに保存されている）は、このような格好です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key type of a hash may be specified as a shape trait--see S09.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T223509Z" creationid="Toshiyuki" creationdate="20140328T223509Z">
        <seg>ハッシュのキーの型はshapeトレイトとして指定されます ― S09を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyword for individual cases is &lt;c1&gt;when&lt;/c1&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125157Z" creationid="Toshiyuki" creationdate="20130811T125157Z">
        <seg>個々のケースのキーワードは&lt;c1&gt;when&lt;/c1&gt;だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latter constructs the regex object &lt;e2&gt;and&lt;/e2&gt; immediately matches it against the topic variable &lt;c3&gt;$_&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T055604Z" creationid="Toshiyuki" creationdate="20140222T023438Z">
        <seg>後者は正規表現オブジェクトを構築し、そしてトピック変数&lt;c3&gt;$_&lt;/c3&gt;に対してすぐにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The leading question mark indicates an &lt;e1&gt;zero-width assertion&lt;/e1&gt;: a rule that never consumes characters from the matched string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T073749Z" creationid="Toshiyuki" creationdate="20140222T024213Z">
        <seg>先行クエスチョンマークは&lt;e1&gt;ゼロ幅アサーション&lt;/e1&gt;を示します： マッチされた文字列から文字を決して消費しないルールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lexical scope supplies the declared target for the dynamic operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T004107Z" creationid="Toshiyuki" creationdate="20130728T004107Z">
        <seg>レキシカルスコープは動的な操作のために宣言されたターゲットを供給する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The line:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T044728Z" creationid="Toshiyuki" creationdate="20131027T044728Z">
        <seg>この行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list is evaluated lazily by default, so instead of using a &lt;c0&gt;while&lt;/c0&gt; to read a file a line at a time as you would in Perl 5:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T062615Z" creationid="Toshiyuki" creationdate="20130810T062615Z">
        <seg>デフォルトではリストは不精に評価されるので、Perl 5ではファイルを一行ずつ読み込むために代わりに&lt;c0&gt;while&lt;/c0&gt;を使う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list-like part contains the positional arguments and the hash-like parts contains the named arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T140348Z" creationid="Toshiyuki" creationdate="20140110T140348Z">
        <seg>リストのような部分は位置引数と名前付き引数を含むハッシュのような部分を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lookup inside &lt;c1&gt;on-message&lt;/c1&gt; stores a Role in &lt;c2&gt;$plug-in&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T041213Z" creationid="Toshiyuki" creationdate="20140115T142452Z">
        <seg>&lt;c1&gt;on-message&lt;/c1&gt;の内側の検索は、ロールを&lt;c2&gt;$plug-in&lt;/c2&gt;に保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop conditional on a &lt;c4&gt;repeat&lt;/c4&gt; block is required, so it will be recognized even if you put it on a line by its own:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T152109Z" creationid="Toshiyuki" creationdate="20130809T152109Z">
        <seg>&lt;c4&gt;repeat&lt;/c4&gt;ブロックのループ条件が必要なので、 それを独自の行に置いても評価される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The match object produced from that call is accessible as &lt;c6&gt;$&lt;dup&gt;&lt;word&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T041324Z" creationid="Toshiyuki" creationdate="20140222T015842Z">
        <seg>その呼び出しから作り出されるマッチオブジェクトは、&lt;c6&gt;$&lt;dup&gt;&lt;word&gt;&lt;/c6&gt;としてアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method form will leave any block in the dynamic scope that can be named as an object and that responds to the &lt;c2&gt;.leave&lt;/c2&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T071918Z" creationid="Toshiyuki" creationdate="20130817T071918Z">
        <seg>メソッド形式はオブジェクトとして名前付けでき、&lt;c2&gt;.leave&lt;/c2&gt;メソッドに応答するダイナミックスコープの何か一つのブロックを抜け出すだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method itself takes the passed parameter--which must be an instance of the &lt;c0&gt;Task&lt;/c0&gt; class--and &lt;c1&gt;push&lt;/c1&gt;es it onto the invocant's &lt;c2&gt;@!dependencies&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T140805Z" creationid="Toshiyuki" creationdate="20140111T190502Z">
        <seg>メソッド自身は渡されたパラメータを受け取ります ― それは&lt;c0&gt;Task&lt;/c0&gt;クラスのインスタンスでなければなりません ― そしてそれをインボカントの&lt;c2&gt;@!dependencies&lt;/c2&gt;属性に&lt;c1&gt;プッシュ&lt;/c1&gt;します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most general quantifier is &lt;c0&gt;**&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T225106Z" creationid="Toshiyuki" creationdate="20140221T225106Z">
        <seg>最も一般的な数量詞は&lt;c0&gt;**&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most important types are:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140226T143428Z" creationid="Toshiyuki" creationdate="20140226T143428Z">
        <seg>最も重要な型は以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the lexical variable to bind to, if any</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044020Z" creationid="Toshiyuki" creationdate="20140322T044020Z">
        <seg>バインドするレキシカル変数の名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The negated character class is a special application of this idea.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T025733Z" creationid="Toshiyuki" creationdate="20140117T182940Z">
        <seg>否定の文字クラスは、このアイデアの特別な適用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The negated form of this, &lt;c2&gt;:!name&lt;/c2&gt;, has an implicit value of &lt;c3&gt;Bool::False&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T154443Z" creationid="Toshiyuki" creationdate="20140104T154443Z">
        <seg>否定の形式、&lt;c2&gt;:!name&lt;/c2&gt;は暗黙に&lt;c3&gt;Bool::False&lt;/c3&gt;を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new &lt;c0&gt;constant&lt;/c0&gt; declarator introduces a compile-time constant, either a variable or named value, which may be initialized with a pseudo-assignment:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T131802Z" creationid="Toshiyuki" creationdate="20130802T131802Z">
        <seg>新しい&lt;c0&gt;constant&lt;/c0&gt;宣言は変数または名前付きの値にコンパイル時の定数をもたらし、擬似割り当てで初期化されるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new sub is like any other sub, and works with all the various parameter-passing schemes already described.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T071435Z" creationid="Toshiyuki" creationdate="20140111T071435Z">
        <seg>新しいサブルーチンは他のサブルーチンのように様々なパラメーター渡しの機構が既に記述されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next line containing new features is:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T060822Z" creationid="Toshiyuki" creationdate="20131027T060822Z">
        <seg>新機能を含んでいる次の行は、以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next two lines follow the same pattern:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T103744Z" creationid="Toshiyuki" creationdate="20131026T103737Z">
        <seg>次の2行は同じパターンが続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nominal type</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044026Z" creationid="Toshiyuki" creationdate="20140322T044026Z">
        <seg>名目型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only exceptions to that are the backslash, square brackets and the dash &lt;c1&gt;-&lt;/c1&gt;, which need to be escaped with a backslash:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T025929Z" creationid="Toshiyuki" creationdate="20140117T183249Z">
        <seg>それに対する唯一の例外はバックスラッシュ、ブラケットとダッシュ&lt;c1&gt;-&lt;/c1&gt;です。そして、それはバックスラッシュでエスケープされる必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only remaining difficulty arises if both the user and a library writer attempt to use dynamic gather with user-defined callbacks that contain &lt;c11&gt;take&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T160934Z" creationid="Toshiyuki" creationdate="20130810T160934Z">
        <seg>ユーザーとライブラリ作者がダイナミックなgatherを&lt;c11&gt;take&lt;/c11&gt;を含むユーザー定義のコールバックと使用しようと試みるなら、唯一残っている難しさが生じる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operators &lt;c0&gt;&lt;&lt;/c0&gt;, &lt;c1&gt;&lt;=&lt;/c1&gt;, &lt;c2&gt;&gt;=&lt;/c2&gt;, and &lt;c3&gt;&gt;&lt;/c3&gt; compare the relative size of numbers.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T124703Z" creationid="Toshiyuki" creationdate="20131028T124703Z">
        <seg>演算子&lt;c0&gt;&lt;&lt;/c0&gt;、&lt;c1&gt;&lt;=&lt;/c1&gt;、&lt;c2&gt;&gt;=&lt;/c2&gt;そして&lt;c3&gt;&gt;&lt;/c3&gt;は数の相対的なサイズを比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original object stays the same.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140115T143104Z" creationid="Toshiyuki" creationdate="20140115T143104Z">
        <seg>最初のオブジェクトは、同じもののままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other action methods work the same way.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T012215Z" creationid="Toshiyuki" creationdate="20140226T142142Z">
        <seg>他のアクションメソッドは同じ方法で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other case is a list which contains at least one value--the pivot--and possibly other values to partition according to the pivot.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T120606Z" creationid="Toshiyuki" creationdate="20140113T073526Z">
        <seg>他のケースは少なくとも1つの値 ― 中心点 ― と中心点によって分割される可能な他の値を含むリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other way round, converting a JSON string to a Perl 6 data structure, is covered in the chapter &lt;a0&gt;link&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T221249Z" creationid="Toshiyuki" creationdate="20140314T221249Z">
        <seg>反対にJSON文字列をPerl6データ構造に変換することは&lt;a0&gt;リンク&lt;/a0&gt;の章で取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other way round, converting a JSON string to a Perl 6 data structure, is covered in the chapter link.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T182730Z" creationid="Toshiyuki" creationdate="20140112T182730Z">
        <seg>反対に、JSON文字列をPerl 6データ構造に変えることは、章リンク先でカバーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The outer regex will still backtrack, so it can retry the regex &lt;c1&gt;word&lt;/c1&gt; at a different staring position.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T051637Z" creationid="Toshiyuki" creationdate="20140222T022815Z">
        <seg>外側の正規表現はまだバックトラックするので、それは異なる位置を凝視している正規表現&lt;c1&gt;word&lt;/c1&gt;を再び試みることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output after the second call is at least &lt;c0&gt;1&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T224820Z" creationid="Toshiyuki" creationdate="20140112T224657Z">
        <seg>2回目の呼び出しの後の出力は、少なくとも&lt;c0&gt;1&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output can look like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T104840Z" creationid="Toshiyuki" creationdate="20140112T135553Z">
        <seg>出力はこのようになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parenthesized form of type coercion may be used in declarations where it makes sense to accept a wider set of types but coerce them to a narrow type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140407T124226Z" creationid="Toshiyuki" creationdate="20140407T124226Z">
        <seg>括弧に入れられた形式の型制約は、広いセットを受け入れるが、狭く制限されることが意味を成す宣言で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The plus &lt;c5&gt;+&lt;/c5&gt; stands for one or more occurrences, &lt;c6&gt;\w+&lt;/c6&gt; &lt;e7&gt;usually&lt;/e7&gt; matches what you might consider a word (though only matches the first three characters from &lt;c8&gt;isn't&lt;/c8&gt; because &lt;c9&gt;'&lt;/c9&gt; isn't a word character).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T030952Z" creationid="Toshiyuki" creationdate="20140118T010942Z">
        <seg>プラスの&lt;c5&gt;+&lt;/c5&gt;は一つ以上の発生を表します、&lt;c6&gt;\w+&lt;/c6&gt;はあなたがワードと考えられるものに&lt;e7&gt;通常は&lt;/e7&gt;マッチします（しかし&lt;c8&gt;isn't&lt;/c8&gt;からは最初の3文字だけにマッチします。&lt;c9&gt;'&lt;/c9&gt;はワード文字ではないからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous chapter already used other types of operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T050808Z" creationid="Toshiyuki" creationdate="20131027T050808Z">
        <seg>前の章は、他のタイプの演算子をすでに使いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous example to match a list of words was:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T015940Z" creationid="Toshiyuki" creationdate="20140222T015940Z">
        <seg>ワードのリストにマッチする前の例は、以下の通りでした：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous value of &lt;c0&gt;$_&lt;/c0&gt; is not available within the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114904Z" creationid="Toshiyuki" creationdate="20130810T114904Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;の前の値はループ内では使用できない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of role composition is simple.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T013643Z" creationid="Toshiyuki" creationdate="20140115T102202Z">
        <seg>ロール合成のプロセスは単純です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program next determines the maximum score:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T064918Z" creationid="Toshiyuki" creationdate="20131027T064918Z">
        <seg>次のプログラムは最大のスコアを決定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program takes advantage of this property of Perl 6's &lt;c2&gt;sort&lt;/c2&gt; to achieve the goal by sorting twice: first by the number of sets won (the secondary criterion), then by the number of matches won.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T161349Z" creationid="Toshiyuki" creationdate="20131026T150157Z">
        <seg>プログラムは2度ソートすることで目的を達成するために、Perl 6の&lt;c2&gt;sort&lt;/c2&gt;のこの特性を利用します：最初に勝ったセット数（第2の基準）、それから勝った試合数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program then counts the number of sets each player has won:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T004353Z" creationid="Toshiyuki" creationdate="20131026T115924Z">
        <seg>それからプログラムは、各々のプレーヤーが獲得したセット数を数えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program will exhaust memory before it ever prints &lt;c4&gt;'A'&lt;/c4&gt; or &lt;c5&gt;'B'&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T174119Z" creationid="Toshiyuki" creationdate="20140112T174119Z">
        <seg>プログラムはこれまでに&lt;c4&gt;'A'&lt;/c4&gt;または&lt;c5&gt;'B'&lt;/c5&gt;を出力する前にメモリーを空にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The programmer here has made a mistake and should choose to compose only one role to provide the desired behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T021110Z" creationid="Toshiyuki" creationdate="20140115T140238Z">
        <seg>ここでのプログラマーは間違いをしています。そして、望ましい振る舞いを提供するために1つのロールだけを合成すること選ぶべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The real insight for me was realizing that transforming trees is the best way to write a compiler, but I don't expect readers to have gone through the trouble of writing compilers the hard way first.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T002115Z" creationid="Toshiyuki" creationdate="20140224T162845Z">
        <seg>ツリーを変形することがコンパイラを記述する最善の方法であると認識していましたが、私は最初にコンパイラを書くという難しい方法で読者にトラブルを経験させたいと思っていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The recursive calls demonstrate a powerful truth of multidispatch: these calls do not necessarily recurse to the &lt;c2&gt;Array&lt;/c2&gt; candidate, but dispatch to the appropriate candidate based on the types of &lt;e3&gt;their&lt;/e3&gt; arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T222838Z" creationid="Toshiyuki" creationdate="20140314T222838Z">
        <seg>再帰呼び出しはマルチディスパッチの強力な事実を示します：それらは&lt;c2&gt;Array&lt;/c2&gt;候補に必ずしも再帰するというわけではありません。しかし&lt;e3&gt;それらの&lt;/e3&gt;引数の型に基づいて適切な候補をディスパッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reduction method calls the &lt;c1&gt;.ast&lt;/c1&gt; method on each matched pair and installs the result list in its own AST.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T012114Z" creationid="Toshiyuki" creationdate="20140225T144422Z">
        <seg>還元メソッドはマッチしたペアの各々で&lt;c1&gt;.ast&lt;/c1&gt;メソッドを呼び、それ自身のASTに結果リストをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reduction method for &lt;c0&gt;object&lt;/c0&gt; extracts the AST of the &lt;c1&gt;pairlist&lt;/c1&gt; submatch and turns it into a hash by calling its &lt;c2&gt;hash&lt;/c2&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T011811Z" creationid="Toshiyuki" creationdate="20140225T144329Z">
        <seg>&lt;c0&gt;object&lt;/c0&gt;のための還元メソッドは&lt;c1&gt;pairlist&lt;/c1&gt;サブマッチのASTを抜き出し、その&lt;c2&gt;hash&lt;/c2&gt;メソッドを呼ぶことによってハッシュに変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The referees tell you the results of each game in the format &lt;c0&gt;Player1 Player2 | 3:2&lt;/c0&gt;, which means that &lt;c1&gt;Player1&lt;/c1&gt; won against &lt;c2&gt;Player2&lt;/c2&gt; by 3 to 2 sets.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T024154Z" creationid="Toshiyuki" creationdate="20131026T012014Z">
        <seg>レフェリーは、あなたに各々のゲームの結果を&lt;c0&gt;Player1 Player2 | 3:2&lt;/c0&gt;というフォーマットで伝えます。それは&lt;c1&gt;Player1&lt;/c1&gt;が3対2セットで&lt;c2&gt;Player2&lt;/c2&gt;に対して勝利したことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The regex does &lt;e0&gt;not&lt;/e0&gt; match the string &lt;c1&gt;eggs, milk, sugarandflour&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T042143Z" creationid="Toshiyuki" creationdate="20140222T021106Z">
        <seg>正規表現は、文字列に&lt;c1&gt;eggs, milk, sugarandflour&lt;/c1&gt;にマッチするものを見つけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The regex first anchors to a left word boundary with &lt;c0&gt;«&lt;/c0&gt; so that it doesn't match partial duplication of words.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T034739Z" creationid="Toshiyuki" creationdate="20140321T034739Z">
        <seg>最初の正規表現は&lt;c0&gt;«&lt;/c0&gt;で左の単語境界に固定するので、部分的なワードの重複にマッチしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The regex first anchors to a left word boundary with &lt;c0&gt;�&lt;/c0&gt; so that it doesn't match partial duplication of words.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T013603Z" creationid="Toshiyuki" creationdate="20140222T013603Z">
        <seg>最初の正規表現は&lt;c0&gt;�&lt;/c0&gt;で左の単語境界に固定するので、部分的なワードの重複にマッチしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of quicksort is a couple of recursive calls to sort both partitions:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T120624Z" creationid="Toshiyuki" creationdate="20140113T073553Z">
        <seg>残りのクイックソートは両方の分割を分類する二、三の再帰的呼び出しです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the expression is merely a list of constants evaluated, then discarded.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T112604Z" creationid="Toshiyuki" creationdate="20131027T112604Z">
        <seg>式の残りは単に定数と評価されるリストで、破棄されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the parameters are dependent &lt;c0&gt;Task&lt;/c0&gt; instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T090212Z" creationid="Toshiyuki" creationdate="20140112T090212Z">
        <seg>残りのパラメータは従属する&lt;c0&gt;Task&lt;/c0&gt;のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of this chapter assumes some implicit knowledge that readers likely won't have now.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T001811Z" creationid="Toshiyuki" creationdate="20140224T162827Z">
        <seg>この章の残りは、読者が現在は望んでいないと思われるいくつかの潜在的な知識を想定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of a conditional statement is the result of the block chosen to execute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T044423Z" creationid="Toshiyuki" creationdate="20130803T044423Z">
        <seg>条件文の結果はブロックが実行に選んだ結果になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value is a list of &lt;c1&gt;Pair&lt;/c1&gt; objects, the keys of which are the names or numbers of the capture and the values the corresponding &lt;c2&gt;Match&lt;/c2&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134608Z" creationid="Toshiyuki" creationdate="20140222T025341Z">
        <seg>戻り値は&lt;c1&gt;Pair&lt;/c1&gt;オブジェクトのリストで、名前のキーまたはキャプチャーと値の数に対応する&lt;c2&gt;Match&lt;/c2&gt;オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The right side of the &lt;c2&gt;+&lt;/c2&gt; operator is more complicated.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T061121Z" creationid="Toshiyuki" creationdate="20131027T061121Z">
        <seg>右側の&lt;c2&gt;+&lt;/c2&gt;演算子はより複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The right-hand side calls a &lt;e0&gt;method&lt;/e0&gt; --a named group of behavior-- named &lt;c1&gt;get&lt;/c1&gt; on the file handle stored in &lt;c2&gt;$file&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154544Z" creationid="Toshiyuki" creationdate="20131026T041036Z">
        <seg>右側は&lt;e0&gt;メソッド&lt;/e0&gt; ― 名前を付けられた振る舞いのグループ ― &lt;c1&gt;get&lt;/c1&gt;を&lt;c2&gt;$file&lt;/c2&gt;に格納されたファイルハンドルに対して呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The right-hand side of the assignment is a call to a method named &lt;c1&gt;split&lt;/c1&gt;, passing along the string &lt;c2&gt;' | '&lt;/c2&gt; as an argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T103107Z" creationid="Toshiyuki" creationdate="20131026T102734Z">
        <seg>割り当ての右側は&lt;c1&gt;split&lt;/c1&gt;という名前のメソッドの呼び出しです。文字列&lt;c2&gt;' | '&lt;/c2&gt;を引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The role &lt;c0&gt;AnswerIfTalkedTo&lt;/c0&gt; declares a stub for the method &lt;c1&gt;bot-nick&lt;/c1&gt;, but never provides an implementation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T033601Z" creationid="Toshiyuki" creationdate="20140115T141724Z">
        <seg>ロール&lt;c0&gt;AnswerIfTalkedTo&lt;/c0&gt;はメソッド&lt;c1&gt;bot-nick&lt;/c1&gt;のためにスタブを宣言しますが、実装を決して提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The role composer will produce a compile-time error about this conflict, asking the programmer to provide a resolution.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T020125Z" creationid="Toshiyuki" creationdate="20140115T140003Z">
        <seg>ロールコンポーザーはこの競合についてコンパイル時エラーを出すでしょう。そして、プログラマーに解決を提供するよう頼みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The role composer will verify that all of the role's requirements are satisfied once and only once, and from then on Perl's type system will consider all instances of the class as corresponding to the type implied by the role.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T023421Z" creationid="Toshiyuki" creationdate="20140115T140600Z">
        <seg>ロールコンポーザーはロールの必要条件のすべてが一回だけ満たされることを確かめるでしょう。そしてその時以来、Perlの型システムはクラスの全てのインスタンスがロールによる型と暗黙に一致することをよく考えるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The routine returns &lt;c0&gt;0&lt;/c0&gt; to indicate a draw.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T115233Z" creationid="Toshiyuki" creationdate="20140113T050939Z">
        <seg>ルーチンはドローを示すために&lt;c0&gt;0&lt;/c0&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules for deciding if a value is true or false depend on the type of the value:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021335Z" creationid="Toshiyuki" creationdate="20140322T021335Z">
        <seg>値が真か偽か決定する規則は、型の値に依存します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second declaration also uses the private twigil:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182749Z" creationid="Toshiyuki" creationdate="20140111T182749Z">
        <seg>2回目の宣言も、プライベートtwigilを使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second example makes the comparison case insensitive by comparing not the values, but their upper case equivalents.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T124536Z" creationid="Toshiyuki" creationdate="20131029T124536Z">
        <seg>第2の例は比較を値でなく、それらの大文字の等価物を比較することによって大文字と小文字の区別をしなくします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second extracts the results for each player and stores them in &lt;c2&gt;$r1&lt;/c2&gt; and &lt;c3&gt;$r2&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T115711Z" creationid="Toshiyuki" creationdate="20131026T115711Z">
        <seg>2番目は各々のプレーヤーの成績を得て、それらを&lt;c2&gt;$r1&lt;/c2&gt;と&lt;c3&gt;$r2&lt;/c3&gt;に保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second method contains the main logic of the dependency handler:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T190532Z" creationid="Toshiyuki" creationdate="20140111T190532Z">
        <seg>第2のメソッドは、依存ハンドラーのメインのロジックを含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics of &lt;c0&gt;INIT&lt;/c0&gt; and &lt;c1&gt;once&lt;/c1&gt; are not equivalent to each other in the case of cloned closures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030444Z" creationid="Toshiyuki" creationdate="20130822T030444Z">
        <seg>&lt;c0&gt;INIT&lt;/c0&gt;と&lt;c1&gt;once&lt;/c1&gt;のセマンティクスは他のそれぞれの複製されたクロージャとは同等ではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The separator can itself be a regex.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T033635Z" creationid="Toshiyuki" creationdate="20140221T225730Z">
        <seg>セパレーター自体を正規表現にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The separator is matched between two occurrences of the quantified regex.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T225704Z" creationid="Toshiyuki" creationdate="20140221T225704Z">
        <seg>セパレーターは2つの数量化された正規表現の間にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The signature &lt;c9&gt;(::T $, T $)&lt;/c9&gt; will bind only two objects of the same type, or where the second is a subtype of the first.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114700Z" creationid="Toshiyuki" creationdate="20140113T050851Z">
        <seg>シグネチャー&lt;c9&gt;(::T $, T $)&lt;/c9&gt;は同じ型の2つのオブジェクトをバインドするか、2番目は1番目のサブタイプです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The signature binding approach might seem clumsy, but when you use it in the main signature of a subroutine, you get tremendous power:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T042107Z" creationid="Toshiyuki" creationdate="20140110T170436Z">
        <seg>シグネチャーバインディングアプローチは不恰好かもしれませんが、サブルーチンのメインのシグネチャーでそれを使うとき、あなたは相当なパワーを得ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The signature of the method &lt;c1&gt;on-message&lt;/c1&gt; captures the invocant into a variable &lt;c2&gt;$self&lt;/c2&gt; marked &lt;c3&gt;rw&lt;/c3&gt;, which indicates that the invocant may be modified.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T123515Z" creationid="Toshiyuki" creationdate="20140115T142239Z">
        <seg>メソッド&lt;c1&gt;on-message&lt;/c1&gt;のシグネチャーは、インボカントが変更されることを示す&lt;c3&gt;rw&lt;/c3&gt;にマークされた変数&lt;c2&gt;$self&lt;/c2&gt;のインボカントを捕えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The signature will only match if the multi has a single parameter which is an empty list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T120136Z" creationid="Toshiyuki" creationdate="20140113T073510Z">
        <seg>マルチが空のリストである一つのパラメータを持っているならば、シグネチャーはマッチするだけでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The similarity of grammars to classes goes deeper than storing regexes in a namespace as a class might store methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T223314Z" creationid="Toshiyuki" creationdate="20140223T101402Z">
        <seg>グラマーとクラスの類似性は、クラスがメソッドを格納するように正規表現を名前空間に格納するよりより深いものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest case of a regex is a constant string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124243Z" creationid="Toshiyuki" creationdate="20140115T143508Z">
        <seg>正規表現で最も単純なケースは固定文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest enhancement is to allow such a comment in any place where whitespace is valid.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T224411Z" creationid="Toshiyuki" creationdate="20140223T102743Z">
        <seg>最も単純な拡張は、空白が有効なところでそのようなコメントを許可することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest way to sort the players by score would be &lt;c0&gt;@names.sort({ %matches{$_} })&lt;/c0&gt;, which sorts by number of matches won.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T144815Z" creationid="Toshiyuki" creationdate="20131026T144815Z">
        <seg>スコアによってプレイヤーをソートする最も単純な方法は&lt;c0&gt;@names.sort({ %matches{$_} })&lt;/c0&gt;です。それは試合に勝った数でソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The smart match operator always decides what kind of comparison to do based upon the type of the value on the right hand side.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T125346Z" creationid="Toshiyuki" creationdate="20131029T125346Z">
        <seg>スマートマッチ演算子は、常に右側の値の型に基づいてどんな比較をするべきかについて決めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The solution to this is the same as with the cycle-detection in Question 2: introducing an attribute &lt;c9&gt;$!started&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T214023Z" creationid="Toshiyuki" creationdate="20140314T214023Z">
        <seg>これの解決は問題2の循環検出と同じです：属性&lt;c9&gt;$!started&lt;/c9&gt;を導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sort method then orders the values according to that return value:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T124359Z" creationid="Toshiyuki" creationdate="20131029T124359Z">
        <seg>sortメソッドはその返り値によって値を整理します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The special variable &lt;c0&gt;$/&lt;/c0&gt; stores the &lt;e1&gt;match object&lt;/e1&gt;, which allows you inspect the matched text.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124514Z" creationid="Toshiyuki" creationdate="20140117T181750Z">
        <seg>特殊変数&lt;c0&gt;$/&lt;/c0&gt;は&lt;e1&gt;マッチオブジェクト&lt;/e1&gt;を格納します。そして、それはあなたがマッチしたテキストを調べることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specific implementation used to run this test actually executes the &lt;c4&gt;where&lt;/c4&gt;-block twice.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T225036Z" creationid="Toshiyuki" creationdate="20140112T224924Z">
        <seg>実際にこのテストを走らせるのに用いられる特定の実装は、二回&lt;c4&gt;where&lt;/c4&gt;ブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The statement form can be particularly useful to expose a lexically scoped declaration to the surrounding lexical scope without "trapping" it inside a block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T084118Z" creationid="Toshiyuki" creationdate="20130818T084118Z">
        <seg>文形式はブロック内の「トラッピング」なしのレキシカルスコープで囲まれた宣言を公開するのに便利だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string matched by the first group of parentheses is available in &lt;c3&gt;$/[0]&lt;/c3&gt;, the second in &lt;c4&gt;$/[1]&lt;/c4&gt;, etc. &lt;c5&gt;$/&lt;/c5&gt; acts as an array containing the captures from each parentheses group:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T034512Z" creationid="Toshiyuki" creationdate="20140221T233644Z">
        <seg>最初のグループの括弧でマッチした文字列は&lt;c3&gt;$/[0]&lt;/c3&gt;で利用できます。2番目は&lt;c4&gt;$/[1]&lt;/c4&gt;、など。&lt;c5&gt;$/&lt;/c5&gt;はそれぞれの括弧グループのキャプチャーを含む配列として振る舞います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for this &lt;e3&gt;backreference&lt;/e3&gt; is a dollar sign followed by the name of the capture in angle brackets (footnote: In grammars--see (grammars)--&lt;c4&gt;&lt;word&gt;&lt;/c4&gt; looks up a regex named &lt;c5&gt;word&lt;/c5&gt; in the current grammar and parent grammars, and creates a capture of the same name.).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130346Z" creationid="Toshiyuki" creationdate="20140222T015432Z">
        <seg>この&lt;e3&gt;後方参照&lt;/e3&gt;のための構文は、かぎ括弧でキャプチャーという名で追従されるドル記号です（脚注：grammarsで－grammars（文法）を見てください－&lt;c4&gt;&lt;word&gt;&lt;/c4&gt;は現在の文法と親文法で&lt;c5&gt;word&lt;/c5&gt;という名の正規表現の上で見て、同じ名前のキャプチャーを作ります。）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax of calling method with &lt;c0&gt;.^&lt;/c0&gt; instead of a single dot means that it is actually a method call on the &lt;e1&gt;meta class&lt;/e1&gt;, which is a class managing the properties of the &lt;c2&gt;Employee&lt;/c2&gt; class - or any other class you are interested in.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T151834Z" creationid="Toshiyuki" creationdate="20140112T160227Z">
        <seg>シングルドットの代わりの&lt;c0&gt;.^&lt;/c0&gt;は実際は&lt;e1&gt;メタクラス&lt;/e1&gt;のメソッドコールで、それは&lt;c2&gt;Employee&lt;/c2&gt;のプロパティを管理します ― またはあなたが興味のある他のクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third attribute represents the state of completion of a task:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T183131Z" creationid="Toshiyuki" creationdate="20140111T183131Z">
        <seg>第3の属性は、仕事の完成の状態を表します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three-way comparison operators take two operands, and return &lt;c0&gt;Order::Increase&lt;/c0&gt; if the left is smaller, &lt;c1&gt;Order::Same&lt;/c1&gt; when both are equal, and &lt;c2&gt;Order::Decrease&lt;/c2&gt; if the right operand is smaller (footnote: &lt;c3&gt;Order::Increase&lt;/c3&gt;, &lt;c4&gt;Order::Same&lt;/c4&gt;, and &lt;c5&gt;Order::Decrease&lt;/c5&gt; are enumerations (enums); see &lt;a6&gt;link&lt;/a6&gt; ).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T141133Z" creationid="Toshiyuki" creationdate="20131028T141038Z">
        <seg>三者間の比較演算子は2つのオペランドを取り、左がより小さいなら&lt;c0&gt;Order::Increase&lt;/c0&gt;を、両者が等しいなら&lt;c1&gt;Order::Same&lt;/c1&gt;を、右のオペランドがより小さいなら&lt;c2&gt;Order::Decrease&lt;/c2&gt;を返します（注釈：&lt;c3&gt;Order::Increase&lt;/c3&gt;、 &lt;c4&gt;Order::Same&lt;/c4&gt;、そして&lt;c5&gt;Order::Decrease&lt;/c5&gt;は列挙（enums）です；&lt;a6&gt;リンク&lt;/a6&gt;を見てください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The trigonometric functions &lt;c0&gt;sin&lt;/c0&gt;, &lt;c1&gt;cos&lt;/c1&gt;, &lt;c2&gt;tan&lt;/c2&gt;, &lt;c3&gt;asin&lt;/c3&gt;, &lt;c4&gt;acos&lt;/c4&gt;, &lt;c5&gt;atan&lt;/c5&gt;, &lt;c6&gt;sec&lt;/c6&gt;, &lt;c7&gt;cosec&lt;/c7&gt;, &lt;c8&gt;cotan&lt;/c8&gt;, &lt;c9&gt;asec&lt;/c9&gt;, &lt;c10&gt;acosec&lt;/c10&gt;, &lt;c11&gt;acotan&lt;/c11&gt;, &lt;c12&gt;sinh&lt;/c12&gt;, &lt;c13&gt;cosh&lt;/c13&gt;, &lt;c14&gt;tanh&lt;/c14&gt;, &lt;c15&gt;asinh&lt;/c15&gt;, &lt;c16&gt;acosh&lt;/c16&gt;, &lt;c17&gt;atanh&lt;/c17&gt;, &lt;c18&gt;sech&lt;/c18&gt;, &lt;c19&gt;cosech&lt;/c19&gt;, &lt;c20&gt;cotanh&lt;/c20&gt;, &lt;c21&gt;asech&lt;/c21&gt;, &lt;c22&gt;acosech&lt;/c22&gt; and &lt;c23&gt;acotanh&lt;/c23&gt; work in units of radians by default.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020127Z" creationid="Toshiyuki" creationdate="20140322T020127Z">
        <seg>三角関数&lt;c0&gt;sin&lt;/c0&gt;、&lt;c1&gt;cos&lt;/c1&gt;、&lt;c2&gt;tan&lt;/c2&gt;、&lt;c3&gt;asin&lt;/c3&gt;、&lt;c4&gt;acos&lt;/c4&gt;、&lt;c5&gt;atan&lt;/c5&gt;、&lt;c6&gt;sec&lt;/c6&gt;、&lt;c7&gt;cosec&lt;/c7&gt;、&lt;c8&gt;cotan&lt;/c8&gt;、&lt;c9&gt;asec&lt;/c9&gt;、&lt;c10&gt;acosec&lt;/c10&gt;、&lt;c11&gt;acotan&lt;/c11&gt;、&lt;c12&gt;sinh&lt;/c12&gt;、&lt;c13&gt;cosh&lt;/c13&gt;、&lt;c14&gt;tanh&lt;/c14&gt;、&lt;c15&gt;asinh&lt;/c15&gt;、&lt;c16&gt;acosh&lt;/c16&gt;、&lt;c17&gt;atanh&lt;/c17&gt;、&lt;c18&gt;sech&lt;/c18&gt;、&lt;c19&gt;cosech&lt;/c19&gt;、&lt;c20&gt;cotanh&lt;/c20&gt;、&lt;c21&gt;asech&lt;/c21&gt;、&lt;c22&gt;acosech&lt;/c22&gt;、&lt;c23&gt;acotanh&lt;/c23&gt;はデフォルトでラジアン単位で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type inside the parens indicates the acceptable set of types that are allowed to be bound or assigned to this location via coercion.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140407T124932Z" creationid="Toshiyuki" creationdate="20140407T124932Z">
        <seg>括弧の内側の型は、強制によってこの場所にバインドするか割り当てられることを許可された許容できる型のセットを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unhandled list is a dynamic variable so that it's easy for .resume to manipulate it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115244Z" creationid="Toshiyuki" creationdate="20130814T115244Z">
        <seg>ハンドルされないリストはダイナミックな変数なので.resumeがそれを扱うのは簡単だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The upshot of this is that--after reading the chapter on writing classes and methods--you too will be able to write things that can smart-match just by implementing an &lt;c3&gt;ACCEPTS&lt;/c3&gt; method to do the right thing.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T125116Z" creationid="Toshiyuki" creationdate="20131029T130611Z">
        <seg>これの結果は ― クラスとメソッドを記述した章を読んだ後に ― 正しいことをするために&lt;c3&gt;ACCEPTS&lt;/c3&gt;メソッドを実装するだけでスマートマッチできるものを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of the term &lt;e0&gt;bound&lt;/e0&gt; instead of &lt;e1&gt;assigned&lt;/e1&gt; is significant here.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131129T145947Z" creationid="Toshiyuki" creationdate="20131129T145747Z">
        <seg>&lt;e0&gt;バインドされた&lt;/e0&gt;という用語を&lt;e1&gt;割り当てられた&lt;/e1&gt;の代わりに使うことはここでは重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a loop statement is the list of values from each iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T131033Z" creationid="Toshiyuki" creationdate="20130808T131033Z">
        <seg>ループ文の値はそれぞれの反復の値のリストになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the conditional expression may be optionally bound to a closure parameter:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T045847Z" creationid="Toshiyuki" creationdate="20130804T045847Z">
        <seg>条件式の値はクロージャのパラメータに任意に結び付けられるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned by the &lt;c0&gt;take&lt;/c0&gt; to the &lt;c1&gt;take&lt;/c1&gt;'s own context is that same returned argument (which is ignored when the &lt;c2&gt;take&lt;/c2&gt; is in sink context).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T203222Z" creationid="Toshiyuki" creationdate="20130810T203222Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;から&lt;c1&gt;take&lt;/c1&gt;自身のコンテキストに返された値は返された同じ引数だ（それは&lt;c2&gt;take&lt;/c2&gt;がsinkコンテキストの時は無視される）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The various comparison operators all coerce their arguments to certain types before comparing them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T034317Z" creationid="Toshiyuki" creationdate="20131029T124624Z">
        <seg>いろいろな比較演算子は、それらを比較する前に特定の型に対するそれらの引数をすべて自動変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word &lt;c2&gt;returns&lt;/c2&gt; is allowed as an alias for &lt;c3&gt;of&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T212945Z" creationid="Toshiyuki" creationdate="20140328T212945Z">
        <seg>&lt;c2&gt;returns&lt;/c2&gt;が&lt;c3&gt;of&lt;/c3&gt;の別名として使用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word character after the comma is not part of the match, because it is in a look-ahead introduced by &lt;c0&gt;&lt;&amp;quest;before ... &gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T132840Z" creationid="Toshiyuki" creationdate="20140322T132812Z">
        <seg>コンマの後のワード文字はマッチの一部ではありません。なぜなら&lt;c0&gt;&lt;&amp;quest;before ... &gt;&lt;/c0&gt;によって導入される先読みだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word character after the comma is not part of the match, because it is in a look-ahead introduced by &lt;c0&gt;&lt;?before ... &gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T133728Z" creationid="Toshiyuki" creationdate="20140321T071703Z">
        <seg>コンマの後のワード文字はマッチの一部ではありません。なぜなら&lt;c0&gt;&lt;？before ... &gt; &lt;/c0&gt;によって導入される先読みだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then it matches the previous capture followed by a right word boundary.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130047Z" creationid="Toshiyuki" creationdate="20140222T013849Z">
        <seg>それから、適切な単語境界が続く前のキャプチャーにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then it returns the incremented value; &lt;c6&gt;my $x = 1; say ++$x&lt;/c6&gt; prints &lt;c7&gt;2&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T142731Z" creationid="Toshiyuki" creationdate="20131026T142731Z">
        <seg>そうすると、それはインクリメントされた値を返します；&lt;c6&gt;my $x = 1; say ++$x&lt;/c6&gt;は&lt;c7&gt;2&lt;/c7&gt;と出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then press Compose-key and the "greater than" key twice.) or text editor (footnote: Emacs users can type C-x 8 Enter 00bb Enter, vim users can type &lt;c2&gt;C-k &gt;&gt;&lt;/c2&gt;.) does not make it easy to write it you can also write it using two angle brackets (&lt;c3&gt;&gt;&gt;&lt;/c3&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T033125Z" creationid="Toshiyuki" creationdate="20140322T032935Z">
        <seg>Then press Compose-key and the "greater than" key twice.)またはテキストエディタ(footnote: Emacs users can type C-x 8 Enter 00bb Enter, vim users can type &lt;c2&gt;C-k &gt;&gt;&lt;/c2&gt;.)がそれを入力するのが簡単でないなら、2つのアングルブラケットを使うこともできます（&lt;c3&gt;&gt;&gt;&lt;/c3&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are actually two assignment operators with different precedence.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T114209Z" creationid="Toshiyuki" creationdate="20131027T114209Z">
        <seg>優先順位の異なる2つの割り当て演算子が現に存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are multiple ways to write &lt;c1&gt;Pair&lt;/c1&gt;s.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T145759Z" creationid="Toshiyuki" creationdate="20140104T145759Z">
        <seg>&lt;c1&gt;Pair&lt;/c1&gt;を書くには複数の方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several ways to compare objects in Perl.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T125102Z" creationid="Toshiyuki" creationdate="20131027T125102Z">
        <seg>Perlではオブジェクトを比較するいくつかの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three ways to declare formal parameters to a closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T123503Z" creationid="Toshiyuki" creationdate="20130729T123503Z">
        <seg>クロージャに仮パラメータを宣言する方法が3つある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two other variants.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140115T141357Z" creationid="Toshiyuki" creationdate="20140115T141357Z">
        <seg>2つの他の異形があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There does not seem to be a prevailing term in the industry for this, so we've coined the term &lt;i1&gt;lexotic&lt;/i1&gt; to refer to these strange operations that perform a dynamic operation with a lexical target in mind.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T010232Z" creationid="Toshiyuki" creationdate="20130728T005906Z">
        <seg>これに関して業界で一般的な語句が無いように思う。そういうわけで、レキシカルなターゲットを考慮して動的な操作を行うこれらの奇妙な操作を言及するために、我々は&lt;i1&gt;レギゾチック&lt;/i1&gt;という語句を作った。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a &lt;c0&gt;when&lt;/c0&gt; statement modifier, but it does not have any breakout semantics; it is merely a smartmatch against the current topic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121031Z" creationid="Toshiyuki" creationdate="20130813T121031Z">
        <seg>&lt;c0&gt;when&lt;/c0&gt;文修飾子があるが、なんの脱出のセマンティクスも持たない。それは単に現在のトピックに反してスマートマッチする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a new &lt;c0&gt;state&lt;/c0&gt; declarator that introduces a lexically scoped variable like &lt;c1&gt;my&lt;/c1&gt; does, but with a lifetime that persists for the life of the closure, so that it keeps its value from the end of one call to the beginning of the next.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133110Z" creationid="Toshiyuki" creationdate="20130802T133110Z">
        <seg>新しい&lt;c0&gt;state&lt;/c0&gt;宣言は&lt;c1&gt;my&lt;/c1&gt;がするようなレキシカルスコープの変数をもたらす。しかしライフタイムがクロージャの寿命の間持続するので、呼び出しの終わりから次の呼び出しまで値を保持する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a special value named &lt;c0&gt;Nil&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132633Z" creationid="Toshiyuki" creationdate="20140327T132633Z">
        <seg>&lt;c0&gt;Nil&lt;/c0&gt;という名前の特殊な値があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a &lt;c2&gt;let&lt;/c2&gt; prefix operator that sets a hypothetical value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T134150Z" creationid="Toshiyuki" creationdate="20130802T134150Z">
        <seg>仮想の値をセットする&lt;c2&gt;let&lt;/c2&gt;接頭演算子もある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no &lt;c0&gt;foreach&lt;/c0&gt; statement any more.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060705Z" creationid="Toshiyuki" creationdate="20130810T060705Z">
        <seg>今や&lt;c0&gt;foreach&lt;/c0&gt;文は存在しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no corresponding native &lt;c1&gt;str&lt;/c1&gt; type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T131141Z" creationid="Toshiyuki" creationdate="20140328T131141Z">
        <seg>対応するネイティブ&lt;c1&gt;str&lt;/c1&gt;型はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no longer a &lt;c0&gt;continue&lt;/c0&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130739Z" creationid="Toshiyuki" creationdate="20130808T130739Z">
        <seg>もはや&lt;c0&gt;continue&lt;/c0&gt;ブロックはない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the code calls the &lt;c1&gt;.reverse&lt;/c1&gt; method on the result of the second sort, and stores the final list in &lt;c2&gt;@sorted&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T151352Z" creationid="Toshiyuki" creationdate="20131026T151352Z">
        <seg>したがって、コードは第2のソートの結果に対して&lt;c1&gt;.reverse&lt;/c1&gt;メソッドを呼び出し、最終のリストを&lt;c2&gt;@sorted&lt;/c2&gt;に保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T201344Z" creationid="Toshiyuki" creationdate="20140104T201344Z">
        <seg>したがって：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These &lt;e2&gt;character classes&lt;/e2&gt; follow the Unicode definition of what is a letter, a number, and so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T125217Z" creationid="Toshiyuki" creationdate="20140117T182617Z">
        <seg>これらの&lt;e2&gt;文字クラス&lt;/e2&gt;は何が文字、数などであるかというユニコード定義に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These adverbial forms all weed out non-existing entries if the adverb is true; if not, they leave them in, just as an ordinary slice would.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T084850Z" creationid="Toshiyuki" creationdate="20140329T084715Z">
        <seg>副詞が真である場合はこれらの副詞形式は存在しないエントリーを全て除きます。そうでなければ、通常のスライスのようにそれらを残します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These aliases are also available inside the regex.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T125939Z" creationid="Toshiyuki" creationdate="20140222T010426Z">
        <seg>これらの別名は正規表現の中でも利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are far cheaper to check than constraint checks.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T114142Z" creationid="Toshiyuki" creationdate="20140113T044759Z">
        <seg>制約がチェックするより、これらをチェックするのははるかに安いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are storage locations that every instance of a class will obtain.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182109Z" creationid="Toshiyuki" creationdate="20140111T182109Z">
        <seg>これらは、クラスのすべてのインスタンスが得るだろう記憶場所です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are taken at face value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T074331Z" creationid="Toshiyuki" creationdate="20130811T074331Z">
        <seg>それらは表面通りの意味でとられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These auto-called blocks are known as &lt;i1&gt;phasers&lt;/i1&gt;, since they generally mark the transition from one phase of computing to another.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T080249Z" creationid="Toshiyuki" creationdate="20130818T080249Z">
        <seg>これらの自動呼び出しされるブロックは&lt;i1&gt;phasers&lt;/i1&gt;として知られる。だから一つの計算フェーズから他への移行を一般的にマークする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These captures are again &lt;c3&gt;Match&lt;/c3&gt; objects, so match objects are really trees of matches.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T091838Z" creationid="Toshiyuki" creationdate="20140222T025240Z">
        <seg>これらのキャプチャーは再び &lt;c3&gt;Match&lt;/c3&gt;オブジェクトであるので、マッチオブジェクトは本当にマッチのツリーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These circumfix square brackets are the &lt;e0&gt;reduction meta operator&lt;/e0&gt;, which transforms the enclosed infix operator into an operator that expects a list (a &lt;e1&gt;listop&lt;/e1&gt;), and carries out the operation between each two consecutive list items.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T064544Z" creationid="Toshiyuki" creationdate="20131027T064544Z">
        <seg>これらの接周辞角括弧は&lt;e0&gt;縮小メタ演算子&lt;/e0&gt;です。囲っている接中辞演算子をリストを期待する演算子（&lt;e1&gt;listop&lt;/e1&gt;）に変え、各々の2連続リストアイテムの間で演算を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constructs establish a dynamic scope without necessarily establishing a lexical scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T080849Z" creationid="Toshiyuki" creationdate="20130811T080849Z">
        <seg>これらの構成物はレキシカルスコープを確立する必要なしに動的スコープを確立する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These dispatch forms may seem rare, but they're very useful for event driven programming.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T033423Z" creationid="Toshiyuki" creationdate="20140115T141535Z">
        <seg>これらのディスパッチ形式は珍しく見えます。しかし、それらはイベント駆動プログラミングのために非常に有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These have the advantage of passing the variable in question into the closure as its topic:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093134Z" creationid="Toshiyuki" creationdate="20130818T093134Z">
        <seg>そのトピックとしてのクロージャ内の問題の変数に渡すアドバンテージをそれらは持つ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These implementations have in turn influenced the design of the language by highlighting misfeatures, contradictions, or features of difficult implementation and little benefit.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T022834Z" creationid="Toshiyuki" creationdate="20131025T215505Z">
        <seg>これらの実装は設計ミス、矛盾または困難な実装と利便性の小さい機能を強調することによって、言語のデザインに次々に影響を与えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These items each specify a task that must be completed before the present one can complete.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T183034Z" creationid="Toshiyuki" creationdate="20140111T183034Z">
        <seg>これらのアイテムは、完了することができる現在の前に完了しなければならない仕事を各々指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These lines loop over the items in &lt;c0&gt;@scores&lt;/c0&gt;, binding them to the special variable &lt;c1&gt;$_&lt;/c1&gt; one at a time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T070806Z" creationid="Toshiyuki" creationdate="20131027T070806Z">
        <seg>これらの行は&lt;c0&gt;@scores&lt;/c0&gt;上でループし、1つずつそれらを特殊変数&lt;c1&gt;$_&lt;/c1&gt;に結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These matches extend beyond the ASCII range--&lt;c0&gt;\d&lt;/c0&gt; matches Latin, Arabic-Indic, Devanagari and other digits, &lt;c1&gt;\s&lt;/c1&gt; matches non-breaking whitespace, and so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T125204Z" creationid="Toshiyuki" creationdate="20140117T182600Z">
        <seg>これらのマッチはASCIIの範囲を超えて ― &lt;c0&gt;\d&lt;/c0&gt;はラテン語、アラビア・インド語、デバナーガリーと他の数字にマッチし、&lt;c1&gt;\s&lt;/c1&gt;は非改行空白などにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These need not be identical contexts, since they may bind or coerce the resulting parcels differently:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T035929Z" creationid="Toshiyuki" creationdate="20130811T035929Z">
        <seg>それらは同一のコンテキストを必要としない。だから結果として生じるパーセルを違うようにバインドするか強制する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These roles are generally not used directly as object types.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130018Z" creationid="Toshiyuki" creationdate="20140328T130018Z">
        <seg>これらのロールがオブジェクト型として直接使われることは通常ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These three calls all mean the same thing:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T012959Z" creationid="Toshiyuki" creationdate="20140104T154139Z">
        <seg>これら3つの呼び出しは同じことを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two lines of code declare two hashes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140307T154913Z" creationid="Toshiyuki" creationdate="20131026T083256Z">
        <seg>2行のコードは、2つのハッシュを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two tasks contradict each other to some degree.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140115T101527Z" creationid="Toshiyuki" creationdate="20140115T101527Z">
        <seg>これらの2つのタスクは、ある程度互いに反対します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These variables are called &lt;e0&gt;parameters&lt;/e0&gt; (footnote: In this book, we will use the traditional convention of using the term &lt;e1&gt;parameters&lt;/e1&gt; when referring to the variables in a subroutine's signature and &lt;e2&gt;arguments&lt;/e2&gt; when referring to the values actually passed when a subroutine is called.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T035423Z" creationid="Toshiyuki" creationdate="20131126T124021Z">
        <seg>それらの変数は&lt;e0&gt;パラメータ&lt;/e0&gt;と呼ばれます（脚注：この本では、我々は従来の表記法の&lt;e1&gt;パラメータ&lt;/e1&gt;をサブルーチンシグネチャーの変数とサブルーチンが呼ばれた時に実際に参照する&lt;e2&gt;引数&lt;/e2&gt;に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They also provide a mechanism for code re-use.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122434Z" creationid="Toshiyuki" creationdate="20140115T101431Z">
        <seg>それらはコード再利用のメカニズムも提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They have a special calling syntax, and can manipulate each other.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T044137Z" creationid="Toshiyuki" creationdate="20131027T044137Z">
        <seg>それらには特別な呼び出し構文があって、互いを操作することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They parse the same as phasers:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T082139Z" creationid="Toshiyuki" creationdate="20130818T082139Z">
        <seg>それらはphasersと同じにパースする：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They represent entities in the system, providing models from which to create instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122509Z" creationid="Toshiyuki" creationdate="20140115T101320Z">
        <seg>それらはシステムで実体を意味します。そしてインスタンスをつくるモデルを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They transform the information they extract from the match object into native Perl 6 data structures, and call &lt;c0&gt;make&lt;/c0&gt; to set those native structures as their own ASTs.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T012433Z" creationid="Toshiyuki" creationdate="20140226T142221Z">
        <seg>それらはマッチオブジェクトから抜き出した情報をネイティブのPerl 6データ構造に変換して、それらのネイティブ構造を彼ら自身のASTとしてセットするために&lt;c0&gt;make&lt;/c0&gt;を呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;e1&gt;subsignature&lt;/e1&gt; also acts as a constraint on the array parameter: the signature binding will fail unless the list in the capture contains at least one item.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T042130Z" creationid="Toshiyuki" creationdate="20140110T174421Z">
        <seg>この&lt;e1&gt;サブシグネチャー&lt;/e1&gt;は配列パラメータの制約としても働きます：キャプチャーのリストが少なくとも1つのアイテムを含まない限り、シグネチャーバインディングは失敗するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;e3&gt;encapsulation&lt;/e3&gt; is one of the key principles of object oriented design.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182300Z" creationid="Toshiyuki" creationdate="20140111T182300Z">
        <seg>この&lt;e3&gt;カプセル化&lt;/e3&gt;は、オブジェクト指向デザインの重要な原則の1つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This adverb indicates that the given argument must be bound to a concrete object; if not, a runtime exception will be thrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T132259Z" creationid="Toshiyuki" creationdate="20140110T132259Z">
        <seg>この副詞は与えられた引数が具体的なオブジェクトでなければならないことを示します。そうでなければ実行時例外がスローされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows the two expressions &lt;c2&gt;$a = 1, $b = 2&lt;/c2&gt; and &lt;c3&gt;@a = 1, 2&lt;/c3&gt; to both mean something sensible: assignment to two variables in a list, and assignment of a two-item list to a single variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T033644Z" creationid="Toshiyuki" creationdate="20131027T120743Z">
        <seg>これは2つの式&lt;c2&gt;$a = 1, $b = 2&lt;/c2&gt;と&lt;c3&gt;@a = 1, 2&lt;/c3&gt;両方を許します：リストの2つの変数への割り当てと、1つの変数への2アイテムリストの割り当てです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows type objects to be assigned to scalars, but to disappear in non-scalar contexts.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140407T123956Z" creationid="Toshiyuki" creationdate="20140407T123956Z">
        <seg>これにより型オブジェクトはスカラーに割り当てられることができます。しかし非スカラーコンテキストでは消えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to modify the argument inside the subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T000734Z" creationid="Toshiyuki" creationdate="20131205T103611Z">
        <seg>これはサブルーチン内で引数を変更することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to restrict the data type of the value returned from a subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T232658Z" creationid="Toshiyuki" creationdate="20140104T232658Z">
        <seg>これは、サブルーチンから返される値のデータ型を制限することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to write a regex that detects that common error of duplicated words, just like the example at the beginning of this chapter:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T034655Z" creationid="Toshiyuki" creationdate="20140222T013256Z">
        <seg>これは、章の初めの例のような複製されたワードのエラーを見つける正規表現を書くのを可能にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This applies to anything that needs to be looked up at compile time, including names of variables, and named values such as types and subs.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T072719Z" creationid="Toshiyuki" creationdate="20130811T072613Z">
        <seg>これは実行時に探索される必要がある何にでも適用される。変数名、型やサブルーチンのような名前付きの値を含めて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This assertion is &lt;c1&gt;&lt;?after&gt;&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134102Z" creationid="Toshiyuki" creationdate="20140222T024430Z">
        <seg>このアサーションは&lt;c1&gt;&lt;？after&gt;&lt;/c1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This automatic substitution of code with its contents is &lt;e4&gt;interpolation&lt;/e4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T152800Z" creationid="Toshiyuki" creationdate="20131026T152800Z">
        <seg>このコードによる内容の自動置換は&lt;e4&gt;展開&lt;/e4&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This basically gives us list comprehensions as rvalue expressions:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T125239Z" creationid="Toshiyuki" creationdate="20130810T125239Z">
        <seg>これは基本的に右辺値の式としてリストの理解力を我々に与える：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book is a work-in-progress.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T022208Z" creationid="Toshiyuki" creationdate="20140322T022208Z">
        <seg>この本は編集の作業中です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book is primarily for people who want to learn Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T023111Z" creationid="Toshiyuki" creationdate="20131025T222035Z">
        <seg>この本は主にPerl 6を学びたい人々のためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This brings Perl 6 a lot of the expressive power provided by pattern matching in various functional languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T073204Z" creationid="Toshiyuki" creationdate="20140113T073204Z">
        <seg>これは、Perl 6にいろいろな関数型言語でパターンマッチによって提供される多くの表現力豊かなパワーをもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be a bit cumbersome, so in the particular case of labels, the label that is already visible in the current lexical scope is considered a kind of pseudo object specifying a potential dynamic context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T074045Z" creationid="Toshiyuki" creationdate="20130817T074045Z">
        <seg>これは少し扱いづらい。そういうわけでラベルの特定の場合、現在のレキシカルスコープのすでに可視のラベルは潜在的なダイナミックコンテキストを示す擬似オブジェクトの一種とみなされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful to peg some behavior to an empty list while still returning an empty list:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T080629Z" creationid="Toshiyuki" creationdate="20140329T080629Z">
        <seg>これは空のリストを返している間に何らかの振る舞いを空のリストに釘付けるのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This candidate adds two new twists.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T223209Z" creationid="Toshiyuki" creationdate="20140314T223209Z">
        <seg>この候補は2つの新しいひねりを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This candidate will match only &lt;e4&gt;some&lt;/e4&gt; values of the type &lt;c5&gt;Any&lt;/c5&gt;--those where the value is undefined.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T223546Z" creationid="Toshiyuki" creationdate="20140112T222529Z">
        <seg>この候補は&lt;e4&gt;いくつかの&lt;/e4&gt;&lt;c5&gt;Any&lt;/c5&gt;型の値だけにマッチします ― それらは未定義の値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This case behaves the same way as compile-time composition, in that the role composer will compose them all into the imaginary anonymous subclass.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T161004Z" creationid="Toshiyuki" creationdate="20140115T142804Z">
        <seg>ロールコンポーザーが想像上の匿名のサブクラスにそれらのすべてを合成するだろうという点で、このケースはコンパイル時合成と同じ方法でふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter's example uses &lt;c4&gt;\w&lt;/c4&gt; to build the definition of a "word".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124621Z" creationid="Toshiyuki" creationdate="20140117T182303Z">
        <seg>この章の例は、ワードの定義を構築するために&lt;c4&gt;\w&lt;/c4&gt;を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This code defines a single multi sub named &lt;c0&gt;to-json&lt;/c0&gt;, which takes one argument and turns that into a string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T183329Z" creationid="Toshiyuki" creationdate="20140112T183329Z">
        <seg>このコードは&lt;c0&gt;to-json&lt;/c0&gt;という名前のマルチサブを定義し、それは1つの引数を受け取って文字列にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This code defines three multis, one of which increases a counter whenever its &lt;c0&gt;where&lt;/c0&gt; clause executes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112925Z" creationid="Toshiyuki" creationdate="20140112T224331Z">
        <seg>このコードは3つのマルチを定義します。そしてそのwhere節を実行するときはいつでも、その内の一つはカウンターを増やします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This code introduces a regex named &lt;c0&gt;word&lt;/c0&gt;, which matches at least one word character, optionally followed by a single quote and some more word characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130248Z" creationid="Toshiyuki" creationdate="20140222T014628Z">
        <seg>このコードは、&lt;c0&gt;word&lt;/c0&gt;という名前の正規表現を導入します。それは少なくとも1つのワード文字にマッチし、シングルクォートといくつかのワード文字が任意に続くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This construct only allows you to attach a single statement to the end of an expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T121759Z" creationid="Toshiyuki" creationdate="20130810T121759Z">
        <seg>この構成は単独の文の式の末尾だけで可能だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This could be done by pushing the resumed exception onto the unhandled list, and then the thrower checking to see if there is only a single resumed exception in the "unhandled" list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115100Z" creationid="Toshiyuki" creationdate="20130814T115100Z">
        <seg>これはハンドルされないリストの上に再開された例外をプッシュすることで行われ、そのとき例外を投げるものは一つだけの再開された例外が「ハンドルされない」リストにあるなら見るためにチェックする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This delegation is common in object destructors, where each subclass may perform some cleanup for its own particular data.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121401Z" creationid="Toshiyuki" creationdate="20140113T075949Z">
        <seg>このデリゲーションはオブジェクトデストラクタで一般的です。そこで各々のサブクラスはそれ自身の特定のデータのために若干のクリーンアップを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This does not affect any other instances of the same class; only this one instance has changed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140317T124751Z" creationid="Toshiyuki" creationdate="20140115T142614Z">
        <seg>これは、同じクラスの何の他のインスタンスには影響を及ぼしません；この唯一のインスタンスだけが変わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This dynamic control is orthogonal to any lexically scoped warning controls, which merely decide whether to call &lt;c1&gt;warn()&lt;/c1&gt; in the first place.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T120128Z" creationid="Toshiyuki" creationdate="20130817T120128Z">
        <seg>ダイナミックな制御はどんなレキシカルスコープの警告制御にも直交する。そしてそれは単に&lt;c1&gt;warn()&lt;/c1&gt;を呼ぶかどうか最初の場所で決定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This easiest way to do this is by calling the &lt;c0&gt;bless&lt;/c0&gt; method, also inherited from &lt;c1&gt;Object&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T193827Z" creationid="Toshiyuki" creationdate="20140111T193739Z">
        <seg>これをする最も簡単な方法は&lt;c0&gt;bless&lt;/c0&gt;メソッドを呼ぶことで、それも&lt;c1&gt;Object&lt;/c1&gt;から継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example demonstrates how multiple dispatch can encapsulate all of the rules of a popular game.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T045713Z" creationid="Toshiyuki" creationdate="20140113T045713Z">
        <seg>この例は、複数のディスパッチがどのように人気があるゲームの規則の全てをカプセル化することができるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example makes a very simple text output by printing &lt;c0&gt;X&lt;/c0&gt; characters to represent horizontal bars:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T044632Z" creationid="Toshiyuki" creationdate="20131027T044632Z">
        <seg>この例は水平バーを表す&lt;c0&gt;X&lt;/c0&gt;という文字を出力することによって非常に単純なテキスト出力を作ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example passes an actions object to the grammar's &lt;c0&gt;parse&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T232412Z" creationid="Toshiyuki" creationdate="20140224T162325Z">
        <seg>この例は、グラマーの&lt;c0&gt;parse&lt;/c0&gt;メソッドにactionsオブジェクトを渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This explains some of the &lt;e0&gt;why&lt;/e0&gt; of currying, but not much of the &lt;e1&gt;what&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043142Z" creationid="Toshiyuki" creationdate="20140111T043809Z">
        <seg>これは&lt;e0&gt;なぜ&lt;/e0&gt;カリーなのかを説明します。カリーとは&lt;e1&gt;何か&lt;/e1&gt;については多くはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This expression uses the infix operators &lt;c1&gt;-&lt;/c1&gt; and &lt;c2&gt;/&lt;/c2&gt; for numerical calculations.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T065407Z" creationid="Toshiyuki" creationdate="20131027T065407Z">
        <seg>この式は接中辞演算子&lt;c1&gt;-&lt;/c1&gt;と&lt;c2&gt;/&lt;/c2&gt;を数値計算に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This final candidate matches not only objects for which there is no candidate defined, but it can match for &lt;e0&gt;all&lt;/e0&gt; objects, including &lt;c1&gt;Int&lt;/c1&gt;, &lt;c2&gt;Bool&lt;/c2&gt;, &lt;c3&gt;Num&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113624Z" creationid="Toshiyuki" creationdate="20140113T043542Z">
        <seg>この最終的な候補は定義される候補がないオブジェクトとマッチします。しかしそれは&lt;c1&gt;Int&lt;/c1&gt;、&lt;c2&gt;Bool&lt;/c2&gt;、&lt;c3&gt;Num&lt;/c3&gt;を含む&lt;e0&gt;全ての&lt;/e0&gt;オブジェクトとマッチすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function is similar to &lt;c3&gt;printf&lt;/c3&gt; in C and Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T070959Z" creationid="Toshiyuki" creationdate="20131027T070959Z">
        <seg>この機能はC言語とPerl 5の&lt;c3&gt;printf&lt;/c3&gt;に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives a degree of safety, but it happens at runtime and is thus not as safe as compile time composition.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124011Z" creationid="Toshiyuki" creationdate="20140115T142835Z">
        <seg>これはある程度の安全性を与えます。しかしそれは実行時に起こるので、コンパイル時合成ほど安全でありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens both for standard methods defined via the method keyword and for methods generated through other means such as attribute accessors.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144130Z" creationid="Toshiyuki" creationdate="20140112T093159Z">
        <seg>これはmethodキーワードを通して定義される標準的なメソッドのために、そして、属性アクセッサのような他の手段によって発生するメソッドのために起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the added benefit of limiting the scope of the &lt;c0&gt;$line&lt;/c0&gt; parameter to the block it's bound to.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063058Z" creationid="Toshiyuki" creationdate="20130810T063058Z">
        <seg>これはブロックにバインドされた&lt;c0&gt;$line&lt;/c0&gt;パラメータのスコープを制限するという追加の利点を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the effect of switching the match order of the final two atoms (&lt;c13&gt;B&lt;/c13&gt; and &lt;c14&gt;C&lt;/c14&gt;), but since Perl knows that the regex engine should be looking for the goal, a better error message can be given when the goal does not match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T144643Z" creationid="Toshiyuki" creationdate="20140222T133451Z">
        <seg>これは最終的な2つのアトム（&lt;c13&gt;B&lt;/c13&gt;と&lt;c14&gt;C&lt;/c14&gt;）のマッチ順序を変える効果を持っています。しかし正規表現エンジンが最終目的を探すべきであるということをPerlが知っているので、最終目的がマッチしないとき、より良いエラーメッセージが与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This helps Perl 6 provide generic programming, along the lines of generics in C# and Java, or templates in C++.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122625Z" creationid="Toshiyuki" creationdate="20140115T101918Z">
        <seg>C#とJavaのジェネリクスまたはC++のテンプレートの系統に沿って、これはPerl 6がジェネリックプログラミングを提供するのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implicit conversion is called &lt;e4&gt;coercion&lt;/e4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T013516Z" creationid="Toshiyuki" creationdate="20140226T142629Z">
        <seg>この暗黙変換は、&lt;e4&gt;自動型変換&lt;/e4&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implies a right word boundary, so there is no need to use an explicit boundary.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T013831Z" creationid="Toshiyuki" creationdate="20140222T013831Z">
        <seg>これは右の単語境界を示すので、明示的な境界は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes &lt;c0&gt;$_&lt;/c0&gt; and &lt;c1&gt;@_&lt;/c1&gt;, as well as the new &lt;c2&gt;$/&lt;/c2&gt;, which is the return value of the last regex match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090703Z" creationid="Toshiyuki" creationdate="20140329T090703Z">
        <seg>これは&lt;c0&gt;$_&lt;/c0&gt;と&lt;c1&gt;@_&lt;/c1&gt;だけでなく新しい&lt;c2&gt;$/&lt;/c2&gt;、最後の正規表現マッチの戻り値も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interpolation happens only in strings delimited by double quotes &lt;c5&gt;"..."&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T152901Z" creationid="Toshiyuki" creationdate="20131026T152901Z">
        <seg>この展開はダブルクォート&lt;c5&gt;"..."&lt;/c5&gt;で区切られる文字列だけで起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is &lt;e0&gt;greedy&lt;/e0&gt; matching.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T225944Z" creationid="Toshiyuki" creationdate="20140221T225944Z">
        <seg>これは&lt;e0&gt;貪欲&lt;/e0&gt;なマッチングです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a shortcut for:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T115946Z" creationid="Toshiyuki" creationdate="20131026T115946Z">
        <seg>これは以下の短縮形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also an example of candidates with different &lt;e0&gt;arity&lt;/e0&gt; (number of expected arguments).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T035322Z" creationid="Toshiyuki" creationdate="20140113T063756Z">
        <seg>これは、異なる&lt;e0&gt;arity&lt;/e0&gt;（期待される引数の数）を持つ候補の例でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is called &lt;e0&gt;multidispatch&lt;/e0&gt;, and the functions to which Perl can dispatch in this case are &lt;e1&gt;multis&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112237Z" creationid="Toshiyuki" creationdate="20140112T182140Z">
        <seg>これは&lt;e0&gt;マルチディスパッチ&lt;/e0&gt;と呼ばれます。そしてこの場合にPerlがディスパッチできる関数が&lt;e1&gt;multis&lt;/e1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is called &lt;e10&gt;sigil invariance&lt;/e10&gt;.).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T094318Z" creationid="Toshiyuki" creationdate="20131026T094253Z">
        <seg>これは&lt;e10&gt;シギル不変性&lt;/e10&gt;と呼ばれます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is common in substitutions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131652Z" creationid="Toshiyuki" creationdate="20140222T024000Z">
        <seg>これは置換で一般的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is defined as the textually last statement of its top-level list of statements; any statements embedded within those top-level statements are in their own lower-level list of statements and, while they may be a final statement in their subscope, they're not considered the final statement of the outer block in question.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T015413Z" creationid="Toshiyuki" creationdate="20130803T015413Z">
        <seg>これは文の最上位リストの最後のテキスト文として定義される；それら最上位の文に埋め込まれた任意の文がそれらのより低いレベルのリストにあり、そしてそれらがサブスコープの最後の文かもしれないなら、それらは問題の外側のブロックの最後の文とみなされない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is done using the &lt;c0&gt;returns&lt;/c0&gt; trait:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T232727Z" creationid="Toshiyuki" creationdate="20140104T232727Z">
        <seg>これは&lt;c0&gt;returns&lt;/c0&gt;トレイトを使って行います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is equivalent to</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113741Z" creationid="Toshiyuki" creationdate="20130810T113741Z">
        <seg>これは以下と同等だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is especially useful for writing routines that delegate to other routines with the same arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T131008Z" creationid="Toshiyuki" creationdate="20140110T161953Z">
        <seg>これは、特に同じ引数で他のルーチンへのデリゲートを書くのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is exactly like normal alternation, but as we'll see in the next section, has the advantage of being extensible.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T222702Z" creationid="Toshiyuki" creationdate="20140223T095710Z">
        <seg>これはまさに通常の論理和のようです。しかし我々が次のセクションで見るように、拡張可能というアドバンテージを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is how some invocations could look like (footnote: &lt;The use of random numbers through &lt;c0&gt;roll&lt;/c0&gt; means that you will likely see different output if you try it.)&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044723Z" creationid="Toshiyuki" creationdate="20140313T134929Z">
        <seg>これは起動のいくつかの例です（脚注：&lt;c0&gt;roll&lt;/c0&gt;を通しての乱数の使用は、あなたがそれを試すならば、あなたが異なる出力をたぶん見るだろうことを意味します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is how some invocations could look like (footnote: The use of random numbers through &lt;c0&gt;roll&lt;/c0&gt; means that you will likely see different output if you try it.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T173701Z" creationid="Toshiyuki" creationdate="20140111T173701Z">
        <seg>これはいくつかの起動がどのように見えるかです（注釈：&lt;c0&gt;roll&lt;/c0&gt;を通じた乱数はあなたが試したものと違う出力を見るだろうことを意味します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is illustrated in the second &lt;c3&gt;$counter&lt;/c3&gt; output.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113030Z" creationid="Toshiyuki" creationdate="20140112T224837Z">
        <seg>これは第二の$counter出力で例示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is less concise to write, due to the optional second parameter:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T050225Z" creationid="Toshiyuki" creationdate="20140111T050225Z">
        <seg>第2のオプショナルパラメータを書くのは簡潔ではありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is part of the flattening property: after composing a role into the class, the roles in and of themselves are only important when querying the class to determine &lt;e0&gt;if&lt;/e0&gt; it performs the role.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T014232Z" creationid="Toshiyuki" creationdate="20140115T135615Z">
        <seg>これはプロパティ平坦化の一部です：ロールをクラスに合成した後に、ロールを実行するかどうか決定するためにクラスを問い合わせる場合だけ、それら自身は重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is part of the power of smart matching: more complex types can define interesting and useful ways to compare themselves to other things.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T125745Z" creationid="Toshiyuki" creationdate="20131029T125745Z">
        <seg>これは、スマートマッチングのパワーの一部です：より複雑な型は、自分自身を他のものと比較する興味深くて役に立つ方法を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful for list comprehensions:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121125Z" creationid="Toshiyuki" creationdate="20130813T121125Z">
        <seg>これは特にリストの理解の役に立つ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful for the do-once block, since it is officially a loop and can take therefore loop control statements.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T130634Z" creationid="Toshiyuki" creationdate="20130810T130634Z">
        <seg>これは特にdo-onceブロックに役に立ち、正式なループなのでループ制御文をとることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is seldom really necessary, because it is often a better alternative to make parameters optional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T035419Z" creationid="Toshiyuki" creationdate="20140113T063849Z">
        <seg>パラメータを任意にすることがしばしばより良い代わりであるので、これはあまり必要でありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is simple to understand.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T180851Z" creationid="Toshiyuki" creationdate="20140112T180851Z">
        <seg>これは理解するのは簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is subtly different from Perl 5's behavior, which was to return the value of the last expression evaluated, even if that expression was just a conditional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T020026Z" creationid="Toshiyuki" creationdate="20130803T020026Z">
        <seg>これは文が条件付きだけであっても最後に評価された文が返されるというPerl 5の振る舞いと微妙に異なる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the mechanism by which the &lt;c1&gt;AdminBot&lt;/c1&gt; class can perform the appropriate &lt;c2&gt;on-message&lt;/c2&gt; method provided by both the &lt;c3&gt;KarmaTracking&lt;/c3&gt; and the &lt;c4&gt;Oping&lt;/c4&gt; roles.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T031109Z" creationid="Toshiyuki" creationdate="20140115T140909Z">
        <seg>これは、&lt;c1&gt;AdminBot&lt;/c1&gt;クラスが&lt;c3&gt;KarmaTracking&lt;/c3&gt;と&lt;c4&gt;Oping&lt;/c4&gt;ロールによって提供される適切な&lt;c2&gt;on-message&lt;/c2&gt;メソッドを実行することができるメカニズムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the opposite of the desired order.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T030125Z" creationid="Toshiyuki" creationdate="20131026T151217Z">
        <seg>これは望ましい順番と逆です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful if you wish to be very specific about what kind of comparison you want and are unsure of the types of the values you are comparing.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T124728Z" creationid="Toshiyuki" creationdate="20131029T124728Z">
        <seg>あなたがどんな比較を望むか非常にはっきりしていて欲しくて、比較している値の型が不確かであるならば、これは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very helpful for bracketing constructs as it puts the brackets near one another.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T145333Z" creationid="Toshiyuki" creationdate="20140222T133522Z">
        <seg>これはお互いの近くにブラケットを置いて構成物を括弧に入れるのに非常に有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is what will execute every time the subroutine is called.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T125223Z" creationid="Toshiyuki" creationdate="20131029T131902Z">
        <seg>これはサブルーチンが呼ばれるときに毎回実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This iteration places each item--each a &lt;c2&gt;Task&lt;/c2&gt; object--into the topic variable, &lt;c3&gt;$_&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T140958Z" creationid="Toshiyuki" creationdate="20140111T191905Z">
        <seg>この繰り返しはそれぞれのアイテムを ― それぞれの&lt;c2&gt;Task&lt;/c2&gt;オブジェクトを ― トピック変数&lt;c3&gt;$_&lt;/c3&gt;に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of list should not be confused with the flattening list context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073716Z" creationid="Toshiyuki" creationdate="20140329T073716Z">
        <seg>この種のリストはフラット化リストコンテキストと混同されるべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This line consists of three individually simple steps.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T142844Z" creationid="Toshiyuki" creationdate="20131026T142844Z">
        <seg>この行は、3つの個々に単純なステップから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This line tells the compiler which version of Perl the program expects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T024639Z" creationid="Toshiyuki" creationdate="20131026T015909Z">
        <seg>この行は、プログラムがどのバージョンのPerlを期待するかについてコンパイラに伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to keep track of what you last "took":</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T213301Z" creationid="Toshiyuki" creationdate="20130810T213301Z">
        <seg>これはあなたが最後に取ったのは何か追い続けるのを簡単にする：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may be overridden by attaching a &lt;c1&gt;.resume_value&lt;/c1&gt; to the warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T074213Z" creationid="Toshiyuki" creationdate="20130818T074213Z">
        <seg>これは&lt;c1&gt;.resume_value&lt;/c1&gt;を警告に付け加えることでオーバーライドすることもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that &lt;c0&gt;.*&lt;/c0&gt; will find both those methods that mixed into the object from one or more roles along with any that already existed in the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T160651Z" creationid="Toshiyuki" creationdate="20140115T142715Z">
        <seg>これは、&lt;c0&gt;.*&lt;/c0&gt;が1つ以上のロールからミックスされたメソッドとクラスの中にすでに存在するもの両方を一緒に見つけるということを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that &lt;c1&gt;CATCH&lt;/c1&gt; and &lt;c2&gt;CONTROL&lt;/c2&gt; always require a block, since they take an argument that sets &lt;c3&gt;$_&lt;/c3&gt; to the current topic, so that the innards are able to behave as a switch statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T090602Z" creationid="Toshiyuki" creationdate="20130818T090602Z">
        <seg>これは&lt;c1&gt;CATCH&lt;/c1&gt;と&lt;c2&gt;CONTROL&lt;/c2&gt;が常にブロックを要求することを意味する。それらは&lt;c3&gt;$_&lt;/c3&gt;を現在のトピックにセットする引数をとるので、内部はswitch文として振る舞うことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that a subroutine may only be called within the scope in which it was declared.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T132502Z" creationid="Toshiyuki" creationdate="20131029T132502Z">
        <seg>これは、サブルーチンがそれが宣言された範囲の中でのみ呼ばれることができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that it is possible to dispatch based upon the shape of a data structure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T073150Z" creationid="Toshiyuki" creationdate="20140113T073150Z">
        <seg>これは、それがデータ構造の形に基づくディスパッチに可能であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the previous example may be simplified to:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T062118Z" creationid="Toshiyuki" creationdate="20140104T222656Z">
        <seg>これは前の例を次のように単純化できることを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the two nested arrays could not be recovered at the point of delegation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T131512Z" creationid="Toshiyuki" creationdate="20140110T162716Z">
        <seg>これは、2つのネストした配列はデリゲートのポイントで復元することができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you &lt;s2&gt;can not&lt;/s2&gt; modify them from inside the subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131129T150137Z" creationid="Toshiyuki" creationdate="20131129T150137Z">
        <seg>これはサブルーチン内でそれらを変更&lt;s2&gt;できない&lt;/s2&gt;ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism is really only good for objects that know how to return a boolean value and still remain themselves.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T145534Z" creationid="Toshiyuki" creationdate="20130809T145534Z">
        <seg>この仕組みは本当にブール値をどのように返すのか知っていてそれら自身がまだ残るオブジェクトにだけ良い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This meta class enables other ways of introspection too:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110318Z" creationid="Toshiyuki" creationdate="20140112T160339Z">
        <seg>このメタクラスはイントロスペクションの他の方法も利用可能にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This metadata can go far beyond that which subroutines, signatures, and parameters normally provide.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044439Z" creationid="Toshiyuki" creationdate="20140111T081510Z">
        <seg>このメタデータは、サブルーチン、シグネチャーとパラメータが通常提供するそれをはるかに越えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This modifier allows optional whitespace in the text wherever there one or more whitespace characters appears in the pattern.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T041943Z" creationid="Toshiyuki" creationdate="20140222T020821Z">
        <seg>そこで1以上の空白文字がパターンで出現する場合はいつでも、この修飾子はテキストで任意の空白文字を許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator also has a special feature: it causes the parser to interpret any bare identifier on the left-hand side as a string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T030838Z" creationid="Toshiyuki" creationdate="20131027T050028Z">
        <seg>この演算子も特殊な機能を持っています： 左側のどんな裸の識別子でも、パーサーに文字列として解釈させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This prints:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T233849Z" creationid="Toshiyuki" creationdate="20140221T233849Z">
        <seg>これは次のように出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process of failing and trying again is &lt;e0&gt;backtracking&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130813Z" creationid="Toshiyuki" creationdate="20140222T021608Z">
        <seg>失敗して再び試すこのプロセスは&lt;e0&gt;バックトラック&lt;/e0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process of iteration has produced a more cohesive and consistent language specification.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T022937Z" creationid="Toshiyuki" creationdate="20131025T215553Z">
        <seg>この繰り返しのプロセスは、より結合力があって一貫した言語仕様を生み出しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process transforms the match tree into a different tree--in this case, the actual JSON tree.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T001300Z" creationid="Toshiyuki" creationdate="20140224T162646Z">
        <seg>このプロセスはマッチツリーを異なるツリーに変えます ― この場合、実際のJSONツリーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This produces the output:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T015809Z" creationid="Toshiyuki" creationdate="20131026T015809Z">
        <seg>これは次のように出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This program demonstrates a simple and pluggable IRC bot framework which understands a few simple commands.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121833Z" creationid="Toshiyuki" creationdate="20140113T080319Z">
        <seg>このプログラムは2、3の単純な命令を理解する、単純で接続可能なIRCロボットフレームワークを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This program produces the output:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T044707Z" creationid="Toshiyuki" creationdate="20131027T044707Z">
        <seg>このプログラムは以下のように出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This restriction allows a clever compiler optimization: it can sort all candidates by narrowness once to find the candidate with the best matching signature by examining nominal type constraints.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T044741Z" creationid="Toshiyuki" creationdate="20140113T044741Z">
        <seg>この制約は、賢いコンパイラ最適化を許可します：それは、名目型制約を調べることによって最善のマッチするシグネチャで候補を見つけるために、一回で狭さによってすべての候補を分類することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This routine exchanges the contents of its two arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T063450Z" creationid="Toshiyuki" creationdate="20140113T063450Z">
        <seg>このルーチンは、その2つの引数のコンテンツを交換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scalar attribute (with the &lt;c0&gt;$&lt;/c0&gt; sigil) has a type of &lt;c1&gt;Bool&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T183219Z" creationid="Toshiyuki" creationdate="20140111T183219Z">
        <seg>このスカラー属性（&lt;c0&gt;$&lt;/c0&gt;シギル）は&lt;c1&gt;Bool&lt;/c1&gt;型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section is confusing.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T133536Z" creationid="Toshiyuki" creationdate="20140104T133536Z">
        <seg>このセクションは混乱します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This sidebar gets a bit deep, but it's an important concept.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T120722Z" creationid="Toshiyuki" creationdate="20140115T140449Z">
        <seg>この側面記事は少し深くなります、しかし、それは重要な概念です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This slot can hold a custom data structure that you create from the action methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T233545Z" creationid="Toshiyuki" creationdate="20140224T162437Z">
        <seg>このスロットは、アクションメソッドから作成するカスタムデータ構造を保持することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This snippet demonstrates how multis make the code simpler and more obvious.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T214930Z" creationid="Toshiyuki" creationdate="20140112T182657Z">
        <seg>この断片は、multisがどのようにコードをより単純でより明らかにするかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This symmetry can be exploited by declaring a subroutine called &lt;c0&gt;MAIN&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T083711Z" creationid="Toshiyuki" creationdate="20140111T083711Z">
        <seg>この対称性は、&lt;c0&gt;MAIN&lt;/c0&gt;と呼んでいるサブルーチンを宣言することによって利用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type object is a kind of "empty instance" of the class, specifically an instance without any state.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141759Z" creationid="Toshiyuki" creationdate="20140112T090914Z">
        <seg>この型オブジェクトは、クラス（特に何の状態のないインスタンスも）の一種の「空インスタンス」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type object is an "empty instance" of the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T135218Z" creationid="Toshiyuki" creationdate="20140111T181204Z">
        <seg>この型オブジェクトはクラスの「空のインスタンス」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This use of a rule rather than a character class allows you to define your own version of whitespace characters (see grammars).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T063013Z" creationid="Toshiyuki" creationdate="20140222T023933Z">
        <seg>文字クラスではなくこのルールの使用は、あなた自身のバージョンの空白文字を定義するの可能にします（grammarsを見てください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will not cause an infinite loop as long as at least one regex per recursive call consumes at least one character.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T132823Z" creationid="Toshiyuki" creationdate="20140222T132823Z">
        <seg>再帰的呼び出しにつき少なくとも1つの正規表現が少なくとも1つの文字を消費する限り、これは無限ループを引き起こさないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This works for the example, because JSON's specification covers only a few basic structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T043306Z" creationid="Toshiyuki" creationdate="20140113T043306Z">
        <seg>JSONの仕様がほんの少しの基本的な構造だけに適用されるので、これは例で動きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This works, but the repeated "I don't care about whitespace" units are clumsy.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130602Z" creationid="Toshiyuki" creationdate="20140222T020023Z">
        <seg>これは動作します。しかし度重なる「私は空白文字を気にしません」という単位は不恰好です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those calling the subroutine can then choose whether or not to supply an argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131230T040945Z" creationid="Toshiyuki" creationdate="20131230T040945Z">
        <seg>それらのサブルーチン呼び出しは引数を供給するかどうか選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those that are truly global will have global alphabetic names, such as &lt;c0&gt;$*PID&lt;/c0&gt; or &lt;c1&gt;@*ARGS&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090447Z" creationid="Toshiyuki" creationdate="20140329T090447Z">
        <seg>それらの本当にグローバルなものはアルファベットの名前、&lt;c0&gt;$*PID&lt;/c0&gt;または&lt;c1&gt;@*ARGS&lt;/c1&gt;のようなものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Though certain control statements could conceivably be parsed in a self-contained way, for visual consistency all statement-terminating blocks that end in the middle of a line &lt;i0&gt;must&lt;/i0&gt; be terminated by semicolon unless they are naturally terminated by some other statement terminator:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T042251Z" creationid="Toshiyuki" creationdate="20130803T042251Z">
        <seg>確実な制御文はおそらく自己完結的な方法でパースできるだろうが、視覚的な一貫性のために、いくつかの他の文末によって自然に終えるのでない限り、行の中間で終わる全ての終端ブロックは&lt;i0&gt;必ず&lt;/i0&gt;セミコロンで終わらなければならない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Though, for the most part, you can consider these terms interchangeable.) Perl 6 signatures go further; they allow you to constrain the type, value, and "definedness" of its arguments and match against and extract parts of complex data structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T035427Z" creationid="Toshiyuki" creationdate="20131126T125011Z">
        <seg>しかし、ほとんどの場合これらの用語は交換可能と考える事ができます。）Perl 6のシグネチャーは更に上を行きます；それらは型、値、引数の“定義”を強制でき、複雑なデータ構造の部分へのマッチと抽出を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Three-way Comparison</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T140622Z" creationid="Toshiyuki" creationdate="20131028T140622Z">
        <seg>三者間の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Through this mechanism, a generic multi can redirect execution to a more specific version, but the candidate list for this redirection is determined by the caller, not by the lexical scope of the multi, which can't see the caller's lexical scope except through the CALLER:: pseudo package.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T073809Z" creationid="Toshiyuki" creationdate="20130811T073809Z">
        <seg>このメカニズムの中で、ジェネリックマルチはより明確なバージョンの実行に切り替えることができる。しかしこの切替の候補リストは呼び出し元で決まり、レキシカルスコープのマルチではない。そしてそれはCALLER::擬似パッケージを通す場合を除いて呼び出し元のレキシカルスコープを見ることができない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus &lt;c1&gt;$answer ~~ 42&lt;/c1&gt; actually desugars to a method call like &lt;c2&gt;42.ACCEPTS($answer)&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T130159Z" creationid="Toshiyuki" creationdate="20131029T130159Z">
        <seg>このように、&lt;c1&gt;$answer ~~ 42&lt;/c1&gt;は実は&lt;c2&gt;42.ACCEPTS($answer)&lt;/c2&gt;のようなメソッド呼び出しのデシュガーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus &lt;c1&gt;rw&lt;/c1&gt; parameters still work with captures involved.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T125928Z" creationid="Toshiyuki" creationdate="20140110T160139Z">
        <seg>このように&lt;c1&gt;rw&lt;/c1&gt;パラメータはキャプチャーに含まれてもまだ動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus any instance of the &lt;c1&gt;Task&lt;/c1&gt; class can call this method with the &lt;c2&gt;.&lt;/c2&gt; method call operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185456Z" creationid="Toshiyuki" creationdate="20140111T185456Z">
        <seg>したがって&lt;c1&gt;Task&lt;/c1&gt;クラスのどのインスタンスでも&lt;c2&gt;.&lt;/c2&gt;メソッド呼び出し演算子でこのメソッドを呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the iteration construct calls the &lt;c5&gt;.perform()&lt;/c5&gt; method on every &lt;c6&gt;Task&lt;/c6&gt; object in the &lt;c7&gt;@!dependencies&lt;/c7&gt; attribute of the current invocant.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T140612Z" creationid="Toshiyuki" creationdate="20140111T192248Z">
        <seg>したがって、繰り返し構造は&lt;c5&gt;.perform()&lt;/c5&gt;メソッドを&lt;c7&gt;@!dependencies&lt;/c7&gt;属性の全ての&lt;c6&gt;Task&lt;/c6&gt;オブジェクトを現在のインボカントに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To access the non-captured parts too, use &lt;c0&gt;$/.chunks&lt;/c0&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T115625Z" creationid="Toshiyuki" creationdate="20140222T030008Z">
        <seg>キャプチャーされなかった部分にもアクセスするために、代わりに&lt;c0&gt;$/.chunks&lt;/c0&gt;を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To apply a modifier to more than just one character or character class, group items with square brackets:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T230802Z" creationid="Toshiyuki" creationdate="20140221T230802Z">
        <seg>修飾子をちょうど1つ以上の文字または文字クラスに適用するために、スクエアブラケットで項目をグループにしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To coerce your return value, use a coercion type:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224039Z" creationid="Toshiyuki" creationdate="20140328T224039Z">
        <seg>戻り値を強制するために、型の自動変換を使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a single task with no dependencies, write:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T090746Z" creationid="Toshiyuki" creationdate="20140112T090746Z">
        <seg>従属物なしでシングルタスクを作るためには次のように書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define your own custom character classes, listing the appropriate characters inside nested angle and square brackets &lt;c0&gt;&lt;[ ... ]&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T025439Z" creationid="Toshiyuki" creationdate="20140117T182819Z">
        <seg>適切な文字を入れ子になったアングルと角型ブラケット&lt;c0&gt;&lt;[ ... ]&gt;&lt;/c0&gt;にリストして、あなた自身のカスタム文字クラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To distinguish the prefix operator &lt;c3&gt;-&lt;/c3&gt; from the infix operator &lt;c4&gt;-&lt;/c4&gt;, the Perl 6 parser always keeps track of whether it expects an infix operator or a term.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T084823Z" creationid="Toshiyuki" creationdate="20131027T055844Z">
        <seg>接頭辞&lt;c3&gt;-&lt;/c3&gt;と接中辞&lt;c4&gt;-&lt;/c4&gt;を識別するため、Perl 6パーサーは接中辞演算子または項を期待するかどうかにかかわらず、常に経過を追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do this, precede the name of the parameter with a colon:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T011652Z" creationid="Toshiyuki" creationdate="20131231T225420Z">
        <seg>これをするには、パラメータの名前の前にコロンをつけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do this, use the &lt;c2&gt;\(...)&lt;/c2&gt; syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T041428Z" creationid="Toshiyuki" creationdate="20140110T143122Z">
        <seg>これをするために&lt;c2&gt;\(...)&lt;/c2&gt;構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To format a hash value or list of pairs, include formats for both key and value in the first string: &lt;c1&gt;.fmt('%s: %s', "\n")&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T030013Z" creationid="Toshiyuki" creationdate="20140329T030013Z">
        <seg>ハッシュ値かペアのリストをフォーマットするために、キーと値の両方のフォーマットを最初の文字列に含めてください：&lt;c1&gt;.fmt('%s: %s', "\n")&lt;/c1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To format an array value separated by commas, supply a second argument: &lt;c0&gt;.fmt('%03d', ', ')&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T025840Z" creationid="Toshiyuki" creationdate="20140329T025840Z">
        <seg>配列値をコンマで区切るには第二の引数を与えてください：&lt;c0&gt;.fmt('%03d', ', ')&lt;/c0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a formatted representation of any scalar value, use the &lt;c0&gt;.fmt('%03d')&lt;/c0&gt; method to do an implicit &lt;c1&gt;sprintf&lt;/c1&gt; on the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T025737Z" creationid="Toshiyuki" creationdate="20140329T025737Z">
        <seg>スカラー値のフォーマットされた表現を得るために、値上で暗黙の&lt;c1&gt;sprintf&lt;/c1&gt;を行う&lt;c0&gt;.fmt('%03d')&lt;/c0&gt;メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the number of elements in an array, use the &lt;c0&gt;.elems&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T141234Z" creationid="Toshiyuki" creationdate="20140327T141234Z">
        <seg>配列の要素数を得るために&lt;c0&gt;.elems&lt;/c0&gt;メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To hide all candidates of a multi and replace them by another sub, declare it as &lt;c0&gt;only sub YourSub&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T043554Z" creationid="Toshiyuki" creationdate="20140113T075514Z">
        <seg>マルチのすべての候補を隠して、それらを別のサブと取り替えるために、それを&lt;c0&gt;only sub YourSub&lt;/c0&gt;と宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ignore all unhandled exceptions, use an empty &lt;c4&gt;default&lt;/c4&gt; case.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T135119Z" creationid="Toshiyuki" creationdate="20130813T135119Z">
        <seg>全てのハンドルされない例外を無視するために、空の&lt;c4&gt;default&lt;/c4&gt;ケースを使え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To jump into the next &lt;c4&gt;when&lt;/c4&gt; block without testing its condition, you must use a &lt;c5&gt;goto&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115331Z" creationid="Toshiyuki" creationdate="20130813T115331Z">
        <seg>条件をテストせずに次の&lt;c4&gt;when&lt;/c4&gt;ブロックにジャンプするには&lt;c5&gt;goto&lt;/c5&gt;を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a parameter optional, either assign a default value to the parameter in the signature:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T035846Z" creationid="Toshiyuki" creationdate="20131230T041219Z">
        <seg>パラメータを任意にするために、シグネチャー内でデフォルト値をパラメータに割り当てます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a slice subscript return something other than values, append an appropriate adverb to the subscript.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T084149Z" creationid="Toshiyuki" creationdate="20140329T084149Z">
        <seg>スライス添字に値と別の何かを返させるために、添字に適切な副詞を追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To mark them all as handled you must access them individually via the implicit loop of a CATCH block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T164623Z" creationid="Toshiyuki" creationdate="20130817T164623Z">
        <seg>それらを全てハンドルされたとしてマークするためにはCATCHブロックの暗黙のループ経由で個別にアクセスしなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent lazy lists for leaking out unexpectedly, the inside of a &lt;c11&gt;try&lt;/c11&gt; is always considered an eager context, unless the &lt;c12&gt;try&lt;/c12&gt; itself is in a sink context, in which case the inside of &lt;c13&gt;try&lt;/c13&gt; is also in sink context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T123141Z" creationid="Toshiyuki" creationdate="20130813T123141Z">
        <seg>レイジーなリストが思いがけなく漏れるのを防ぐために、&lt;c11&gt;try&lt;/c11&gt;の内部は常にeagerコンテキストとみなされる。その&lt;c12&gt;try&lt;/c12&gt;自身がsinkコンテキストでなく、&lt;c13&gt;try&lt;/c13&gt;の内部もsinkコンテキストの場合でない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To print out the players and their scores, the code loops over &lt;c0&gt;@sorted&lt;/c0&gt;, setting &lt;c1&gt;$n&lt;/c1&gt; to the name of each player in turn.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T151616Z" creationid="Toshiyuki" creationdate="20131026T151616Z">
        <seg>プレイヤーと彼らのスコアを出力するため、コードは&lt;c0&gt;@sorted&lt;/c0&gt;に対してループし、&lt;c1&gt;$n&lt;/c1&gt;に各々のプレイヤーの名前を次々にセットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To print player names in winner-first order, the code must sort the array by the &lt;e1&gt;scores&lt;/e1&gt; of the players, not their names.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T143411Z" creationid="Toshiyuki" creationdate="20131026T143411Z">
        <seg>勝者順のプレイヤー名で出力するために、コードはプレイヤーの名前ではなく&lt;e1&gt;スコア&lt;/e1&gt;でソートしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To process two arrays in parallel use the &lt;c0&gt;zip&lt;/c0&gt; function to generate a list that can be bound to the corresponding number of parameters:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T062101Z" creationid="Toshiyuki" creationdate="20130810T062101Z">
        <seg>二つの配列を並行して処理するために&lt;c0&gt;zip&lt;/c0&gt;関数を使用してパラメータの数が一致するようにバインド可能なリストを生成する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To return a value (to the dynamical caller) from any pointy block or bare closure, you either just let the block return the value of its final expression, or you can use &lt;c0&gt;leave&lt;/c0&gt;, which comes in both function and method forms.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T071032Z" creationid="Toshiyuki" creationdate="20130817T071032Z">
        <seg>何か一つのポインティブロックか裸のクロージャから値を返すために（ダイナミックな呼び出し元へ）、ブロックが最後の文の値を返すようにするだけか、関数かメソッド形式の&lt;c0&gt;leave&lt;/c0&gt;を使うことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To return from your immediate caller, you can say:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T072429Z" creationid="Toshiyuki" creationdate="20130817T072429Z">
        <seg>あなたの呼び出し元から直接に返すなら、次のようにできる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use a role, you must incorporate it into an object, class, or, as we'll see in later chapters, a grammar.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T175418Z" creationid="Toshiyuki" creationdate="20140113T175418Z">
        <seg>ロールを使うために、あなたはそれをオブジェクト、クラス、またはグラマー（後の章）に取り込まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Toying with the candidate list</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T075547Z" creationid="Toshiyuki" creationdate="20140113T075547Z">
        <seg>候補リストで遊ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traits</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132622Z" creationid="Toshiyuki" creationdate="20140326T132622Z">
        <seg>トレイト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traits can apply &lt;e0&gt;implicit constraints&lt;/e0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T063429Z" creationid="Toshiyuki" creationdate="20140113T063429Z">
        <seg>トレイトは&lt;e0&gt;暗黙の制約&lt;/e0&gt;を適用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traits cannot be changed at run-time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132814Z" creationid="Toshiyuki" creationdate="20140326T132814Z">
        <seg>トレイトは実行時に変更できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True if the parameter has &lt;c0&gt;is copy&lt;/c0&gt; trait</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044202Z" creationid="Toshiyuki" creationdate="20140322T044202Z">
        <seg>パラメータが&lt;c0&gt;is copy&lt;/c0&gt;トレイトを持つならTrue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True if the parameter has &lt;c0&gt;is readonly&lt;/c0&gt; trait</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044131Z" creationid="Toshiyuki" creationdate="20140322T044131Z">
        <seg>パラメータが&lt;c0&gt;is readonly&lt;/c0&gt;トレイトを持つならTrue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True if the parameter has &lt;c0&gt;is rw&lt;/c0&gt; trait</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044146Z" creationid="Toshiyuki" creationdate="20140322T044146Z">
        <seg>パラメータが&lt;c0&gt;is rw&lt;/c0&gt;トレイトを持つならTrue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True if the parameter is optional</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044307Z" creationid="Toshiyuki" creationdate="20140322T044307Z">
        <seg>パラメータが任意ならTrue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True if the parameter is slurpy</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044254Z" creationid="Toshiyuki" creationdate="20140322T044254Z">
        <seg>パラメータがslurpyならTrue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>True if the parameter is to be passed by name</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044220Z" creationid="Toshiyuki" creationdate="20140322T044220Z">
        <seg>パラメータが名前渡しならTrue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Twigils</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T014611Z" creationid="Toshiyuki" creationdate="20140329T014611Z">
        <seg>ツウィギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two bars make the regex engine try each alternative in order and the first matching alternative wins.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T231822Z" creationid="Toshiyuki" creationdate="20140221T231822Z">
        <seg>2つのバーは正規表現エンジンがそれぞれの選択肢を順番に試し、最初のマッチが勝つようにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two objects only share the same identity if, in fact, they are the same object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T125939Z" creationid="Toshiyuki" creationdate="20131027T125939Z">
        <seg>実際、それらが同じ物であるならば、2つのオブジェクトは同じ同一性を共有するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133511Z" creationid="Toshiyuki" creationdate="20140327T133511Z">
        <seg>型オブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type objects are &lt;e0&gt;undefined&lt;/e0&gt;, in the sense that they return &lt;c1&gt;False&lt;/c1&gt; if you call the &lt;c2&gt;.defined&lt;/c2&gt; method on them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T181652Z" creationid="Toshiyuki" creationdate="20140111T181652Z">
        <seg>型オブジェクトは&lt;e0&gt;undefined&lt;/e0&gt;です。それらに対して&lt;c2&gt;.defined&lt;/c2&gt;メソッドを呼び出すと&lt;c1&gt;False&lt;/c1&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types are officially compared using name equivalence rather than structural equivalence.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131645Z" creationid="Toshiyuki" creationdate="20140326T125818Z">
        <seg>型は構造よりも名前の同一性を使って比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types as Constraints</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T131937Z" creationid="Toshiyuki" creationdate="20140327T131937Z">
        <seg>制約としての型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscore is always considered alphabetic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T092733Z" creationid="Toshiyuki" creationdate="20140329T092733Z">
        <seg>アンダースコアは常に英字とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, dinner never magically happens.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141955Z" creationid="Toshiyuki" creationdate="20140112T091405Z">
        <seg>残念なことに、夕食は決して魔法のようには出できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike &lt;c0&gt;try&lt;/c0&gt;, the presence of a &lt;c1&gt;CATCH&lt;/c1&gt; block does not imply &lt;c2&gt;use fatal&lt;/c2&gt; semantics for failures; you may, however, use either an explicit &lt;c3&gt;try&lt;/c3&gt; block around the &lt;c4&gt;CATCH&lt;/c4&gt; or an explicit &lt;c5&gt;use fatal&lt;/c5&gt; to guarantee that failures are thrown eagerly rather than lazily.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T121559Z" creationid="Toshiyuki" creationdate="20130814T121559Z">
        <seg>&lt;c0&gt;try&lt;/c0&gt;と違い、&lt;c1&gt;CATCH&lt;/c1&gt;ブロックの存在は失敗のための暗黙の&lt;c2&gt;use fatal&lt;/c2&gt;セマンティクスを行わない；あなたは多分、けれども、&lt;c4&gt;CATCH&lt;/c4&gt;の周りの明示的な&lt;c3&gt;try&lt;/c3&gt;ブロックか明示的な&lt;c5&gt;use fatal&lt;/c5&gt;を失敗がスローされることを保証するために使うだろう。レイジーよりも熱心に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike &lt;c3&gt;do&lt;/c3&gt;, it evaluates the statement or block in sink (void) context; its return value is instead specified by calling the &lt;c4&gt;take&lt;/c4&gt; list prefix operator one or more times within the scope (either lexical or dynamic) of the &lt;c5&gt;gather&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T153248Z" creationid="Toshiyuki" creationdate="20130810T153248Z">
        <seg>&lt;c3&gt;do&lt;/c3&gt;と違い、それは文またはブロックをsink（void）コンテキストで評価する；それの返り値は&lt;c4&gt;take&lt;/c4&gt;リストプレフィックス演算子を&lt;c5&gt;gather&lt;/c5&gt;のスコープ内（レキシカルかダイナミック）で1回以上呼ぶことで代わりに明示される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Perl 5's &lt;c0&gt;do-while&lt;/c0&gt; loop, this is a real loop block now, so &lt;c1&gt;next&lt;/c1&gt;, &lt;c2&gt;last&lt;/c2&gt;, and &lt;c3&gt;redo&lt;/c3&gt; work as expected.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T151638Z" creationid="Toshiyuki" creationdate="20130809T151638Z">
        <seg>Perl 5の&lt;c0&gt;do-while&lt;/c0&gt;ループと違い、これは今実際のループブロックなので、&lt;c1&gt;next&lt;/c1&gt;、&lt;c2&gt;last&lt;/c2&gt;、そして&lt;c3&gt;redo&lt;/c3&gt;が期待通りに機能する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, applying a statement modifier to a &lt;c0&gt;do&lt;/c0&gt; block is specifically disallowed:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T151326Z" creationid="Toshiyuki" creationdate="20130809T151326Z">
        <seg>Perl 5と違い、&lt;c0&gt;do&lt;/c0&gt;ブロックに文修飾子を適用することは明確に禁じられている：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, if a final statement in Perl 6 is a conditional that does not execute any of its branches, it doesn't matter what the value of the conditional is, the value of that conditional statement is always &lt;c0&gt;()&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T020936Z" creationid="Toshiyuki" creationdate="20130803T020936Z">
        <seg>Perl 5と違い、Perl 6の最後の文が条件付きでいずれかの分岐を実行しない場合、条件の値が何かを問題とせず、その条件付き文は常に&lt;c0&gt;()&lt;/c0&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, the notation &lt;c0&gt;&amp;foo&lt;/c0&gt; merely stands for the &lt;c1&gt;foo&lt;/c1&gt; function as a &lt;c2&gt;Routine&lt;/c2&gt; object without calling it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082931Z" creationid="Toshiyuki" creationdate="20140329T082931Z">
        <seg>Perl 5と異なり、表記法&lt;c0&gt;&amp;foo&lt;/c0&gt;はそれを呼び出すことのない&lt;c2&gt;Routine&lt;/c2&gt;オブジェクトとして単に&lt;c1&gt;foo&lt;/c1&gt;関数を表すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, there are (by policy) no implicit blocks around standard control structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T122034Z" creationid="Toshiyuki" creationdate="20130729T122034Z">
        <seg>Perl 5と異なり、標準の制御構造の周りに暗黙のブロックは（ポリシーとして）無い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike many other languages, Perl 6 specifies exception handlers by placing a &lt;c0&gt;CATCH&lt;/c0&gt; block &lt;i1&gt;within&lt;/i1&gt; that block that is having its exceptions handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121517Z" creationid="Toshiyuki" creationdate="20130813T121517Z">
        <seg>他の言語と違い、Perl 6は扱われる例外を持つ&lt;c0&gt;CATCH&lt;/c0&gt;ブロックをそのブロック&lt;i1&gt;内&lt;/i1&gt;に配置することで例外ハンドラを明示する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike positional parameters, named parameters are optional by default.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T011737Z" creationid="Toshiyuki" creationdate="20131231T225604Z">
        <seg>位置に依存するパラメータと違い、デフォルトでは名前が付けられたパラメータは任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike signatures, captures work like references.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T041619Z" creationid="Toshiyuki" creationdate="20140110T155756Z">
        <seg>シグネチャーと違い、キャプチャーはリファレンスのように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike with loop controls, however, scanning a scope includes a scan of any lexical scopes included within the current candidate scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T141842Z" creationid="Toshiyuki" creationdate="20130817T141842Z">
        <seg>ループ制御と違い、けれども、スコープをスキャンすることは現在の候補のスコープ内を含む何か一つのレキシカルスコープのスキャンを含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unpacking</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T162834Z" creationid="Toshiyuki" creationdate="20140110T162834Z">
        <seg>アンパック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unthrown exceptions are meant to provide a failsoft mechanism in which failures can be treated as data and dealt with one by one, without aborting execution of what may be perfectly valid parallel computations.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T174650Z" creationid="Toshiyuki" creationdate="20130817T173036Z">
        <seg>スローされない例外はフェールソフトメカニズムを供給するように意図される。その失敗はデータとして扱うことができ、一つづつ分配できる。完璧に正しい並行計算の実行の中止なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usage of unknown options or too many or few arguments triggers an automatically generated usage message, which can be overridden with a custom &lt;c0&gt;USAGE&lt;/c0&gt; sub:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T174113Z" creationid="Toshiyuki" creationdate="20140111T174113Z">
        <seg>未知のオプション、あるいは多いか少ない引数は自動的に使用法メッセージを発生させます。&lt;c0&gt;USAGE&lt;/c0&gt;サブルーチンでカスタムしてオーバライドできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140212Z" creationid="Toshiyuki" creationdate="20130802T140212Z">
        <seg>使え</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c1&gt;$Package::var&lt;/c1&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000122Z" creationid="Toshiyuki" creationdate="20140329T000122Z">
        <seg>&lt;c1&gt;$Package::var&lt;/c1&gt;を代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use caution as this &lt;s2&gt;will&lt;/s2&gt; alter the original object passed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T000853Z" creationid="Toshiyuki" creationdate="20131205T103739Z">
        <seg>これは渡されたオリジナルのオブジェクトを&lt;s2&gt;変更することになる&lt;/s2&gt;ので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of a placeholder parameter in statement-level blocks triggers a syntax error, because the parameter is not out front where it can be seen.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T151548Z" creationid="Toshiyuki" creationdate="20130810T151548Z">
        <seg>文レベルのブロックでのプレースホルダーパラメータの使用は文法エラーを引き起こす。なぜならそれが見える場所でパラメータは前に出ていないからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the scope declarator &lt;c1&gt;our&lt;/c1&gt; to make the subroutine available within the current package, and install a lexical alias in the scope where you want to use it:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T034837Z" creationid="Toshiyuki" creationdate="20131029T132740Z">
        <seg>サブルーチンを現在のパッケージ内で利用できるようにするには&lt;c1&gt;our&lt;/c1&gt;スコープ宣言を使ってください。そしてあなたが使いたいスコープにレキシカルなエイリアス（別名）をインストールしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-defined classes don't derive from &lt;c5&gt;Cool&lt;/c5&gt; by default, so such classes are also unaffected by changes to &lt;c6&gt;Cool&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000024Z" creationid="Toshiyuki" creationdate="20140329T000024Z">
        <seg>デフォルトでユーザー定義のクラスは&lt;c5&gt;Cool&lt;/c5&gt;から継承しないので、そのようなクラスは&lt;c6&gt;Cool&lt;/c6&gt;による変化の影響を受けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-selected Brackets</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053508Z" creationid="Toshiyuki" creationdate="20140330T053508Z">
        <seg>ユーザー選択のブラケット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using &lt;c4&gt;m/ ... /&lt;/c4&gt; in the call to &lt;c5&gt;subst&lt;/c5&gt; would create a match object and pass it as the first argument, rather than the regex itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T060852Z" creationid="Toshiyuki" creationdate="20140222T023510Z">
        <seg>&lt;c5&gt;subst&lt;/c5&gt;の呼び出しにおいて&lt;c4&gt;m/ ... /&lt;/c4&gt;を使うと、正規表現自体ではなくマッチオブジェクトを作成して、それを最初の引数に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a match object as an array yields access to the positional captures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T091655Z" creationid="Toshiyuki" creationdate="20140222T025114Z">
        <seg>配列としてマッチオブジェクトを使用することは、位置依存のキャプチャーにアクセスを与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using it as a hash reveals the named captures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134353Z" creationid="Toshiyuki" creationdate="20140222T025140Z">
        <seg>ハッシュとしてそれを使うことは、名前をつけられたキャプチャーを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the &lt;c0&gt;returns&lt;/c0&gt; trait is, of course, always optional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T063600Z" creationid="Toshiyuki" creationdate="20140104T232818Z">
        <seg>もちろん&lt;c0&gt;returns&lt;/c0&gt;トレイトの使用は、常に任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the &lt;c4&gt;.&lt;/c4&gt; method call operator without specifying an explicit invocant uses the current topic as the invocant.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T140536Z" creationid="Toshiyuki" creationdate="20140111T192122Z">
        <seg>&lt;c4&gt;.&lt;/c4&gt;メソッドコールを明示的なインボカントなしに呼び出すと、現在のトピックがインボカントになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually, when talking about regex that are rules or tokens, we tend to call them rules or tokens rather than the more general term "regex", to distinguish their special behaviors.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T140421Z" creationid="Toshiyuki" creationdate="20140222T131450Z">
        <seg>通常、ルールまたはトークンである正規表現について話すとき、それらの特別な振る舞いを識別するために、我々は「正規表現」という一般的な用語よりもルールまたはトークンと呼ぶ傾向があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variable</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T004120Z" creationid="Toshiyuki" creationdate="20140309T004120Z">
        <seg>変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables with the &lt;c0&gt;@&lt;/c0&gt; sigil are accessed positionally; variables with the &lt;c1&gt;%&lt;/c1&gt; sigil are accessed by string key.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T095420Z" creationid="Toshiyuki" creationdate="20131026T095420Z">
        <seg>&lt;c0&gt;@&lt;/c0&gt;シギルによる変数は位置的にアクセスされます；&lt;c1&gt;%&lt;/c1&gt;シギルは文字列キーでアクセスされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Verify Rakudo * behavior at press time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T113311Z" creationid="Toshiyuki" creationdate="20140322T113311Z">
        <seg>本のプレス時にはRakudoの振る舞いを検証してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Warnings are produced in Perl 6 by throwing a resumable control exception to the outermost scope, which by default prints the warning and resumes the exception by extracting a resume continuation from the exception, which must be supplied by the &lt;c0&gt;warn()&lt;/c0&gt; function (or equivalent).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T114421Z" creationid="Toshiyuki" creationdate="20130817T114421Z">
        <seg>Perl 6では再開可能な制御例外を最も外側のスコープに投げることで警告が引き起こされる。その警告はデフォルトで警告をプリントし、&lt;c0&gt;warn()&lt;/c0&gt;関数（または同等のもの）から供給されなければならない例外から再開可能な継続取り出すことで例外を再開する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also use the term "dynamic scoping" in the standard fashion to indicate the nested call frames that are created and destroyed every time a function or method is called.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T144249Z" creationid="Toshiyuki" creationdate="20130727T143959Z">
        <seg>我々はまた、関数かメソッドが呼ばれるたびに作成と破棄が行われる入れ子になったコールフレームを示すために「ダイナミックスコープ」という語句を標準的な方法で使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can't really rely on end-of-routine cleanup to deal with failures that are returned as normal data, unless we go with the overhead of a lexical &lt;c6&gt;@!&lt;/c6&gt; variable.]</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T155218Z" creationid="Toshiyuki" creationdate="20130817T155218Z">
        <seg>我々は本当に通常のデータとして返される失敗に対処するためのルーチン終了のクリーンアップを頼りにすることはできない。レキシカルな&lt;c6&gt;@!&lt;/c6&gt;変数へオーバーヘッドとともに行くのでない限り。］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We expect some experience in another programming language, though no prior knowledge of Perl is necessary.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131025T222225Z" creationid="Toshiyuki" creationdate="20131025T222225Z">
        <seg>Perlの事前知識は必要ありませんが、我々は別のプログラミング言語のいくらかの経験を想定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We intend these examples to demonstrate how to use the features, techniques, and idioms explained in the chapter in real programs.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T023234Z" creationid="Toshiyuki" creationdate="20131025T224038Z">
        <seg>我々は、章で説明される実際のプログラムでこれらの例が機能、テクニックとイディオムを使用する方法を示すつもりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We should probably at least issue warnings, though, if the GC eventually collects a failure that was never handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T154727Z" creationid="Toshiyuki" creationdate="20130817T154727Z">
        <seg>たぶん我々は少なくとも警告を出すべきだ。しかしながら、もしGCが結局は決してハンドルされない失敗を集めるなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We use the phrase "lexical scoping" in its industry-standard meaning to indicate those blocks that surround the current textual location.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T140343Z" creationid="Toshiyuki" creationdate="20130727T114316Z">
        <seg>我々は「レキシカルスコープ」という言い回しを業界標準の「現在のテキスト位置を囲んでいるブロック」を示す意味で使用する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We've left them in because they might serve as useful cues for the reader as well as for us authors about what remains to be done.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T022549Z" creationid="Toshiyuki" creationdate="20140322T022549Z">
        <seg>読者と著者に役立つきっかけになるかもしれないので、我々はそれらを残したままにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, it doesn't really fall back, since a &lt;c2&gt;take&lt;/c2&gt; knows at compile time whether it is being used lexically or dynamically.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T155030Z" creationid="Toshiyuki" creationdate="20130810T155030Z">
        <seg>さて、それは本当は戻らない。&lt;c2&gt;take&lt;/c2&gt;がレキシカルかダイナミックに使われるかどうかコンパイル時に知る時から。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What about &lt;c0&gt;AUTOMETH&lt;/c0&gt;?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T034016Z" creationid="Toshiyuki" creationdate="20140115T141855Z">
        <seg>&lt;c0&gt;AUTOMETH&lt;/c0&gt;はどうですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What can you do if there is a conflict?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T020731Z" creationid="Toshiyuki" creationdate="20140115T140112Z">
        <seg>競合があるならば、あなたは何をすることができますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What happens when a class performs a role but overrides all of its methods?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T022622Z" creationid="Toshiyuki" creationdate="20140115T140511Z">
        <seg>クラスがロールを実行するが、そのメソッドすべてをオーバーライドするとき、何が起こりますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is &lt;c0&gt;i&lt;/c0&gt;, if not sqrt(-1)?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014837Z" creationid="Toshiyuki" creationdate="20140228T190235Z">
        <seg>sqrt(-1)でなければ、&lt;c0&gt;i&lt;/c0&gt;は何ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is a role?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T190938Z" creationid="Toshiyuki" creationdate="20140113T105627Z">
        <seg>ロールとは何ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What's the &lt;c0&gt;*&lt;/c0&gt; in the &lt;c1&gt;bless&lt;/c1&gt; call?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141139Z" creationid="Toshiyuki" creationdate="20140111T193347Z">
        <seg>&lt;c1&gt;bless&lt;/c1&gt;の呼び出しの&lt;c0&gt;*&lt;/c0&gt;は何でしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What's the difference?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T135508Z" creationid="Toshiyuki" creationdate="20140222T130749Z">
        <seg>違いは何ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c1&gt;subst&lt;/c1&gt; matches, it substitutes the matched portion of the string with its the second operand:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131309Z" creationid="Toshiyuki" creationdate="20140222T023214Z">
        <seg>&lt;c1&gt;subst&lt;/c1&gt;がマッチするとき、それは文字列のマッチした部分を第2オペランドで置換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a &lt;c0&gt;&lt;value&gt;&lt;/c0&gt; call matches, the action method with the same symbol as the matching subrule executes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T013132Z" creationid="Toshiyuki" creationdate="20140226T142324Z">
        <seg>&lt;c0&gt;&lt;value&gt;&lt;/c0&gt;がマッチを呼ぶとき、サブルールをマッチする同じシンボルのアクションメソッドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a class composes multiple roles, an alternate declaration syntax - called an &lt;c0&gt;also&lt;/c0&gt; declarator - may be more readable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140316T031420Z" creationid="Toshiyuki" creationdate="20140115T140951Z">
        <seg>クラスが複数のロールを合成する場合、代わりの宣言構文 ― &lt;c0&gt;also&lt;/c0&gt;宣言子と呼ばれる ― はより読みやすいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a class inherits from another class that informs the method dispatcher to follow the inheritance chain to look for a method to dispatch.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144059Z" creationid="Toshiyuki" creationdate="20140112T093116Z">
        <seg>クラスがもう一つのクラスを継承するとき、それはディスパッチするためのメソッドを探すために継承チェーンを追従するようにメソッド・ディスパッチャーに知らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a class inherits from multiple classes the dispatcher knows to look at both classes when looking up a method to search for.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144739Z" creationid="Toshiyuki" creationdate="20140112T132902Z">
        <seg>クラスが複数のクラスから継承するとき、ディスパッチャーは捜すメソッドを見るときに両方のクラスを見ることを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function or method returns an object you don't know about, finding its type with &lt;c0&gt;.WHAT&lt;/c0&gt;, a construction recipe for it with &lt;c1&gt;.perl&lt;/c1&gt; and so on you'll get a good idea what this return value is.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T152409Z" creationid="Toshiyuki" creationdate="20140112T161304Z">
        <seg>関数またはメソッドがあなたの知らないオブジェクトを返すとき、&lt;c0&gt;.WHAT&lt;/c0&gt;でその型を見つけ、&lt;c1&gt;.perl&lt;/c1&gt;でその構造を、そしてこの戻り値が何であるかという良いアイデアを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a subroutine has many parameters, it can become difficult for the caller to remember in what order they should pass the arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T011236Z" creationid="Toshiyuki" creationdate="20131231T195250Z">
        <seg>サブルーチンが多くのパラメータを持っているとき、呼び出し元が引数をどんな順序で渡すべきか覚えるのが難しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When array and hash variables appear directly in a double-quoted string (and not inside curly brackets), they are only interpolated if their name is followed by a postcircumfix -- a bracketing pair that follows a statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T030449Z" creationid="Toshiyuki" creationdate="20131026T164945Z">
        <seg>配列とハッシュ変数がダブルクォート付き文字列の中に直接表れるとき（そしてカーリーブラケットの中にない）、名前の後に後置接周辞 ― 文に続く括弧のペアがあるなら、それらは単に展開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When both positional and named parameters are present in the same signature, all the positional parameters need to come before the named parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T170215Z" creationid="Toshiyuki" creationdate="20140104T170215Z">
        <seg>順序に依存するものと名前付きのパラメータが両方とも同じシグネチャに存在するとき、全ての順序依存パラメータは名前付きパラメータの先にこなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When bound into a lol context, however, the parcel objects become real &lt;c0&gt;List&lt;/c0&gt; objects that keep their identity as discrete sublists.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T204650Z" creationid="Toshiyuki" creationdate="20130810T204650Z">
        <seg>lolコンテキストにバインドされるとき、どんな方法でも、パーセルオブジェクトは不連続のサブリストとしてそれらの識別子を持つ本当の&lt;c0&gt;List&lt;/c0&gt;オブジェクトになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When calling the rule &lt;c0&gt;&lt;value&gt;&lt;/c0&gt;, the grammar engine attempts to match the alternatives in parallel and the longest match wins.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T222513Z" creationid="Toshiyuki" creationdate="20140223T095318Z">
        <seg>ルール&lt;c0&gt;&lt;value&gt;&lt;/c0&gt;を呼ぶとき、グラマーエンジンは選択肢のマッチを並列に試みます。そして最長マッチが勝ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When followed by a number, it matches that many times.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T225250Z" creationid="Toshiyuki" creationdate="20140221T225250Z">
        <seg>数値が続くとき、それは複数回マッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When followed by a range, it can match any number of times that the range allows:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T225413Z" creationid="Toshiyuki" creationdate="20140221T225413Z">
        <seg>レンジが続くとき、レンジが許可する範囲で任意の回数マッチできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When matching &lt;c0&gt;m/\w+ 'en'/&lt;/c0&gt; against the string &lt;c1&gt;oxen&lt;/c1&gt;, the &lt;c2&gt;\w+&lt;/c2&gt; group first matches the whole string because of the greediness of &lt;c3&gt;+&lt;/c3&gt;, but then the &lt;c4&gt;en&lt;/c4&gt; literal at the end can't match anything.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T045309Z" creationid="Toshiyuki" creationdate="20140222T021708Z">
        <seg>文字列&lt;c1&gt;oxen&lt;/c1&gt;に対して&lt;c0&gt;m/\w+ 'en'/&lt;/c0&gt;をマッチングするとき、&lt;c2&gt;\w+&lt;/c2&gt;グループは&lt;c3&gt;+&lt;/c3&gt;の欲張りのため、全部の文字列に最初にマッチします。しかし、終わりのリテラルの&lt;c4&gt;en&lt;/c4&gt;はどんなものにもマッチすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When parsing a programming language you might discard whitespace characters and comments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T023749Z" creationid="Toshiyuki" creationdate="20140222T023749Z">
        <seg>プログラミング言語を解析するとき、あなたは空白文字とコメントを捨てるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When phasers are in different modules, the &lt;c3&gt;INIT&lt;/c3&gt; and &lt;c4&gt;END&lt;/c4&gt; phasers are treated as if declared at &lt;c5&gt;use&lt;/c5&gt; time in the using module.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130820T125044Z" creationid="Toshiyuki" creationdate="20130820T125044Z">
        <seg>phasersが異なるモジュールにある時、&lt;c3&gt;INIT&lt;/c3&gt;と&lt;c4&gt;END&lt;/c4&gt; phasersはモジュールを使う&lt;c5&gt;use&lt;/c5&gt;時に宣言されたかのように扱われる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When reaching for multiple inheritance it is good practice to consider whether the design wouldn't be better realized by using roles, which are generally safer because they force the class author to explicitly resolve conflicting method names.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T145912Z" creationid="Toshiyuki" creationdate="20140112T135351Z">
        <seg>デザインがロールを用いてよりよく実現されないかどうかにかかわらず、多重継承に至ることを考慮するのはよい習慣です（それらが明示的に矛盾するメソッド名を解決することをクラス作成者を強要するので、それは一般により安全です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the right-hand side is a scalar, the &lt;e0&gt;item assignment operator&lt;/e0&gt; with tight precedence is used, otherwise the loose-precedence &lt;e1&gt;list assignment operator&lt;/e1&gt; is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T114520Z" creationid="Toshiyuki" creationdate="20131027T114520Z">
        <seg>右側がスカラーであるとき、タイトな優先順による&lt;e0&gt;アイテム割り当て演算子&lt;/e0&gt;が使われます。さもなければ、ゆるい優先順の&lt;e1&gt;リスト割り当て演算子&lt;/e1&gt;が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When two array items have the same value, &lt;c0&gt;sort&lt;/c0&gt; leaves them in the same order as it found them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T145448Z" creationid="Toshiyuki" creationdate="20131026T145448Z">
        <seg>配列の2つのアイテムが同じ値を持つとき、&lt;c0&gt;sort&lt;/c0&gt;はそれらを見つけた順にしておきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as statement modifiers on implicit blocks (thunks), &lt;c0&gt;for&lt;/c0&gt; and &lt;c1&gt;given&lt;/c1&gt; privately temporize the current value of &lt;c2&gt;$_&lt;/c2&gt; for the left side of the statement and restore the original value at loop exit:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114751Z" creationid="Toshiyuki" creationdate="20130810T114751Z">
        <seg>文修飾子が暗黙のブロック（サンク）で使われるとき、&lt;c0&gt;for&lt;/c0&gt;と&lt;c1&gt;given&lt;/c1&gt;は左側の文の現在の&lt;c2&gt;$_&lt;/c2&gt;の値をひそかに一時的とし、ループの終了時に初期値を復元する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When using the &lt;c1&gt;is copy&lt;/c1&gt; trait, only the local copy is assigned; any arguments passed to the subroutine remain unchanged in the caller's scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T001354Z" creationid="Toshiyuki" creationdate="20131221T000857Z">
        <seg>&lt;c1&gt;is copy&lt;/c1&gt;トレイトを使うとき、ローカルコピーだけが割り当てられます；サブルーチンに渡された引数が何であれ、呼び出し元のスコープでは不変のままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When writing generic multi routines you often want to write a bit of code whose meaning is dependent on the linguistic context of the caller.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T042155Z" creationid="Toshiyuki" creationdate="20130811T042155Z">
        <seg>ジェネリックな複数のルーチンを書くとき、あなたはしばしば呼び出し元の言語コンテキストに意味が依存している少しのコードを書こうと思うだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you do so, the order in which they appear does not matter:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131231T224749Z" creationid="Toshiyuki" creationdate="20131231T224749Z">
        <seg>あなたがそうするとき、それらが出現する順序は重要ではありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you run the program, you'll see that &lt;c0&gt;say&lt;/c0&gt; doesn't print the contents of that string verbatim.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T083829Z" creationid="Toshiyuki" creationdate="20131026T152544Z">
        <seg>プログラムを実行するとき、&lt;c0&gt;say&lt;/c0&gt;は文字列の内容を文字通りには出力しないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use an array or list as a number, it evaluates to the number of items in that list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T124900Z" creationid="Toshiyuki" creationdate="20131028T124900Z">
        <seg>あなたが数として配列またはリストを使うとき、それはリストのアイテムの個数と評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever an exception occurs during the execution of a handler, it is pushed onto the end of the &lt;c0&gt;@*undead&lt;/c0&gt; array for later processing by an outer handler.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T111145Z" creationid="Toshiyuki" creationdate="20130814T111145Z">
        <seg>ハンドラの実行中に例外が起こる時はいつでも、外側のハンドラに処理されて後で&lt;c0&gt;@*undead&lt;/c0&gt;配列の終端にプッシュされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever the compiler performs a type check on the parameter &lt;c0&gt;$d&lt;/c0&gt;, it first checks the &lt;e1&gt;nominal&lt;/e1&gt; type (here, &lt;c2&gt;Any&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T223733Z" creationid="Toshiyuki" creationdate="20140112T222651Z">
        <seg>コンパイラがパラメータ&lt;c0&gt;$d&lt;/c0&gt;の型をチェックする時はいつでも、最初に&lt;e1&gt;普通の&lt;/e1&gt;型（ここでは&lt;c2&gt;Any&lt;/c2&gt;）をチェックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever the grammar engine finishes parsing a regex, it calls a method on the actions object with the same name as the regex.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T232713Z" creationid="Toshiyuki" creationdate="20140224T162336Z">
        <seg>グラマーエンジンが正規表現を解析し終わるときはいつでも、それは正規表現と同じ名前でactionsオブジェクトのメソッドを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you write a sub-routine call, you are implicitly creating a &lt;c0&gt;Capture&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T140521Z" creationid="Toshiyuki" creationdate="20140110T140521Z">
        <seg>サブルーチン呼び出しを書く時はいつでも、あなたは暗黙に&lt;c0&gt;Capture&lt;/c0&gt;を作成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which one is actually called depends on the type of the data passed to the subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T221516Z" creationid="Toshiyuki" creationdate="20140112T183643Z">
        <seg>どれが実際に呼ばれるかはサブルーチンに渡されるデータ型に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Perl 6 does enforce encapsulation on attributes, it also saves you from writing accessor methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045805Z" creationid="Toshiyuki" creationdate="20140111T183310Z">
        <seg>Perl 6がカプセル化を属性に強制する間、それはアクセサメソッドを記述することも安全に保ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While attributes give objects state, methods give objects behaviors.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184924Z" creationid="Toshiyuki" creationdate="20140111T184924Z">
        <seg>属性がオブジェクト状態を与える間、メソッドはオブジェクトに作用を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While backtracking is often useful and convenient, it can also be slow and confusing.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130936Z" creationid="Toshiyuki" creationdate="20140222T022028Z">
        <seg>バックトラックはしばしば役立って便利ですが、それは遅くなり混乱させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While multiple inheritance is a useful concept to know and on occasion of use, it is important to understand that there are more useful OOP concepts.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144941Z" creationid="Toshiyuki" creationdate="20140112T135006Z">
        <seg>多重継承は知ると役に立つ概念です。そして使用の時に、より役に立つOOP概念があることを理解するのは重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While regex names are completely up to the grammar writer, a regex named &lt;c0&gt;TOP&lt;/c0&gt; will, by default, be invoked when the &lt;c1&gt;.parse()&lt;/c1&gt; method is executed on a grammar (footnote: The name of the regex that is automatically invoked may also be specified as a parameter to &lt;c2&gt;.parse()&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T134815Z" creationid="Toshiyuki" creationdate="20140222T095529Z">
        <seg>正規表現名が完全にグラマーライター次第である間、&lt;c1&gt;.parse()&lt;/c1&gt;メソッドがグラマー上で実行されるとき、&lt;c0&gt;TOP&lt;/c0&gt;という名前の正規表現がデフォルトで起動されます。（脚注：自動的に起動される正規表現の名前は、&lt;c2&gt;.parse()&lt;/c2&gt;へのパラメータとしても指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this chapter has demonstrated the numeric and string comparison operators --&lt;c0&gt;==&lt;/c0&gt; and &lt;c1&gt;eq&lt;/c1&gt;--there is no operator for comparing ranges.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T135127Z" creationid="Toshiyuki" creationdate="20131029T125555Z">
        <seg>この章が数値と文字列の比較を説明する間 ― &lt;c0&gt;==&lt;/c0&gt;と&lt;c1&gt;eq&lt;/c1&gt; ― レンジを比較する演算子はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this does not work perfectly in all cases (footnote: For example closures cannot easily be reproduced this way; if you don't know what a closure is don't worry.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110124Z" creationid="Toshiyuki" creationdate="20140322T105559Z">
        <seg>とは言え、これは全てのケースで完璧に動作するわけではありません（脚注：例えばクロージャはこの方法では簡単に再構築できません；あなたがクロージャについて知らなければ心配はいりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Will result in the &lt;c0&gt;*@words&lt;/c0&gt; parameter having two string elements, not just a single array element.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T201603Z" creationid="Toshiyuki" creationdate="20140104T201603Z">
        <seg>結果として&lt;c0&gt;*@words&lt;/c0&gt;パラメータは単独の配列要素ではなく2つの文字列要素を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With &lt;c2&gt;.^methods&lt;/c2&gt; you can learn what you can do with it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T161413Z" creationid="Toshiyuki" creationdate="20140112T161413Z">
        <seg>&lt;c2&gt;.^methods&lt;/c2&gt;で、あなたはそれをどうすることができるのかについて学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With &lt;c3&gt;@a&lt;/c3&gt; and &lt;c4&gt;@b&lt;/c4&gt; as defined in the previous example, &lt;c5&gt;@a eqv @b&lt;/c5&gt; is true because &lt;c6&gt;@a&lt;/c6&gt; and &lt;c7&gt;@b&lt;/c7&gt; contain the same values each.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T123658Z" creationid="Toshiyuki" creationdate="20131028T123658Z">
        <seg>前の例で定義した&lt;c3&gt;@a&lt;/c3&gt;と&lt;c4&gt;@b&lt;/c4&gt;で、&lt;c6&gt;@a&lt;/c6&gt;と&lt;c7&gt;@b&lt;/c7&gt;は各々同じ値を含むので&lt;c5&gt;@a eqv @b&lt;/c5&gt;は真です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a target object or label, loop modifiers search lexotically for the scope to modify.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T103526Z" creationid="Toshiyuki" creationdate="20130806T103526Z">
        <seg>ターゲットオブジェクトかラベルを伴って、ループ修飾子はレギゾチックに変更するスコープを検索する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With no explicit type or constraint on the parameter &lt;c0&gt;$d&lt;/c0&gt;, its type defaults to &lt;c1&gt;Any&lt;/c1&gt;--and thus it matches any passed object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T225215Z" creationid="Toshiyuki" creationdate="20140112T225149Z">
        <seg>明確な型またはパラメータ&lt;c0&gt;$d&lt;/c0&gt;への制約なしで、&lt;c1&gt;Any&lt;/c1&gt;へのその型デフォルト ― したがって、それは渡されたどんなオブジェクトにもマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a lift, special rules apply to how names are looked up.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T061300Z" creationid="Toshiyuki" creationdate="20130811T061300Z">
        <seg>lift内では、どのように名前を調べるか特別なルールが適用される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a regex, the syntax &lt;c0&gt;&lt;&amp;word&gt;&lt;/c0&gt; locates the regex &lt;c1&gt;word&lt;/c1&gt; within the current lexical scope and matches against the regex.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T014916Z" creationid="Toshiyuki" creationdate="20140222T014916Z">
        <seg>正規表現の中で、構文&lt;c0&gt;&lt;&amp;word&gt;&lt;/c0&gt;は現在のレキシカルスコープの中で正規表現&lt;c1&gt;word&lt;/c1&gt;を見つけて、正規表現に対してマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within the &lt;c0&gt;if&lt;/c0&gt; block, &lt;c1&gt;$&lt;&lt;dup&gt;&lt;/c1&gt; is short for &lt;c2&gt;$/{'dup'}&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T015501Z" creationid="Toshiyuki" creationdate="20140222T015501Z">
        <seg>ifブロックの中で、$&lt;&lt;dup&gt;は$/{'dup'}の省略です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within the &lt;c0&gt;if&lt;/c0&gt; block, &lt;c1&gt;$&lt;dup&gt;&lt;/c1&gt; is short for &lt;c2&gt;$/{'dup'}&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T041129Z" creationid="Toshiyuki" creationdate="20140321T041129Z">
        <seg>&lt;c0&gt;if&lt;/c0&gt;ブロックの中で、&lt;c1&gt;$&lt;dup&gt;&lt;/c1&gt;は&lt;c2&gt;$/{'dup'}&lt;/c2&gt;の省略です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a target, however, they are purely dynamic, and choose the innermost dynamic loop, which may well be a &lt;c0&gt;map&lt;/c0&gt; or other implicitly looping function, including user-defined functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130721Z" creationid="Toshiyuki" creationdate="20130808T130721Z">
        <seg>ターゲットなしで純粋に動的ならなんであれ、最も深い部分の動的ループを選ぶ。それは&lt;c0&gt;map&lt;/c0&gt;または他の暗黙のユーザー定義の関数を含むループ関数だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without the first word boundary anchor, the regex would for example match &lt;e0&gt;str&lt;s1&gt;and and&lt;/s1&gt; beach&lt;/e0&gt; or &lt;e2&gt;la&lt;s3&gt;the the&lt;/s3&gt; table leg&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130057Z" creationid="Toshiyuki" creationdate="20140222T014011Z">
        <seg>最初の単語境界アンカーなしでは、例の正規表現は&lt;e0&gt;str&lt;s1&gt;and and&lt;/s1&gt; beach&lt;/e0&gt;または&lt;e2&gt;la&lt;s3&gt;the the&lt;/s3&gt; table leg&lt;/e2&gt;にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without the last word boundary anchor it would also match &lt;e4&gt;&lt;s5&gt;the the&lt;/s5&gt;ory&lt;/e4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T014042Z" creationid="Toshiyuki" creationdate="20140222T014042Z">
        <seg>最後のアンカーなしでは&lt;e4&gt;&lt;s5&gt;the the&lt;/s5&gt;ory&lt;/e4&gt;にもマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working With Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140105T064909Z" creationid="Toshiyuki" creationdate="20140105T064909Z">
        <seg>型で作業する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing a fractional value with a dot as the decimal separator, such as &lt;c0&gt;3.14&lt;/c0&gt;, produces a &lt;c1&gt;Rat&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T014646Z" creationid="Toshiyuki" creationdate="20140228T190002Z">
        <seg>小数点（例えば&lt;c0&gt;3.14&lt;/c0&gt;）としてドットで小数値を書くことは&lt;c1&gt;Rat&lt;/c1&gt;を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You already know that the three-argument version and the four-argument version have different candidates: the latter binds its first argument as &lt;c0&gt;rw&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140315T035225Z" creationid="Toshiyuki" creationdate="20140113T063649Z">
        <seg>あなたは、3引数版と4引数版が異なる候補を持っているということをすでに知っています：後者は、&lt;c0&gt;rw&lt;/c0&gt;としてその最初の引数を結びつけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are free instead to write your own accessor method, if at some future point you need to do something more complex than return the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184610Z" creationid="Toshiyuki" creationdate="20140111T184610Z">
        <seg>将来、値を返すより複雑なことをしたいなら、貴方自身のアクセサメソッドを書いて結構です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can abuse this to count how often a type check occurs:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T112835Z" creationid="Toshiyuki" creationdate="20140112T222957Z">
        <seg>型チェックがどれくらい生じるか数えるために、これを酷使することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can achieve that by calling the regex as &lt;c0&gt;&lt;.otherrule&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T131447Z" creationid="Toshiyuki" creationdate="20140222T023817Z">
        <seg>あなたは&lt;c0&gt;&lt;.otherrule&gt;&lt;/c0&gt;として正規表現を呼ぶことによって、それを達成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also look behind to assert that the string only matches &lt;e0&gt;after&lt;/e0&gt; another regex fragment.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T084955Z" creationid="Toshiyuki" creationdate="20140222T024415Z">
        <seg>文字列が別の正規表現の断片の&lt;e0&gt;後に&lt;/e0&gt;だけマッチすると主張するために、後ろを見ることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also write the regex as &lt;c5&gt;m/hou?se/&lt;/c5&gt; without any spaces, and the &lt;c6&gt;?&lt;/c6&gt; will still quantify only the &lt;c7&gt;u&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T125424Z" creationid="Toshiyuki" creationdate="20140117T183449Z">
        <seg>何の空白もない&lt;c5&gt;m/hou?se/&lt;/c5&gt;のように正規表現を書くこともできます。そして&lt;c6&gt;?&lt;/c6&gt;はまだ&lt;c7&gt;u&lt;/c7&gt;だけを数量化するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can ask if two objects have the same numeric value with the &lt;c0&gt;==&lt;/c0&gt; infix operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T124101Z" creationid="Toshiyuki" creationdate="20131028T124101Z">
        <seg>2つのオブジェクトが同じ数値を持つかどうか、&lt;c0&gt;==&lt;/c0&gt;接中辞演算子で尋ねることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call methods on that instance, as long as they do not try to access any state; &lt;c1&gt;new&lt;/c1&gt; is an example, as it creates a new object rather than modifying or accessing an existing object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141945Z" creationid="Toshiyuki" creationdate="20140112T091343Z">
        <seg>それらが何の状態にもアクセスしようとしない限り、あなたはそのインスタンスでメソッドを呼ぶことができます；&lt;c1&gt;new&lt;/c1&gt;がその例です。存在するオブジェクトを変更するよりも新しいオブジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can cause built-ins to automatically throw exceptions on failure using</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T165751Z" creationid="Toshiyuki" creationdate="20130817T165751Z">
        <seg>次を使ってビルトインを失敗時に例外を自動的にスローさせる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can compose a role into a class at compile time or add it to an individual object at runtime.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T121748Z" creationid="Toshiyuki" creationdate="20140113T080250Z">
        <seg>あなたはロールをコンパイル時にクラスに合成するか、実行時に個々のオブジェクトにそれを追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare a parameter read/write by including the "&lt;c0&gt;is rw&lt;/c0&gt;" trait.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112806Z" creationid="Toshiyuki" creationdate="20130810T112806Z">
        <seg>&lt;c0&gt;is rw&lt;/c0&gt;トレイトを付け加えることでパラメータのread/writeを宣言することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare regexes just like subroutines--and even name them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T130205Z" creationid="Toshiyuki" creationdate="20140222T014111Z">
        <seg>あなたは正規表現をまるでサブルーチンのように宣言することができます ― そして、それらに名前さえつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do that with ordinary slicing access, or you can use signature binding:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T042032Z" creationid="Toshiyuki" creationdate="20140110T162921Z">
        <seg>あなたは普通のスライスアクセスでそうすることができる、または、あなたはシグネチャーバインディングを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can explicitly break out of a &lt;c0&gt;when&lt;/c0&gt; block (and its surrounding topicalizer block) early using the &lt;c1&gt;succeed&lt;/c1&gt; verb.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T113107Z" creationid="Toshiyuki" creationdate="20130812T113107Z">
        <seg>&lt;c1&gt;succeed&lt;/c1&gt;を使って&lt;c0&gt;when&lt;/c0&gt;ブロック（トピカライザーブロックを囲っている）を明示的に早く脱出できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can explicitly leave a &lt;c0&gt;when&lt;/c0&gt; block and go to the next statement following the &lt;c1&gt;when&lt;/c1&gt; by using &lt;c2&gt;proceed&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115044Z" creationid="Toshiyuki" creationdate="20130813T115044Z">
        <seg>&lt;c2&gt;proceed&lt;/c2&gt;を使うことで&lt;c0&gt;when&lt;/c0&gt;ブロックを明示的に抜け、&lt;c1&gt;when&lt;/c1&gt;に続く次の文に行くことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can express any assignment of the form &lt;c0&gt;$var = $var &lt;e1&gt;op&lt;/e1&gt; EXPR&lt;/c0&gt; as &lt;c2&gt;$var &lt;e3&gt;op&lt;/e3&gt;= EXPR&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T045400Z" creationid="Toshiyuki" creationdate="20131027T045400Z">
        <seg>あなたは&lt;c2&gt;$var &lt;e3&gt;op&lt;/e3&gt;= EXPR&lt;/c2&gt;として&lt;c0&gt;$var = $var &lt;e1&gt;op&lt;/e1&gt; EXPR&lt;/c0&gt;のどんな割り当てでも表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can force an explicit boolean context by putting a &lt;c1&gt;?&lt;/c1&gt; in front of an expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021717Z" creationid="Toshiyuki" creationdate="20140322T021717Z">
        <seg>&lt;c1&gt;?&lt;/c1&gt;を式の前に置くことによって明示的なブール値コンテキストを強制できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can inherit from and extend grammars, mix roles into them, and take advantage of polymorphism.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T223630Z" creationid="Toshiyuki" creationdate="20140223T101457Z">
        <seg>あなたはグラマーを継承、拡張、ロールをミックスし、ポリモーフィズムのアドバンテージを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass in arguments to the constructor as well:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140407T123645Z" creationid="Toshiyuki" creationdate="20140407T123645Z">
        <seg>同様に引数をコンストラクタに渡すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass roles around just like any other object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T123727Z" creationid="Toshiyuki" creationdate="20140115T142402Z">
        <seg>あなたは他のオブジェクトのようにロールを渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass them around and store them in data structures just as you can do with any other piece of data.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T034957Z" creationid="Toshiyuki" creationdate="20131029T133249Z">
        <seg>それらを他のデータ断片と同じく渡したりデータ構造に格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can query a hash table for the value that corresponds to a certain &lt;c6&gt;$key&lt;/c6&gt; with &lt;c7&gt;%hash{$key}&lt;/c7&gt; (footnote: Unlike Perl 5, in Perl 6 the sigil does not change when accessing an array or hash with &lt;c8&gt;[ ]&lt;/c8&gt; or &lt;c9&gt;{ }&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T003101Z" creationid="Toshiyuki" creationdate="20131026T094230Z">
        <seg>あなたは&lt;c6&gt;$key&lt;/c6&gt;と一致する特定の値を&lt;c7&gt;%hash{$key}&lt;/c7&gt;でハッシュテーブルに問い合わせることができます。（Perl 5と違い、Perl 6では&lt;c8&gt;[ ]&lt;/c8&gt;または&lt;c9&gt;{ }&lt;/c9&gt;で配列またはハッシュにアクセスする時にシギルを変えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can test for value equivalence using the &lt;c0&gt;===&lt;/c0&gt; infix operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T125339Z" creationid="Toshiyuki" creationdate="20131027T125339Z">
        <seg>同値の値かテストする&lt;c0&gt;===&lt;/c0&gt;接中辞演算子を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can turn any call to a subrule into a zero width assertion.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T073824Z" creationid="Toshiyuki" creationdate="20140222T024234Z">
        <seg>あなたは、どのようなルール呼び出しでもゼロ幅アサーションにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use any of these forms in any context where you can use a &lt;c0&gt;Pair&lt;/c0&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T013501Z" creationid="Toshiyuki" creationdate="20140104T160339Z">
        <seg>&lt;c0&gt;Pair&lt;/c0&gt;オブジェクトを使うことができる場所ならどんな文脈でもこれらの形式を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this method to find out if a given object is a type object or not:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T181736Z" creationid="Toshiyuki" creationdate="20140111T181736Z">
        <seg>あなたは、所定のオブジェクトが型オブジェクトであるかどうかこと知るために、このメソッドを使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can write the equivalent of many built-in anchors with look-ahead and look-behind assertions, though they won't be as efficient.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T085356Z" creationid="Toshiyuki" creationdate="20140222T024538Z">
        <seg>先読みと後読みアサーションで多くのビルトインアンカーの同等物を書くことができますが、それらは効率的ではないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could also write the example line as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T050105Z" creationid="Toshiyuki" creationdate="20131027T050105Z">
        <seg>あなたは例の行を次のように書くこともできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could easily write it yourself:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T132738Z" creationid="Toshiyuki" creationdate="20140111T050014Z">
        <seg>あなたは自分で簡単に書くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could recursively traverse this object and create data structures based on what you find or execute code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T231607Z" creationid="Toshiyuki" creationdate="20140224T161013Z">
        <seg>あなたは再帰的にこのオブジェクトを横断することができ、何を探すか、またはコードを実行するかに基づいてデータ構造を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could think of other ways for Perl 6 to interpret this program.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T111100Z" creationid="Toshiyuki" creationdate="20131027T111100Z">
        <seg>あなたは、Perl 6がこのプログラムを解釈する他の方法について考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to understand everything in this example yet.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T105534Z" creationid="Toshiyuki" creationdate="20140113T105534Z">
        <seg>あなたは、まだこの例ですべてを理解する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to use an explicit default--you can just fall off the last &lt;c1&gt;when&lt;/c1&gt; into ordinary code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133614Z" creationid="Toshiyuki" creationdate="20130811T133614Z">
        <seg>明示的なdefaultを使う必要はない―普通のコードの最後の&lt;c1&gt;when&lt;/c1&gt;をただ離れることもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have a word list and want to find words containing &lt;c0&gt;pe&lt;/c0&gt;, then an arbitrary letter, and then an &lt;c1&gt;l&lt;/c1&gt; (but not a space, as your puzzle has extra markers for those).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T024624Z" creationid="Toshiyuki" creationdate="20140117T182204Z">
        <seg>あなたはワードリストを持っており、そしてワードが&lt;c0&gt;pe&lt;/c0&gt;、それから任意の文字、そして&lt;c1&gt;l&lt;/c1&gt;（しかし空白ではなく、パズルはそれらの追加のマーカーを持っています）を含んでいるワードを探したいと思っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have seen blocks before: both the &lt;c0&gt;for&lt;/c0&gt; loop &lt;c1&gt;-&gt; $line { ... }&lt;/c1&gt; and the &lt;c2&gt;if&lt;/c2&gt; statement worked on blocks.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T144241Z" creationid="Toshiyuki" creationdate="20131026T144241Z">
        <seg>あなたは前にブロックを見ています：&lt;c0&gt;for&lt;/c0&gt;ループ&lt;c1&gt;-&gt; $line { ... }&lt;/c1&gt; と&lt;c2&gt;if&lt;/c2&gt;文の両方はブロックで機能します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have two options to write multi subs: either you start every candidate with &lt;c0&gt;multi sub ...&lt;/c0&gt; or &lt;c1&gt;multi ...&lt;/c1&gt;, or you declare once and for all that the compiler shall view every sub of a given name as a multi candidate.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T120740Z" creationid="Toshiyuki" creationdate="20140113T074928Z">
        <seg>あなたはマルチサブを書くために2つの選択肢を持っています：あなたはすべての候補を&lt;c0&gt;multi sub ...&lt;/c0&gt;または&lt;c1&gt;multi ...&lt;/c1&gt;で始める、またはコンパイラが名前のすべてのサブをマルチ候補として見ると宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You inherit a default constructor named &lt;c0&gt;new&lt;/c0&gt; from the base class &lt;c1&gt;Object&lt;/c1&gt;, but you are free to override &lt;c2&gt;new&lt;/c2&gt;, as this example does:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141122Z" creationid="Toshiyuki" creationdate="20140111T193319Z">
        <seg>あなたは&lt;c0&gt;new&lt;/c0&gt;という名前のデフォルトコンストラクターをベースクラス &lt;c1&gt;Object&lt;/c1&gt;から継承します。しかし例のように&lt;c2&gt;new&lt;/c2&gt;をオーバーライドするのは自由です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may add characters to or subtract characters from classes with the &lt;c0&gt;+&lt;/c0&gt; and &lt;c1&gt;-&lt;/c1&gt; operators:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T025703Z" creationid="Toshiyuki" creationdate="20140117T182920Z">
        <seg>&lt;c0&gt;+&lt;/c0&gt;と&lt;c1&gt;-&lt;/c1&gt;演算子でクラスに文字を加えるか、それを引きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also apply a role to an individual object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T122614Z" creationid="Toshiyuki" creationdate="20140115T101728Z">
        <seg>あなたはロールを個々のオブジェクトにも適用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also export a subroutine to make it available to another scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131029T133012Z" creationid="Toshiyuki" creationdate="20131029T133012Z">
        <seg>あなたはサブルーチンを他のスコープでも利用できるようにエクスポートすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also perform an existence test, either on a single item or a junction of items:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T085221Z" creationid="Toshiyuki" creationdate="20140329T085221Z">
        <seg>単独のアイテムかジャンクションで存在のテストを実行できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also specify that a parameter may only ever be passed an argument by name (meaning that it is not allowed to pass it by position).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T011622Z" creationid="Toshiyuki" creationdate="20131231T225258Z">
        <seg>パラメータがいつも名前による引数であることを示すこともできます（それを位置によって渡すことが許可されないことを意味します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may choose to capture some arguments into positional parameters and leave the rest to be captured by a slurpy array parameter.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T061025Z" creationid="Toshiyuki" creationdate="20140104T204901Z">
        <seg>あなたはいくつかの引数を位置依存のパラメータでキャプチャーし、残りをslurpyな配列パラメータに任せることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may force immediate conversion to a &lt;c0&gt;Capture&lt;/c0&gt; object by prefixing the parcel composer with a backslash:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T074659Z" creationid="Toshiyuki" creationdate="20140329T074659Z">
        <seg>バックスラッシュをパーセルコンポーザーの前に置くことによって&lt;c0&gt;Capture&lt;/c0&gt;オブジェクトへの即時の変換を強制できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have one &lt;c2&gt;CATCH&lt;/c2&gt; block and one &lt;c3&gt;CONTROL&lt;/c3&gt; block, since some user-defined constructs may wish to supply an implicit &lt;c4&gt;CONTROL&lt;/c4&gt; block to your closure, but let you define your own &lt;c5&gt;CATCH&lt;/c5&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T130520Z" creationid="Toshiyuki" creationdate="20130816T130520Z">
        <seg>一つの&lt;c2&gt;CATCH&lt;/c2&gt;ブロックと一つの&lt;c3&gt;CONTROL&lt;/c3&gt;ブロックを持つこともできる。なのでいくつかのユーザー定義の構造が暗黙の&lt;c4&gt;CONTROL&lt;/c4&gt;ブロックをあなたのクロージャに与えたいと思うかもしれないが、あなたに独自の&lt;c5&gt;CATCH&lt;/c5&gt;ブロックを定義させる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may not go into a &lt;c7&gt;given&lt;/c7&gt; or a &lt;c8&gt;for&lt;/c8&gt;, though, because that would bypass a formal parameter binding (not to mention list generation in the case of &lt;c9&gt;for&lt;/c9&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T142603Z" creationid="Toshiyuki" creationdate="20130817T142603Z">
        <seg>あたなは&lt;c7&gt;given&lt;/c7&gt;または&lt;c8&gt;for&lt;/c8&gt;には行かないだろうけれど、それは仮パラメータのバインディングをバイパスするだろう（&lt;c9&gt;for&lt;/c9&gt;のケースのリスト生成の言及ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may not use whitespace between a term and its postfix or postcircumfix operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140308T084543Z" creationid="Toshiyuki" creationdate="20131027T054137Z">
        <seg>項とその接尾辞または後置接周辞演算子の間で空白文字を使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may specify the unit with an argument of &lt;c24&gt;Degrees&lt;/c24&gt;, &lt;c25&gt;Gradians&lt;/c25&gt; or &lt;c26&gt;Circles&lt;/c26&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020228Z" creationid="Toshiyuki" creationdate="20140322T020228Z">
        <seg>単位を引数&lt;c24&gt;Degrees&lt;/c24&gt;、&lt;c25&gt;Gradians&lt;/c25&gt;または&lt;c26&gt;Circles&lt;/c26&gt;で指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may suppress this by modifying the first declaration with &lt;c0&gt;proto&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T130153Z" creationid="Toshiyuki" creationdate="20130730T130153Z">
        <seg>最初の宣言を&lt;c0&gt;proto&lt;/c0&gt;を付けて変更すればこれを抑制できるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may use :!exists to test for non-existence.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T085449Z" creationid="Toshiyuki" creationdate="20140329T085449Z">
        <seg>:!existsで存在しないことをテストできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might know this as &lt;e5&gt;reduce&lt;/e5&gt; from other programming languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T061949Z" creationid="Toshiyuki" creationdate="20131027T061949Z">
        <seg>あなたはこれを他のプログラミング言語の&lt;e5&gt;reduce&lt;/e5&gt;として知っているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must use &lt;c2&gt;last&lt;/c2&gt; (or some more violent control exception such as &lt;c3&gt;return&lt;/c3&gt;) to break out of the entire loop early.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120133Z" creationid="Toshiyuki" creationdate="20130813T120133Z">
        <seg>全体のループを早期に抜けるために&lt;c2&gt;last&lt;/c2&gt;（または&lt;c3&gt;return&lt;/c3&gt;のようないくつかのより乱暴な制御例外）を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need a script that sums up how many matches and sets each player has won to determine the overall winner.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T024114Z" creationid="Toshiyuki" creationdate="20131026T014938Z">
        <seg>あなたは全体の勝者を決定するために、各々のプレーヤーがどれだけの試合とセットで勝ちを得たか合計するスクリプトを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need a wormhole for that.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T092259Z" creationid="Toshiyuki" creationdate="20130818T092259Z">
        <seg>あなたはそれのためにワームホールを必要とする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You've already seen these in previous chapters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T135232Z" creationid="Toshiyuki" creationdate="20140111T181238Z">
        <seg>あなたは、前の章でこれらを既に見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your grammar describes the structure of the AST: its root element is the &lt;c0&gt;TOP&lt;/c0&gt; node, which contains children of the allowed types and so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T000955Z" creationid="Toshiyuki" creationdate="20140224T162604Z">
        <seg>あなたのグラマーはASTの構造を記述します：そのルート要素は&lt;c0&gt;TOP&lt;/c0&gt;ノードです。それは許可された型などの子を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Conjecture: a bare &lt;c0&gt;next($retval)&lt;/c0&gt; function could be taught to do the same, as long as &lt;c1&gt;$retval&lt;/c1&gt; isn't a loop label.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T102953Z" creationid="Toshiyuki" creationdate="20130806T102953Z">
        <seg>[推測：裸の&lt;c0&gt;next($retval)&lt;/c0&gt;関数は同じ事をするように教えられるかもしれない。&lt;c1&gt;$retval&lt;/c1&gt;がループラベルでない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Conjecture: all unhandled exceptions within a routine could be stored in &lt;c0&gt;@!&lt;/c0&gt;, with the most recent first.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T152234Z" creationid="Toshiyuki" creationdate="20130817T152234Z">
        <seg>［推測：ルーチン内の全てのハンドルされない例外は最も最近のものが&lt;c0&gt;@!&lt;/c0&gt;に格納される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Conjecture: there should either be an &lt;c12&gt;callergather&lt;/c12&gt; primitive that does this, or it should be added to the job description of &lt;c13&gt;lift&lt;/c13&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T162958Z" creationid="Toshiyuki" creationdate="20130810T162225Z">
        <seg>［推測：これをする&lt;c12&gt;callergather&lt;/c12&gt;プリミティブか、&lt;c13&gt;lift&lt;/c13&gt;の役割にそれを追加するべきだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>absolute value</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015556Z" creationid="Toshiyuki" creationdate="20140322T015556Z">
        <seg>絶対値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add 1 to the result of the do block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124258Z" creationid="Toshiyuki" creationdate="20130811T124258Z">
        <seg>はdoブロックの結果に1を加算する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>addition</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015357Z" creationid="Toshiyuki" creationdate="20140322T015357Z">
        <seg>加算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>additive infix operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T122409Z" creationid="Toshiyuki" creationdate="20131027T122409Z">
        <seg>加算の接中辞演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and that is equivalent to:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130805T183828Z" creationid="Toshiyuki" creationdate="20130805T161429Z">
        <seg>そしてそれは以下と同じだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>as a quasi-quoting symbol.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T175544Z" creationid="Toshiyuki" creationdate="20140112T175544Z">
        <seg>quasi-quotingシンボルとして。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>autoincrement and autodecrement</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121902Z" creationid="Toshiyuki" creationdate="20131027T121902Z">
        <seg>オートインクリメントとオートデクリメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>boolean prefix</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121926Z" creationid="Toshiyuki" creationdate="20131027T121926Z">
        <seg>ブールの接頭辞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calls the &lt;c0&gt;foo&lt;/c0&gt; function with three arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124219Z" creationid="Toshiyuki" creationdate="20130811T124219Z">
        <seg>は&lt;c0&gt;foo&lt;/c0&gt;関数を三つの引数で呼ぶ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can now be written as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140110T131957Z" creationid="Toshiyuki" creationdate="20140110T131957Z">
        <seg>これは次のように書くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>causes &lt;c0&gt;$x&lt;/c0&gt; to start with its current value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140153Z" creationid="Toshiyuki" creationdate="20130802T140153Z">
        <seg>は&lt;c0&gt;$x&lt;/c0&gt;をその現在の値で始める。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>chaining binary operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T123339Z" creationid="Toshiyuki" creationdate="20131027T123333Z">
        <seg>チェーンするバイナリ演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>clarify "same structure"</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131028T123904Z" creationid="Toshiyuki" creationdate="20131028T123904Z">
        <seg>「同じ構造」を明確にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>concatenation: &lt;c0&gt;'a' ~ 'b'&lt;/c0&gt; is &lt;c1&gt;'ab'&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020708Z" creationid="Toshiyuki" creationdate="20140322T020708Z">
        <seg>連結：&lt;c0&gt;'a' ~ 'b'&lt;/c0&gt;は&lt;c1&gt;'ab'&lt;/c1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>conditional operator</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T123401Z" creationid="Toshiyuki" creationdate="20131027T123401Z">
        <seg>代入演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>conversion to number</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015441Z" creationid="Toshiyuki" creationdate="20140322T015441Z">
        <seg>数値への変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>conversion to string: &lt;c0&gt;~1&lt;/c0&gt; becomes &lt;c1&gt;'1'&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020805Z" creationid="Toshiyuki" creationdate="20140322T020805Z">
        <seg>文字列への変換：&lt;c0&gt;~1&lt;/c0&gt;は&lt;c1&gt;'1'&lt;/c1&gt;になる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert first character to lower case</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021045Z" creationid="Toshiyuki" creationdate="20140322T021045Z">
        <seg>最初の文字だけ小文字にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert first character to upper case</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021030Z" creationid="Toshiyuki" creationdate="20140322T021030Z">
        <seg>最初の文字だけ大文字にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>convert the first character of each word to upper case, and all other characters to lower case</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021133Z" creationid="Toshiyuki" creationdate="20140322T021133Z">
        <seg>それぞれの単語の最初の文字だけ大文字にし、他のすべての文字を小文字にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deletes the entries &lt;i0&gt;en passant&lt;/i0&gt; while returning them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T084807Z" creationid="Toshiyuki" creationdate="20140329T084807Z">
        <seg>はそれらを返す&lt;i0&gt;ついでに&lt;/i0&gt;エントリーを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>description</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043916Z" creationid="Toshiyuki" creationdate="20140322T043916Z">
        <seg>概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>digit</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124735Z" creationid="Toshiyuki" creationdate="20140322T124735Z">
        <seg>数字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>division</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015305Z" creationid="Toshiyuki" creationdate="20140322T015305Z">
        <seg>除算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>en</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T031444Z" creationid="Toshiyuki" creationdate="20140222T031444Z">
        <seg>ja</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>end of a line</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232523Z" creationid="Toshiyuki" creationdate="20140221T232523Z">
        <seg>行の終わり</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>end of string</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232513Z" creationid="Toshiyuki" creationdate="20140221T232513Z">
        <seg>文字列の終わり</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exponentiation operator</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121915Z" creationid="Toshiyuki" creationdate="20131027T121915Z">
        <seg>指数演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>exponentiation: &lt;c0&gt;$a**$b&lt;/c0&gt; is &lt;c1&gt;$a&lt;/c1&gt; to the power of &lt;c2&gt;$b&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015246Z" creationid="Toshiyuki" creationdate="20140322T015246Z">
        <seg>累乗：&lt;c0&gt;$a**$b&lt;/c0&gt;は&lt;c1&gt;$a&lt;/c1&gt;への&lt;c2&gt;$b&lt;/c2&gt;の累乗です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>extract a part of the string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020852Z" creationid="Toshiyuki" creationdate="20140322T020852Z">
        <seg>文字列の一部を取り出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>horizontal whitespace</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124805Z" creationid="Toshiyuki" creationdate="20140322T124805Z">
        <seg>水平空白</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if we're gonna blow past</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T110705Z" creationid="Toshiyuki" creationdate="20130814T110705Z">
        <seg>もし我々が過去を吹きとばそうとしているなら</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in Perl 6 you should use a &lt;c0&gt;for&lt;/c0&gt; instead:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T062641Z" creationid="Toshiyuki" creationdate="20130810T062641Z">
        <seg>Perl 6では代わりに&lt;c0&gt;for&lt;/c0&gt;を使うべきだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125737Z" creationid="Toshiyuki" creationdate="20130730T125623Z">
        <seg>と代わりに書く必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>integer division</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015322Z" creationid="Toshiyuki" creationdate="20140322T015322Z">
        <seg>整数部</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is actually short for:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114018Z" creationid="Toshiyuki" creationdate="20130810T114018Z">
        <seg>は実際は以下の略だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to the Cish idiom:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060605Z" creationid="Toshiyuki" creationdate="20130810T060605Z">
        <seg>はC言語風のイディオムと同等だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is exactly equivalent to</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133252Z" creationid="Toshiyuki" creationdate="20130811T133252Z">
        <seg>は以下とまさに同等だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is parsed as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124611Z" creationid="Toshiyuki" creationdate="20130811T124611Z">
        <seg>は以下のようにパースされる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is really just short for:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T072238Z" creationid="Toshiyuki" creationdate="20130817T072238Z">
        <seg>は実際は以下の略だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it was always exit from your lexically scoped &lt;c0&gt;LINE&lt;/c0&gt; loop, even if some inner dynamic scope you can't see happens to also have that label.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T074659Z" creationid="Toshiyuki" creationdate="20130817T074659Z">
        <seg>それは常にレキシカルスコープな&lt;c0&gt;LINE&lt;/c0&gt;ループから抜け出す。あなたが見ることができないいくつかのダイナミックスコープがたまたまそのラベルを持っていても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>item assignment</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T123408Z" creationid="Toshiyuki" creationdate="20131027T123408Z">
        <seg>アイテム割り当て</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>left word boundary</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232606Z" creationid="Toshiyuki" creationdate="20140221T232606Z">
        <seg>左の語境界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>list infix</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T124844Z" creationid="Toshiyuki" creationdate="20131027T124844Z">
        <seg>リスト接中辞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>list prefix, list assignment</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T124910Z" creationid="Toshiyuki" creationdate="20131027T124910Z">
        <seg>リスト接頭辞、リスト割り当て</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>logarithm to base 10</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015639Z" creationid="Toshiyuki" creationdate="20140322T015639Z">
        <seg>10が底の対数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>loose unary prefix</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T123425Z" creationid="Toshiyuki" creationdate="20131027T123425Z">
        <seg>ルーズな単項接頭辞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>lower case</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021018Z" creationid="Toshiyuki" creationdate="20140322T021008Z">
        <seg>小文字にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>marks only the last exception as handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T163350Z" creationid="Toshiyuki" creationdate="20130817T163350Z">
        <seg>は最後の例外だけハンドルされたとマークする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043913Z" creationid="Toshiyuki" creationdate="20140322T043913Z">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method calls and postcircumfixes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121835Z" creationid="Toshiyuki" creationdate="20131027T121835Z">
        <seg>メソッド呼び出しと後置接周辞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>modulo (remainder after division)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015353Z" creationid="Toshiyuki" creationdate="20140322T015353Z">
        <seg>剰余（除算後の余り）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>multiplication</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015257Z" creationid="Toshiyuki" creationdate="20140322T015257Z">
        <seg>乗算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>multiplicative infix operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T122358Z" creationid="Toshiyuki" creationdate="20131027T122358Z">
        <seg>乗法の接中辞演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my $str = 'milk,flour,sugar and eggs';
say $str.subst(/',' &lt;?before \w&gt;/, ', ',  :g);
# output: milk, flour, sugar and eggs</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T133718Z" creationid="Toshiyuki" creationdate="20140322T133718Z">
        <seg>my $str = 'milk,flour,sugar and eggs';
say $str.subst(/',' &lt;？before \w&gt;/, ', ',  :g);
# output: milk, flour, sugar and eggs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>named unary prefix</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T122518Z" creationid="Toshiyuki" creationdate="20131027T122518Z">
        <seg>名前付きの単項接頭辞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>natural logarithm</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015622Z" creationid="Toshiyuki" creationdate="20140322T015622Z">
        <seg>自然対数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>negation</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015504Z" creationid="Toshiyuki" creationdate="20140322T015504Z">
        <seg>符号反転</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>newline</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124751Z" creationid="Toshiyuki" creationdate="20140322T124751Z">
        <seg>改行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>non-chaining binary operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T123320Z" creationid="Toshiyuki" creationdate="20131027T123320Z">
        <seg>チェーンしないバイナリ演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>number of characters in the string</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021000Z" creationid="Toshiyuki" creationdate="20140322T021000Z">
        <seg>文字列の文字数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125614Z" creationid="Toshiyuki" creationdate="20130730T125614Z">
        <seg>または</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or append a question mark to the parameter's name:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131230T041646Z" creationid="Toshiyuki" creationdate="20131230T041646Z">
        <seg>またはクエスチョンマークを引数名に追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently, using placeholders:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T125903Z" creationid="Toshiyuki" creationdate="20130810T125903Z">
        <seg>または同じようにプレースホルダーを使う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T054724Z" creationid="Toshiyuki" creationdate="20130809T151429Z">
        <seg>または同様に：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>prefix context operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121944Z" creationid="Toshiyuki" creationdate="20131027T121944Z">
        <seg>接頭コンテキスト演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>prints out only the result of &lt;c0&gt;5 - 7&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121612Z" creationid="Toshiyuki" creationdate="20131027T121612Z">
        <seg>は&lt;c0&gt;5 - 7&lt;/c0&gt;の結果だけ出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>remove trailing newline</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020841Z" creationid="Toshiyuki" creationdate="20140322T020841Z">
        <seg>末尾の改行を削除する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>replication operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T122430Z" creationid="Toshiyuki" creationdate="20131027T122430Z">
        <seg>複製演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>replication: &lt;c0&gt;'a' x 2&lt;/c0&gt; is &lt;c1&gt;'aa'&lt;/c1&gt;</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020722Z" creationid="Toshiyuki" creationdate="20140322T020722Z">
        <seg>複製：&lt;c0&gt;'a' x 2&lt;/c0&gt;は&lt;c1&gt;'aa'&lt;/c1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right word boundary</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232645Z" creationid="Toshiyuki" creationdate="20140221T232645Z">
        <seg>右の語境界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>right-hand or left-hand?</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T113851Z" creationid="Toshiyuki" creationdate="20131027T113851Z">
        <seg>右側か左側か？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rounding down to an integer</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015720Z" creationid="Toshiyuki" creationdate="20140322T015720Z">
        <seg>整数へ切り捨てる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rounding to next integer</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015734Z" creationid="Toshiyuki" creationdate="20140322T015734Z">
        <seg>次の整数へ丸める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rounding up to an integer</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015651Z" creationid="Toshiyuki" creationdate="20140322T015651Z">
        <seg>整数へ丸める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>say $str.subst(/',' &lt;?alpha&gt;/, ', ',  :g);</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T133827Z" creationid="Toshiyuki" creationdate="20140322T133827Z">
        <seg>say $str.subst(/',' &lt;？alpha&gt;/, ', ',  :g);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>se/&lt;/c2&gt; matches either &lt;c3&gt;house&lt;/c3&gt; or &lt;c4&gt;hose&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T125343Z" creationid="Toshiyuki" creationdate="20140322T125343Z">
        <seg>se/&lt;/c2&gt;は&lt;c3&gt;house&lt;/c3&gt;または&lt;c4&gt;hose&lt;/c4&gt;にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sets the variable to 0 at &lt;c0&gt;END&lt;/c0&gt; time, since that is when the "my" declaration is actually executed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085607Z" creationid="Toshiyuki" creationdate="20130818T085607Z">
        <seg>は&lt;c0&gt;END&lt;/c0&gt;時に変数を0にセットする。「my」宣言が実際に実行される時まで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>so you can modify the current list element in that case.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114118Z" creationid="Toshiyuki" creationdate="20130810T114118Z">
        <seg>なのでその場合あなたは現在のリストの要素を変更できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>square root</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015616Z" creationid="Toshiyuki" creationdate="20140322T015616Z">
        <seg>平方根</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>start of a line</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232519Z" creationid="Toshiyuki" creationdate="20140221T232519Z">
        <seg>行の開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>start of line</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T085447Z" creationid="Toshiyuki" creationdate="20140321T085447Z">
        <seg>行の開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>start of string</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232504Z" creationid="Toshiyuki" creationdate="20140221T232504Z">
        <seg>文字列の開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>string concatenation</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T122440Z" creationid="Toshiyuki" creationdate="20131027T122440Z">
        <seg>文字列の結合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>style="fill: $c" /&gt;]
}

# both calls work the same
paint-rectangle :color&lt;Blue&gt;;
paint-rectangle :colour&lt;Blue&gt;;

# of course you can still fill the other options
paint-rectangle :width(30), :height(10), :colour&lt;Blue&gt;;</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T012712Z" creationid="Toshiyuki" creationdate="20140309T012712Z">
        <seg>style="fill: $c" /&gt;]
}

# both calls work the same
paint-rectangle :color&lt;Blue&gt;;
paint-rectangle :colour&lt;Blue&gt;;

# もちろん、あなたはまだ他のオプションを満たすことができます
paint-rectangle :width(30), :height(10), :colour&lt;Blue&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>subtraction</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015401Z" creationid="Toshiyuki" creationdate="20140322T015401Z">
        <seg>減算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tabulator</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124747Z" creationid="Toshiyuki" creationdate="20140322T124747Z">
        <seg>タブ文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>term</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121752Z" creationid="Toshiyuki" creationdate="20131027T121752Z">
        <seg>項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the result is a &lt;c0&gt;Parcel&lt;/c0&gt; object containing three &lt;c1&gt;Int&lt;/c1&gt; objects and a &lt;c2&gt;Pair&lt;/c2&gt; object, that is, four positional objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073956Z" creationid="Toshiyuki" creationdate="20140329T073956Z">
        <seg>の結果は3つの&lt;c1&gt;Int&lt;/c1&gt;オブジェクトと&lt;c2&gt;Pair&lt;/c2&gt;オブジェクトを含む&lt;c0&gt;Parcel&lt;/c0&gt;、すなわち4つの位置依存オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the syntactic &lt;c0&gt;Parcel&lt;/c0&gt; is translated (at compile time, in this case) into a &lt;c1&gt;Capture&lt;/c1&gt; object with three positionals and one named argument in preparation for binding.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T074309Z" creationid="Toshiyuki" creationdate="20140329T074309Z">
        <seg>構文法の&lt;c0&gt;Parcel&lt;/c0&gt;はバインディングに備えて3つの位置依存と名前付き引数の&lt;c1&gt;Capture&lt;/c1&gt;オブジェクトに変換（この場合はコンパイル時に） されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then in a different program or module you can write</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T034927Z" creationid="Toshiyuki" creationdate="20131029T133053Z">
        <seg>そして異なるプログラムまたはモジュールで次のように書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to automatically assign to &lt;c0&gt;$_&lt;/c0&gt; is not carried over to Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T111849Z" creationid="Toshiyuki" creationdate="20130810T111731Z">
        <seg>を自動的に&lt;c0&gt;$_&lt;/c0&gt;へ割り当てることはPerl 6へは持ち越されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get the Perl 5 behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140241Z" creationid="Toshiyuki" creationdate="20130802T140241Z">
        <seg>Perl 5の振る舞いを得るために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>upper case</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T021014Z" creationid="Toshiyuki" creationdate="20140322T021004Z">
        <seg>大文字にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>vertical whitespace</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124814Z" creationid="Toshiyuki" creationdate="20140322T124814Z">
        <seg>垂直空白</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where each call to the block would bind a new invocant for the &lt;c0&gt;.waste&lt;/c0&gt; method, each of which is likely different from the original invocant to the &lt;c1&gt;.haste&lt;/c1&gt; method.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T103305Z" creationid="Toshiyuki" creationdate="20130804T103305Z">
        <seg>それぞれのブロックへの呼び出しが&lt;c0&gt;.waste&lt;/c0&gt;メソッドへの新しいインボカントをバインドするようなら、それぞれは&lt;c1&gt;.haste&lt;/c1&gt;メソッドのオリジナルのインボカントとおそらく違う。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is short for</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112030Z" creationid="Toshiyuki" creationdate="20130810T112030Z">
        <seg>それは以下の略だ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whitespace</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124741Z" creationid="Toshiyuki" creationdate="20140322T124741Z">
        <seg>空白</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will no longer see the value of the outer &lt;c0&gt;$x&lt;/c0&gt;; you'll need to say either</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125609Z" creationid="Toshiyuki" creationdate="20130730T125609Z">
        <seg>はもやは外側の&lt;c0&gt;$x&lt;/c0&gt;の値を見ない；あなたは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>word character</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124728Z" creationid="Toshiyuki" creationdate="20140322T124728Z">
        <seg>ワード文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you're really calling into a &lt;i0&gt;catch lambda&lt;/i0&gt; that works something like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T110054Z" creationid="Toshiyuki" creationdate="20130814T110054Z">
        <seg>実際にはこれの何かのように動作する&lt;i0&gt;catch lambda&lt;/i0&gt;の中へ呼んでいる：</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
    <tu>
      <prop type="file">S04-control.html</prop>
      <prop type="prev">The Relationship of Lexical and Dynamic Scopes</prop>
      <prop type="next">We use the phrase "lexical scoping" in its industry-standard meaning to indicate those blocks that surround the current textual location.</prop>
      <tuv lang="EN-US">
        <seg>Control flow is a dynamic feature of all computer programming languages, but languages differ in the extent to which control flow is attached to declarative features of the language, which are often known as "static" or "lexical".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T113135Z" creationid="Toshiyuki" creationdate="20130727T111855Z">
        <seg>制御フローは全てのコンピュータープログラミング言語における動的な機能だが、 制御フローに付属する「スタティック」や「レキシカル」として知られる宣言的機能の範囲は言語で異なる。</seg>
      </tuv>
    </tu>
    <tu>
      <prop type="file">UsingPerl6_20131020.html</prop>
      <prop type="prev">...
}</prop>
      <prop type="next">&lt;c3&gt;$file.lines&lt;/c3&gt; produces a list of the lines read from the file &lt;e4&gt;scores&lt;/e4&gt;, starting with the line where the previous calls to &lt;c5&gt;$file.get&lt;/c5&gt; left off, and going all the way to the end of the file.</prop>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;for&lt;/c0&gt; produces a loop that runs the &lt;e1&gt;block&lt;/e1&gt; delimited by curly brackets once for each item of the list, setting the variable &lt;c2&gt;$line&lt;/c2&gt; to the current value of each iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T101222Z" creationid="Toshiyuki" creationdate="20131026T101222Z">
        <seg>&lt;c0&gt;for&lt;/c0&gt;はカーリーブラケットで区切られた&lt;e1&gt;ブロック&lt;/e1&gt;をリストのアイテムそれぞれに1回実行するループを生成し、それぞれの繰り返しの現在の値を変数&lt;c2&gt;$line&lt;/c2&gt;にセットします。</seg>
      </tuv>
    </tu>
  </body>
</tmx>
