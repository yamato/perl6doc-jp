<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="3.1.4" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>(&lt;c1&gt;next&lt;/c1&gt; without a label is purely dynamic.) Lexotic and dynamic control flow is implemented by a system of control exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T062449Z" creationid="Toshiyuki" creationdate="20130728T061924Z">
        <seg>（ラベルなしの&lt;c1&gt;next&lt;/c1&gt;は純粋に動的だ。） レギゾチックとダイナミックな制御フローは制御例外としてシステムによって実装される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(All normal types in Perl may be evaluated for truth.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T070644Z" creationid="Toshiyuki" creationdate="20130804T070644Z">
        <seg>（Perlのすべての通常の型は真偽のために評価されるだろう。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Always assuming the user expects the right thing, of course...) In particular, if the user labels a loop with a specific label, and calls a loop control from within the lexical scope of that loop, and if that call mentions the outer loop's label, then that outer loop is the one that must be controlled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080908Z" creationid="Toshiyuki" creationdate="20130817T080908Z">
        <seg>（ユーザーが常に仮定するのは正しいことだ。もちろん）特に、特定のラベルでユーザーがループにラベルを付けるなら、そしてループ制御をそのレキシカルスコープ内でよぶなら、そしてその呼出しが外側のループのラベルを言及するなら、制御されなければならない外側のループは一つだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(By similar reasoning, an &lt;c5&gt;unless&lt;/c5&gt; allows binding of a false parameter.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T084132Z" creationid="Toshiyuki" creationdate="20130804T084132Z">
        <seg>（似た理由で、&lt;c5&gt;unless&lt;/c5&gt;偽のパラメータのバインディングを許可する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Contrast with a non-conditional statement such as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T100105Z" creationid="Toshiyuki" creationdate="20130804T100105Z">
        <seg>（条件付きでない文の対比はこのようになる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(FLAT is an acronym meaning Flat Lists Are Typical.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T210028Z" creationid="Toshiyuki" creationdate="20130810T210028Z">
        <seg>（FLATはFlat Lists Are Typicalの頭文字だ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If bare statements were allowed, the temporary binding of &lt;c4&gt;$_&lt;/c4&gt; would leak out past the end of the &lt;c5&gt;CATCH&lt;/c5&gt; or &lt;c6&gt;CONTROL&lt;/c6&gt;, with unpredictable and quite possibly dire consequences.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T091247Z" creationid="Toshiyuki" creationdate="20130818T091247Z">
        <seg>（もし裸の文が許可されるなら、&lt;c4&gt;$_&lt;/c4&gt;の一時的なバインディングは&lt;c5&gt;CATCH&lt;/c5&gt;または &lt;c6&gt;CONTROL&lt;/c6&gt;の終端をすぎてリークする。予測できず、まったく緊急かもしれない結果を伴って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If that is not the block you wish to leave, you must use the &lt;c12&gt;LABEL.leave&lt;/c12&gt; method (or some other control exception such as &lt;c13&gt;return&lt;/c13&gt; or &lt;c14&gt;next&lt;/c14&gt;) to be more specific, since the compiler may find it difficult to guess which surrounding construct was intended as the actual topicalizer.) The value of the inner block is returned as the value of the outer block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T131811Z" creationid="Toshiyuki" creationdate="20130811T131811Z">
        <seg>（もしそれが抜けたくないブロックなら、より明確にするために&lt;c12&gt;LABEL.leave&lt;/c12&gt;メソッド（または&lt;c13&gt;return&lt;/c13&gt;か&lt;c14&gt;next&lt;/c14&gt;のようないくつかの他の制御例外）を使わなければならない。 だからコンパイラが実際のトピカライザーとして意図される周囲の構成物がどれか推測するのは難しいだろう。） 内側のブロックの値は外側のブロックの値として返される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the &lt;c2&gt;LINE&lt;/c2&gt; is not visible, it would have been caught earlier at compile time since &lt;c3&gt;LINE&lt;/c3&gt; would likely be a bareword.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T075529Z" creationid="Toshiyuki" creationdate="20130817T075529Z">
        <seg>（もし&lt;c2&gt;LINE&lt;/c2&gt;が見えないなら、 &lt;c3&gt;LINE&lt;/c3&gt;が裸のワードのようになるまでコンパイル時に早期にキャッチされる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, it's lexotic.) If the &lt;c1&gt;LINE&lt;/c1&gt; label is visible but you aren't actually in a dynamic scope controlled by that label, an exception is thrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T075123Z" creationid="Toshiyuki" creationdate="20130817T075123Z">
        <seg>（言い換えれば、それはレギゾチックだ。）もし&lt;c1&gt;LINE&lt;/c1&gt;ラベルが可視だが実際にはラベルによって制御されたダイナミックスコープにいるなら、例外がスローされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, there is an implicit &lt;c5&gt;.die&lt;/c5&gt; just inside the end of the &lt;c6&gt;CATCH&lt;/c6&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T135455Z" creationid="Toshiyuki" creationdate="20130813T135455Z">
        <seg>（言い換えれば、&lt;c6&gt;CATCH&lt;/c6&gt;ブロックの内部の終端に暗黙の&lt;c5&gt;.die&lt;/c5&gt;があるだけだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Initialization of ordinary variables does not count--presumably the presence of a label will prevent code-movement optimizations past the label.) So, for instance, it's always possible to &lt;c5&gt;goto&lt;/c5&gt; into the next case of a &lt;c6&gt;when&lt;/c6&gt; or into either the "then" or "else" branch of a conditional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T142332Z" creationid="Toshiyuki" creationdate="20130817T142332Z">
        <seg>（普通の変数の初期化はカウントしない―多分、ラベルの存在はラベルを過ぎるcode-movement最適化を防ぐだろう。）なので、例えば、&lt;c5&gt;goto&lt;/c5&gt;で次のケースの&lt;c6&gt;when&lt;/c6&gt;か「then」または「else」の条件分岐に飛ぶことは常に可能だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It is erroneous to depend on this order if the module is used more than once, however, since the phasers are only installed the first time they're noticed.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030324Z" creationid="Toshiyuki" creationdate="20130822T030324Z">
        <seg>（モジュールが2回以上使われるなら、この順番に頼るのは間違いだ。しかしながら、phasersはそれらが初めて気づいた時だけインストールされる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(More generally, any container has a container type, including subroutines and modules.) The &lt;c0&gt;of&lt;/c0&gt; type is stored as its &lt;c1&gt;of&lt;/c1&gt; property, while the container type of the container is just the object type of the container itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T212922Z" creationid="Toshiyuki" creationdate="20140328T212922Z">
        <seg>（より一般化すると、どのようなコンテナもコンテナ型を持っています。それはサブルーチンとモジュールも含みます。）&lt;c0&gt;of&lt;/c0&gt;型は&lt;c1&gt;of&lt;/c1&gt;プロパティとして保存されます。コンテナの型はコンテナ自身のただのオブジェクト型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that both of these scans are done at compile time; if the scans fail, it's a compile-time semantic error.) Typically, such an outer block will be the block of a &lt;c5&gt;given&lt;/c5&gt; or a &lt;c6&gt;for&lt;/c6&gt; statement, but any block that sets the topic can be broken out of.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T165517Z" creationid="Toshiyuki" creationdate="20130812T165517Z">
        <seg>（両方のスキャンはコンパイル時に行われるので注意；もしスキャンが失敗したら、コンパイル時セマンティックエラーだ。）典型的には、そのようなブロックは&lt;c5&gt;given&lt;/c5&gt;か&lt;c6&gt;for&lt;/c6&gt;文のブロックだろう。しかしトピックをセットするどんなブロックでも脱出できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that fatal exception types can do the &lt;c2&gt;Resumable&lt;/c2&gt; role even if thrown via &lt;c3&gt;fail()&lt;/c3&gt;--when uncaught they just hit the outermost fatal handler instead of the outermost warning handler, so some inner scope has to explicitly treat them as warnings and resume them.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T115135Z" creationid="Toshiyuki" creationdate="20130817T115115Z">
        <seg>致命的な例外型は&lt;c3&gt;fail()&lt;/c3&gt;経由でスローされても&lt;c2&gt;Resumable&lt;/c2&gt;ロールを行えるので注意―キャッチされない時は最も外側の警告ハンドラの代わりに最も外側の致命的ハンドラをヒットするだけなので、いくつかの内側のスコープはそれらを警告と、それらを再会するとして明示的に扱う必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that, unlike C's idea of "falling through", subsequent &lt;c3&gt;when&lt;/c3&gt; conditions are evaluated.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115352Z" creationid="Toshiyuki" creationdate="20130813T115245Z">
        <seg>（C言語の「フォールスルー」の考えと違い、その後に続く&lt;c3&gt;when&lt;/c3&gt;の条件は評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note, however, that the value of a variable calculated at compile time may not persist under run-time cloning of any surrounding closure.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085255Z" creationid="Toshiyuki" creationdate="20130818T085255Z">
        <seg>（注意、けれども、コンパイル時に計算される変数の値はなにか一つの周囲のクロージャの実行時の複製まで残存しないだろう。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note: the implicit default binding of an outer &lt;c10&gt;$_&lt;/c10&gt; to an inner &lt;c11&gt;$_&lt;/c11&gt; can be emulated for a bare block, so that doesn't fall under the prohibition on bypassing formal binding.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T144409Z" creationid="Toshiyuki" creationdate="20130817T144409Z">
        <seg>（注意：外側の&lt;c10&gt;$_&lt;/c10&gt;の暗黙のデフォルトのバインディングから内側の&lt;c11&gt;$_&lt;/c11&gt;は裸のブロックのためにエミュレートできる。それゆえそれは正式のバインディングのバイパスの禁止に該当しない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or we use push semantics and &lt;c3&gt;$!&lt;/c3&gt; means &lt;c4&gt;@![*-1]&lt;/c4&gt;.) This might be more robust than merely making &lt;c5&gt;@!&lt;/c5&gt; a parameter to CATCH.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T152707Z" creationid="Toshiyuki" creationdate="20130817T152707Z">
        <seg>（または我々はpushセマンティクスを使い、&lt;c3&gt;$!&lt;/c3&gt;は&lt;c4&gt;@![*-1]&lt;/c4&gt;を意味する。）これは単に&lt;c5&gt;@!&lt;/c5&gt;をCATCHへのパラメータにするより強いかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Otherwise any &lt;c5&gt;die&lt;/c5&gt; would cause an infinite loop.) Instead we treasure them up and rethrow them to a handler further up.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T120951Z" creationid="Toshiyuki" creationdate="20130814T120951Z">
        <seg>（さもなければ&lt;c5&gt;die&lt;/c5&gt;は無限ループを引き起こすだろう。）その代わりとして我々はそれらを取っておき、さらに上のハンドラに再スローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See Definition of Success below for more.) &lt;c4&gt;temp&lt;/c4&gt; and &lt;c5&gt;let&lt;/c5&gt; temporize or hypotheticalize the value or the variable depending on whether you do assignment or binding.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T135926Z" creationid="Toshiyuki" creationdate="20130802T135926Z">
        <seg>（以下、詳細は成功の定義を参照）&lt;c4&gt;temp&lt;/c4&gt;と&lt;c5&gt;let&lt;/c5&gt;はあなたが割り当てるかバインドするかどうかに依存して値か変数を一時的にするか仮定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See below.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T123536Z" creationid="Toshiyuki" creationdate="20130813T123536Z">
        <seg>（以下を参照。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That is, in the abstract, they're all anonymous subroutines that take a snapshot of their lexical environment.) How a block is invoked and how its results are used are matters of context, but closures all work the same on the inside.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T120626Z" creationid="Toshiyuki" creationdate="20130729T120626Z">
        <seg>（それは抽象的には、それらは全てレキシカル環境のスナップショットを撮る無名サブルーチンだ。）ブロックがどのように呼び出され、結果がどのように使われるかはコンテキストの問題だが、クロージャは内部で全て同じに動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That is, it is a &lt;c12&gt;Mu&lt;/c12&gt; method, not a &lt;c13&gt;Failure&lt;/c13&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161841Z" creationid="Toshiyuki" creationdate="20130817T161841Z">
        <seg>（すなわち、それは&lt;c12&gt;Mu&lt;/c12&gt;メソッドで、&lt;c13&gt;Failure&lt;/c13&gt;メソッドではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c1&gt;repeat&lt;/c1&gt; keyword forces the conditional to be evaluated at the end of the loop, so it's still C's &lt;c2&gt;do-while&lt;/c2&gt; semantics.) Therefore, even under GNU style rules, the previous example may be rewritten into a very clear:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T054713Z" creationid="Toshiyuki" creationdate="20130810T053604Z">
        <seg>（&lt;c1&gt;repeat&lt;/c1&gt;キーワードは条件文をループの終わりで評価するようにさせるので、それはまだ C言語の&lt;c2&gt;do-while&lt;/c2&gt;セマンティクスだ。）したがって、GNUスタイルの規則でさえ、前の例はとてもわかりやすく書きなおされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c1&gt;while&lt;/c1&gt;'s declaration of &lt;c2&gt;$line&lt;/c2&gt; continues to be visible past the end of the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063315Z" creationid="Toshiyuki" creationdate="20130810T063300Z">
        <seg>（&lt;c1&gt;while&lt;/c1&gt;の&lt;c2&gt;$line&lt;/c2&gt;の宣言はブロックの終わりを過ぎても見え続ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c6&gt;Failure&lt;/c6&gt; may, however, be stored in any container whose type allows the &lt;c7&gt;Failure&lt;/c7&gt; role to be mixed in.) The &lt;c8&gt;.handled&lt;/c8&gt; method returns &lt;c9&gt;False&lt;/c9&gt; on failures that have not been handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161714Z" creationid="Toshiyuki" creationdate="20130817T161714Z">
        <seg>（&lt;c6&gt;Failure&lt;/c6&gt;はおそらく、どんな方法でも、&lt;c7&gt;Failure&lt;/c7&gt;ロールをミックスインされるために型が許可される何か一つのコンテナに格納される。）&lt;c8&gt;.handled&lt;/c8&gt;メソッドはハンドルされたことのない失敗で&lt;c9&gt;False&lt;/c9&gt;を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The difference between Perl 5 and Perl 6 in this respect arises only because Perl 5 didn't have user-defined control structures, hence the sub's lexical scope was &lt;i0&gt;always&lt;/i0&gt; the innermost dynamic scope, so the preference to the lexical scope in the current sub was implicit.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T081757Z" creationid="Toshiyuki" creationdate="20130817T081757Z">
        <seg>（この関係のPerl 5とPerl 6の間の違いは唯一発生する。なぜならPerl 5はユーザー定義の制御構造を持たず、それゆえにsubのレキシカルスコープは&lt;i0&gt;常に&lt;/i0&gt;最も深いダイナミックスコープのようなので、現在のsubのレキシカルスコープの優先傾向は暗黙だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Using the term "label" loosely, to include other solutions besides the label syntax, such as .gather and .take methods on some identity object.)]</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T195732Z" creationid="Toshiyuki" creationdate="20130810T195732Z">
        <seg>（「ラベル」という語句を緩く使う、ラベル文法に加えて他の解決策を付け加える、いくつかの識別オブジェクトでの.gatherと.takeメソッドのような 。）］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You can always establish a lexical scope explicitly by using the block form of argument.) As statement introducers, all these keywords must be followed by whitespace.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T081130Z" creationid="Toshiyuki" creationdate="20130811T081130Z">
        <seg>（ブロック形式の引数を使うことでいつでもレキシカルスコープを確立することができる。）文をもたらすものによって、これらすべてのキーワードは空白が続かなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You could write a macro that violates this, but resist the urge.) Variables that mediate between an outer statement and an inner block (such as loop variables) should generally be declared as formal parameters to that block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T123354Z" creationid="Toshiyuki" creationdate="20130729T123036Z">
        <seg>（あなたはこれを犯すマクロを書くことが可能だが、衝動を抑えてくれ。）外側の文と内側のブロック（ループ変数のような）の間を仲介する変数は一般的にはそのブロックの仮パラメータとして宣言されるべきだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$&lt;/c0&gt; always means a scalar variable, &lt;c1&gt;@&lt;/c1&gt; an array variable, and &lt;c2&gt;%&lt;/c2&gt; a hash variable, even when subscripting.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022212Z" creationid="Toshiyuki" creationdate="20140329T022212Z">
        <seg>&lt;c0&gt;$&lt;/c0&gt;は常にスカラー変数、&lt;c1&gt;@&lt;/c1&gt;は配列変数、&lt;c2&gt;%&lt;/c2&gt;はハッシュ変数を意味します（たとえ添字付けの場合でも）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Int&lt;/c0&gt; automatically supports promotion to arbitrary precision, as well as holding &lt;c1&gt;Inf&lt;/c1&gt; and &lt;c2&gt;NaN&lt;/c2&gt; values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130411Z" creationid="Toshiyuki" creationdate="20140328T130411Z">
        <seg>&lt;c0&gt;Int&lt;/c0&gt;は&lt;c1&gt;Inf&lt;/c1&gt;値と&lt;c2&gt;NaN&lt;/c2&gt;値だけでなく、随意精度への昇格を自動的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Num&lt;/c0&gt; must support the largest native floating point format that runs at full speed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130641Z" creationid="Toshiyuki" creationdate="20140328T130641Z">
        <seg>&lt;c0&gt;Num&lt;/c0&gt;は最大速度で実行できるもっとも大きいネイティブの浮動小数点フォーマットをサポートしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Numeric&lt;/c0&gt; Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130101Z" creationid="Toshiyuki" creationdate="20140328T130101Z">
        <seg>&lt;c0&gt;Numeric&lt;/c0&gt;型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Rat&lt;/c0&gt; supports extended precision rational arithmetic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130731Z" creationid="Toshiyuki" creationdate="20140328T130731Z">
        <seg>&lt;c0&gt;Rat&lt;/c0&gt;は拡張精度有理数演算をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;my Dog $spot&lt;/c0&gt; by itself does not automatically call a &lt;c1&gt;Dog&lt;/c1&gt; constructor.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133640Z" creationid="Toshiyuki" creationdate="20140327T133640Z">
        <seg>&lt;c0&gt;my Dog $spot&lt;/c0&gt;はそれ自体で&lt;c1&gt;Dog&lt;/c1&gt;のコンストラクタを呼びません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;$!&lt;/c1&gt; would then be sugar for &lt;c2&gt;@![0]&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T152257Z" creationid="Toshiyuki" creationdate="20130817T152257Z">
        <seg>&lt;c1&gt;$!&lt;/c1&gt;はその時&lt;c2&gt;@![0]&lt;/c2&gt;のシュガーだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;$!&lt;/c2&gt; is a convenient link to the last failure, and only ever contains one exception, the most recent.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T151646Z" creationid="Toshiyuki" creationdate="20130817T151646Z">
        <seg>&lt;c2&gt;$!&lt;/c2&gt;は最後の失敗への便利なリンクで、一つだけの最も最近の例外を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c3&gt;$0&lt;/c3&gt;, &lt;c4&gt;$1&lt;/c4&gt;, &lt;c5&gt;$2&lt;/c5&gt;, etc., are aliases into the &lt;c6&gt;$/&lt;/c6&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090731Z" creationid="Toshiyuki" creationdate="20140329T090731Z">
        <seg>&lt;c3&gt;$0&lt;/c3&gt;、&lt;c4&gt;$1&lt;/c4&gt;、&lt;c5&gt;$2&lt;/c5&gt;などは&lt;c6&gt;$/&lt;/c6&gt;オブジェクトの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c5&gt;Nil&lt;/c5&gt; also indicates a failed match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132843Z" creationid="Toshiyuki" creationdate="20140327T132843Z">
        <seg>&lt;c5&gt;Nil&lt;/c5&gt;は失敗したマッチも示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;CATCH&lt;/c0&gt; block handles only "bad" exceptions, and lets control exceptions pass unhindered.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125424Z" creationid="Toshiyuki" creationdate="20130816T125424Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロックは「悪い」例外だけ扱う。そして制御例外を妨げられないようにパスさせる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;CATCH&lt;/c0&gt; block is just a trait of the closure containing it, and is automatically called at the appropriate moment.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T075013Z" creationid="Toshiyuki" creationdate="20130818T075013Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロックはそれを含むクロージャのただのトレイトだ。そして適切な時に自動的に呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;CATCH&lt;/c0&gt; block sees the lexical scope in which it was defined, but its caller is the dynamic location that threw the exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115433Z" creationid="Toshiyuki" creationdate="20130814T115433Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロックはそれが定義されたレキシカルスコープをみる。しかしその呼び出し元は例外を投げたダイナミックロケーションだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;Str&lt;/c0&gt; is a Unicode string object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T131121Z" creationid="Toshiyuki" creationdate="20140328T131121Z">
        <seg>&lt;c0&gt;Str&lt;/c0&gt;はユニコード文字列オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;gather&lt;/c0&gt; is not considered a loop, but it is easy to combine with a loop statement as in the examples above.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T040719Z" creationid="Toshiyuki" creationdate="20130811T040719Z">
        <seg>&lt;c0&gt;gather&lt;/c0&gt;はループと見なされないが、上述した例におけるループ文に結合するのは簡単だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;return&lt;/c0&gt; always exits from the lexically surrounding sub or method definition (that is, from a function officially declared with the &lt;c1&gt;sub&lt;/c1&gt;, &lt;c2&gt;method&lt;/c2&gt;, or &lt;c3&gt;submethod&lt;/c3&gt; keywords).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T044152Z" creationid="Toshiyuki" creationdate="20130817T044152Z">
        <seg>&lt;c0&gt;return&lt;/c0&gt;は常にレキシカルに囲っているsubまたはメソッドの定義から抜け出る（すなわち、&lt;c1&gt;sub&lt;/c1&gt;、&lt;c2&gt;method&lt;/c2&gt;、または&lt;c3&gt;submethod&lt;/c3&gt;キーワードで正式に定義されている機能から）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;return&lt;/c0&gt;, for example, is considered a form of abnormal control flow, since it can jump out of multiple levels of closures to the end of the scope of the current subroutine definition.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T124607Z" creationid="Toshiyuki" creationdate="20130816T124306Z">
        <seg>例えば&lt;c0&gt;return&lt;/c0&gt;はアブノーマルな制御フローの形式と見なされる。だからそれは多数のレベルのクロージャから現在のサブルーチンの定義のスコープの終端までジャンプできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c3&gt;once&lt;/c3&gt; runs separately for each clone, so separate clones can keep separate state variables:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030938Z" creationid="Toshiyuki" creationdate="20130822T030712Z">
        <seg>&lt;c3&gt;once&lt;/c3&gt;はそれぞれの複製で別々に実行するので、別々の複製は異なるstate変数を保持できる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c7&gt;when&lt;/c7&gt; statement implicitly does a "smart match" between the current topic (&lt;c8&gt;$_&lt;/c8&gt;) and the argument of the &lt;c9&gt;when&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T130150Z" creationid="Toshiyuki" creationdate="20130811T130150Z">
        <seg>&lt;c7&gt;when&lt;/c7&gt;文は現在のトピック（&lt;c8&gt;$_&lt;/c8&gt;）と&lt;c9&gt;when&lt;/c9&gt;の引数の間で暗黙に「スマートマッチ」を行う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;i0&gt;name&lt;/i0&gt; is anything that is a legal part of a variable name (not counting the sigil).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T093723Z" creationid="Toshiyuki" creationdate="20140329T093723Z">
        <seg>&lt;i0&gt;名前&lt;/i0&gt;は変数名（シギルは数えない）の有効な部分なら何でもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bare &lt;c0&gt;die&lt;/c0&gt;/&lt;c1&gt;fail&lt;/c1&gt; takes &lt;c2&gt;$!&lt;/c2&gt; as the default argument specifying the exception to be thrown or propagated outward to the caller's &lt;c3&gt;$!&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T165331Z" creationid="Toshiyuki" creationdate="20130817T165331Z">
        <seg>裸の&lt;c0&gt;die&lt;/c0&gt;/&lt;c1&gt;fail&lt;/c1&gt;はスローされるか外側に伝搬される呼び出し元の&lt;c3&gt;$!&lt;/c3&gt;を明示する&lt;c2&gt;$!&lt;/c2&gt;をデフォルトの引数としてとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bare closure (except the block associated with a conditional statement) without placeholder arguments that uses &lt;c0&gt;$_&lt;/c0&gt; (either explicitly or implicitly) is treated as though &lt;c1&gt;$_&lt;/c1&gt; were a formal parameter:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T125517Z" creationid="Toshiyuki" creationdate="20130729T125517Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;（明示的か暗黙的かどちらか）を使うプレースホルダー引数無しの裸のクロージャ（条件付きの文に関連付けられているブロックは除く）は&lt;c1&gt;$_&lt;/c1&gt;が仮パラメータかのように扱われる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call may also be partially applied (primed) by using the &lt;c1&gt;.assuming&lt;/c1&gt; method:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T083749Z" creationid="Toshiyuki" creationdate="20140329T083749Z">
        <seg>呼び出しは&lt;c1&gt;.assuming&lt;/c1&gt;メソッドを用いて部分的に適用される（満たされる）こともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class is a module and thus can export stuff, but a class adds even more behavior to support Perl 6's standard class-based OO.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131700Z" creationid="Toshiyuki" creationdate="20140329T131700Z">
        <seg>クラスはモジュールなのでものをエクスポートすることができます。しかしPerl 6の標準のクラスベースのOOをサポートするためにより多くの動作をクラスは追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class is a module declared with the &lt;c0&gt;class&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131120Z" creationid="Toshiyuki" creationdate="20140329T131120Z">
        <seg>クラスは&lt;c0&gt;class&lt;/c0&gt;キーワードで宣言されるモジュールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A line ending with a closing brace "&lt;c0&gt;}&lt;/c0&gt;", followed by nothing but whitespace or comments, will terminate a statement if an end of statement can occur there.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T031036Z" creationid="Toshiyuki" creationdate="20130803T031036Z">
        <seg>閉じ括弧&lt;c0&gt;}&lt;/c0&gt;で終わり、次に何も続かない行末（空白文字とコメントは除く）は文の終了を発生させることができるなら文を終了する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A list of zero or more comma-separated objects may be grouped together by parentheses into a "parenthesis cell", or &lt;c0&gt;Parcel&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073616Z" creationid="Toshiyuki" creationdate="20140329T073616Z">
        <seg>0以上のコンマで区切られたオブジェクトは括弧によって“括弧セル”または&lt;c0&gt;Parcel&lt;/c0&gt;にグループ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A signature object (&lt;c0&gt;Signature&lt;/c0&gt;) may be created with colon-prefixed parens:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082134Z" creationid="Toshiyuki" creationdate="20140329T082134Z">
        <seg>シグネチャーオブジェクト（&lt;c0&gt;Signature&lt;/c0&gt;）はコロンを前につけた括弧で作成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch statement is a means of topicalizing, so the switch keyword is the English topicalizer, &lt;c0&gt;given&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125000Z" creationid="Toshiyuki" creationdate="20130811T125000Z">
        <seg>switch文はトピカライズの手段だ。そういうわけで、switchキーワードは英語のトピカライザー、&lt;c0&gt;given&lt;/c0&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable may itself be bound to a container type that specifies how the container works, without specifying what kinds of things it contains.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132445Z" creationid="Toshiyuki" creationdate="20140327T132445Z">
        <seg>どんな種類のものを含むか指定することなく、どのように機能するか指定しているコンテナ型に変数がバインドされている場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable's type is a constraint indicating what sorts of values the variable may contain.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132054Z" creationid="Toshiyuki" creationdate="20140327T132054Z">
        <seg>変数の型は、どんな種類の値を含むかについて示している制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variant of &lt;c0&gt;do&lt;/c0&gt; is &lt;c1&gt;gather&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152335Z" creationid="Toshiyuki" creationdate="20130810T152335Z">
        <seg>&lt;c0&gt;do&lt;/c0&gt;の変形は&lt;c1&gt;gather&lt;/c1&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to S12, properties are actually implemented by a kind of mixin mechanism, and such mixins are accomplished by the generation of an individual anonymous class for the object (unless an identical anonymous class already exists and can safely be shared).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132615Z" creationid="Toshiyuki" creationdate="20140326T132615Z">
        <seg>S12によると、プロパティは実際のところ一種のミックスインメカニズムで実現されます。そのようなミックスインは個々のオブジェクト（同一の匿名クラスが既に存在し、安全に共有できるのでなければ）のための匿名クラスの生成によって達成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the &lt;c0&gt;try&lt;/c0&gt; block or statement implicitly enforces a &lt;c1&gt;use fatal&lt;/c1&gt; context such that failures are immediately thrown as exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T123525Z" creationid="Toshiyuki" creationdate="20130813T123525Z">
        <seg>加えて、&lt;c0&gt;try&lt;/c0&gt;ブロックまたは文は暗黙的に失敗が例外として即時にスローされるように&lt;c1&gt;use fatal&lt;/c1&gt;コンテキストを強要する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All abnormal control flow is, in the general case, handled by the exception mechanism (which is likely to be optimized away in specific cases.) Here "abnormal" means any transfer of control outward that is not just falling off the end of a block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T124319Z" creationid="Toshiyuki" creationdate="20130816T124219Z">
        <seg>全てのアブノーマルな制御フローは、一般の場合、例外メカニズムによって扱われる（それはたぶん特定のケースに最適化される）。ここで「アブノーマル」は何か一つの外側への制御の転送を意味する。そしてそれはブロックの終端から離れるだけではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, the return type may be specified within the signature:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T230312Z" creationid="Toshiyuki" creationdate="20140328T230312Z">
        <seg>あるいは、戻り値の型はシグネチャで指定可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ampersand and invocation</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082723Z" creationid="Toshiyuki" creationdate="20140329T082723Z">
        <seg>アンパサンドと起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;of&lt;/c0&gt; type on an array or hash specifies the type stored by each element:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T222144Z" creationid="Toshiyuki" creationdate="20140328T222144Z">
        <seg>配列またはハッシュでの&lt;c0&gt;of&lt;/c0&gt;型は個々の要素で保存される型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c1&gt;of&lt;/c1&gt; type is given as a prefix or with the &lt;c2&gt;of&lt;/c2&gt; keyword:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T213135Z" creationid="Toshiyuki" creationdate="20140328T213135Z">
        <seg>&lt;c1&gt;of&lt;/c1&gt;型は接頭辞または&lt;c2&gt;of&lt;/c2&gt;キーワードで与えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c2&gt;INIT&lt;/c2&gt; only runs once for all copies of a cloned closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030538Z" creationid="Toshiyuki" creationdate="20130822T030538Z">
        <seg>&lt;c2&gt;INIT&lt;/c2&gt;は全ての複製されたクロージャで1回だけ実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;i0&gt;identifier&lt;/i0&gt; is composed of an alphabetic character followed by any sequence of alphanumeric characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T092032Z" creationid="Toshiyuki" creationdate="20140329T092032Z">
        <seg>&lt;i0&gt;識別子&lt;/i0&gt;は英数字のシーケンスが続く英字で構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An exception handler is just a switch statement on an implicit topic that happens to be the current exception to be dealt with.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T130151Z" creationid="Toshiyuki" creationdate="20130813T130151Z">
        <seg>例外ハンドラは分配されて現在の例外になるために起こるトピックで暗黙に文をただスイッチする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An explicit placeholder may also be used:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T084207Z" creationid="Toshiyuki" creationdate="20130804T084207Z">
        <seg>明示的なプレースホルダーも使われる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier may also contain isolated apostrophes or hyphens provided the next character is alphabetic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T093347Z" creationid="Toshiyuki" creationdate="20140329T093347Z">
        <seg>識別子は次が英字になっている独立したアポストロフィーまたはハイフンも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124223Z" creationid="Toshiyuki" creationdate="20130811T124223Z">
        <seg>そして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another consequence of this is that any block just inside a left parenthesis is immediately called like a bare block, so a multidimensional list comprehension may be written using a block with multiple parameters fed by a &lt;c0&gt;for&lt;/c0&gt; modifier:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T125832Z" creationid="Toshiyuki" creationdate="20130810T125832Z">
        <seg>これのもう一つの結果は、左括弧内のどんなブロックも裸のブロックのように直ちに呼び出されるので、多次元リストの理解力は&lt;c0&gt;for&lt;/c0&gt;修飾子で与えられた複数パラメータ付きのブロックを使うことで書き直せる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any block object can be used, not just labels, so to return a value from this iteration of the current block you can say:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T102511Z" creationid="Toshiyuki" creationdate="20130806T102511Z">
        <seg>ラベルだけでなく任意のオブジェクトを使える。それゆえ、現在のブロックのこのイテレーションから値を返すためにあなたは次のように書くことができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any other use of the &lt;c5&gt;Failure&lt;/c5&gt; object to extract a normal value will throw its associated exception immediately.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T155735Z" creationid="Toshiyuki" creationdate="20130817T155735Z">
        <seg>通常の値を取り出すための何か他の&lt;c5&gt;Failure&lt;/c5&gt;オブジェクトの使用はそれに関連付けられた例外を即座にスローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any parcels in the returned list are normally flattened when bound into flat context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T204319Z" creationid="Toshiyuki" creationdate="20130810T204319Z">
        <seg>返されたリストのどんなパーセルでも、フラットコンテキストにバインドされた時に通常は平坦化される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any remaining special variables will be lexically scoped.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090525Z" creationid="Toshiyuki" creationdate="20140329T090525Z">
        <seg>残りの特殊変数はレキシカルスコープになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name used as a value is the undefined prototype object of that type, or &lt;i0&gt;type object&lt;/i0&gt; for short.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T134127Z" creationid="Toshiyuki" creationdate="20140327T134127Z">
        <seg>値として使われる型名は何でもその型の未定義のプロトタイプオブジェクト、略して&lt;i0&gt;型オブジェクト&lt;/i0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from &lt;c0&gt;CATCH&lt;/c0&gt; and &lt;c1&gt;CONTROL&lt;/c1&gt;, which can only occur once, most of these can occur multiple times within the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093455Z" creationid="Toshiyuki" creationdate="20130818T093455Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;と&lt;c1&gt;CONTROL&lt;/c1&gt;は別として、それは一回だけ起こる。それらの大部分はブロック内で複数回発生できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apostrophe separator</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000056Z" creationid="Toshiyuki" creationdate="20140329T000056Z">
        <seg>アポストロフィーセパレーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments bound to the formal parameters of a pointy block are by default readonly within the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112434Z" creationid="Toshiyuki" creationdate="20130810T112434Z">
        <seg>ポインティブロックの仮パラメータにバインドされた引数はブロック内ではデフォルトで読み取り専用だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in C, the parentheses are required if you supply the 3-part spec; however, the 3-part loop spec may be entirely omitted to write an infinite loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060500Z" creationid="Toshiyuki" creationdate="20130810T060138Z">
        <seg>C言語における3部構成の仕様を与えるなら括弧が要求される；けれども、3部構成の仕様は無限ループを書くためには完全に省略できるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Perl 5, "&lt;c0&gt;our $foo&lt;/c0&gt;" introduces a lexically scoped alias for a variable in the current package.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T131442Z" creationid="Toshiyuki" creationdate="20130802T131442Z">
        <seg>Perl 5における&lt;c0&gt;our $foo&lt;/c0&gt;は現在のパッケージに変数のためのレキシカルスコープな別名をもたらす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Perl 5, it is possible to &lt;c4&gt;goto&lt;/c4&gt; into a lexical scope, but only for lexical scopes that require no special initialization of parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T142000Z" creationid="Toshiyuki" creationdate="20130817T142000Z">
        <seg>Perl 5におけるレキシカルスコープへの&lt;c4&gt;goto&lt;/c4&gt;は可能だ。しかし特別なパラメータの初期化を必要としないレキシカルスコープのみだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Perl 5, many built-in functions simply return an undefined value when you ask for a value out of range, or the function fails somehow.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T151040Z" creationid="Toshiyuki" creationdate="20130817T151040Z">
        <seg>Perl 5にあるようなたくさんのビルトイン関数は、あなたが値が範囲外か問い合わせるか関数がなぜか失敗するときに単純に未定義値を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned earlier, the loop variable is named by passing a parameter to the closure:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T061134Z" creationid="Toshiyuki" creationdate="20130810T061134Z">
        <seg>前に簡単に述べたように、ループ変数はクロージャにパラメータを渡すことで名前が付けられる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with an ordinary &lt;c0&gt;while&lt;/c0&gt;, you may optionally bind the result of the conditional expression to a parameter of the block:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T054928Z" creationid="Toshiyuki" creationdate="20130810T054928Z">
        <seg>通常の&lt;c0&gt;while&lt;/c0&gt;のように、条件式の結果をブロックのパラメータに任意に結びつけるなら：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with calls to &lt;c0&gt;return&lt;/c0&gt;, the warning control exception is an abstraction that the compiler is free to optimize away (along with the associated continuation) when the compiler or runtime can determine that the semantics would be preserved by merely printing out the error and going on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T124211Z" creationid="Toshiyuki" creationdate="20130817T124211Z">
        <seg>&lt;c0&gt;return&lt;/c0&gt;の呼び出しのように、警告制御例外はコンパイラが自由に最適化して取り除く抽象化だ（関連付けられた継続と一緒に）コンパイラかランタイムが決定できるとき、そのセマンティクスは単にエラーと進行をプリントするために保存される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with conditionals, you may optionally bind the result of the conditional expression to a parameter of the block:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T144106Z" creationid="Toshiyuki" creationdate="20130809T144106Z">
        <seg>条件文のように、条件付きの式の結果をブロックのパラメータに任意にバインドするなら：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with modules, the public storage, interface, and name of the class is represented by a package and its name, which is usually (but not necessarily) a global name.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131404Z" creationid="Toshiyuki" creationdate="20140329T131404Z">
        <seg>モジュールと同様に、パブリックストレージ、インターフェース、クラス名はパッケージとその名前によって表され、それは通常（しかし必ずではなく）グローバル名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with ordinary loop controls, the label is searched for first lexically within the current subroutine, then dynamically outside of it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T131653Z" creationid="Toshiyuki" creationdate="20130817T131653Z">
        <seg>普通のループ制御のように、ラベルは最初に現在のサブルーチン内レキシカルに検索される。その時はそれの外側をダイナミックに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with other statement prefixes, these value-producing constructs may be placed in front of either a block or a statement:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T082956Z" creationid="Toshiyuki" creationdate="20130818T082956Z">
        <seg>他の文接頭辞の様に、それらの値を出す構造はブロックか文の前に配置することもできる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the &lt;c7&gt;.leave&lt;/c7&gt; method, there is also a &lt;c8&gt;.succeed&lt;/c8&gt; method to break from a labelled block functioning as a switch:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120642Z" creationid="Toshiyuki" creationdate="20130813T120642Z">
        <seg>&lt;c7&gt;.leave&lt;/c7&gt;メソッドのように、switchとして機能するラベル付きブロックから抜けるための&lt;c8&gt;.succeed&lt;/c8&gt;メソッドもある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At run time, &lt;c7&gt;succeed&lt;/c7&gt; uses a control exception to scan up the dynamic chain to find the call frame belonging to that same outer block, and when it has found that frame, it does a &lt;c8&gt;.leave&lt;/c8&gt; on it to unwind the call frames.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114158Z" creationid="Toshiyuki" creationdate="20130813T114158Z">
        <seg>実行時に、&lt;c7&gt;succeed&lt;/c7&gt;は同じ外側のブロックに属するコールフレームを探すためのダイナミックチェインをスキャンするために制御例外を使う。そしてそのフレームが見つかった時、コールフレームを巻き戻すために&lt;c8&gt;.leave&lt;/c8&gt;を行う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backtracking control</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T021421Z" creationid="Toshiyuki" creationdate="20140222T021421Z">
        <seg>バックトラック制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;gather&lt;/c0&gt; evaluates its block or statement in sink context, this typically causes the &lt;c1&gt;take&lt;/c1&gt; function to be evaluated in sink context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T210403Z" creationid="Toshiyuki" creationdate="20130810T210403Z">
        <seg>&lt;c0&gt;gather&lt;/c0&gt;はそのブロックか文をsinkコンテキストで評価するので、これは典型的には&lt;c1&gt;take&lt;/c1&gt;関数がsinkコンテキストで評価されることを引き起こす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;when&lt;/c0&gt; statements are executed in order, the default must come last.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133337Z" creationid="Toshiyuki" creationdate="20130811T133337Z">
        <seg>なぜなら&lt;c0&gt;when&lt;/c0&gt;文は順番に実行されるので、defaultは最後に来なければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is possible to go to a label that is after the operation, and because Perl 6 does one-pass parsing, any &lt;c0&gt;goto&lt;/c0&gt; to a label that has not been yet declared (or is declared outside the outward lexical scope of the &lt;c1&gt;goto&lt;/c1&gt;) must enclose the label in quotes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T145112Z" creationid="Toshiyuki" creationdate="20130817T145112Z">
        <seg>なぜなら演算の後のラベルに行くことが可能で、Perl 6はワンパス解析を行うので、まだ定義されていない（または&lt;c1&gt;goto&lt;/c1&gt;の外側のレキシカルスコープの外に定義された）ラベルへのどれか一つの&lt;c0&gt;goto&lt;/c0&gt;はラベルをクオートで囲まなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of smart matching, ordinary &lt;c2&gt;when&lt;/c2&gt; statements are sufficiently powerful to pattern match the current exception against classes or patterns or numbers without any special syntax for exception handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T134345Z" creationid="Toshiyuki" creationdate="20130813T134345Z">
        <seg>スマートマッチングにより、通常の&lt;c2&gt;when&lt;/c2&gt;文は現在のクラスまたはパターンまたは例外ハンドラのための何らかの特別な文法のない数字に対する例外にマッチするために十分にパワフルだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because subroutine declarations are expressions, not statements, this is now invalid:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T032106Z" creationid="Toshiyuki" creationdate="20130803T032106Z">
        <seg>サブルーチンの宣言は式であり文ではないので、これは今では無効だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before you get too happy about this pragma, note that Perl 6 contains various parallel processing primitives that will tend to get blown up prematurely by thrown exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T172058Z" creationid="Toshiyuki" creationdate="20130817T172058Z">
        <seg>このプラグマでハッピーになる前に、Perl 6はスローされた例外によって早まって爆発しがちな様々な並行処理プリミティブを含むので注意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bracketing Characters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053433Z" creationid="Toshiyuki" creationdate="20140330T053433Z">
        <seg>ブラケット文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-In Data Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140325T141352Z" creationid="Toshiyuki" creationdate="20140325T141352Z">
        <seg>ビルトインデータ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But &lt;c0&gt;state&lt;/c0&gt; automatically applies "once" semantics to any initializer, so this also works:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T031051Z" creationid="Toshiyuki" creationdate="20130822T031051Z">
        <seg>しかし&lt;c0&gt;state&lt;/c0&gt;はどんなイニシャライザにも自動的に「once」セマンティクスを適用するので、これも動作する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But as always, you must use them all:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152144Z" creationid="Toshiyuki" creationdate="20130810T152144Z">
        <seg>しかしいつも通り、それらを全て使う必要がある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But generally that means you should refactor instead.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115447Z" creationid="Toshiyuki" creationdate="20130813T115447Z">
        <seg>しかし一般には代わりにリファクターするべきだということを意味する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But these two are valid:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T032204Z" creationid="Toshiyuki" creationdate="20130803T032204Z">
        <seg>しかしこれら二つは有効だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But to do that, it may eventually have to peel back any number of layers of dynamic call frames internal to the subroutine's current call frame.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T003645Z" creationid="Toshiyuki" creationdate="20130728T003645Z">
        <seg>それを行うためには、結局は皮をむき、ダイナミックコールフレーム内部のたくさんのレイヤーからサブルーチンの現在のコールフレームへ戻らなければならないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But use of a &lt;c2&gt;default&lt;/c2&gt; block is good documentation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133703Z" creationid="Toshiyuki" creationdate="20130811T133703Z">
        <seg>しかし&lt;c2&gt;default&lt;/c2&gt;ブロックの使用はよいドキュメンテーションだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default the innermost call frame matching the selection criteria will be exited.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T073639Z" creationid="Toshiyuki" creationdate="20130817T073639Z">
        <seg>デフォルトでは選択基準にマッチする最も深いコールフレームは抜けだされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default the second declaration will get a compiler warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T130008Z" creationid="Toshiyuki" creationdate="20130730T130008Z">
        <seg>デフォルトでは、二回目の宣言はコンパイラーの警告が出るだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131047Z" creationid="Toshiyuki" creationdate="20140329T131047Z">
        <seg>クラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code that is generated at run time can still fire off &lt;c0&gt;CHECK&lt;/c0&gt; and &lt;c1&gt;INIT&lt;/c1&gt; phasers, though of course those phasers can't do things that would require travel back in time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T092236Z" creationid="Toshiyuki" creationdate="20130818T092236Z">
        <seg>実行時に生成されるコードは&lt;c0&gt;CHECK&lt;/c0&gt;と&lt;c1&gt;INIT&lt;/c1&gt;　phasersをまだ発射できる。けれどももちろんそれらのphasersは時間内に行ったり来たりすることを要求することができない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coercive type declarations</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053600Z" creationid="Toshiyuki" creationdate="20140330T053600Z">
        <seg>制約型宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional statement modifiers work as in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T103406Z" creationid="Toshiyuki" creationdate="20130804T103406Z">
        <seg>条件付き文の修飾子はPerl 5のように動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T042318Z" creationid="Toshiyuki" creationdate="20130803T042318Z">
        <seg>条件付きの文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants (and enums) default to &lt;c1&gt;our&lt;/c1&gt; scoping so they can be accessed from outside the package.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T132343Z" creationid="Toshiyuki" creationdate="20130802T132127Z">
        <seg>定数（と列挙型）は&lt;c1&gt;our&lt;/c1&gt;スコープで初期化されるので、外側のパッケージからアクセスできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constraints and container types can be used together:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132506Z" creationid="Toshiyuki" creationdate="20140327T132506Z">
        <seg>制約とコンテナ型は一緒に使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructors</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T193050Z" creationid="Toshiyuki" creationdate="20140111T193050Z">
        <seg>コンストラクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructs marked with a &lt;c0&gt;*&lt;/c0&gt; have a run-time value, and if evaluated earlier than their surrounding expression, they simply save their result for use in the expression later when the rest of the expression is evaluated:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T082758Z" creationid="Toshiyuki" creationdate="20130818T082758Z">
        <seg>&lt;c0&gt;*&lt;/c0&gt;でマークされた構造は実行時の値を持つ。そしてそれらを囲う文より早く評価されたら、それらは文の残りが評価された時に後で文で使うために単純に結果を保存する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Container Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132156Z" creationid="Toshiyuki" creationdate="20140327T132156Z">
        <seg>コンテナ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Container types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224446Z" creationid="Toshiyuki" creationdate="20140328T224446Z">
        <seg>コンテナ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Containers enforce type safety on setting, whereas subroutines enforce type safety on return.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T223645Z" creationid="Toshiyuki" creationdate="20140328T223645Z">
        <seg>コンテナはセット時に型安全を強制するのに対し、サブルーチンはreturn時に型安全を強制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control exceptions may be caught with a &lt;c1&gt;CONTROL&lt;/c1&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125447Z" creationid="Toshiyuki" creationdate="20130816T125447Z">
        <seg>制御例外は&lt;c1&gt;CONTROL&lt;/c1&gt;ブロックでキャッチできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, &lt;c2&gt;$x.substr&lt;/c2&gt; implies conversion to a string or buffer type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T233548Z" creationid="Toshiyuki" creationdate="20140328T233548Z">
        <seg>反対に、&lt;c2&gt;$x.substr&lt;/c2&gt;は文字列かバッファー型への変換を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarators generally make the colon optional:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082408Z" creationid="Toshiyuki" creationdate="20140329T082408Z">
        <seg>宣言文は一般にコロンを任意にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a container type is the Perl 6 equivalent to tying a variable in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224736Z" creationid="Toshiyuki" creationdate="20140328T224736Z">
        <seg>コンテナ型を定義することはPerl 5のタイ変数のPerl 6の同等物です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each iteration's value is returned as a single "argument" object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T131157Z" creationid="Toshiyuki" creationdate="20130808T131157Z">
        <seg>それぞれの反復の値は一つの「引数」オブジェクトとして返される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each subsequent clone gets an initial state that is one higher than the previous, and each clone maintains its own state of &lt;c0&gt;$x&lt;/c0&gt;, because that's what &lt;c1&gt;state&lt;/c1&gt; variables do.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T031421Z" creationid="Toshiyuki" creationdate="20130822T031421Z">
        <seg>それぞれの後に続く複製は前よりも1高い初期stateを得る。そしてそれぞれのクローンは独自の&lt;c0&gt;$x&lt;/c0&gt;のstateを&lt;c1&gt;state&lt;/c1&gt;変数がするように扱う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded Comments</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053453Z" creationid="Toshiyuki" creationdate="20140330T053453Z">
        <seg>埋め込みコメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even in the absence of closure cloning, &lt;c0&gt;INIT&lt;/c0&gt; runs before the mainline code, while &lt;c1&gt;once&lt;/c1&gt; puts off the initialization till the last possible moment, then runs exactly once, and caches its value for all subsequent calls (assuming it wasn't called in sink context, in which case the &lt;c2&gt;once&lt;/c2&gt; is evaluated once only for its side effects).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130825T072119Z" creationid="Toshiyuki" creationdate="20130825T072119Z">
        <seg>クロージャの複製なしでも、&lt;c0&gt;INIT&lt;/c0&gt;はメインラインコードの前に実行する。&lt;c1&gt;once&lt;/c1&gt;が最後の可能な時まで延期する間、一度実行し、後の呼び出しのために値をキャッシュする（sinkコンテキストで呼ばれないと仮定し、&lt;c2&gt;once&lt;/c2&gt;が副作用のために1回だけ評価される場合）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every block is a closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T115438Z" creationid="Toshiyuki" creationdate="20130729T115438Z">
        <seg>全てのブロックはクロージャだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every object can produce a "WHICH" value that uniquely identifies the object for hashing and other value-based comparisons.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T122046Z" creationid="Toshiyuki" creationdate="20140328T122046Z">
        <seg>全てのオブジェクトはハッシュと他の値ベースの比較のためにオブジェクトをユニークに識別する“WHICH”値を生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except for such formal parameter declarations, all lexically scoped declarations are visible from the point of declaration to the end of the enclosing block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T130432Z" creationid="Toshiyuki" creationdate="20130729T130432Z">
        <seg>このような仮パラメータ宣言を除いて、すべてのレキシカルスコープの宣言は宣言の時点から取り囲むブロックの終了ま可視だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except within a quote literal, a &lt;c0&gt;#&lt;/c0&gt; character always introduces a comment in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140830T105607Z" creationid="Toshiyuki" creationdate="20140830T105607Z">
        <seg>クォートリテラルを除き、Perl 6において&lt;c0&gt;#&lt;/c0&gt;文字は常にコメントの開始になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception handlers</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121138Z" creationid="Toshiyuki" creationdate="20130813T121138Z">
        <seg>例外ハンドラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception handlers are supposed to reduce uncertainty, not increase it.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T091632Z" creationid="Toshiyuki" creationdate="20130818T091632Z">
        <seg>例外ハンドラは不確実に減らすと思われる。増加ではない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exceptions are not resumable in Perl 6 unless the exception object does the &lt;c1&gt;Resumable&lt;/c1&gt; role.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T114557Z" creationid="Toshiyuki" creationdate="20130817T114557Z">
        <seg>例外オブジェクトが&lt;c1&gt;Resumable&lt;/c1&gt;ロールを行わない限り例外はPerl 6で再開可能ではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit types are optional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T165359Z" creationid="Toshiyuki" creationdate="20140328T165359Z">
        <seg>型の明示は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions inside the signature are parsed as parameter declarations rather than ordinary expressions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082234Z" creationid="Toshiyuki" creationdate="20140329T082234Z">
        <seg>シグネチャーの中の式は普通の式よりもパラメータ宣言としてパースされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Perl 6 we have to make this preference for lexotic behavior explicit.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T081915Z" creationid="Toshiyuki" creationdate="20130817T081915Z">
        <seg>Perl 6ではこの優先傾向を明示的なレギゾチックな振る舞いのために作る必要がある。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a container, however, use of a coercion type as the &lt;c0&gt;of&lt;/c0&gt; coerces upon setting rather than returning the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224441Z" creationid="Toshiyuki" creationdate="20140328T224441Z">
        <seg>コンテナについては、&lt;c0&gt;of&lt;/c0&gt;としての型の強制の使用は値を返すよりもセットする方に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all builtin operations, all &lt;c0&gt;Str&lt;/c0&gt; positions are reported as position objects, not integers.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T133559Z" creationid="Toshiyuki" creationdate="20140328T133559Z">
        <seg>全ての組み込み演算のために、全ての&lt;c0&gt;Str&lt;/c0&gt;の位置は整数ではなく位置オブジェクトとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For any statement, prefixing with a &lt;c0&gt;do&lt;/c0&gt; allows you to return the value of that statement and use it in an expression:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T121351Z" creationid="Toshiyuki" creationdate="20130810T121351Z">
        <seg>どんな文でも、&lt;c0&gt;do&lt;/c0&gt;を前につけるとその値を返し、式として使えるようになる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T071641Z" creationid="Toshiyuki" creationdate="20140309T071641Z">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For finer-grained control of which iterations return values, use &lt;c0&gt;gather&lt;/c0&gt; and &lt;c1&gt;take&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T141605Z" creationid="Toshiyuki" creationdate="20130809T141605Z">
        <seg>値を返す反復のきめ細かな制御のために、&lt;c0&gt;gather&lt;/c0&gt;と&lt;c1&gt;take&lt;/c1&gt;を使え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, &lt;c0&gt;$x.abs&lt;/c0&gt; implies conversion to an appropriate numeric type if &lt;c1&gt;$x&lt;/c1&gt; is "cool" but doesn't already support a method of that name.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T233441Z" creationid="Toshiyuki" creationdate="20140328T233441Z">
        <seg>例えば、もし&lt;c1&gt;$x&lt;/c1&gt;が“cool”だが既にその名前のメソッドをサポートしない場合、&lt;c0&gt;$x.abs&lt;/c0&gt;は適切な数値型への変換を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, &lt;c0&gt;next&lt;/c0&gt; with a label will prefer to exit a loop lexotically, but if there is no loop with an appropriate label in the lexical context, it will then scan upward dynamically through the call frames for any loop with the appropriate label, even though that loop will not be lexically visible.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T053246Z" creationid="Toshiyuki" creationdate="20130728T053246Z">
        <seg>例えばラベルと一緒の&lt;c0&gt;next&lt;/c0&gt;はレギゾチックにループを抜ける方を好む。しかしループのないレキシカルコンテキストでラベルが割り当てられているなら、それはコールフレームを通ってラベルの割り当てられたどんなループでも動的に上方へスキャンするだろう。しかしながらループはレキシカルな可視ではないだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a &lt;c0&gt;return&lt;/c0&gt; statement always returns from the lexically scoped subroutine that surrounds it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T001641Z" creationid="Toshiyuki" creationdate="20130727T170533Z">
        <seg>例えば&lt;c0&gt;return&lt;/c0&gt;文は常にそれを囲むレキシカルスコープなサブルーチンから戻ってくる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a &lt;c2&gt;CHECK&lt;/c2&gt; block is called at the end of compiling a compilation unit.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T080355Z" creationid="Toshiyuki" creationdate="20130818T080355Z">
        <seg>例えば、&lt;c2&gt;CHECK&lt;/c2&gt;ブロックはコンパイル単位をコンパイルする終端で呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, unlike normal lexically scope variables, dynamic variables search up the dynamic call stack for a variable of a particular name, but at each "stop" along the way, they are actually looking in the lexical "pad" associated with that particular dynamic scope's call frame.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T155130Z" creationid="Toshiyuki" creationdate="20130727T155130Z">
        <seg>例えば通常のレキシカルなスコープの変数と違い、ダイナミックな変数は特定の名前の変数のためにダイナミックコールスタックをそれぞれの「ストップ」まで道々探すけれども、実際は特定のダイナミックスコープのコールフレームに関連付けられたレキシカル「パッド」を見ている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the lexotic return of &lt;c2&gt;next&lt;/c2&gt;, the control exception will contain the identity of the loop scope to be exited (since the label was already "used up" to discover that identity), but for the dynamic fallback, the exception will contain only the loop label to be matched dynamically.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T115017Z" creationid="Toshiyuki" creationdate="20130729T115017Z">
        <seg>レギゾチックなリターンの&lt;c2&gt;next&lt;/c2&gt;では、制御例外は終了されるループスコープの識別子を含んでいるだろう。しかしダイナミックなフォールバックでは、その例外は動的にマッチされるループラベルだけが含まれているだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From there it continues to scan outward to find the innermost block outside the &lt;c3&gt;when&lt;/c3&gt; that defines &lt;c4&gt;$_&lt;/c4&gt;, either explicitly or implicitly.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T114431Z" creationid="Toshiyuki" creationdate="20130812T114431Z">
        <seg>そこからそれは&lt;c4&gt;$_&lt;/c4&gt;を定義する&lt;c3&gt;when&lt;/c3&gt;の外側の最も深いブロックを探すために外側にスキャンを続ける。明示的か暗黙的に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further call frames up the caller stack may be located by use of the &lt;c0&gt;callframe&lt;/c0&gt; function:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T073303Z" creationid="Toshiyuki" creationdate="20130817T073303Z">
        <seg>呼び出し元のスタックより上のコールフレームは&lt;c0&gt;callframe&lt;/c0&gt;関数の使用によって配置することもできる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further compounding the difficulty is that every dynamic scope's outer call frame is associated with a lexical scope somewhere, so you can't just consider one kind of scoping or the other in isolation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T152246Z" creationid="Toshiyuki" creationdate="20130727T152246Z">
        <seg>それ以上に難しさをより一層ひどくするのは、それぞれのダイナミックスコープの外側のコールフレームがレキシカルスコープの何処かに関連付けられていることだ。そういう訳で、あなたは一種類のスコープどちらかだけを分離して考えることはできない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally you don't need to worry about this unless you're defining a control construct.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125602Z" creationid="Toshiyuki" creationdate="20130816T125602Z">
        <seg>一般に、あなたが制御構造を定義するのでなければこれに関して心配する必要はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T232202Z" creationid="Toshiyuki" creationdate="20140328T232202Z">
        <seg>ジェネリック型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given &lt;c0&gt;sink&lt;/c0&gt;, there's no need for an "else" clause on Perl 6's loops, and the &lt;c1&gt;sink&lt;/c1&gt; construct works in any list, not just &lt;c2&gt;for&lt;/c2&gt; loops.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T080818Z" creationid="Toshiyuki" creationdate="20140329T080818Z">
        <seg>&lt;c0&gt;sink&lt;/c0&gt;があればPerl 6のループで“else”節は必要なく、&lt;c1&gt;sink&lt;/c1&gt;構造は&lt;c2&gt;for&lt;/c2&gt;ループだけでなくどんなリストでも動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammars</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T132534Z" creationid="Toshiyuki" creationdate="20140321T132534Z">
        <seg>グラマー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handled exceptions break out past this implicit rethrow.) Hence, &lt;c7&gt;CATCH&lt;/c7&gt; is unlike all other switch statements in that it treats code inside a &lt;c8&gt;default&lt;/c8&gt; block differently from code that's after all the &lt;c9&gt;when&lt;/c9&gt; blocks but not in a &lt;c10&gt;default&lt;/c10&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T105620Z" creationid="Toshiyuki" creationdate="20130814T105620Z">
        <seg>扱われる例外は暗黙の再スローを過ぎて抜けだす。）その後、&lt;c7&gt;CATCH&lt;/c7&gt;は他のすべてのswitch文と違って&lt;c8&gt;default&lt;/c8&gt;ブロック内のコードを違うように扱う。結局&lt;c9&gt;when&lt;/c9&gt;ブロックで&lt;c10&gt;default&lt;/c10&gt;ブロックではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence numeric coercions such as &lt;c2&gt;+"42foo"&lt;/c2&gt; can be forced to return &lt;c3&gt;42&lt;/c3&gt; after issuing a warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T074800Z" creationid="Toshiyuki" creationdate="20130818T074800Z">
        <seg>その後、&lt;c2&gt;+"42foo"&lt;/c2&gt;のような数値強制は警告を出す後に&lt;c3&gt;42&lt;/c3&gt;を返すように強要できる。 after issuing a warning.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence these declare the same variables with the same scope as the preceding example, but run the statements as a whole at the indicated time:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T084908Z" creationid="Toshiyuki" creationdate="20130818T084908Z">
        <seg>その後、それらはすぐ前の例と同じスコープと同じ値を宣言する。しかし示された時に全体として文を実行する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the &lt;c0&gt;leave&lt;/c0&gt; function:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T072226Z" creationid="Toshiyuki" creationdate="20130817T072226Z">
        <seg>それゆえに、&lt;c0&gt;leave&lt;/c0&gt;関数は：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hierarchical types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T225105Z" creationid="Toshiyuki" creationdate="20140328T225105Z">
        <seg>階層型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a &lt;c2&gt;take&lt;/c2&gt; function that is not in sink context gathers its return objects &lt;i3&gt;en passant&lt;/i3&gt; and also returns them unchanged.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T213004Z" creationid="Toshiyuki" creationdate="20130810T213004Z">
        <seg>しかしながら、sinkコンテキストでない&lt;c2&gt;take&lt;/c2&gt;関数はリターンオブジェクトを&lt;i3&gt;ついでに&lt;/i3&gt;集め、そしてそれらを不変で返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a &lt;c3&gt;CATCH&lt;/c3&gt; must not behave that way, so we say that a &lt;c4&gt;CATCH&lt;/c4&gt; block never attempts to handle any exception thrown within its own dynamic scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T120608Z" creationid="Toshiyuki" creationdate="20130814T120608Z">
        <seg>しかしながら、&lt;c3&gt;CATCH&lt;/c3&gt;はそのように振舞ってはならない。それゆえ、&lt;c4&gt;CATCH&lt;/c4&gt;ブロックは決して独自のダイナミックスコープの範囲内で投げられた何か一つの例外をハンドルしようとしないといえる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in that case &lt;c5&gt;&amp;foo&lt;/c5&gt; by itself is not sufficient to uniquely name a specific function.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T083442Z" creationid="Toshiyuki" creationdate="20140329T083429Z">
        <seg>しかし、その場合&lt;c5&gt;&amp;foo&lt;/c5&gt;自身は特定の関数にユニークに名前を付けるのに十分ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's not an error when prefixed by a &lt;c0&gt;do&lt;/c0&gt;, or when followed by a statement modifier:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T151708Z" creationid="Toshiyuki" creationdate="20130810T151708Z">
        <seg>けれども、&lt;c0&gt;do&lt;/c0&gt;によって前に付けられる時、または文修飾子が続く時はエラーではない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, recursive calls to the same clone use the same state variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133530Z" creationid="Toshiyuki" creationdate="20130802T133530Z">
        <seg>しかしながら、同一のクローンの再帰的呼び出しは同じstate変数を使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, that's likely to be visually confused with a following &lt;c0&gt;while&lt;/c0&gt; loop at the best of times, so it's also allowed to put the loop conditional at the front, with the same meaning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T053609Z" creationid="Toshiyuki" creationdate="20130809T152726Z">
        <seg>しかしながら、&lt;c0&gt;while&lt;/c0&gt;ループが続くのは多分視覚的にわかりにくいので、同じ意味でループ条件を前に置くことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the labeled forms can use method call syntax: &lt;c3&gt;LABEL.next&lt;/c3&gt;, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T042110Z" creationid="Toshiyuki" creationdate="20130806T042110Z">
        <seg>しかし、ラベル付きの形式はメソッド呼び出し文法を使用出来る：&lt;c3&gt;LABEL.next&lt;/c3&gt;など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the name is introduced into the scope of the declaration itself, so it may be used to call itself recursively:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021832Z" creationid="Toshiyuki" creationdate="20140329T021832Z">
        <seg>しかし名前は宣言自体に導入されているので、自分自身を再帰的に呼び出すのに使えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the new semantics of autothrowing when sink eats a Failure means we won't have many unthrown exceptions waiting around to be handled at the end of the block anymore.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T153700Z" creationid="Toshiyuki" creationdate="20130817T153700Z">
        <seg>しかしながら、sinkがFailureを食べるときの自動スローの新しいセマンティクスは我々がたくさんのブロックの終端で待つハンドルされるスローされない例外を持ちたくないことを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there have to be some culturally enforced standards on which constructs capture which exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080123Z" creationid="Toshiyuki" creationdate="20130817T080123Z">
        <seg>けれども、構造がその例外を捕らえるいくつかの文化的に強要された標準がある必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this is likely to fail on autochomped filehandles, so use the &lt;c0&gt;for&lt;/c0&gt; loop instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063749Z" creationid="Toshiyuki" creationdate="20130810T063749Z">
        <seg>しかしながら、これは自動でchompされたファイルハンドルではおそらく失敗するので、代わりに&lt;c0&gt;for&lt;/c0&gt;ループを使え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, use of &lt;c0&gt;$_&lt;/c0&gt; with a conditional or conditionally repeating statement's block is &lt;i1&gt;not&lt;/i1&gt; considered sufficiently explicit to turn a 0-ary block into a 1-ary function, so all these methods use the same invocant:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T095940Z" creationid="Toshiyuki" creationdate="20130804T095940Z">
        <seg>しかしながら、0のブロックを1の関数に変えるために&lt;c0&gt;$_&lt;/c0&gt;を条件付きまたは条件付きで繰り返すブロックで使うことは十分に明白とは見なされない。だから全てのこれらのメソッドは同じインボカントを使う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you may omit the parentheses on the conditional:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T044327Z" creationid="Toshiyuki" creationdate="20130803T044327Z">
        <seg>けれども、括弧は条件付きで省略できる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any arguments are supplied to the &lt;c9&gt;succeed&lt;/c9&gt; function, they are passed out via the &lt;c10&gt;leave&lt;/c10&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114350Z" creationid="Toshiyuki" creationdate="20130813T114350Z">
        <seg>何か一つの引数が&lt;c9&gt;succeed&lt;/c9&gt;関数に与えられたら、それらは&lt;c10&gt;leave&lt;/c10&gt;メソッド経由で渡される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any exceptions are returned as not handled, the exception thrower keeps looking for a higher dynamic scope for a spot to unwind to.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T112836Z" creationid="Toshiyuki" creationdate="20130814T112836Z">
        <seg>もし何か一つの例外がハンドルされないとして返されるなら、例外を投げるものはスポットして巻き戻すためにより高いダイナミックスコープを探し続ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If continuations are used, the &lt;c0&gt;.resume&lt;/c0&gt; call will simply goto the continuation in question, and the lambda's callframe is abandoned.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T114130Z" creationid="Toshiyuki" creationdate="20130814T114130Z">
        <seg>もし継続が使われたら、&lt;c0&gt;.resume&lt;/c0&gt;呼び出しは単純に問題の継続に飛び、 そのlambdaのコールフレームは破棄される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If followed by a block it does not parse as a list operator or even as a prefix unary; it will never look for any additional expression following the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124145Z" creationid="Toshiyuki" creationdate="20130811T124145Z">
        <seg>もしブロックが続くリスト演算子か単項の接頭辞としてパースしないなら；ブロックに続く追加のどんな式も探さないだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If instead of the above you say:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T074109Z" creationid="Toshiyuki" creationdate="20130817T074109Z">
        <seg>上述の代わりに次のように書くなら：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no explicit handler handles it, the implicit outermost exception handler will eventually decide to abort and print all unhandled exceptions passed in as its current &lt;c0&gt;@!&lt;/c0&gt; list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T073531Z" creationid="Toshiyuki" creationdate="20130818T073531Z">
        <seg>もし明示的なハンドラがそれをハンドルしないなら、暗黙の最も外側の例外ハンドラは結局無視して現在の&lt;c0&gt;@!&lt;/c0&gt;リストとして渡される全てのハンドルされない例外をプリントすると決定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If none of the cases in the &lt;c3&gt;CATCH&lt;/c3&gt; handles the exception, the exception will be rethrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T134608Z" creationid="Toshiyuki" creationdate="20130813T134608Z">
        <seg>&lt;c3&gt;CATCH&lt;/c3&gt;の例外を扱うケースがないなら、例外は再スローされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c7&gt;gather&lt;/c7&gt; contains no &lt;c8&gt;take&lt;/c8&gt; lexically, it by definition cannot be the lexotic target of any &lt;c9&gt;take&lt;/c9&gt;, so it can only harvest dynamic &lt;c10&gt;take&lt;/c10&gt; calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T160429Z" creationid="Toshiyuki" creationdate="20130810T160429Z">
        <seg>&lt;c7&gt;gather&lt;/c7&gt;が&lt;c8&gt;take&lt;/c8&gt;をレキシカルに含んでいないなら、定義によってどんな&lt;c9&gt;take&lt;/c9&gt;のレギゾチックターゲットにもなれない。なので動的な&lt;c10&gt;take&lt;/c10&gt;呼び出しだけ収納できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the conditional does not execute any branch, the return value is &lt;c0&gt;()&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T050026Z" creationid="Toshiyuki" creationdate="20130803T050026Z">
        <seg>もし条件がいずれの分岐も実行しないなら、返り値は&lt;c0&gt;()&lt;/c0&gt;になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the failure throws its exception and the exception resumes, the thrower by default returns the null string (&lt;c0&gt;''&lt;/c0&gt;) to whatever caused the failure to throw its exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T074133Z" creationid="Toshiyuki" creationdate="20130818T074133Z">
        <seg>もし失敗が例外をスローして例外が再開するなら、スロー元はデフォルトで例外をスローするための失敗を引き起こすならなんでもnull文字列（&lt;c0&gt;''&lt;/c0&gt;）を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the smart match fails, control proceeds the next statement normally, which may or may not be a &lt;c0&gt;when&lt;/c0&gt; statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T132125Z" creationid="Toshiyuki" creationdate="20130811T132125Z">
        <seg>もしスマートマッチが失敗したら、制御は通常通り次の文へ進み、そしてそれは&lt;c0&gt;when&lt;/c0&gt;文になるかどうかわからない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the smart match succeeds, &lt;c10&gt;when&lt;/c10&gt;'s associated block is executed, and the innermost surrounding block that has &lt;c11&gt;$_&lt;/c11&gt; as one of its formal parameters (either explicit or implicit) is automatically broken out of.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T130833Z" creationid="Toshiyuki" creationdate="20130811T130833Z">
        <seg>もしスマートマッチが成功したら、&lt;c10&gt;when&lt;/c10&gt;に関連付けられたブロックは実行され、&lt;c11&gt;$_&lt;/c11&gt;を仮パラメータ（明示的か暗黙的）の一つとして持つ最も深い部分を囲うブロックは自動的に切り離される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the warning exception supports the &lt;c2&gt;.resume_value&lt;/c2&gt; method, that will be the value of the failure after it has resumed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130811Z" creationid="Toshiyuki" creationdate="20130817T130811Z">
        <seg>もし警告例外が&lt;c2&gt;.resume_value&lt;/c2&gt;メソッドをサポートするなら、それが再開された後に失敗の値になるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are any unhandled &lt;c1&gt;@!&lt;/c1&gt; exceptions, or if any exceptions were caught by the inner SIMPLECATCH (which does nothing but runs its push code, which should not produce any exceptions), then the CATCH block returns them to the exception thrower.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T111820Z" creationid="Toshiyuki" creationdate="20130814T111820Z">
        <seg>もしハンドルされない&lt;c1&gt;@!&lt;/c1&gt;例外があるなら、または何か一つの例外が内側のSIMPLECATCHにキャッチされるなら（それは何もしないがプッシュコードを実行する。そしてそれはどんな例外も引き起こすべきではない）、CATCHブロックは例外を投げるものにそれを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no statements in the block at all, the result is also &lt;c1&gt;()&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T022654Z" creationid="Toshiyuki" creationdate="20130803T022654Z">
        <seg>ブロックに文が全くないなら、その結果も&lt;c1&gt;()&lt;/c1&gt;になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no such lexically scoped outer loop in the current subroutine, then a fallback search is made outward through the dynamic scopes in the same way Perl 5 does.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T081114Z" creationid="Toshiyuki" creationdate="20130817T081114Z">
        <seg>もし現在のサブルーチンにそのようなレキシカルスコープの外側のループがないなら、フォールバックの検索はダイナミックスコープを通して外側にPerl 5と同じ方法で行われる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you &lt;i2&gt;don't&lt;/i2&gt; deal with the failures as data, then sink context will automatically throw any unhandled &lt;c3&gt;Failure&lt;/c3&gt; that you try to discard.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T175500Z" creationid="Toshiyuki" creationdate="20130817T175500Z">
        <seg>もしデータとして失敗に対処しないなら、 あなたが破棄しようと試みるハンドルされないどれか一つの&lt;c3&gt;Failure&lt;/c3&gt;をsinkコンテキストは自動的にスローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you declare a lexical twice in the same scope, it is the same lexical:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125859Z" creationid="Toshiyuki" creationdate="20130730T125859Z">
        <seg>もしもあなたがレキシカルを同じスコープで二回定義したら、それは同じレキシカルだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a &lt;c5&gt;CATCH&lt;/c5&gt; block within the &lt;c6&gt;try&lt;/c6&gt;, it replaces the default &lt;c7&gt;CATCH&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T122130Z" creationid="Toshiyuki" creationdate="20130813T122130Z">
        <seg>もし&lt;c5&gt;CATCH&lt;/c5&gt;ブロックを&lt;c6&gt;try&lt;/c6&gt;内に定義すると、デフォルトの&lt;c7&gt;CATCH&lt;/c7&gt;を差し替える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a switch that is the main block of a &lt;c0&gt;for&lt;/c0&gt; loop that uses &lt;c1&gt;$_&lt;/c1&gt; as its loop variable, and you break out of the switch either implicitly or explicitly (that is, the switch "succeeds"), control merely goes to the end of that block, and thence on to the next iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115936Z" creationid="Toshiyuki" creationdate="20130813T115936Z">
        <seg>もし&lt;c1&gt;$_&lt;/c1&gt;をループ変数として使っている&lt;c0&gt;for&lt;/c0&gt;ループのメインブロックとなっているswitchを持っており、switchを暗黙か明示的に抜けるなら（すなわち、switchが「成功する」）、制御は単にブロックの終わりに行き、そこから次のループの反復に行く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you rely on &lt;c0&gt;$_&lt;/c0&gt; as the implicit parameter to a block, then &lt;c1&gt;$_&lt;/c1&gt; is considered read/write by default.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113936Z" creationid="Toshiyuki" creationdate="20130810T113936Z">
        <seg>もし&lt;c0&gt;$_&lt;/c0&gt;をブロックの暗黙のパラメータとして当てにするなら、&lt;c1&gt;$_&lt;/c1&gt;はデフォルトでread/writeと見なされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you take multiple items in a comma list (since it is, after all, a list operator), they will be wrapped up in a &lt;c0&gt;Parcel&lt;/c0&gt; object for return as the next argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T201027Z" creationid="Toshiyuki" creationdate="20130810T201027Z">
        <seg>もしコンマリストで複数のアイテムをとるなら（だから、結局、リスト演算子）、それらは次の引数として返すために&lt;c0&gt;Parcel&lt;/c0&gt;オブジェクトにラップされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you test a &lt;c0&gt;Failure&lt;/c0&gt; for &lt;c1&gt;.defined&lt;/c1&gt; or &lt;c2&gt;.Bool&lt;/c2&gt;, the &lt;c3&gt;Failure&lt;/c3&gt; marks itself as &lt;i4&gt;handled&lt;/i4&gt;; the exception acts as a relatively harmless undefined value thereafter.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T155554Z" creationid="Toshiyuki" creationdate="20130817T155554Z">
        <seg>もし&lt;c0&gt;Failure&lt;/c0&gt;を&lt;c1&gt;.defined&lt;/c1&gt;または&lt;c2&gt;.Bool&lt;/c2&gt;のためにテストするなら、 &lt;c3&gt;Failure&lt;/c3&gt;はそれ自身を&lt;i4&gt;handled&lt;/i4&gt;としてマークする；例外はその後は相対的に無害な未定義値としてふるまう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a &lt;c0&gt;for&lt;/c0&gt; loop with a parameter named &lt;c1&gt;$_&lt;/c1&gt; (either explicitly or implicitly), that parameter can function as the topic of any &lt;c2&gt;when&lt;/c2&gt; statements within the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T111358Z" creationid="Toshiyuki" creationdate="20130812T111358Z">
        <seg>もし&lt;c0&gt;for&lt;/c0&gt;ループを名前付きパラメータ&lt;c1&gt;$_&lt;/c1&gt;（明示的か暗黙的）と共に使うなら、そのパラメータはループ内のどんな&lt;c2&gt;when&lt;/c2&gt;文のトピックとしても機能できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want it to be available, you must rewrite it as an explicit block using curlies:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T115013Z" creationid="Toshiyuki" creationdate="20130810T115013Z">
        <seg>もし使用できるようにしたいなら、カーリーブラケットを使って明白なブロックとして書き直す必要がある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to continue the expression after the statement, or if you want to attach multiple statements, you must either use the curly form or surround the entire expression in brackets of some sort:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T122313Z" creationid="Toshiyuki" creationdate="20130810T121937Z">
        <seg>もし文の後に式を続けたい、または複数の文を付け加えたいなら、カーリー形式か全体の式をブラケットで囲むかしなければならない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to return a closure from a function, you must use an explicit prefix such as &lt;c0&gt;return&lt;/c0&gt; or &lt;c1&gt;sub&lt;/c1&gt; or &lt;c2&gt;-&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T150911Z" creationid="Toshiyuki" creationdate="20130810T150911Z">
        <seg>もし関数からクロージャを返したければ、&lt;c0&gt;return&lt;/c0&gt;または&lt;c1&gt;sub&lt;/c1&gt;または&lt;c2&gt;-&gt;&lt;/c2&gt;のような明白な接頭辞を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you've referred to &lt;c0&gt;$x&lt;/c0&gt; prior to the first declaration, and the compiler tentatively bound it to &lt;c1&gt;$OUTER::x&lt;/c1&gt;, then it's an error to declare it, and the compiler is required to complain at that point.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T131017Z" creationid="Toshiyuki" creationdate="20130730T131017Z">
        <seg>もしあなたが最初の宣言の前に&lt;c0&gt;$x&lt;/c0&gt;を参照し、コンパイラがそれを仮に&lt;c1&gt;$OUTER::x&lt;/c1&gt;にバインドしたら、それを宣言することはエラーであり、コンパイラがその時点で文句を言う必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If, instead of throwing a warning directly, the program calls &lt;c1&gt;fail()&lt;/c1&gt; with a resumable exception, the throwing of the warning is delayed until first use (or the caller's policy) requires it to be thrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130550Z" creationid="Toshiyuki" creationdate="20130817T130550Z">
        <seg>もし代わりに例外を直接スルーするなら、プログラムは&lt;c1&gt;fail()&lt;/c1&gt;を再開可能な例外と共に呼ぶ。警告のスローは最初の使用（または呼び出し元のポリシー）がスローを要求するまで延ばされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 5, a bare block is deemed to be a do-once loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T120255Z" creationid="Toshiyuki" creationdate="20130810T120255Z">
        <seg>Perl 5では、裸のブロックはdo-onceループと判断される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, control flow is designed to do what the user expects most of the time, but this implies that we must consider the declarative nature of labels and blocks and combine those with the dynamic nature of the call stack.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T170258Z" creationid="Toshiyuki" creationdate="20130727T170258Z">
        <seg>Perl 6では制御フローはユーザーが殆どの場合期待する通りにデザインされているが、これは宣言的な性質のラベルとブロックとコールスタックの動的な性質とそれらを結びつけることについて我々が考えなければならないことを伴う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, the bare block is not a do-once.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T120317Z" creationid="Toshiyuki" creationdate="20130810T120317Z">
        <seg>Perl 6では裸のブロックはdo-onceではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a boolean context, a Hash object is true if there are any pairs in the hash.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090056Z" creationid="Toshiyuki" creationdate="20140329T090056Z">
        <seg>ブールコンテキストでは、ハッシュに何らかのペアがあればハッシュオブジェクトは真です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to &lt;c0&gt;next&lt;/c0&gt;, &lt;c1&gt;last&lt;/c1&gt;, and &lt;c2&gt;redo&lt;/c2&gt;, Perl 6 also supports &lt;c3&gt;goto&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T131449Z" creationid="Toshiyuki" creationdate="20130817T131449Z">
        <seg>&lt;c0&gt;next&lt;/c0&gt;、&lt;c1&gt;last&lt;/c1&gt;、&lt;c2&gt;redo&lt;/c2&gt;に加えてPerl 6は&lt;c3&gt;goto&lt;/c3&gt;もサポートする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, all formal parameters are the equivalent of &lt;c0&gt;my&lt;/c0&gt; variables within the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T125913Z" creationid="Toshiyuki" creationdate="20130729T125913Z">
        <seg>いずれにせよ、全ての仮パラメータはブロック内の&lt;c0&gt;my&lt;/c0&gt;変数と同等だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, the overriding design principle here is that no unhandled exception is ever dropped on the floor, but propagated outward until it is handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T182231Z" creationid="Toshiyuki" creationdate="20130817T182231Z">
        <seg>いずれにせよ、ここでのオーバーライドのデザイン原理は、ハンドルされない例外は常に床に落ちる。しかしハンドルされるまで外側に伝搬される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In boolean contexts, a true value is returned if and only if there are any elements in the container.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022628Z" creationid="Toshiyuki" creationdate="20140329T022628Z">
        <seg>ブール値コンテキストでは何らかの要素がコンテナにあれば真を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case this sets the &lt;c0&gt;of&lt;/c0&gt; property of the container to &lt;c1&gt;Dog&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T213252Z" creationid="Toshiyuki" creationdate="20140328T213252Z">
        <seg>いずれもコンテナの&lt;c0&gt;of&lt;/c0&gt;プロパティに&lt;c1&gt;Dog&lt;/c1&gt;をセットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, most of these phasers will take either a block or a thunk (known as a &lt;i0&gt;blast&lt;/i0&gt; in the vernacular).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T083300Z" creationid="Toshiyuki" creationdate="20130818T083300Z">
        <seg>実際は、大部分のphasersはブロックかサンク（固有の言葉で&lt;i0&gt;blast&lt;/i0&gt;として知られる）をとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, this construct would be relatively useless if you could bind only boolean values as parameters, since within the closure you already know whether it evaluated to true or false.) Binding within an &lt;c1&gt;else&lt;/c1&gt; automatically binds the value tested by the previous &lt;c2&gt;if&lt;/c2&gt; or &lt;c3&gt;elsif&lt;/c3&gt;, which, while known to be false, might nevertheless be an &lt;i4&gt;interesting&lt;/i4&gt; value of false.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T084044Z" creationid="Toshiyuki" creationdate="20130804T084044Z">
        <seg>実際は、もしあなたがブール値をパラメータとしてしかバインドしないなら、この構成物は相対的に役に立たない。だから、あなたはクロージャの範囲内でそれが真か偽で評価されるかすでに知っている。&lt;c1&gt;else&lt;/c1&gt;のバインドは値を前にテストした&lt;c2&gt;if&lt;/c2&gt;か&lt;c3&gt;elsif&lt;/c3&gt;に自動的にバインドし、偽と判明している間、&lt;i4&gt;面白い&lt;/i4&gt;偽の値にも関わらず。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, for most iterated solutions you should consider using a &lt;c2&gt;for&lt;/c2&gt; loop instead (see below).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T145855Z" creationid="Toshiyuki" creationdate="20130809T145855Z">
        <seg>一般に、最も繰り返される解決法のためにあなたは&lt;c2&gt;for&lt;/c2&gt;ループを代わりに使うことを検討すべきだ（下記参照）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, initializing phasers execute in order declared, while finalizing phasers execute in the opposite order.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130820T124713Z" creationid="Toshiyuki" creationdate="20130820T124713Z">
        <seg>一般にphasersの初期化は宣言順に実行し、ファイナライズは逆順に実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In item context, variables such as &lt;c3&gt;@array&lt;/c3&gt; and &lt;c4&gt;%hash&lt;/c4&gt; simply return themselves as &lt;c5&gt;Array&lt;/c5&gt; and &lt;c6&gt;Hash&lt;/c6&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022325Z" creationid="Toshiyuki" creationdate="20140329T022325Z">
        <seg>アイテムコンテキストでは&lt;c3&gt;@array&lt;/c3&gt;と&lt;c4&gt;%hash&lt;/c4&gt;のような変数は単にそれら自身を&lt;c5&gt;Array&lt;/c5&gt;と&lt;c6&gt;Hash&lt;/c6&gt;のオブジェクトとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most interesting programs the dynamic scopes are nested quite differently from the lexical scopes, so it's important to distinguish carefully which kind of scoping we're talking about.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T145648Z" creationid="Toshiyuki" creationdate="20130727T145648Z">
        <seg>最も興味深いプログラムでは、ダイナミックスコープはレキシカルスコープと全く違うように入れ子になっている。そういうわけで、我々が話しているようなスコープとは注意深く区別することが大切だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric context (i.e. when cast into &lt;c0&gt;Int&lt;/c0&gt; or &lt;c1&gt;Num&lt;/c1&gt;), a &lt;c2&gt;Hash&lt;/c2&gt; object becomes the number of pairs contained in the hash.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090003Z" creationid="Toshiyuki" creationdate="20140329T090003Z">
        <seg>数値コンテキスト（すなわち&lt;c0&gt;Int&lt;/c0&gt;または&lt;c1&gt;Num&lt;/c1&gt;にキャストする時）では、&lt;c2&gt;Hash&lt;/c2&gt;オブジェクトはハッシュに含まれるペアの数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric contexts, the number of elements in the container is returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022543Z" creationid="Toshiyuki" creationdate="20140329T022543Z">
        <seg>数値コンテキストではコンテナの要素数が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, it first tries this form:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080933Z" creationid="Toshiyuki" creationdate="20130817T080933Z">
        <seg>言い換えれば、最初にこの形式を試す：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular,</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124152Z" creationid="Toshiyuki" creationdate="20130811T124152Z">
        <seg>特に、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, this means that &lt;c3&gt;once&lt;/c3&gt; can make use of any parameters passed in on the first call, whereas &lt;c4&gt;INIT&lt;/c4&gt; cannot.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130825T072440Z" creationid="Toshiyuki" creationdate="20130825T072440Z">
        <seg>特に、&lt;c3&gt;once&lt;/c3&gt;は最初の呼び出しで任意のパラメータを使えるようにするのに対し、&lt;c4&gt;INIT&lt;/c4&gt;はできない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, we now generally use &lt;c3&gt;for&lt;/c3&gt; to iterate filehandles.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T150043Z" creationid="Toshiyuki" creationdate="20130809T150043Z">
        <seg>特に、我々は現在一般的に&lt;c3&gt;for&lt;/c3&gt;をファイルハンドルを反復するために使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In string contexts, lists and list-like objects automatically stringify to appropriate (white-space separated) string values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022516Z" creationid="Toshiyuki" creationdate="20140329T022516Z">
        <seg>文字列コンテキストでは、リストとリストのようなオブジェクトは自動的に適切な（空白で区切られた）文字列値に文字列化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the absence of explicit control flow terminating the block early, the return value of a block is the value of its final statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T165145Z" creationid="Toshiyuki" creationdate="20130802T165145Z">
        <seg>ブロックを早期に終える明白な制御フローがない場合、ブロックの返り値は最後の文の値だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case where you want all your parameters to default to &lt;c0&gt;rw&lt;/c0&gt;, you may use the visually suggestive double-ended arrow to indicate that values flow both ways:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113722Z" creationid="Toshiyuki" creationdate="20130810T113722Z">
        <seg>このケースで全てのパラメータを&lt;c0&gt;rw&lt;/c0&gt;としたいなら、値の流れを視覚的に表す両頭矢印を使ってもよい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In theory, any user-defined control construct can catch any control exception it likes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T075745Z" creationid="Toshiyuki" creationdate="20130817T075735Z">
        <seg>理論的には、どれか一つのユーザー定義の制御構造はそれのように制御例外をキャッチできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the &lt;c0&gt;CATCH&lt;/c0&gt; block, the exception in question is bound to &lt;c1&gt;$_&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T130230Z" creationid="Toshiyuki" creationdate="20130813T130230Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロック内部で、問題の例外は&lt;c1&gt;$_&lt;/c1&gt;にバインドされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead &lt;c0&gt;do {...}&lt;/c0&gt; is the do-once loop (which is another reason you can't put a statement modifier on it; use &lt;c1&gt;repeat&lt;/c1&gt; for a test-at-the-end loop).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T121058Z" creationid="Toshiyuki" creationdate="20130810T121058Z">
        <seg>代わりに&lt;c0&gt;do {...}&lt;/c0&gt;はdo-onceループだ（それは文修飾子を置くことができないもう一つの理由だ；&lt;c1&gt;repeat&lt;/c1&gt;をtest-at-the-endループのために使え）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, use a &lt;c1&gt;NEXT&lt;/c1&gt; block within the body of the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130901Z" creationid="Toshiyuki" creationdate="20130808T130901Z">
        <seg>代わりに、&lt;c1&gt;NEXT&lt;/c1&gt;ブロックをループの本体内で使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you should write the more Pascal-like &lt;c0&gt;repeat&lt;/c0&gt; loop:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T151411Z" creationid="Toshiyuki" creationdate="20130809T151411Z">
        <seg>代わりとして、よりパスカル的な&lt;c0&gt;repeat&lt;/c0&gt;ループを書くべきだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introspection</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043536Z" creationid="Toshiyuki" creationdate="20140322T043536Z">
        <seg>イントロスペクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invariant sigils</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021914Z" creationid="Toshiyuki" creationdate="20140329T021914Z">
        <seg>不変のシギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also makes the &lt;c8&gt;try&lt;/c8&gt; keyword redundant, because any block can function as a &lt;c9&gt;try&lt;/c9&gt; block if you put a &lt;c10&gt;CATCH&lt;/c10&gt; block within it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T122339Z" creationid="Toshiyuki" creationdate="20130813T122339Z">
        <seg>それはまた&lt;c8&gt;try&lt;/c8&gt;キーワードを冗長にさせる。なぜならどんなブロックでも&lt;c10&gt;CATCH&lt;/c10&gt;ブロックを中に置けば&lt;c9&gt;try&lt;/c9&gt;ブロックとして機能できるからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It either returns an unthrown exception, or throws the exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T170453Z" creationid="Toshiyuki" creationdate="20130817T170453Z">
        <seg>それはスローされない例外または例外をスローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is given as a trait of the variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224539Z" creationid="Toshiyuki" creationdate="20140328T224539Z">
        <seg>それは変数のトレイトとして与えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is illegal to return from the closure if that &lt;c0&gt;Routine&lt;/c0&gt; no longer owns a call frame in the current call stack.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T045817Z" creationid="Toshiyuki" creationdate="20130817T045817Z">
        <seg>&lt;c0&gt;Routine&lt;/c0&gt;が現在のコールスタックでもうコールフレームを所持していないならクロージャから戻るのは不当だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to fail with a resumable exception, such as a warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T073634Z" creationid="Toshiyuki" creationdate="20130818T073634Z">
        <seg>警告のように、再開可能な例外と共に失敗することが可能だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It means "there is no value here".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132653Z" creationid="Toshiyuki" creationdate="20140327T132653Z">
        <seg>それは「ここに値はない」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It merely assigns an undefined &lt;c2&gt;Dog&lt;/c2&gt; prototype object to &lt;c3&gt;$spot&lt;/c3&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133740Z" creationid="Toshiyuki" creationdate="20140327T133728Z">
        <seg>それは単に未定義の&lt;c2&gt;Dog&lt;/c2&gt;プロトタイプオブジェクトを&lt;c3&gt;$spot&lt;/c3&gt;に割り当てるだけです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns &lt;c10&gt;True&lt;/c10&gt; for handled exceptions and for all non-&lt;c11&gt;Failure&lt;/c11&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161809Z" creationid="Toshiyuki" creationdate="20130817T161809Z">
        <seg>それはハンドルされる例外と全ての非&lt;c11&gt;Failure&lt;/c11&gt;オブジェクトのために&lt;c10&gt;True&lt;/c10&gt;を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It works exactly like &lt;c3&gt;temp&lt;/c3&gt;, except that the value will be restored only if the current block exits unsuccessfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T134934Z" creationid="Toshiyuki" creationdate="20130802T134934Z">
        <seg>現在のブロックを失敗して抜ける場合だけ値が復元されることを除き、ちょうど&lt;c3&gt;temp&lt;/c3&gt;のよに動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's always spelled &lt;c1&gt;for&lt;/c1&gt; in Perl 6, so it always takes a list as an argument:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060854Z" creationid="Toshiyuki" creationdate="20130810T060854Z">
        <seg>Perl 6では常に&lt;c1&gt;for&lt;/c1&gt;と綴られるので、常に引数としてリストを取る：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's not an error to pass parameters to such a block either:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T151941Z" creationid="Toshiyuki" creationdate="20130810T151941Z">
        <seg>そのようなブロックにパラメータを渡すのはどちらもエラーではない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterations that return &lt;c0&gt;()&lt;/c0&gt; (such as by calling &lt;c1&gt;next&lt;/c1&gt; with no extra return arguments) return that &lt;c2&gt;()&lt;/c2&gt; as the next value, which will therefore disappear when interpolated in flat context, but will interpolate an empty &lt;c3&gt;Parcel&lt;/c3&gt; into slice context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T141044Z" creationid="Toshiyuki" creationdate="20130809T141044Z">
        <seg>&lt;c0&gt;()&lt;/c0&gt;を返す反復（&lt;c1&gt;next&lt;/c1&gt;を余分なリターン引数なしに呼ぶような）は&lt;c2&gt;()&lt;/c2&gt;を次の値として返す。それによってフラットコンテキストに保管された時に見えなくなる。しかしスライスコンテキストでは空の&lt;c3&gt;Parcel&lt;/c3&gt;を補完する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Less obviously, so does a &lt;c3&gt;gather&lt;/c3&gt;; if a &lt;c4&gt;gather&lt;/c4&gt; lexically contains any &lt;c5&gt;take&lt;/c5&gt; calls, it is marked as lexotic-only, and it will be invisible to a dynamic &lt;c6&gt;take&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T160003Z" creationid="Toshiyuki" creationdate="20130810T160003Z">
        <seg>あまり明らかでない、それゆえ&lt;c3&gt;gather&lt;/c3&gt;を行う；もし&lt;c4&gt;gather&lt;/c4&gt;が何か一つの&lt;c5&gt;take&lt;/c5&gt;呼び出しをレキシカルに含んでいるなら、それはlexotic-onlyとしてマークされる。そしてダイナミックな&lt;c6&gt;take&lt;/c6&gt;には不可視になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexical Conventions</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053423Z" creationid="Toshiyuki" creationdate="20140330T053423Z">
        <seg>レキシカルの規則</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexicals may not "leak" from a block to any other external scope (at least, not without some explicit aliasing action on the part of the block, such as exportation of a symbol from a module).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T124829Z" creationid="Toshiyuki" creationdate="20130730T124829Z">
        <seg>レキシカルはブロックから他の外部スコープへは「リーク」しない（少なくともモジュールからのシンボルのエクスポートのような、ブロック部分のいくつかの明示的なエイリアシングが無い場合）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexotic operators in Perl 6 include:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T010307Z" creationid="Toshiyuki" creationdate="20130728T010307Z">
        <seg>Perl 6のレギゾチック演算子は以下を含む：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like &lt;c2&gt;do&lt;/c2&gt;, it is followed by a statement or block, and executes it once.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152531Z" creationid="Toshiyuki" creationdate="20130810T152531Z">
        <seg>&lt;c2&gt;do&lt;/c2&gt;のように、それには文かブロックが続き、一回実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise any subscripting operation on &lt;c19&gt;Nil&lt;/c19&gt; returns &lt;c20&gt;Nil&lt;/c20&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133123Z" creationid="Toshiyuki" creationdate="20140327T133123Z">
        <seg>どうように&lt;c19&gt;Nil&lt;/c19&gt;での添字付け演算子も&lt;c20&gt;Nil&lt;/c20&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, temporization is never needed for &lt;c1&gt;statement_control:&lt;for&gt;&lt;/c1&gt; because it always calls a closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T120043Z" creationid="Toshiyuki" creationdate="20130810T120043Z">
        <seg>同様に、&lt;c1&gt;statement_control:&lt;for&gt;&lt;/c1&gt;のためにテンポラリー化は決して必要ない。なぜならそれは常にクロージャを呼び出すからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, we can just remember the gather's result parcel by binding and later coercing it:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T040204Z" creationid="Toshiyuki" creationdate="20130811T040204Z">
        <seg>同様に、我々はちょうどgatherの結果のパーセルをバインドと後での強制によって覚えることができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List stringification</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022409Z" creationid="Toshiyuki" creationdate="20140329T022409Z">
        <seg>リストの文字列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literals</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T120105Z" creationid="Toshiyuki" creationdate="20140329T120105Z">
        <seg>リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop commands like &lt;c1&gt;next&lt;/c1&gt; are abnormal, but looping because you hit the end of the block is not.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125031Z" creationid="Toshiyuki" creationdate="20130816T125031Z">
        <seg>&lt;c1&gt;next&lt;/c1&gt;のようなループコマンドはアブノーマルだ。しかしあなたがブロックの終端をヒットするルーピングは違う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop modifiers &lt;c0&gt;next&lt;/c0&gt;, &lt;c1&gt;last&lt;/c1&gt;, and &lt;c2&gt;redo&lt;/c2&gt; also work much as in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T041904Z" creationid="Toshiyuki" creationdate="20130806T041904Z">
        <seg>ループ修飾子&lt;c0&gt;next&lt;/c0&gt;、&lt;c1&gt;last&lt;/c1&gt;、&lt;c2&gt;redo&lt;/c2&gt;もPerl 5と同様に動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130805T161445Z" creationid="Toshiyuki" creationdate="20130805T161445Z">
        <seg>ループ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looping statement modifiers are the same as in Perl 5 except that, for ease of writing list comprehensions, a looping statement modifier is allowed to contain a single conditional statement modifier:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T041823Z" creationid="Toshiyuki" creationdate="20130806T041823Z">
        <seg>ループ文修飾子はPerl 5と同様だ。リストを書く可読性のために、ループ文修飾子はひとつの条件文修飾子を含むことが許可されることを除けば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many constructs define a particular interplay of lexical and dynamic features.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T153018Z" creationid="Toshiyuki" creationdate="20130727T153018Z">
        <seg>多くの構成物がレキシカルとダイナミックの機能の特定の相互作用を定義する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of the special variables of Perl 5 are going away.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090305Z" creationid="Toshiyuki" creationdate="20140329T090305Z">
        <seg>Perl 5の多くの特殊変数は無くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T024614Z" creationid="Toshiyuki" creationdate="20140222T024614Z">
        <seg>マッチオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184849Z" creationid="Toshiyuki" creationdate="20140111T184849Z">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods on Arrays</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T141203Z" creationid="Toshiyuki" creationdate="20140327T141203Z">
        <seg>配列のメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifiers</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T015922Z" creationid="Toshiyuki" creationdate="20140222T015922Z">
        <seg>修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More abstractly, any declarations associated with those textual blocks are also considered to be part of the lexical scope, and this is where the term earns the "lexical" part of its name, in the sense that lexical scoping actually does define the "lexicon" for the current chunk of code, insofar as the definitions of variables and routines create a local domain-specific language.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T140658Z" creationid="Toshiyuki" creationdate="20130727T140145Z">
        <seg>より抽象的には、それらのテキストブロックに関連付けられた宣言は全てレキシカルスコープの一部とみなされ、そしてこれは名前のレキシカル部分を得る場所でもある。という訳で、変数とルーチンの定義が局所的なドメイン固有言語を創造する限りにおいて、レキシカルスコープは現在のコードのチャンクのための辞書を実際に定義する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More precisely, it first scans outward (lexically) for the innermost containing &lt;c2&gt;when&lt;/c2&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T113612Z" creationid="Toshiyuki" creationdate="20130812T113612Z">
        <seg>より正確には、それは最初に&lt;c2&gt;when&lt;/c2&gt;ブロックを含む最も深い部分を外側へ（レキシカルに）スキャンする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More specifically, when you write:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T105641Z" creationid="Toshiyuki" creationdate="20130814T105641Z">
        <seg>より明白には、あなたが次のように書くとき：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most list contexts are flat rather than sliced, so the boundaries between individual &lt;c2&gt;take&lt;/c2&gt; calls usually disappear.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T205908Z" creationid="Toshiyuki" creationdate="20130810T205908Z">
        <seg>最も多いリストコンテキストはスライスよりもフラットなので、個々の&lt;c2&gt;take&lt;/c2&gt;呼び出しの間の境界は普通は見えなくなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the non-value-producing phasers may also be so used:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085336Z" creationid="Toshiyuki" creationdate="20130818T085336Z">
        <seg>大部分の値を出さないphasersも使うことができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Much like &lt;c0&gt;return&lt;/c0&gt; may only return from an "official" subroutine or method, a loop exit like &lt;c1&gt;next&lt;/c1&gt; should be caught by the construct the user expects it to be caught by.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080353Z" creationid="Toshiyuki" creationdate="20130817T080353Z">
        <seg>とても似ている&lt;c0&gt;return&lt;/c0&gt;は「公式な」サブルーチンかメソッドからだけ戻れる。&lt;c1&gt;next&lt;/c1&gt;のようなループの脱出はユーザーがキャッチされると期待する構造にキャッチされるべきだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiline Comments</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053441Z" creationid="Toshiyuki" creationdate="20140330T053441Z">
        <seg>複数行コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple parameters may be passed, in which case the list is traversed more than one element at a time:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T061613Z" creationid="Toshiyuki" creationdate="20130810T061613Z">
        <seg>複数のパラメータが渡されるようなら、その場合はリストは一度に一つ以上の要素を横断される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Name Equivalence of Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053537Z" creationid="Toshiyuki" creationdate="20140330T053537Z">
        <seg>型の名前同一性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T091745Z" creationid="Toshiyuki" creationdate="20140329T091745Z">
        <seg>名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names and Variables</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000030Z" creationid="Toshiyuki" creationdate="20140329T000030Z">
        <seg>名前と変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names may also be declared in the signature of a function.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021445Z" creationid="Toshiyuki" creationdate="20140329T021445Z">
        <seg>名前は関数のシグネチャーでも宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No additional context is applied by the &lt;c1&gt;take&lt;/c1&gt; operator, since all context is lazy in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T201307Z" creationid="Toshiyuki" creationdate="20130810T201307Z">
        <seg>&lt;c1&gt;take&lt;/c1&gt;演算子によって追加のコンテキストが何も適用されないので、Perl 6では全てのコンテキストはレイジーだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No temporization is necessary with the explicit form since &lt;c0&gt;$_&lt;/c0&gt; is a formal parameter to the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T115601Z" creationid="Toshiyuki" creationdate="20130810T115601Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;をブロックの仮パラメータにしてから明白な形式でテンポラリー化は必要ない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal flat list context ignores parcel boundaries and flattens the list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T135641Z" creationid="Toshiyuki" creationdate="20130808T131930Z">
        <seg>通常のフラットリストコンテキストはパーセルの境界を無視し、リストを平坦化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal names and variables are declared using a &lt;i0&gt;scope declarator&lt;/i0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021409Z" creationid="Toshiyuki" creationdate="20140329T021409Z">
        <seg>通常の名前と変数は&lt;i0&gt;スコープ宣言&lt;/i0&gt;で宣言されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that Perl 5's special rule causing</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T111901Z" creationid="Toshiyuki" creationdate="20130810T111627Z">
        <seg>次のことにも注意。Perl 5の特別な規則で</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T163309Z" creationid="Toshiyuki" creationdate="20130817T163309Z">
        <seg>ただし注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;c0&gt;$x&lt;/c0&gt; is also initialized to the &lt;c1&gt;Int&lt;/c1&gt; type object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132547Z" creationid="Toshiyuki" creationdate="20140327T132547Z">
        <seg>&lt;c0&gt;$x&lt;/c0&gt;は&lt;c1&gt;Int&lt;/c1&gt;型オブジェクトにも初期化されるので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that any &lt;c0&gt;die&lt;/c0&gt; in the catch lambda eventually rethrows outside the lambda as a new exception, but not until the current exception handler has a chance to handle all exceptions that came in via &lt;c1&gt;@!&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T113621Z" creationid="Toshiyuki" creationdate="20130814T113621Z">
        <seg>catch lambdaのどれかひとつの&lt;c0&gt;die&lt;/c0&gt;がlambdaを新しい例外として結局外側に再スローする。しかし現在の例外ハンドラが&lt;c1&gt;@!&lt;/c1&gt;を経て入るすべての例外をハンドルする機会を持つまでではない。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that any construct in the statement_prefix category defines special syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T121430Z" creationid="Toshiyuki" creationdate="20130811T121430Z">
        <seg>statement_prefixカテゴリーのどんな構成物も特別な文法を定義するので注意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that temporizations that are undone upon scope exit must be prepared to be redone if a continuation within that scope is taken.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T155653Z" creationid="Toshiyuki" creationdate="20130802T155653Z">
        <seg>スコープの終了でなされないテンポライゼーションは、そのスコープ内の継続が取られるならやり直すために準備されなければならないことに注意しろ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &lt;c0&gt;take&lt;/c0&gt; itself is in sink context in this example because the &lt;c1&gt;for&lt;/c1&gt; loop is in the sink context provided inside the gather.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T040458Z" creationid="Toshiyuki" creationdate="20130811T040458Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;自体はこの例ではsinkコンテキストにある。なぜならgather内に与えられた&lt;c1&gt;for&lt;/c1&gt;ループがsinkコンテキストにあるからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value being evaluated for truth and subsequently bound is not necessarily a value of type &lt;c0&gt;Bool&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T070604Z" creationid="Toshiyuki" creationdate="20130804T070604Z">
        <seg>真偽のために評価される、そしてその後に続いてバインドされる値は&lt;c0&gt;Bool&lt;/c0&gt;型である必要性はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085411Z" creationid="Toshiyuki" creationdate="20130818T085411Z">
        <seg>注意、けれども、その</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nothing is ever bound implicitly, however, and many conditionals would simply bind &lt;c0&gt;True&lt;/c0&gt; or &lt;c1&gt;False&lt;/c1&gt; in an uninteresting fashion.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T145004Z" creationid="Toshiyuki" creationdate="20130809T145004Z">
        <seg>これまでに何も暗黙にバインドされていない、どんな方法でも、そして多数の条件文が単純に&lt;c0&gt;True&lt;/c0&gt;か&lt;c1&gt;False&lt;/c1&gt;をつまらないやり方でバインドする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric and boolean context of hashes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T085841Z" creationid="Toshiyuki" creationdate="20140329T085841Z">
        <seg>ハッシュの数値とブールコンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric and string conversions use these lazy warnings to allow (but not require) failsoft semantics.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T131145Z" creationid="Toshiyuki" creationdate="20130817T131145Z">
        <seg>数値と文字列の変換はフェールソフトセマンティクスを許可する（しかし要求されない）ためにlazy warningsを使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, an explicit &lt;c4&gt;next&lt;/c4&gt; might be clearer than a &lt;c5&gt;succeed&lt;/c5&gt; if you really want to go directly to the next iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120420Z" creationid="Toshiyuki" creationdate="20130813T120420Z">
        <seg>当然、明示的な&lt;c4&gt;next&lt;/c4&gt;は&lt;c5&gt;succeed&lt;/c5&gt;よりもはっきりしているかもしれない。もしあなたが本当に次の反復に直接行きたいと思うなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, &lt;c6&gt;succeed&lt;/c6&gt; can take an optional argument giving the value for that iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120526Z" creationid="Toshiyuki" creationdate="20130813T120526Z">
        <seg>一方では、&lt;c6&gt;succeed&lt;/c6&gt;はループの反復のための変数を与える任意の引数をとることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if a statement_prefix is followed by a non-block statement, all nested blockless statement_prefixes will terminate at the same statement ending:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124551Z" creationid="Toshiyuki" creationdate="20130811T124551Z">
        <seg>一方では、もしstatement_prefixの後にブロックでない文が続くなら、全ての入れ子になったブロックなしのstatement_prefixesは同じ文の末端で終わるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One additional level of control is the notion of &lt;i0&gt;lazy warnings&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130107Z" creationid="Toshiyuki" creationdate="20130817T130107Z">
        <seg>制御の追加のレベルは&lt;i0&gt;lazy warnings&lt;/i0&gt;の考えだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One other difference from Perl 5 is that the default is not to undefine a variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140100Z" creationid="Toshiyuki" creationdate="20130802T140100Z">
        <seg>一つPerl 5と違うことは、デフォルトは変数を未定義にしないことだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-pass parsing</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053343Z" creationid="Toshiyuki" creationdate="20140330T053343Z">
        <seg>ワンパス構文解析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only &lt;c14&gt;Failure&lt;/c14&gt; objects need to store the actual status however; other types just return &lt;c15&gt;True&lt;/c15&gt;.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161959Z" creationid="Toshiyuki" creationdate="20130817T161959Z">
        <seg>&lt;c14&gt;Failure&lt;/c14&gt;だけが実際のステータスを格納することを必要とする；他の型はただ&lt;c15&gt;True&lt;/c15&gt;を返す。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only argumentless phasers may use the statement form.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085659Z" creationid="Toshiyuki" creationdate="20130818T085659Z">
        <seg>引数なしのphasersだけが文形式を使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other kinds of phasers can be installed as well; these are automatically called at various times as appropriate, and some of them respond to various control exceptions and exit values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T081130Z" creationid="Toshiyuki" creationdate="20130818T081130Z">
        <seg>他の種類のphasersは同様にうまくインストールされる；それらは適切に様々なタイミングで自動的に呼ばれ、それらのいくつかは様々な制御例外と抜け出る値に応答する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise the value will be the null string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130827Z" creationid="Toshiyuki" creationdate="20130817T130827Z">
        <seg>さもなければ値はnull文字列になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameter types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T230823Z" creationid="Toshiyuki" creationdate="20140328T230806Z">
        <seg>パラメーターの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters may be given types, just like any other variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T230903Z" creationid="Toshiyuki" creationdate="20140328T230903Z">
        <seg>パラメータは他の変数のように型を与えられることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parcels</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073359Z" creationid="Toshiyuki" creationdate="20140329T073359Z">
        <seg>パーセル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5's "&lt;c0&gt;local&lt;/c0&gt;" function has been renamed to &lt;c1&gt;temp&lt;/c1&gt; to better reflect what it does.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133905Z" creationid="Toshiyuki" creationdate="20130802T133905Z">
        <seg>Perl 5の&lt;c0&gt;local&lt;/c0&gt;関数は何をするのかより良く表すように&lt;c1&gt;temp&lt;/c1&gt;に名前を変更した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has &lt;c0&gt;Failure&lt;/c0&gt; objects, known as "unthrown exceptions" (though really a &lt;c1&gt;Failure&lt;/c1&gt; merely contains an unthrown exception), which know whether they have been handled or not.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T151438Z" creationid="Toshiyuki" creationdate="20130817T151438Z">
        <seg>Perl 6は&lt;c0&gt;Failure&lt;/c0&gt;オブジェクト、「スローされない例外」を持つ（実際は&lt;c1&gt;Failure&lt;/c1&gt;は単にスローされない例外を含む）。それはそれらがハンドルされたかどうか知っている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has a rich set of literal forms, many of which can be used for textual input as well.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T120253Z" creationid="Toshiyuki" creationdate="20140329T120253Z">
        <seg>Perl 6はリテラルの形式の豊富なセットを持っており、それらの多くが原文の入力に同様に使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has an optional type system that helps you write safer code that performs better.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140325T141840Z" creationid="Toshiyuki" creationdate="20140325T141556Z">
        <seg>Perl 6はより良く動作する安全なコードを書くのに役立つ任意指定の型システムを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 includes a system of &lt;b0&gt;sigils&lt;/b0&gt; to mark the fundamental structural type of a variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000343Z" creationid="Toshiyuki" creationdate="20140329T000343Z">
        <seg>Perl 6は変数の基本的な構造上の型を表示するために&lt;b0&gt;シギル&lt;/b0&gt;システムを含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 intrinsically supports big integers and rationals through its system of type declarations.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130220Z" creationid="Toshiyuki" creationdate="20140328T130220Z">
        <seg>Perl 6は型宣言のシステムによって大きい整数と有理数をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 supports the notion of &lt;b0&gt;properties&lt;/b0&gt; on various kinds of objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131839Z" creationid="Toshiyuki" creationdate="20140326T131839Z">
        <seg>Perl 6は様々なオブジェクトで&lt;b0&gt;プロパティ&lt;/b0&gt;の概念をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl supports generic types through what are called "roles" which represent capabilities or interfaces.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T125916Z" creationid="Toshiyuki" creationdate="20140328T125750Z">
        <seg>Perlは機能またはインターフェースを表す“ロール”と呼ばれるものを通してジェネリック型をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl variables have two associated types: their "of type" and their "container type".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T165628Z" creationid="Toshiyuki" creationdate="20140328T165628Z">
        <seg>Perlの変数は2つの関連する型を持ちます：それらの“型”とそれらの“コンテナ”です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Phasers marked with a &lt;c3&gt;*&lt;/c3&gt; can be used for their return value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T081415Z" creationid="Toshiyuki" creationdate="20130818T081415Z">
        <seg>&lt;c3&gt;*&lt;/c3&gt;でマークされたPhasersはそれらの返り値として使用できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pointy blocks and bare closures are transparent to &lt;c4&gt;return&lt;/c4&gt;, in that the &lt;c5&gt;return&lt;/c5&gt; statement still means &lt;c6&gt;&amp;?ROUTINE.leave&lt;/c6&gt; from the &lt;c7&gt;Routine&lt;/c7&gt; that existed in dynamic scope when the closure was cloned.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T044655Z" creationid="Toshiyuki" creationdate="20130817T044655Z">
        <seg>ポインティブロックと裸のクロージャは&lt;c4&gt;return&lt;/c4&gt;には明白だ。&lt;c5&gt;return&lt;/c5&gt;文はまだ	クロージャが複製された時ダイナミックスコープに抜け出た&lt;c7&gt;Routine&lt;/c7&gt;から&lt;c6&gt;&amp;?ROUTINE.leave&lt;/c6&gt;することを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Presumably multiple dispatch could sort this out.]</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T103253Z" creationid="Toshiyuki" creationdate="20130806T103253Z">
        <seg>多分、マルチディスパッチはこれを選り分けできる。]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties applied to objects constructed at compile-time, such as variables and classes, are also called &lt;b0&gt;traits&lt;/b0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132801Z" creationid="Toshiyuki" creationdate="20140326T132801Z">
        <seg>変数やクラスのように、コンパイル時に構成されるオブジェクトに適用されるプロパティは&lt;b0&gt;トレイト&lt;/b0&gt;とも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties are like object attributes, except that they're managed by the individual object rather than by the object's class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131958Z" creationid="Toshiyuki" creationdate="20140326T131958Z">
        <seg>プロパティはオブジェクト属性のようですが、それらはクラスよりもむしろ個々のオブジェクトによって管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties on Objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131852Z" creationid="Toshiyuki" creationdate="20140326T131852Z">
        <seg>オブジェクトのプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of the &lt;c3&gt;take&lt;/c3&gt;'s immediate context, the object returned is also added to the list of values being gathered, which is returned by the &lt;c4&gt;gather&lt;/c4&gt; as a lazy list (that is, an iterator, really), with each argument element of that list corresponding to one &lt;c5&gt;take&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T204205Z" creationid="Toshiyuki" creationdate="20130810T204205Z">
        <seg>&lt;c3&gt;take&lt;/c3&gt;の直接のコンテキストに関わらず、返されたオブジェクトも集められた値のリストに追加され、それは&lt;c4&gt;gather&lt;/c4&gt;によってレイジーリストとして返される（すなわち、本当にイテレータ）そのリストの一つの&lt;c5&gt;take&lt;/c5&gt;に対応するそれぞれの引数の要素と一緒に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember, no implicit block scopes.) It is also possible to write</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063626Z" creationid="Toshiyuki" creationdate="20130810T063626Z">
        <seg>暗黙のブロックスコープはないことを覚えておくこと。）それは次のようにも書ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resumable exceptions may also be implemented by simply marking the current exception as "resumed", in which case the original exception thrower simply returns to the code that threw the resumable exception, rather than unwinding before returning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T114629Z" creationid="Toshiyuki" creationdate="20130814T114629Z">
        <seg>再開可能な例外は現在の例外を単純に「resumed」としてマーキングして実装される。その場合に初期の例外を投げるものは再開可能な例外を投げたコードを単純に返す。返す前に巻き戻すよりも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resumable exceptions may or may not leave normally depending on the implementation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T113840Z" creationid="Toshiyuki" creationdate="20130814T113840Z">
        <seg>再開可能な例外が普通に去るかどうかは実装に依存する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Roles</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T080142Z" creationid="Toshiyuki" creationdate="20140113T080142Z">
        <seg>ロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scope declarators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021303Z" creationid="Toshiyuki" creationdate="20140329T021303Z">
        <seg>スコープ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more on function parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T130016Z" creationid="Toshiyuki" creationdate="20130729T130016Z">
        <seg>関数のパラメータについてより詳しくはS06を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130917Z" creationid="Toshiyuki" creationdate="20130808T130917Z">
        <seg>以下を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See previous section for discussion of ways to return from catch lambdas.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T124949Z" creationid="Toshiyuki" creationdate="20130817T124949Z">
        <seg>キャッチlambdaから返す方法の議論は前のセクションを参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Separate clones of the closure get separate state variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133323Z" creationid="Toshiyuki" creationdate="20130802T133323Z">
        <seg>異なるクロージャのクローンは異なるstate変数を得る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000155Z" creationid="Toshiyuki" creationdate="20140329T000155Z">
        <seg>シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils are now invariant.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022027Z" creationid="Toshiyuki" creationdate="20140329T021935Z">
        <seg>シギルは現在は不変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;c0&gt;do&lt;/c0&gt; is defined as going in front of a statement, it follows that it can always be followed by a statement label.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T130303Z" creationid="Toshiyuki" creationdate="20130810T130303Z">
        <seg>&lt;c0&gt;do&lt;/c0&gt;は文の前の出発として定義されるので、常に文ラベルが続くことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;c1&gt;when&lt;/c1&gt; statements are presumed to be executed in order like normal statements, it's not required that all the statements in a switch block be &lt;c2&gt;when&lt;/c2&gt; statements (though it helps the optimizer to have a sequence of contiguous &lt;c3&gt;when&lt;/c3&gt; statements, because then it can arrange to jump directly to the first appropriate test that might possibly match.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133157Z" creationid="Toshiyuki" creationdate="20130811T133157Z">
        <seg>&lt;c1&gt;when&lt;/c1&gt;文は通常の文のように順番に実行されると仮定されるので、switchブロックのすべての文が&lt;c2&gt;when&lt;/c2&gt;文になる必要はない（それは連続の&lt;c3&gt;when&lt;/c3&gt;のシーケンスを持つためにオプティマイザを助ける。なぜならマッチできると思われる最初の適切なテストに直接ジャンプするようにアレンジできるからだ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since a bare expression may be used as a statement, you may use &lt;c0&gt;do&lt;/c0&gt; on an expression, but its only effect is to function as an unmatched left parenthesis, much like the &lt;c1&gt;$&lt;/c1&gt; operator in Haskell.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T124326Z" creationid="Toshiyuki" creationdate="20130810T123311Z">
        <seg>裸の式は文として使われると思われるので、&lt;c0&gt;do&lt;/c0&gt;を式で使うだろう。しかしそれの唯一の効果は左括弧が対応がとれていない関数だ。Haskellの&lt;c1&gt;$&lt;/c1&gt;演算子にとても似ている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since all exception handlers run in the dynamic scope of the throw, that reduces to simply returning from the &lt;c1&gt;warn&lt;/c1&gt; function most of the time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T124718Z" creationid="Toshiyuki" creationdate="20130817T124718Z">
        <seg>全ての例外ハンドラはスローのダイナミックスコープで実行するので、それは大抵の場合&lt;c1&gt;warn&lt;/c1&gt;関数から単純に返すように変える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since bracketed expressions consider their insides to be statements, this works out consistently even where you might expect problems:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T031831Z" creationid="Toshiyuki" creationdate="20130803T031831Z">
        <seg>括弧に入れられた式はそれらの内部を文とみなすので、あなたが問題を予期している所でも一貫して上手くいく：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since leaving a block is considered a successful return, breaking out of one with &lt;c11&gt;succeed&lt;/c11&gt; is also considered a successful return for the purposes of &lt;c12&gt;KEEP&lt;/c12&gt; and &lt;c13&gt;UNDO&lt;/c13&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114609Z" creationid="Toshiyuki" creationdate="20130813T114609Z">
        <seg>ブロックを去ることは成功したリターンとみなされるので、&lt;c11&gt;succeed&lt;/c11&gt;で脱出することも&lt;c12&gt;KEEP&lt;/c12&gt;と&lt;c13&gt;UNDO&lt;/c13&gt;の目的のための成功したリターンとみなされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the loop executes once before evaluating the condition, the bound parameter will be undefined that first time through the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T055600Z" creationid="Toshiyuki" creationdate="20130810T055600Z">
        <seg>条件を評価する前にループを1回実行するので、結び付けられたパラメータはループの初回に未定義にされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since warnings are processed using the standard control exception mechanism, they may be intercepted and either suppressed or fatalized anywhere within the dynamic scope by supplying a suitable &lt;c0&gt;CONTROL&lt;/c0&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T115816Z" creationid="Toshiyuki" creationdate="20130817T115816Z">
        <seg>警告は標準の制御例外メカニズムを使って処理されるので、それらは横取りされることもでき、適切な&lt;c0&gt;CONTROL&lt;/c0&gt;ブロックの供給によるダイナミックスコープ内で抑制されるかどこでも致命的にされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single-line Comments</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053448Z" creationid="Toshiyuki" creationdate="20140330T053448Z">
        <seg>ラインコメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slice context turns any parcel objects into &lt;c0&gt;Seq&lt;/c0&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T132209Z" creationid="Toshiyuki" creationdate="20130808T132209Z">
        <seg>スライスコンテキストはどんなパーセルオブジェクトでも&lt;c0&gt;Seq&lt;/c0&gt;オブジェクトに変える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140105Z" creationid="Toshiyuki" creationdate="20130802T140105Z">
        <seg>つまり</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So do the implicit conditionals implied by short-circuit operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130805T160823Z" creationid="Toshiyuki" creationdate="20130805T160823Z">
        <seg>このように、暗黙の条件は短絡演算子によって暗に意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if you examine the &lt;c2&gt;ENTER&lt;/c2&gt; trait of a block, you'll find that it's really a list of phasers rather than a single phaser.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130820T124134Z" creationid="Toshiyuki" creationdate="20130820T124134Z">
        <seg>もし&lt;c2&gt;ENTER&lt;/c2&gt;ブロックのトレイトを調査するなら、あなたは単独のphaserよりも本当のphaserのリストだと気づくだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So logically, if the &lt;c1&gt;CATCH&lt;/c1&gt; block throws its own exception, you would expect the &lt;c2&gt;CATCH&lt;/c2&gt; block to catch its own exception recursively forever.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T120157Z" creationid="Toshiyuki" creationdate="20130814T120157Z">
        <seg>論理的には、もし&lt;c1&gt;CATCH&lt;/c1&gt;ブロックが独自の例外を投げるなら、あなたは&lt;c2&gt;CATCH&lt;/c2&gt;ブロックがその独自の例外を再帰的に絶えずキャッチすると期待するだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So switching behavior is actually caused by the &lt;c6&gt;when&lt;/c6&gt; statements in the block, not by the nature of the block itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T130033Z" creationid="Toshiyuki" creationdate="20130811T130033Z">
        <seg>それゆえ、switchの振る舞いは実際はブロックの&lt;c6&gt;when&lt;/c6&gt;文によって引き起こされ、ブロック自身の性質によってではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the old &lt;c6&gt;next LINE&lt;/c6&gt; syntax is still allowed but really does something like &lt;c7&gt;LINE.next(())&lt;/c7&gt; underneath.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T102156Z" creationid="Toshiyuki" creationdate="20130806T102156Z">
        <seg>それゆえ、&lt;c6&gt;next LINE&lt;/c6&gt;という文法はまだ許可される。しかし本当は表面化に&lt;c7&gt;LINE.next(())&lt;/c7&gt;のようなことをしている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So they aren't really traits, exactly--they add themselves onto a list stored in the actual trait.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093613Z" creationid="Toshiyuki" creationdate="20130818T093613Z">
        <seg>それらは実際にはトレイトでないので、まさに―それらは実際のトレイトに格納されたリストに自身を加える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So we will say that it is erroneous for a library writer to mix dynamic gather with callbacks unless those callbacks are somehow "ungathered" to the outer dynamic scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T161444Z" creationid="Toshiyuki" creationdate="20130810T161444Z">
        <seg>そういうわけでダイナミックなgatherをコールバックと混ぜるのはライブラリ作者には誤りだと我々は言う。それらのコールバックが外側のダイナミックスコープにどういうわけか「ungathered」でない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some object types can behave as value types.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T121805Z" creationid="Toshiyuki" creationdate="20140328T121805Z">
        <seg>いくつかのオブジェクト型は値型として振る舞うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the statement prefixes also behave a little bit like phasers, but they run in-line with the executable code, so they are spelled in lowercase.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T081828Z" creationid="Toshiyuki" creationdate="20130818T081828Z">
        <seg>いくつかの文接頭辞も少しphasersのようにふるまう。しかしそれらは実行可能なコードとともにインラインを実行する。なのでそれらは小文字で綴る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of these operators also fall back to a purely dynamic interpretation if the lexotic interpretation doesn't work.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T012428Z" creationid="Toshiyuki" creationdate="20130728T012428Z">
        <seg>これらの演算子の幾つかは、レギゾチックな解釈が正常に動作しない場合に純粋な動的解釈に逆戻りすることもある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of these phasers also have corresponding traits that can be set on variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093015Z" creationid="Toshiyuki" creationdate="20130818T093015Z">
        <seg>phasersのいくつかは変数にセットできる対応するトレイトも持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special variables</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090220Z" creationid="Toshiyuki" creationdate="20140329T090220Z">
        <seg>特殊変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying a dispatch candidate</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T083236Z" creationid="Toshiyuki" creationdate="20140329T083236Z">
        <seg>ディスパッチ候補を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020250Z" creationid="Toshiyuki" creationdate="20140322T020250Z">
        <seg>文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings, the &lt;c0&gt;Str&lt;/c0&gt; Type</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T131040Z" creationid="Toshiyuki" creationdate="20140328T131040Z">
        <seg>文字列、&lt;c0&gt;Str&lt;/c0&gt;型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T030020Z" creationid="Toshiyuki" creationdate="20140329T030020Z">
        <seg>添字付け</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts are always evaluated in list context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T031657Z" creationid="Toshiyuki" creationdate="20140329T031657Z">
        <seg>添字付けは常にリストコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124621Z" creationid="Toshiyuki" creationdate="20130811T124621Z">
        <seg>Switch文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is,</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060536Z" creationid="Toshiyuki" creationdate="20130810T060536Z">
        <seg>すなわち、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, precedence decisions do not cross a &lt;c2&gt;do&lt;/c2&gt; boundary, and the missing "right paren" is assumed at the next statement terminator or unmatched bracket.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T124306Z" creationid="Toshiyuki" creationdate="20130810T124306Z">
        <seg>すなわち、優先順位の決定は&lt;c2&gt;do&lt;/c2&gt;の境界を横切らず、欠けた「右括弧」は次の文の終止符か対応のとれていないブラケットと仮定される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the construct:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113956Z" creationid="Toshiyuki" creationdate="20130810T113956Z">
        <seg>すなわち、構成物：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the stack is not unwound until some exception handler chooses to unwind it by "handling" the exception in question.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115741Z" creationid="Toshiyuki" creationdate="20130814T115741Z">
        <seg>すなわち、そのスタックはいくつかの例外ハンドラが問題の例外を「ハンドリング」することによってそれを巻き戻すために選ばれるまで巻き戻されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, these two statements are equivalent:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T031141Z" creationid="Toshiyuki" creationdate="20130803T031141Z">
        <seg>つまり、これら二つの文は同等だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That should now be written:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112113Z" creationid="Toshiyuki" creationdate="20130810T111931Z">
        <seg>それは今は書き直されるべきだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "point of declaration" is the moment the compiler sees "&lt;c0&gt;my $foo&lt;/c0&gt;", not the end of the statement as in Perl 5, so</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125416Z" creationid="Toshiyuki" creationdate="20130730T125416Z">
        <seg>「宣言のポイント」はコンパイラが「&lt;c0&gt;my $foo&lt;/c0&gt;」を見る時点であり、Perl 5における文の終わりではない。つまり</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;$Package'var&lt;/c0&gt; syntax is gone.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000110Z" creationid="Toshiyuki" creationdate="20140329T000110Z">
        <seg>&lt;c0&gt;$Package'var&lt;/c0&gt;構文はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.WHICH&lt;/c0&gt; Method for Value Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T121731Z" creationid="Toshiyuki" creationdate="20140328T121731Z">
        <seg>値型のための&lt;c0&gt;.WHICH&lt;/c0&gt;メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.fmt&lt;/c0&gt; method</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T025540Z" creationid="Toshiyuki" creationdate="20140329T025540Z">
        <seg>&lt;c0&gt;.fmt&lt;/c0&gt;メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.handled&lt;/c0&gt; method is &lt;c1&gt;rw&lt;/c1&gt;, so you may mark an exception as handled by assigning &lt;c2&gt;True&lt;/c2&gt; to it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T162419Z" creationid="Toshiyuki" creationdate="20130817T162419Z">
        <seg>&lt;c0&gt;.handled&lt;/c0&gt;メソッドは&lt;c1&gt;rw&lt;/c1&gt;なので、&lt;c2&gt;True&lt;/c2&gt;を割り当てることで例外がハンドルされたとマークすることもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Cool&lt;/c0&gt; module also contains all multisubs of last resort; these are automatically searched if normal multiple dispatch does not find a viable candidate.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T233824Z" creationid="Toshiyuki" creationdate="20140328T233824Z">
        <seg>&lt;c0&gt;Cool&lt;/c0&gt;モジュールは最後の手段の全てのマルチサブを含みます；通常のマルチディスパッチが可能な候補を見つけなければ、それらは自動的に検索されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Cool&lt;/c0&gt; type is derived from &lt;c1&gt;Any&lt;/c1&gt;, and contains all the methods that are "cool" (as in, "I'm cool with an argument of that type.").</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T232612Z" creationid="Toshiyuki" creationdate="20140328T232612Z">
        <seg>&lt;c0&gt;Cool&lt;/c0&gt;型は&lt;c1&gt;Any&lt;/c1&gt;から派生し、“cool”（“私はその型の引数にクールです”）なメソッドを全て含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;StrPos&lt;/c0&gt; Type</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T133413Z" creationid="Toshiyuki" creationdate="20140328T133413Z">
        <seg>&lt;c0&gt;StrPos&lt;/c0&gt;型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;anon&lt;/c0&gt; declarator allows a declaration to provide a name that can be used in error messages, but that isn't put into any external symbol table:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021656Z" creationid="Toshiyuki" creationdate="20140329T021656Z">
        <seg>&lt;c0&gt;anon&lt;/c0&gt;宣言はエラーメッセージに使用できる名前を提供するための宣言を可能にしますが、それはどの外部のシンボルテーブルにも置かれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;fail&lt;/c0&gt; function responds to the caller's &lt;c1&gt;use fatal&lt;/c1&gt; state.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T170326Z" creationid="Toshiyuki" creationdate="20130817T170326Z">
        <seg>&lt;c0&gt;fail&lt;/c0&gt;関数は呼び出し元の&lt;c1&gt;use fatal&lt;/c1&gt;状態に応答する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;for&lt;/c0&gt; statement</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060619Z" creationid="Toshiyuki" creationdate="20130810T060619Z">
        <seg>&lt;c0&gt;for&lt;/c0&gt;文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;gather&lt;/c0&gt; statement prefix</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152216Z" creationid="Toshiyuki" creationdate="20130810T152216Z">
        <seg>&lt;c0&gt;gather&lt;/c0&gt;文プレフィックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;if&lt;/c0&gt; and &lt;c1&gt;unless&lt;/c1&gt; statements work much as they do in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T042914Z" creationid="Toshiyuki" creationdate="20130803T042914Z">
        <seg>&lt;c0&gt;if&lt;/c0&gt;文と&lt;c1&gt;unless&lt;/c1&gt;文はPerl 5のように動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;loop&lt;/c0&gt; statement is the C-style &lt;c1&gt;for&lt;/c1&gt; loop in disguise:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T055854Z" creationid="Toshiyuki" creationdate="20130810T055854Z">
        <seg>&lt;c0&gt;loop&lt;/c0&gt;文はC言語スタイルの&lt;c1&gt;for&lt;/c1&gt;ループを装う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;of&lt;/c0&gt; type specifies what kinds of values may be stored in the variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T213053Z" creationid="Toshiyuki" creationdate="20140328T213053Z">
        <seg>&lt;c0&gt;of&lt;/c0&gt;型はどのような種類の値が変数に保存されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;repeat&lt;/c0&gt; statement</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T150051Z" creationid="Toshiyuki" creationdate="20130809T150051Z">
        <seg>&lt;c0&gt;repeat&lt;/c0&gt;文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;returns&lt;/c0&gt; declarations is an alias for the &lt;c1&gt;of&lt;/c1&gt; type of a subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T223849Z" creationid="Toshiyuki" creationdate="20140328T223849Z">
        <seg>&lt;c0&gt;returns&lt;/c0&gt;宣言はサブルーチンの&lt;c1&gt;of&lt;/c1&gt;型の別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;sink&lt;/c0&gt; statement prefix will eagerly evaluate any block or statement, throw away the results, and instead return the empty &lt;c1&gt;Parcel&lt;/c1&gt; value, &lt;c2&gt;()&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T080120Z" creationid="Toshiyuki" creationdate="20140329T080120Z">
        <seg>&lt;c0&gt;sink&lt;/c0&gt;ステートメントプレフィックスは何らかのブロックまたはステートメントを評価して結果を捨て、その代わりに空の&lt;c1&gt;Parcel&lt;/c1&gt;値、&lt;c2&gt;()&lt;/c2&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;take&lt;/c0&gt; function essentially has two contexts simultaneously, the context in which the &lt;c1&gt;gather&lt;/c1&gt; is operating, and the context in which the &lt;c2&gt;take&lt;/c2&gt; is operating.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T035625Z" creationid="Toshiyuki" creationdate="20130811T035625Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;関数は本質的に同時に二つのコンテキストを持つ。&lt;c1&gt;gather&lt;/c1&gt;が動作中のコンテキスト、&lt;c2&gt;take&lt;/c2&gt;が動作中のコンテキスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;take&lt;/c0&gt; function is lexotic if there is a visible outer &lt;c1&gt;gather&lt;/c1&gt;, but falls back to purely dynamic if not.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T154155Z" creationid="Toshiyuki" creationdate="20130810T154155Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;関数は、可視の外側の&lt;c1&gt;gather&lt;/c1&gt;があるならレギゾチックだ。 しかしそうでないなら純粋なダイナミックに戻る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;take&lt;/c0&gt; operation may be defined internally using resumable control exceptions, or dynamic variables, or pigeons carrying clay tablets.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T041108Z" creationid="Toshiyuki" creationdate="20130811T041108Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;の動作は再動作可能な制御例外、または動的変数、または粘土板を運ぶハトを使って内部的に定義されているだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;unless&lt;/c0&gt; statement does not allow an &lt;c1&gt;elsif&lt;/c1&gt; or &lt;c2&gt;else&lt;/c2&gt; in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T045700Z" creationid="Toshiyuki" creationdate="20130804T045700Z">
        <seg>Perl 6では&lt;c0&gt;unless&lt;/c0&gt;文は&lt;c1&gt;elsif&lt;/c1&gt;または&lt;c2&gt;else&lt;/c2&gt;を許可しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;while&lt;/c0&gt; and &lt;c1&gt;until&lt;/c1&gt; statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T142714Z" creationid="Toshiyuki" creationdate="20130809T142714Z">
        <seg>&lt;c0&gt;while&lt;/c0&gt;と&lt;c1&gt;until&lt;/c1&gt;文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;while&lt;/c0&gt; and &lt;c1&gt;until&lt;/c1&gt; statements work as in Perl 5, except that you may leave out the parentheses around the conditional:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T143804Z" creationid="Toshiyuki" creationdate="20130809T143804Z">
        <seg>&lt;c0&gt;while&lt;/c0&gt;と&lt;c1&gt;until&lt;/c1&gt;文はPerl 5のように動作する。条件文の周囲の括弧を省略するかもしれない場合を除いて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;given&lt;/c1&gt; block is just one way to set the current topic, but a switch statement can be any block that sets &lt;c2&gt;$_&lt;/c2&gt;, including a &lt;c3&gt;for&lt;/c3&gt; loop (assuming one of its loop variables is bound to &lt;c4&gt;$_&lt;/c4&gt;) or the body of a method (if you have declared the invocant as &lt;c5&gt;$_&lt;/c5&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125816Z" creationid="Toshiyuki" creationdate="20130811T125816Z">
        <seg>&lt;c1&gt;given&lt;/c1&gt;ブロックは現在のトピックをセットする一つの方法だ。しかしswitch文は&lt;c2&gt;$_&lt;/c2&gt;をセットするどんなブロックにもなれる。&lt;c3&gt;for&lt;/c3&gt;ループ（ループ変数の一つが&lt;c4&gt;$_&lt;/c4&gt;にバインドされていると仮定する）またはメソッドの本体（もしインボカントを&lt;c5&gt;$_&lt;/c5&gt;として宣言しているなら）を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;.next&lt;/c4&gt; and &lt;c5&gt;.last&lt;/c5&gt; methods take an optional argument giving the final value of that loop iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T101538Z" creationid="Toshiyuki" creationdate="20130806T101538Z">
        <seg>&lt;c4&gt;.next&lt;/c4&gt;と&lt;c5&gt;.last&lt;/c5&gt;メソッドはそのループのイテレーションの最終値を与える任意の引数をとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Cool class (and package)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T232404Z" creationid="Toshiyuki" creationdate="20140328T232404Z">
        <seg>Coolクラス（とパッケージ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl 6 equivalent to Perl 5's &lt;c0&gt;eval {...}&lt;/c0&gt; is &lt;c1&gt;try {...}&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121703Z" creationid="Toshiyuki" creationdate="20130813T121703Z">
        <seg>Perl 5の&lt;c0&gt;eval {...}&lt;/c0&gt;に対するPerl 6の同等物は&lt;c1&gt;try {...}&lt;/c1&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Relationship of Blocks and Declarations</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T115332Z" creationid="Toshiyuki" creationdate="20130729T115332Z">
        <seg>ブロックと宣言の関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Relationship of Blocks and Statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T155712Z" creationid="Toshiyuki" creationdate="20130802T155712Z">
        <seg>ブロックと文の関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The choice any particular implementation makes is specifically &lt;i1&gt;not&lt;/i1&gt; part of the definition of Perl 6, and you should not rely on it in portable code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T041448Z" creationid="Toshiyuki" creationdate="20130811T041448Z">
        <seg>どんな特定の実装の選択も明確にPerl 6の定義の一部ではない。そして移植可能なコード内でそれに頼るべきではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler is free to infer what type information it can from the types you supply, but it will not complain about missing type information unless you ask it to.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140325T142047Z" creationid="Toshiyuki" creationdate="20140325T141831Z">
        <seg>コンパイラがあなたが供給できる型から型情報を推測するのは自由です。しかしあなたがそれを尋ねない限り、欠けている型情報について不満を言いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The container type specifies how the variable itself is implemented.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224517Z" creationid="Toshiyuki" creationdate="20140328T224517Z">
        <seg>コンテナ型は変数自体がどのように実装されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The control lambda is logically separate from the catch lambda, though an implementation is allowed to combine them if it is careful to retain separate semantics for catch and control exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T125641Z" creationid="Toshiyuki" creationdate="20130817T125641Z">
        <seg>制御lambdaはキャッチlambdaとは論理的に異なる。けれどもキャッチと制御例外のセマンティクスを別々に注意して保持するなら実装を結合することは許可される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current topic is always aliased to the special variable &lt;c0&gt;$_&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125321Z" creationid="Toshiyuki" creationdate="20130811T125321Z">
        <seg>現在のトピックは常に特殊変数&lt;c0&gt;$_&lt;/c0&gt;にエイリアスされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default case:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133227Z" creationid="Toshiyuki" creationdate="20130811T133227Z">
        <seg>defaultケース：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definitions of alphabetic and numeric include appropriate Unicode characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T092741Z" creationid="Toshiyuki" creationdate="20140329T092658Z">
        <seg>英字と数字の定義は適切なユニコード文字も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The eventual binding context thus determines whether to throw away or keep the groupings resulting from each individual &lt;c1&gt;take&lt;/c1&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T205608Z" creationid="Toshiyuki" creationdate="20130810T205608Z">
        <seg>最終のバインディングコンテキストはグルーピングを捨てるか保つか決める。それぞれの個々の&lt;c1&gt;take&lt;/c1&gt;呼び出しからの結果として。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception thrower looks up the call stack for a catch lambda that returns () to indicate all exceptions are handled, and then it is happy, and unwinds the stack to that point.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T112512Z" creationid="Toshiyuki" creationdate="20130814T112512Z">
        <seg>例外を投げるものは全ての例外がハンドルされることを示すために()を返すlambdaをキャッチするためにコールスタックを探す。そしてそのときハッピーで、その点にスタックを巻き戻す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flattening or slicing of any such returned parcel will be dependent on how the &lt;c2&gt;gather&lt;/c2&gt;'s return iterator is iterated (with &lt;c3&gt;.get&lt;/c3&gt; vs &lt;c4&gt;.getarg&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T201914Z" creationid="Toshiyuki" creationdate="20130810T201914Z">
        <seg>そのような返されたパーセルの平坦化またはスライシングは&lt;c2&gt;gather&lt;/c2&gt;の返したイテレータがどのように反復するかに依存している（&lt;c3&gt;.get&lt;/c3&gt;対&lt;c4&gt;.getarg&lt;/c4&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following treats every other value in &lt;c1&gt;@values&lt;/c1&gt; as modifiable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113118Z" creationid="Toshiyuki" creationdate="20130810T113118Z">
        <seg>次のコードは&lt;c1&gt;@values&lt;/c1&gt;の値を一つ置きに変更可能として扱う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function (or listop) form always exits from the innermost block, returning its arguments as the final value of the block exactly as &lt;c1&gt;return&lt;/c1&gt; does.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T071452Z" creationid="Toshiyuki" creationdate="20130817T071429Z">
        <seg>関数（またはリスト演算子）形式は常に最も深いブロックから抜け出し、&lt;c1&gt;return&lt;/c1&gt;がするようにブロックの最後の値としてその引数を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general loop statement</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T055617Z" creationid="Toshiyuki" creationdate="20130810T055617Z">
        <seg>一般のループ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implicit break (what &lt;c2&gt;succeed&lt;/c2&gt; does explicitly) of a &lt;c3&gt;when&lt;/c3&gt; block is abnormal.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125233Z" creationid="Toshiyuki" creationdate="20130816T125233Z">
        <seg>&lt;c3&gt;when&lt;/c3&gt;ブロックの暗黙の中断（&lt;c2&gt;succeed&lt;/c2&gt;は明示的に行う）はアブノーマルだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implicit break of a normal &lt;c0&gt;when&lt;/c0&gt; block works the same way, returning the value of the entire block (normally from its last statement) via an implicit &lt;c1&gt;succeed&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114905Z" creationid="Toshiyuki" creationdate="20130813T114905Z">
        <seg>通常の&lt;c0&gt;when&lt;/c0&gt;ブロックの暗黙の脱出は同じ方法の動作で、暗黙の&lt;c1&gt;succeed&lt;/c1&gt;を経て全体のブロック（通常はその最後の文）の値を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializing expression is evaluated at &lt;c0&gt;BEGIN&lt;/c0&gt; time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T131959Z" creationid="Toshiyuki" creationdate="20130802T131959Z">
        <seg>初期化式は&lt;c0&gt;BEGIN&lt;/c0&gt;時に評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key type of a hash may be specified as a shape trait--see S09.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T223509Z" creationid="Toshiyuki" creationdate="20140328T223509Z">
        <seg>ハッシュのキーの型はshapeトレイトとして指定されます ― S09を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyword for individual cases is &lt;c1&gt;when&lt;/c1&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125157Z" creationid="Toshiyuki" creationdate="20130811T125157Z">
        <seg>個々のケースのキーワードは&lt;c1&gt;when&lt;/c1&gt;だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lexical scope supplies the declared target for the dynamic operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T004107Z" creationid="Toshiyuki" creationdate="20130728T004107Z">
        <seg>レキシカルスコープは動的な操作のために宣言されたターゲットを供給する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list is evaluated lazily by default, so instead of using a &lt;c0&gt;while&lt;/c0&gt; to read a file a line at a time as you would in Perl 5:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T062615Z" creationid="Toshiyuki" creationdate="20130810T062615Z">
        <seg>デフォルトではリストは不精に評価されるので、Perl 5ではファイルを一行ずつ読み込むために代わりに&lt;c0&gt;while&lt;/c0&gt;を使う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop conditional on a &lt;c4&gt;repeat&lt;/c4&gt; block is required, so it will be recognized even if you put it on a line by its own:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T152109Z" creationid="Toshiyuki" creationdate="20130809T152109Z">
        <seg>&lt;c4&gt;repeat&lt;/c4&gt;ブロックのループ条件が必要なので、 それを独自の行に置いても評価される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method form will leave any block in the dynamic scope that can be named as an object and that responds to the &lt;c2&gt;.leave&lt;/c2&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T071918Z" creationid="Toshiyuki" creationdate="20130817T071918Z">
        <seg>メソッド形式はオブジェクトとして名前付けでき、&lt;c2&gt;.leave&lt;/c2&gt;メソッドに応答するダイナミックスコープの何か一つのブロックを抜け出すだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new &lt;c0&gt;constant&lt;/c0&gt; declarator introduces a compile-time constant, either a variable or named value, which may be initialized with a pseudo-assignment:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T131802Z" creationid="Toshiyuki" creationdate="20130802T131802Z">
        <seg>新しい&lt;c0&gt;constant&lt;/c0&gt;宣言は変数または名前付きの値にコンパイル時の定数をもたらし、擬似割り当てで初期化されるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only remaining difficulty arises if both the user and a library writer attempt to use dynamic gather with user-defined callbacks that contain &lt;c11&gt;take&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T160934Z" creationid="Toshiyuki" creationdate="20130810T160934Z">
        <seg>ユーザーとライブラリ作者がダイナミックなgatherを&lt;c11&gt;take&lt;/c11&gt;を含むユーザー定義のコールバックと使用しようと試みるなら、唯一残っている難しさが生じる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous value of &lt;c0&gt;$_&lt;/c0&gt; is not available within the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114904Z" creationid="Toshiyuki" creationdate="20130810T114904Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;の前の値はループ内では使用できない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of a conditional statement is the result of the block chosen to execute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T044423Z" creationid="Toshiyuki" creationdate="20130803T044423Z">
        <seg>条件文の結果はブロックが実行に選んだ結果になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics of &lt;c0&gt;INIT&lt;/c0&gt; and &lt;c1&gt;once&lt;/c1&gt; are not equivalent to each other in the case of cloned closures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030444Z" creationid="Toshiyuki" creationdate="20130822T030444Z">
        <seg>&lt;c0&gt;INIT&lt;/c0&gt;と&lt;c1&gt;once&lt;/c1&gt;のセマンティクスは他のそれぞれの複製されたクロージャとは同等ではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The statement form can be particularly useful to expose a lexically scoped declaration to the surrounding lexical scope without "trapping" it inside a block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T084118Z" creationid="Toshiyuki" creationdate="20130818T084118Z">
        <seg>文形式はブロック内の「トラッピング」なしのレキシカルスコープで囲まれた宣言を公開するのに便利だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unhandled list is a dynamic variable so that it's easy for .resume to manipulate it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115244Z" creationid="Toshiyuki" creationdate="20130814T115244Z">
        <seg>ハンドルされないリストはダイナミックな変数なので.resumeがそれを扱うのは簡単だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a loop statement is the list of values from each iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T131033Z" creationid="Toshiyuki" creationdate="20130808T131033Z">
        <seg>ループ文の値はそれぞれの反復の値のリストになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the conditional expression may be optionally bound to a closure parameter:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T045847Z" creationid="Toshiyuki" creationdate="20130804T045847Z">
        <seg>条件式の値はクロージャのパラメータに任意に結び付けられるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned by the &lt;c0&gt;take&lt;/c0&gt; to the &lt;c1&gt;take&lt;/c1&gt;'s own context is that same returned argument (which is ignored when the &lt;c2&gt;take&lt;/c2&gt; is in sink context).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T203222Z" creationid="Toshiyuki" creationdate="20130810T203222Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;から&lt;c1&gt;take&lt;/c1&gt;自身のコンテキストに返された値は返された同じ引数だ（それは&lt;c2&gt;take&lt;/c2&gt;がsinkコンテキストの時は無視される）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word &lt;c2&gt;returns&lt;/c2&gt; is allowed as an alias for &lt;c3&gt;of&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T212945Z" creationid="Toshiyuki" creationdate="20140328T212945Z">
        <seg>&lt;c2&gt;returns&lt;/c2&gt;が&lt;c3&gt;of&lt;/c3&gt;の別名として使用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three ways to declare formal parameters to a closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T123503Z" creationid="Toshiyuki" creationdate="20130729T123503Z">
        <seg>クロージャに仮パラメータを宣言する方法が3つある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two forms of comment based on &lt;c1&gt;#&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki Yamato" changedate="20140830T110244Z" creationid="Toshiyuki Yamato" creationdate="20140830T110233Z">
        <seg>&lt;c1&gt;#&lt;/c1&gt;ベースのコメントには2つの形式があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There does not seem to be a prevailing term in the industry for this, so we've coined the term &lt;i1&gt;lexotic&lt;/i1&gt; to refer to these strange operations that perform a dynamic operation with a lexical target in mind.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T010232Z" creationid="Toshiyuki" creationdate="20130728T005906Z">
        <seg>これに関して業界で一般的な語句が無いように思う。そういうわけで、レキシカルなターゲットを考慮して動的な操作を行うこれらの奇妙な操作を言及するために、我々は&lt;i1&gt;レギゾチック&lt;/i1&gt;という語句を作った。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a &lt;c0&gt;when&lt;/c0&gt; statement modifier, but it does not have any breakout semantics; it is merely a smartmatch against the current topic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121031Z" creationid="Toshiyuki" creationdate="20130813T121031Z">
        <seg>&lt;c0&gt;when&lt;/c0&gt;文修飾子があるが、なんの脱出のセマンティクスも持たない。それは単に現在のトピックに反してスマートマッチする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a new &lt;c0&gt;state&lt;/c0&gt; declarator that introduces a lexically scoped variable like &lt;c1&gt;my&lt;/c1&gt; does, but with a lifetime that persists for the life of the closure, so that it keeps its value from the end of one call to the beginning of the next.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133110Z" creationid="Toshiyuki" creationdate="20130802T133110Z">
        <seg>新しい&lt;c0&gt;state&lt;/c0&gt;宣言は&lt;c1&gt;my&lt;/c1&gt;がするようなレキシカルスコープの変数をもたらす。しかしライフタイムがクロージャの寿命の間持続するので、呼び出しの終わりから次の呼び出しまで値を保持する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a special value named &lt;c0&gt;Nil&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132633Z" creationid="Toshiyuki" creationdate="20140327T132633Z">
        <seg>&lt;c0&gt;Nil&lt;/c0&gt;という名前の特殊な値があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a &lt;c2&gt;let&lt;/c2&gt; prefix operator that sets a hypothetical value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T134150Z" creationid="Toshiyuki" creationdate="20130802T134150Z">
        <seg>仮想の値をセットする&lt;c2&gt;let&lt;/c2&gt;接頭演算子もある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no &lt;c0&gt;foreach&lt;/c0&gt; statement any more.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060705Z" creationid="Toshiyuki" creationdate="20130810T060705Z">
        <seg>今や&lt;c0&gt;foreach&lt;/c0&gt;文は存在しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no corresponding native &lt;c1&gt;str&lt;/c1&gt; type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T131141Z" creationid="Toshiyuki" creationdate="20140328T131141Z">
        <seg>対応するネイティブ&lt;c1&gt;str&lt;/c1&gt;型はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no longer a &lt;c0&gt;continue&lt;/c0&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130739Z" creationid="Toshiyuki" creationdate="20130808T130739Z">
        <seg>もはや&lt;c0&gt;continue&lt;/c0&gt;ブロックはない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T201344Z" creationid="Toshiyuki" creationdate="20140104T201344Z">
        <seg>したがって：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These adverbial forms all weed out non-existing entries if the adverb is true; if not, they leave them in, just as an ordinary slice would.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T084850Z" creationid="Toshiyuki" creationdate="20140329T084715Z">
        <seg>副詞が真である場合はこれらの副詞形式は存在しないエントリーを全て除きます。そうでなければ、通常のスライスのようにそれらを残します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These auto-called blocks are known as &lt;i1&gt;phasers&lt;/i1&gt;, since they generally mark the transition from one phase of computing to another.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T080249Z" creationid="Toshiyuki" creationdate="20130818T080249Z">
        <seg>これらの自動呼び出しされるブロックは&lt;i1&gt;phasers&lt;/i1&gt;として知られる。だから一つの計算フェーズから他への移行を一般的にマークする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constructs establish a dynamic scope without necessarily establishing a lexical scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T080849Z" creationid="Toshiyuki" creationdate="20130811T080849Z">
        <seg>これらの構成物はレキシカルスコープを確立する必要なしに動的スコープを確立する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These have the advantage of passing the variable in question into the closure as its topic:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093134Z" creationid="Toshiyuki" creationdate="20130818T093134Z">
        <seg>そのトピックとしてのクロージャ内の問題の変数に渡すアドバンテージをそれらは持つ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These need not be identical contexts, since they may bind or coerce the resulting parcels differently:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T035929Z" creationid="Toshiyuki" creationdate="20130811T035929Z">
        <seg>それらは同一のコンテキストを必要としない。だから結果として生じるパーセルを違うようにバインドするか強制する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These roles are generally not used directly as object types.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130018Z" creationid="Toshiyuki" creationdate="20140328T130018Z">
        <seg>これらのロールがオブジェクト型として直接使われることは通常ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They parse the same as phasers:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T082139Z" creationid="Toshiyuki" creationdate="20130818T082139Z">
        <seg>それらはphasersと同じにパースする：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This basically gives us list comprehensions as rvalue expressions:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T125239Z" creationid="Toshiyuki" creationdate="20130810T125239Z">
        <seg>これは基本的に右辺値の式としてリストの理解力を我々に与える：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be a bit cumbersome, so in the particular case of labels, the label that is already visible in the current lexical scope is considered a kind of pseudo object specifying a potential dynamic context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T074045Z" creationid="Toshiyuki" creationdate="20130817T074045Z">
        <seg>これは少し扱いづらい。そういうわけでラベルの特定の場合、現在のレキシカルスコープのすでに可視のラベルは潜在的なダイナミックコンテキストを示す擬似オブジェクトの一種とみなされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful to peg some behavior to an empty list while still returning an empty list:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T080629Z" creationid="Toshiyuki" creationdate="20140329T080629Z">
        <seg>これは空のリストを返している間に何らかの振る舞いを空のリストに釘付けるのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This construct only allows you to attach a single statement to the end of an expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T121759Z" creationid="Toshiyuki" creationdate="20130810T121759Z">
        <seg>この構成は単独の文の式の末尾だけで可能だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This could be done by pushing the resumed exception onto the unhandled list, and then the thrower checking to see if there is only a single resumed exception in the "unhandled" list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115100Z" creationid="Toshiyuki" creationdate="20130814T115100Z">
        <seg>これはハンドルされないリストの上に再開された例外をプッシュすることで行われ、そのとき例外を投げるものは一つだけの再開された例外が「ハンドルされない」リストにあるなら見るためにチェックする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This dynamic control is orthogonal to any lexically scoped warning controls, which merely decide whether to call &lt;c1&gt;warn()&lt;/c1&gt; in the first place.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T120128Z" creationid="Toshiyuki" creationdate="20130817T120128Z">
        <seg>ダイナミックな制御はどんなレキシカルスコープの警告制御にも直交する。そしてそれは単に&lt;c1&gt;warn()&lt;/c1&gt;を呼ぶかどうか最初の場所で決定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the added benefit of limiting the scope of the &lt;c0&gt;$line&lt;/c0&gt; parameter to the block it's bound to.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063058Z" creationid="Toshiyuki" creationdate="20130810T063058Z">
        <seg>これはブロックにバインドされた&lt;c0&gt;$line&lt;/c0&gt;パラメータのスコープを制限するという追加の利点を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes &lt;c0&gt;$_&lt;/c0&gt; and &lt;c1&gt;@_&lt;/c1&gt;, as well as the new &lt;c2&gt;$/&lt;/c2&gt;, which is the return value of the last regex match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090703Z" creationid="Toshiyuki" creationdate="20140329T090703Z">
        <seg>これは&lt;c0&gt;$_&lt;/c0&gt;と&lt;c1&gt;@_&lt;/c1&gt;だけでなく新しい&lt;c2&gt;$/&lt;/c2&gt;、最後の正規表現マッチの戻り値も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is defined as the textually last statement of its top-level list of statements; any statements embedded within those top-level statements are in their own lower-level list of statements and, while they may be a final statement in their subscope, they're not considered the final statement of the outer block in question.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T015413Z" creationid="Toshiyuki" creationdate="20130803T015413Z">
        <seg>これは文の最上位リストの最後のテキスト文として定義される；それら最上位の文に埋め込まれた任意の文がそれらのより低いレベルのリストにあり、そしてそれらがサブスコープの最後の文かもしれないなら、それらは問題の外側のブロックの最後の文とみなされない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is equivalent to</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113741Z" creationid="Toshiyuki" creationdate="20130810T113741Z">
        <seg>これは以下と同等だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful for list comprehensions:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121125Z" creationid="Toshiyuki" creationdate="20130813T121125Z">
        <seg>これは特にリストの理解の役に立つ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful for the do-once block, since it is officially a loop and can take therefore loop control statements.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T130634Z" creationid="Toshiyuki" creationdate="20130810T130634Z">
        <seg>これは特にdo-onceブロックに役に立ち、正式なループなのでループ制御文をとることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is subtly different from Perl 5's behavior, which was to return the value of the last expression evaluated, even if that expression was just a conditional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T020026Z" creationid="Toshiyuki" creationdate="20130803T020026Z">
        <seg>これは文が条件付きだけであっても最後に評価された文が返されるというPerl 5の振る舞いと微妙に異なる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of list should not be confused with the flattening list context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073716Z" creationid="Toshiyuki" creationdate="20140329T073716Z">
        <seg>この種のリストはフラット化リストコンテキストと混同されるべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to keep track of what you last "took":</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T213301Z" creationid="Toshiyuki" creationdate="20130810T213301Z">
        <seg>これはあなたが最後に取ったのは何か追い続けるのを簡単にする：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may be overridden by attaching a &lt;c1&gt;.resume_value&lt;/c1&gt; to the warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T074213Z" creationid="Toshiyuki" creationdate="20130818T074213Z">
        <seg>これは&lt;c1&gt;.resume_value&lt;/c1&gt;を警告に付け加えることでオーバーライドすることもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that &lt;c1&gt;CATCH&lt;/c1&gt; and &lt;c2&gt;CONTROL&lt;/c2&gt; always require a block, since they take an argument that sets &lt;c3&gt;$_&lt;/c3&gt; to the current topic, so that the innards are able to behave as a switch statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T090602Z" creationid="Toshiyuki" creationdate="20130818T090602Z">
        <seg>これは&lt;c1&gt;CATCH&lt;/c1&gt;と&lt;c2&gt;CONTROL&lt;/c2&gt;が常にブロックを要求することを意味する。それらは&lt;c3&gt;$_&lt;/c3&gt;を現在のトピックにセットする引数をとるので、内部はswitch文として振る舞うことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism is really only good for objects that know how to return a boolean value and still remain themselves.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T145534Z" creationid="Toshiyuki" creationdate="20130809T145534Z">
        <seg>この仕組みは本当にブール値をどのように返すのか知っていてそれら自身がまだ残るオブジェクトにだけ良い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This prints:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T233849Z" creationid="Toshiyuki" creationdate="20140221T233849Z">
        <seg>これは次のように出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those that are truly global will have global alphabetic names, such as &lt;c0&gt;$*PID&lt;/c0&gt; or &lt;c1&gt;@*ARGS&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090447Z" creationid="Toshiyuki" creationdate="20140329T090447Z">
        <seg>それらの本当にグローバルなものはアルファベットの名前、&lt;c0&gt;$*PID&lt;/c0&gt;または&lt;c1&gt;@*ARGS&lt;/c1&gt;のようなものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Though certain control statements could conceivably be parsed in a self-contained way, for visual consistency all statement-terminating blocks that end in the middle of a line &lt;i0&gt;must&lt;/i0&gt; be terminated by semicolon unless they are naturally terminated by some other statement terminator:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T042251Z" creationid="Toshiyuki" creationdate="20130803T042251Z">
        <seg>確実な制御文はおそらく自己完結的な方法でパースできるだろうが、視覚的な一貫性のために、いくつかの他の文末によって自然に終えるのでない限り、行の中間で終わる全ての終端ブロックは&lt;i0&gt;必ず&lt;/i0&gt;セミコロンで終わらなければならない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To coerce your return value, use a coercion type:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224039Z" creationid="Toshiyuki" creationdate="20140328T224039Z">
        <seg>戻り値を強制するために、型の自動変換を使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To format a hash value or list of pairs, include formats for both key and value in the first string: &lt;c1&gt;.fmt('%s: %s', "\n")&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T030013Z" creationid="Toshiyuki" creationdate="20140329T030013Z">
        <seg>ハッシュ値かペアのリストをフォーマットするために、キーと値の両方のフォーマットを最初の文字列に含めてください：&lt;c1&gt;.fmt('%s: %s', "\n")&lt;/c1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To format an array value separated by commas, supply a second argument: &lt;c0&gt;.fmt('%03d', ', ')&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T025840Z" creationid="Toshiyuki" creationdate="20140329T025840Z">
        <seg>配列値をコンマで区切るには第二の引数を与えてください：&lt;c0&gt;.fmt('%03d', ', ')&lt;/c0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a formatted representation of any scalar value, use the &lt;c0&gt;.fmt('%03d')&lt;/c0&gt; method to do an implicit &lt;c1&gt;sprintf&lt;/c1&gt; on the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T025737Z" creationid="Toshiyuki" creationdate="20140329T025737Z">
        <seg>スカラー値のフォーマットされた表現を得るために、値上で暗黙の&lt;c1&gt;sprintf&lt;/c1&gt;を行う&lt;c0&gt;.fmt('%03d')&lt;/c0&gt;メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the number of elements in an array, use the &lt;c0&gt;.elems&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T141234Z" creationid="Toshiyuki" creationdate="20140327T141234Z">
        <seg>配列の要素数を得るために&lt;c0&gt;.elems&lt;/c0&gt;メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ignore all unhandled exceptions, use an empty &lt;c4&gt;default&lt;/c4&gt; case.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T135119Z" creationid="Toshiyuki" creationdate="20130813T135119Z">
        <seg>全てのハンドルされない例外を無視するために、空の&lt;c4&gt;default&lt;/c4&gt;ケースを使え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To jump into the next &lt;c4&gt;when&lt;/c4&gt; block without testing its condition, you must use a &lt;c5&gt;goto&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115331Z" creationid="Toshiyuki" creationdate="20130813T115331Z">
        <seg>条件をテストせずに次の&lt;c4&gt;when&lt;/c4&gt;ブロックにジャンプするには&lt;c5&gt;goto&lt;/c5&gt;を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a slice subscript return something other than values, append an appropriate adverb to the subscript.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T084149Z" creationid="Toshiyuki" creationdate="20140329T084149Z">
        <seg>スライス添字に値と別の何かを返させるために、添字に適切な副詞を追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To mark them all as handled you must access them individually via the implicit loop of a CATCH block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T164623Z" creationid="Toshiyuki" creationdate="20130817T164623Z">
        <seg>それらを全てハンドルされたとしてマークするためにはCATCHブロックの暗黙のループ経由で個別にアクセスしなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent lazy lists for leaking out unexpectedly, the inside of a &lt;c11&gt;try&lt;/c11&gt; is always considered an eager context, unless the &lt;c12&gt;try&lt;/c12&gt; itself is in a sink context, in which case the inside of &lt;c13&gt;try&lt;/c13&gt; is also in sink context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T123141Z" creationid="Toshiyuki" creationdate="20130813T123141Z">
        <seg>レイジーなリストが思いがけなく漏れるのを防ぐために、&lt;c11&gt;try&lt;/c11&gt;の内部は常にeagerコンテキストとみなされる。その&lt;c12&gt;try&lt;/c12&gt;自身がsinkコンテキストでなく、&lt;c13&gt;try&lt;/c13&gt;の内部もsinkコンテキストの場合でない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To process two arrays in parallel use the &lt;c0&gt;zip&lt;/c0&gt; function to generate a list that can be bound to the corresponding number of parameters:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T062101Z" creationid="Toshiyuki" creationdate="20130810T062101Z">
        <seg>二つの配列を並行して処理するために&lt;c0&gt;zip&lt;/c0&gt;関数を使用してパラメータの数が一致するようにバインド可能なリストを生成する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To return a value (to the dynamical caller) from any pointy block or bare closure, you either just let the block return the value of its final expression, or you can use &lt;c0&gt;leave&lt;/c0&gt;, which comes in both function and method forms.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T071032Z" creationid="Toshiyuki" creationdate="20130817T071032Z">
        <seg>何か一つのポインティブロックか裸のクロージャから値を返すために（ダイナミックな呼び出し元へ）、ブロックが最後の文の値を返すようにするだけか、関数かメソッド形式の&lt;c0&gt;leave&lt;/c0&gt;を使うことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To return from your immediate caller, you can say:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T072429Z" creationid="Toshiyuki" creationdate="20130817T072429Z">
        <seg>あなたの呼び出し元から直接に返すなら、次のようにできる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traits</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132622Z" creationid="Toshiyuki" creationdate="20140326T132622Z">
        <seg>トレイト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traits cannot be changed at run-time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132814Z" creationid="Toshiyuki" creationdate="20140326T132814Z">
        <seg>トレイトは実行時に変更できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Twigils</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T014611Z" creationid="Toshiyuki" creationdate="20140329T014611Z">
        <seg>ツウィギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133511Z" creationid="Toshiyuki" creationdate="20140327T133511Z">
        <seg>型オブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types are officially compared using name equivalence rather than structural equivalence.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131645Z" creationid="Toshiyuki" creationdate="20140326T125818Z">
        <seg>型は構造よりも名前の同一性を使って比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types as Constraints</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T131937Z" creationid="Toshiyuki" creationdate="20140327T131937Z">
        <seg>制約としての型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscore is always considered alphabetic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T092733Z" creationid="Toshiyuki" creationdate="20140329T092733Z">
        <seg>アンダースコアは常に英字とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike &lt;c0&gt;try&lt;/c0&gt;, the presence of a &lt;c1&gt;CATCH&lt;/c1&gt; block does not imply &lt;c2&gt;use fatal&lt;/c2&gt; semantics for failures; you may, however, use either an explicit &lt;c3&gt;try&lt;/c3&gt; block around the &lt;c4&gt;CATCH&lt;/c4&gt; or an explicit &lt;c5&gt;use fatal&lt;/c5&gt; to guarantee that failures are thrown eagerly rather than lazily.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T121559Z" creationid="Toshiyuki" creationdate="20130814T121559Z">
        <seg>&lt;c0&gt;try&lt;/c0&gt;と違い、&lt;c1&gt;CATCH&lt;/c1&gt;ブロックの存在は失敗のための暗黙の&lt;c2&gt;use fatal&lt;/c2&gt;セマンティクスを行わない；あなたは多分、けれども、&lt;c4&gt;CATCH&lt;/c4&gt;の周りの明示的な&lt;c3&gt;try&lt;/c3&gt;ブロックか明示的な&lt;c5&gt;use fatal&lt;/c5&gt;を失敗がスローされることを保証するために使うだろう。レイジーよりも熱心に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike &lt;c3&gt;do&lt;/c3&gt;, it evaluates the statement or block in sink (void) context; its return value is instead specified by calling the &lt;c4&gt;take&lt;/c4&gt; list prefix operator one or more times within the scope (either lexical or dynamic) of the &lt;c5&gt;gather&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T153248Z" creationid="Toshiyuki" creationdate="20130810T153248Z">
        <seg>&lt;c3&gt;do&lt;/c3&gt;と違い、それは文またはブロックをsink（void）コンテキストで評価する；それの返り値は&lt;c4&gt;take&lt;/c4&gt;リストプレフィックス演算子を&lt;c5&gt;gather&lt;/c5&gt;のスコープ内（レキシカルかダイナミック）で1回以上呼ぶことで代わりに明示される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Perl 5's &lt;c0&gt;do-while&lt;/c0&gt; loop, this is a real loop block now, so &lt;c1&gt;next&lt;/c1&gt;, &lt;c2&gt;last&lt;/c2&gt;, and &lt;c3&gt;redo&lt;/c3&gt; work as expected.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T151638Z" creationid="Toshiyuki" creationdate="20130809T151638Z">
        <seg>Perl 5の&lt;c0&gt;do-while&lt;/c0&gt;ループと違い、これは今実際のループブロックなので、&lt;c1&gt;next&lt;/c1&gt;、&lt;c2&gt;last&lt;/c2&gt;、そして&lt;c3&gt;redo&lt;/c3&gt;が期待通りに機能する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, applying a statement modifier to a &lt;c0&gt;do&lt;/c0&gt; block is specifically disallowed:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T151326Z" creationid="Toshiyuki" creationdate="20130809T151326Z">
        <seg>Perl 5と違い、&lt;c0&gt;do&lt;/c0&gt;ブロックに文修飾子を適用することは明確に禁じられている：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, if a final statement in Perl 6 is a conditional that does not execute any of its branches, it doesn't matter what the value of the conditional is, the value of that conditional statement is always &lt;c0&gt;()&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T020936Z" creationid="Toshiyuki" creationdate="20130803T020936Z">
        <seg>Perl 5と違い、Perl 6の最後の文が条件付きでいずれかの分岐を実行しない場合、条件の値が何かを問題とせず、その条件付き文は常に&lt;c0&gt;()&lt;/c0&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, the notation &lt;c0&gt;&amp;foo&lt;/c0&gt; merely stands for the &lt;c1&gt;foo&lt;/c1&gt; function as a &lt;c2&gt;Routine&lt;/c2&gt; object without calling it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082931Z" creationid="Toshiyuki" creationdate="20140329T082931Z">
        <seg>Perl 5と異なり、表記法&lt;c0&gt;&amp;foo&lt;/c0&gt;はそれを呼び出すことのない&lt;c2&gt;Routine&lt;/c2&gt;オブジェクトとして単に&lt;c1&gt;foo&lt;/c1&gt;関数を表すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, there are (by policy) no implicit blocks around standard control structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T122034Z" creationid="Toshiyuki" creationdate="20130729T122034Z">
        <seg>Perl 5と異なり、標準の制御構造の周りに暗黙のブロックは（ポリシーとして）無い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike many other languages, Perl 6 specifies exception handlers by placing a &lt;c0&gt;CATCH&lt;/c0&gt; block &lt;i1&gt;within&lt;/i1&gt; that block that is having its exceptions handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121517Z" creationid="Toshiyuki" creationdate="20130813T121517Z">
        <seg>他の言語と違い、Perl 6は扱われる例外を持つ&lt;c0&gt;CATCH&lt;/c0&gt;ブロックをそのブロック&lt;i1&gt;内&lt;/i1&gt;に配置することで例外ハンドラを明示する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike with loop controls, however, scanning a scope includes a scan of any lexical scopes included within the current candidate scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T141842Z" creationid="Toshiyuki" creationdate="20130817T141842Z">
        <seg>ループ制御と違い、けれども、スコープをスキャンすることは現在の候補のスコープ内を含む何か一つのレキシカルスコープのスキャンを含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unthrown exceptions are meant to provide a failsoft mechanism in which failures can be treated as data and dealt with one by one, without aborting execution of what may be perfectly valid parallel computations.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T174650Z" creationid="Toshiyuki" creationdate="20130817T173036Z">
        <seg>スローされない例外はフェールソフトメカニズムを供給するように意図される。その失敗はデータとして扱うことができ、一つづつ分配できる。完璧に正しい並行計算の実行の中止なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140212Z" creationid="Toshiyuki" creationdate="20130802T140212Z">
        <seg>使え</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c1&gt;$Package::var&lt;/c1&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000122Z" creationid="Toshiyuki" creationdate="20140329T000122Z">
        <seg>&lt;c1&gt;$Package::var&lt;/c1&gt;を代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of a placeholder parameter in statement-level blocks triggers a syntax error, because the parameter is not out front where it can be seen.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T151548Z" creationid="Toshiyuki" creationdate="20130810T151548Z">
        <seg>文レベルのブロックでのプレースホルダーパラメータの使用は文法エラーを引き起こす。なぜならそれが見える場所でパラメータは前に出ていないからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-defined classes don't derive from &lt;c5&gt;Cool&lt;/c5&gt; by default, so such classes are also unaffected by changes to &lt;c6&gt;Cool&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000024Z" creationid="Toshiyuki" creationdate="20140329T000024Z">
        <seg>デフォルトでユーザー定義のクラスは&lt;c5&gt;Cool&lt;/c5&gt;から継承しないので、そのようなクラスは&lt;c6&gt;Cool&lt;/c6&gt;による変化の影響を受けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-selected Brackets</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053508Z" creationid="Toshiyuki" creationdate="20140330T053508Z">
        <seg>ユーザー選択のブラケット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Warnings are produced in Perl 6 by throwing a resumable control exception to the outermost scope, which by default prints the warning and resumes the exception by extracting a resume continuation from the exception, which must be supplied by the &lt;c0&gt;warn()&lt;/c0&gt; function (or equivalent).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T114421Z" creationid="Toshiyuki" creationdate="20130817T114421Z">
        <seg>Perl 6では再開可能な制御例外を最も外側のスコープに投げることで警告が引き起こされる。その警告はデフォルトで警告をプリントし、&lt;c0&gt;warn()&lt;/c0&gt;関数（または同等のもの）から供給されなければならない例外から再開可能な継続取り出すことで例外を再開する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also use the term "dynamic scoping" in the standard fashion to indicate the nested call frames that are created and destroyed every time a function or method is called.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T144249Z" creationid="Toshiyuki" creationdate="20130727T143959Z">
        <seg>我々はまた、関数かメソッドが呼ばれるたびに作成と破棄が行われる入れ子になったコールフレームを示すために「ダイナミックスコープ」という語句を標準的な方法で使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can't really rely on end-of-routine cleanup to deal with failures that are returned as normal data, unless we go with the overhead of a lexical &lt;c6&gt;@!&lt;/c6&gt; variable.]</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T155218Z" creationid="Toshiyuki" creationdate="20130817T155218Z">
        <seg>我々は本当に通常のデータとして返される失敗に対処するためのルーチン終了のクリーンアップを頼りにすることはできない。レキシカルな&lt;c6&gt;@!&lt;/c6&gt;変数へオーバーヘッドとともに行くのでない限り。］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We should probably at least issue warnings, though, if the GC eventually collects a failure that was never handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T154727Z" creationid="Toshiyuki" creationdate="20130817T154727Z">
        <seg>たぶん我々は少なくとも警告を出すべきだ。しかしながら、もしGCが結局は決してハンドルされない失敗を集めるなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We use the phrase "lexical scoping" in its industry-standard meaning to indicate those blocks that surround the current textual location.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140830T111514Z" creationid="Toshiyuki" creationdate="20130727T114316Z">
        <seg>我々は「レキシカルスコープ」という言い回しを業界標準の「現在の位置のテキストを囲んでいるブロック」という意味で使用する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, it doesn't really fall back, since a &lt;c2&gt;take&lt;/c2&gt; knows at compile time whether it is being used lexically or dynamically.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T155030Z" creationid="Toshiyuki" creationdate="20130810T155030Z">
        <seg>さて、それは本当は戻らない。&lt;c2&gt;take&lt;/c2&gt;がレキシカルかダイナミックに使われるかどうかコンパイル時に知る時から。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When bound into a lol context, however, the parcel objects become real &lt;c0&gt;List&lt;/c0&gt; objects that keep their identity as discrete sublists.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T204650Z" creationid="Toshiyuki" creationdate="20130810T204650Z">
        <seg>lolコンテキストにバインドされるとき、どんな方法でも、パーセルオブジェクトは不連続のサブリストとしてそれらの識別子を持つ本当の&lt;c0&gt;List&lt;/c0&gt;オブジェクトになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When phasers are in different modules, the &lt;c3&gt;INIT&lt;/c3&gt; and &lt;c4&gt;END&lt;/c4&gt; phasers are treated as if declared at &lt;c5&gt;use&lt;/c5&gt; time in the using module.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130820T125044Z" creationid="Toshiyuki" creationdate="20130820T125044Z">
        <seg>phasersが異なるモジュールにある時、&lt;c3&gt;INIT&lt;/c3&gt;と&lt;c4&gt;END&lt;/c4&gt; phasersはモジュールを使う&lt;c5&gt;use&lt;/c5&gt;時に宣言されたかのように扱われる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as statement modifiers on implicit blocks (thunks), &lt;c0&gt;for&lt;/c0&gt; and &lt;c1&gt;given&lt;/c1&gt; privately temporize the current value of &lt;c2&gt;$_&lt;/c2&gt; for the left side of the statement and restore the original value at loop exit:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114751Z" creationid="Toshiyuki" creationdate="20130810T114751Z">
        <seg>文修飾子が暗黙のブロック（サンク）で使われるとき、&lt;c0&gt;for&lt;/c0&gt;と&lt;c1&gt;given&lt;/c1&gt;は左側の文の現在の&lt;c2&gt;$_&lt;/c2&gt;の値をひそかに一時的とし、ループの終了時に初期値を復元する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever an exception occurs during the execution of a handler, it is pushed onto the end of the &lt;c0&gt;@*undead&lt;/c0&gt; array for later processing by an outer handler.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T111145Z" creationid="Toshiyuki" creationdate="20130814T111145Z">
        <seg>ハンドラの実行中に例外が起こる時はいつでも、外側のハンドラに処理されて後で&lt;c0&gt;@*undead&lt;/c0&gt;配列の終端にプッシュされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a target object or label, loop modifiers search lexotically for the scope to modify.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T103526Z" creationid="Toshiyuki" creationdate="20130806T103526Z">
        <seg>ターゲットオブジェクトかラベルを伴って、ループ修飾子はレギゾチックに変更するスコープを検索する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a target, however, they are purely dynamic, and choose the innermost dynamic loop, which may well be a &lt;c0&gt;map&lt;/c0&gt; or other implicitly looping function, including user-defined functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130721Z" creationid="Toshiyuki" creationdate="20130808T130721Z">
        <seg>ターゲットなしで純粋に動的ならなんであれ、最も深い部分の動的ループを選ぶ。それは&lt;c0&gt;map&lt;/c0&gt;または他の暗黙のユーザー定義の関数を含むループ関数だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can cause built-ins to automatically throw exceptions on failure using</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T165751Z" creationid="Toshiyuki" creationdate="20130817T165751Z">
        <seg>次を使ってビルトインを失敗時に例外を自動的にスローさせる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare a parameter read/write by including the "&lt;c0&gt;is rw&lt;/c0&gt;" trait.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112806Z" creationid="Toshiyuki" creationdate="20130810T112806Z">
        <seg>&lt;c0&gt;is rw&lt;/c0&gt;トレイトを付け加えることでパラメータのread/writeを宣言することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can explicitly break out of a &lt;c0&gt;when&lt;/c0&gt; block (and its surrounding topicalizer block) early using the &lt;c1&gt;succeed&lt;/c1&gt; verb.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T113107Z" creationid="Toshiyuki" creationdate="20130812T113107Z">
        <seg>&lt;c1&gt;succeed&lt;/c1&gt;を使って&lt;c0&gt;when&lt;/c0&gt;ブロック（トピカライザーブロックを囲っている）を明示的に早く脱出できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can explicitly leave a &lt;c0&gt;when&lt;/c0&gt; block and go to the next statement following the &lt;c1&gt;when&lt;/c1&gt; by using &lt;c2&gt;proceed&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115044Z" creationid="Toshiyuki" creationdate="20130813T115044Z">
        <seg>&lt;c2&gt;proceed&lt;/c2&gt;を使うことで&lt;c0&gt;when&lt;/c0&gt;ブロックを明示的に抜け、&lt;c1&gt;when&lt;/c1&gt;に続く次の文に行くことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to use an explicit default--you can just fall off the last &lt;c1&gt;when&lt;/c1&gt; into ordinary code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133614Z" creationid="Toshiyuki" creationdate="20130811T133614Z">
        <seg>明示的なdefaultを使う必要はない―普通のコードの最後の&lt;c1&gt;when&lt;/c1&gt;をただ離れることもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also perform an existence test, either on a single item or a junction of items:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T085221Z" creationid="Toshiyuki" creationdate="20140329T085221Z">
        <seg>単独のアイテムかジャンクションで存在のテストを実行できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may force immediate conversion to a &lt;c0&gt;Capture&lt;/c0&gt; object by prefixing the parcel composer with a backslash:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T074659Z" creationid="Toshiyuki" creationdate="20140329T074659Z">
        <seg>バックスラッシュをパーセルコンポーザーの前に置くことによって&lt;c0&gt;Capture&lt;/c0&gt;オブジェクトへの即時の変換を強制できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have one &lt;c2&gt;CATCH&lt;/c2&gt; block and one &lt;c3&gt;CONTROL&lt;/c3&gt; block, since some user-defined constructs may wish to supply an implicit &lt;c4&gt;CONTROL&lt;/c4&gt; block to your closure, but let you define your own &lt;c5&gt;CATCH&lt;/c5&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T130520Z" creationid="Toshiyuki" creationdate="20130816T130520Z">
        <seg>一つの&lt;c2&gt;CATCH&lt;/c2&gt;ブロックと一つの&lt;c3&gt;CONTROL&lt;/c3&gt;ブロックを持つこともできる。なのでいくつかのユーザー定義の構造が暗黙の&lt;c4&gt;CONTROL&lt;/c4&gt;ブロックをあなたのクロージャに与えたいと思うかもしれないが、あなたに独自の&lt;c5&gt;CATCH&lt;/c5&gt;ブロックを定義させる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may not go into a &lt;c7&gt;given&lt;/c7&gt; or a &lt;c8&gt;for&lt;/c8&gt;, though, because that would bypass a formal parameter binding (not to mention list generation in the case of &lt;c9&gt;for&lt;/c9&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T142603Z" creationid="Toshiyuki" creationdate="20130817T142603Z">
        <seg>あたなは&lt;c7&gt;given&lt;/c7&gt;または&lt;c8&gt;for&lt;/c8&gt;には行かないだろうけれど、それは仮パラメータのバインディングをバイパスするだろう（&lt;c9&gt;for&lt;/c9&gt;のケースのリスト生成の言及ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may suppress this by modifying the first declaration with &lt;c0&gt;proto&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T130153Z" creationid="Toshiyuki" creationdate="20130730T130153Z">
        <seg>最初の宣言を&lt;c0&gt;proto&lt;/c0&gt;を付けて変更すればこれを抑制できるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may use :!exists to test for non-existence.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T085449Z" creationid="Toshiyuki" creationdate="20140329T085449Z">
        <seg>:!existsで存在しないことをテストできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must use &lt;c2&gt;last&lt;/c2&gt; (or some more violent control exception such as &lt;c3&gt;return&lt;/c3&gt;) to break out of the entire loop early.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120133Z" creationid="Toshiyuki" creationdate="20130813T120133Z">
        <seg>全体のループを早期に抜けるために&lt;c2&gt;last&lt;/c2&gt;（または&lt;c3&gt;return&lt;/c3&gt;のようないくつかのより乱暴な制御例外）を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need a wormhole for that.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T092259Z" creationid="Toshiyuki" creationdate="20130818T092259Z">
        <seg>あなたはそれのためにワームホールを必要とする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Conjecture: a bare &lt;c0&gt;next($retval)&lt;/c0&gt; function could be taught to do the same, as long as &lt;c1&gt;$retval&lt;/c1&gt; isn't a loop label.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T102953Z" creationid="Toshiyuki" creationdate="20130806T102953Z">
        <seg>[推測：裸の&lt;c0&gt;next($retval)&lt;/c0&gt;関数は同じ事をするように教えられるかもしれない。&lt;c1&gt;$retval&lt;/c1&gt;がループラベルでない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Conjecture: all unhandled exceptions within a routine could be stored in &lt;c0&gt;@!&lt;/c0&gt;, with the most recent first.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T152234Z" creationid="Toshiyuki" creationdate="20130817T152234Z">
        <seg>［推測：ルーチン内の全てのハンドルされない例外は最も最近のものが&lt;c0&gt;@!&lt;/c0&gt;に格納される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add 1 to the result of the do block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124258Z" creationid="Toshiyuki" creationdate="20130811T124258Z">
        <seg>はdoブロックの結果に1を加算する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and that is equivalent to:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130805T183828Z" creationid="Toshiyuki" creationdate="20130805T161429Z">
        <seg>そしてそれは以下と同じだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calls the &lt;c0&gt;foo&lt;/c0&gt; function with three arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124219Z" creationid="Toshiyuki" creationdate="20130811T124219Z">
        <seg>は&lt;c0&gt;foo&lt;/c0&gt;関数を三つの引数で呼ぶ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>causes &lt;c0&gt;$x&lt;/c0&gt; to start with its current value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140153Z" creationid="Toshiyuki" creationdate="20130802T140153Z">
        <seg>は&lt;c0&gt;$x&lt;/c0&gt;をその現在の値で始める。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deletes the entries &lt;i0&gt;en passant&lt;/i0&gt; while returning them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T084807Z" creationid="Toshiyuki" creationdate="20140329T084807Z">
        <seg>はそれらを返す&lt;i0&gt;ついでに&lt;/i0&gt;エントリーを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>description</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043916Z" creationid="Toshiyuki" creationdate="20140322T043916Z">
        <seg>概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>digit</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124735Z" creationid="Toshiyuki" creationdate="20140322T124735Z">
        <seg>数字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if we're gonna blow past</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T110705Z" creationid="Toshiyuki" creationdate="20130814T110705Z">
        <seg>もし我々が過去を吹きとばそうとしているなら</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in Perl 6 you should use a &lt;c0&gt;for&lt;/c0&gt; instead:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T062641Z" creationid="Toshiyuki" creationdate="20130810T062641Z">
        <seg>Perl 6では代わりに&lt;c0&gt;for&lt;/c0&gt;を使うべきだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125737Z" creationid="Toshiyuki" creationdate="20130730T125623Z">
        <seg>と代わりに書く必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is actually short for:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114018Z" creationid="Toshiyuki" creationdate="20130810T114018Z">
        <seg>は実際は以下の略だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to the Cish idiom:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060605Z" creationid="Toshiyuki" creationdate="20130810T060605Z">
        <seg>はC言語風のイディオムと同等だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is exactly equivalent to</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133252Z" creationid="Toshiyuki" creationdate="20130811T133252Z">
        <seg>は以下とまさに同等だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is parsed as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124611Z" creationid="Toshiyuki" creationdate="20130811T124611Z">
        <seg>は以下のようにパースされる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is really just short for:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T072238Z" creationid="Toshiyuki" creationdate="20130817T072238Z">
        <seg>は実際は以下の略だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it was always exit from your lexically scoped &lt;c0&gt;LINE&lt;/c0&gt; loop, even if some inner dynamic scope you can't see happens to also have that label.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T074659Z" creationid="Toshiyuki" creationdate="20130817T074659Z">
        <seg>それは常にレキシカルスコープな&lt;c0&gt;LINE&lt;/c0&gt;ループから抜け出す。あなたが見ることができないいくつかのダイナミックスコープがたまたまそのラベルを持っていても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>marks only the last exception as handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T163350Z" creationid="Toshiyuki" creationdate="20130817T163350Z">
        <seg>は最後の例外だけハンドルされたとマークする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043913Z" creationid="Toshiyuki" creationdate="20140322T043913Z">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125614Z" creationid="Toshiyuki" creationdate="20130730T125614Z">
        <seg>または</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently, using placeholders:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T125903Z" creationid="Toshiyuki" creationdate="20130810T125903Z">
        <seg>または同じようにプレースホルダーを使う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T054724Z" creationid="Toshiyuki" creationdate="20130809T151429Z">
        <seg>または同様に：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sets the variable to 0 at &lt;c0&gt;END&lt;/c0&gt; time, since that is when the "my" declaration is actually executed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085607Z" creationid="Toshiyuki" creationdate="20130818T085607Z">
        <seg>は&lt;c0&gt;END&lt;/c0&gt;時に変数を0にセットする。「my」宣言が実際に実行される時まで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>so you can modify the current list element in that case.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114118Z" creationid="Toshiyuki" creationdate="20130810T114118Z">
        <seg>なのでその場合あなたは現在のリストの要素を変更できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the result is a &lt;c0&gt;Parcel&lt;/c0&gt; object containing three &lt;c1&gt;Int&lt;/c1&gt; objects and a &lt;c2&gt;Pair&lt;/c2&gt; object, that is, four positional objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073956Z" creationid="Toshiyuki" creationdate="20140329T073956Z">
        <seg>の結果は3つの&lt;c1&gt;Int&lt;/c1&gt;オブジェクトと&lt;c2&gt;Pair&lt;/c2&gt;オブジェクトを含む&lt;c0&gt;Parcel&lt;/c0&gt;、すなわち4つの位置依存オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the syntactic &lt;c0&gt;Parcel&lt;/c0&gt; is translated (at compile time, in this case) into a &lt;c1&gt;Capture&lt;/c1&gt; object with three positionals and one named argument in preparation for binding.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T074309Z" creationid="Toshiyuki" creationdate="20140329T074309Z">
        <seg>構文法の&lt;c0&gt;Parcel&lt;/c0&gt;はバインディングに備えて3つの位置依存と名前付き引数の&lt;c1&gt;Capture&lt;/c1&gt;オブジェクトに変換（この場合はコンパイル時に） されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to automatically assign to &lt;c0&gt;$_&lt;/c0&gt; is not carried over to Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T111849Z" creationid="Toshiyuki" creationdate="20130810T111731Z">
        <seg>を自動的に&lt;c0&gt;$_&lt;/c0&gt;へ割り当てることはPerl 6へは持ち越されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get the Perl 5 behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140241Z" creationid="Toshiyuki" creationdate="20130802T140241Z">
        <seg>Perl 5の振る舞いを得るために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where each call to the block would bind a new invocant for the &lt;c0&gt;.waste&lt;/c0&gt; method, each of which is likely different from the original invocant to the &lt;c1&gt;.haste&lt;/c1&gt; method.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T103305Z" creationid="Toshiyuki" creationdate="20130804T103305Z">
        <seg>それぞれのブロックへの呼び出しが&lt;c0&gt;.waste&lt;/c0&gt;メソッドへの新しいインボカントをバインドするようなら、それぞれは&lt;c1&gt;.haste&lt;/c1&gt;メソッドのオリジナルのインボカントとおそらく違う。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is short for</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112030Z" creationid="Toshiyuki" creationdate="20130810T112030Z">
        <seg>それは以下の略だ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whitespace</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124741Z" creationid="Toshiyuki" creationdate="20140322T124741Z">
        <seg>空白</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will no longer see the value of the outer &lt;c0&gt;$x&lt;/c0&gt;; you'll need to say either</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125609Z" creationid="Toshiyuki" creationdate="20130730T125609Z">
        <seg>はもやは外側の&lt;c0&gt;$x&lt;/c0&gt;の値を見ない；あなたは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you're really calling into a &lt;i0&gt;catch lambda&lt;/i0&gt; that works something like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T110054Z" creationid="Toshiyuki" creationdate="20130814T110054Z">
        <seg>実際にはこれの何かのように動作する&lt;i0&gt;catch lambda&lt;/i0&gt;の中へ呼んでいる：</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
