<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="3.1.6" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>()
1, 2, 3
&lt;a b c&gt;
ﾂｫa b cﾂｻ
qw/a b c/</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124020Z" creationid="yamato" creationdate="20140914T124020Z">
        <seg>()
1, 2, 3
&lt;a b c&gt;
«a b c»
qw/a b c/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(&lt;c1&gt;next&lt;/c1&gt; without a label is purely dynamic.) Lexotic and dynamic control flow is implemented by a system of control exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T062449Z" creationid="Toshiyuki" creationdate="20130728T061924Z">
        <seg>（ラベルなしの&lt;c1&gt;next&lt;/c1&gt;は純粋に動的だ。） レギゾチックとダイナミックな制御フローは制御例外としてシステムによって実装される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A single underscore is also allowed between a radix prefix and a following digit, as explained in the next section.) Underscores are not allowed anywhere else in any numeric literal, including next to the radix point or exponentiator, or at the beginning or end.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（次のセクションで説明されるように、一つのアンダーラインも根接頭辞と以下の桁の間でも許される。）アンダーラインは、何か数値リテラル（基数点またはexponentiatorへの次を含む）の他のどこにも、または、始めまたは終わりで許されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(All normal types in Perl may be evaluated for truth.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T070644Z" creationid="Toshiyuki" creationdate="20130804T070644Z">
        <seg>（Perlのすべての通常の型は真偽のために評価されるだろう。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Always assuming the user expects the right thing, of course...) In particular, if the user labels a loop with a specific label, and calls a loop control from within the lexical scope of that loop, and if that call mentions the outer loop's label, then that outer loop is the one that must be controlled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080908Z" creationid="Toshiyuki" creationdate="20130817T080908Z">
        <seg>（ユーザーが常に仮定するのは正しいことだ。もちろん）特に、特定のラベルでユーザーがループにラベルを付けるなら、そしてループ制御をそのレキシカルスコープ内でよぶなら、そしてその呼出しが外側のループのラベルを言及するなら、制御されなければならない外側のループは一つだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(As it happens, conversion to a buf type based on 32-bit integers produces valid UTF-32 in the native endianness.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（たまたま、32ビット整数に基づくbuf型への転換はネイティブendiannessで有効なUTF-32を生じる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(By similar reasoning, an &lt;c5&gt;unless&lt;/c5&gt; allows binding of a false parameter.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T084132Z" creationid="Toshiyuki" creationdate="20130804T084132Z">
        <seg>（似た理由で、&lt;c5&gt;unless&lt;/c5&gt;偽のパラメータのバインディングを許可する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Contrast with a non-conditional statement such as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T100105Z" creationid="Toshiyuki" creationdate="20130804T100105Z">
        <seg>（条件付きでない文の対比はこのようになる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Counting the elements in the array will also force eager completion.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（配列で要素を数えることは熱心な完成も強制する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Directly subscripting the type with either square brackets or curlies is reserved for various generic type-theoretic operations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（直接、どちらの正方形による型でも括弧に入れる添え字付けまたはcurliesは、いろいろな汎用的な型理論的な演算のために予約である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Except that a space is not added if the element already ends in some kind of whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（が、要素が何らかの空白文字ですでに終わるならば、スペースは加えられない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(FLAT is an acronym meaning Flat Lists Are Typical.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T210028Z" creationid="Toshiyuki" creationdate="20130810T210028Z">
        <seg>（FLATはFlat Lists Are Typicalの頭文字だ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For a prototype system (a non-class-based object system), all objects are merely managed by the same meta object.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（プロトタイプシステム（非クラスベースオブジェクトシステム）については、すべてのオブジェクトは単に同じメタオブジェクトによって管理されるだけである。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(However, as with the other bracketed forms, the value may end up being used as a subscript depending on context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（しかし、他の括弧に入れられた形と同様に、値は結局前後関係に従う添え字として使われることになるかもしれない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If bare statements were allowed, the temporary binding of &lt;c4&gt;$_&lt;/c4&gt; would leak out past the end of the &lt;c5&gt;CATCH&lt;/c5&gt; or &lt;c6&gt;CONTROL&lt;/c6&gt;, with unpredictable and quite possibly dire consequences.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T091247Z" creationid="Toshiyuki" creationdate="20130818T091247Z">
        <seg>（もし裸の文が許可されるなら、&lt;c4&gt;$_&lt;/c4&gt;の一時的なバインディングは&lt;c5&gt;CATCH&lt;/c5&gt;または &lt;c6&gt;CONTROL&lt;/c6&gt;の終端をすぎてリークする。予測できず、まったく緊急かもしれない結果を伴って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If it returns a list, that list is interpolated as if it were an array.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（それがリストを返るならば、まるでそれが配列であるように、そのリストは改変される。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If that is not the block you wish to leave, you must use the &lt;c12&gt;LABEL.leave&lt;/c12&gt; method (or some other control exception such as &lt;c13&gt;return&lt;/c13&gt; or &lt;c14&gt;next&lt;/c14&gt;) to be more specific, since the compiler may find it difficult to guess which surrounding construct was intended as the actual topicalizer.) The value of the inner block is returned as the value of the outer block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T131811Z" creationid="Toshiyuki" creationdate="20130811T131811Z">
        <seg>（もしそれが抜けたくないブロックなら、より明確にするために&lt;c12&gt;LABEL.leave&lt;/c12&gt;メソッド（または&lt;c13&gt;return&lt;/c13&gt;か&lt;c14&gt;next&lt;/c14&gt;のようないくつかの他の制御例外）を使わなければならない。 だからコンパイラが実際のトピカライザーとして意図される周囲の構成物がどれか推測するのは難しいだろう。） 内側のブロックの値は外側のブロックの値として返される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the &lt;c2&gt;LINE&lt;/c2&gt; is not visible, it would have been caught earlier at compile time since &lt;c3&gt;LINE&lt;/c3&gt; would likely be a bareword.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T075529Z" creationid="Toshiyuki" creationdate="20130817T075529Z">
        <seg>（もし&lt;c2&gt;LINE&lt;/c2&gt;が見えないなら、 &lt;c3&gt;LINE&lt;/c3&gt;が裸のワードのようになるまでコンパイル時に早期にキャッチされる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(If the last is used as a subscript, the subscripter notices there are two arguments and passes that dimension's size twice.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（最後が添え字として使われるならば、subscripterは2つの引数があると気がついて、二回その次元のサイズを超える。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, it does autoboxing and autounboxing as necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（言い換えると、それは、autoboxingして、必要に応じてautounboxingすることをする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, it's lexotic.) If the &lt;c1&gt;LINE&lt;/c1&gt; label is visible but you aren't actually in a dynamic scope controlled by that label, an exception is thrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T075123Z" creationid="Toshiyuki" creationdate="20130817T075123Z">
        <seg>（言い換えれば、それはレギゾチックだ。）もし&lt;c1&gt;LINE&lt;/c1&gt;ラベルが可視だが実際にはラベルによって制御されたダイナミックスコープにいるなら、例外がスローされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In other words, there is an implicit &lt;c5&gt;.die&lt;/c5&gt; just inside the end of the &lt;c6&gt;CATCH&lt;/c6&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T135455Z" creationid="Toshiyuki" creationdate="20130813T135455Z">
        <seg>（言い換えれば、&lt;c6&gt;CATCH&lt;/c6&gt;ブロックの内部の終端に暗黙の&lt;c5&gt;.die&lt;/c5&gt;があるだけだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In practice, the compiler hopefully keeps track of its current compiling scope anyway, so no scan is needed.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（実際には、コンパイラは期待を持って、いずれにしろスコープを編集しているその流れの経過を追うので、走査が必要でない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Initialization of ordinary variables does not count--presumably the presence of a label will prevent code-movement optimizations past the label.) So, for instance, it's always possible to &lt;c5&gt;goto&lt;/c5&gt; into the next case of a &lt;c6&gt;when&lt;/c6&gt; or into either the "then" or "else" branch of a conditional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T142332Z" creationid="Toshiyuki" creationdate="20130817T142332Z">
        <seg>（普通の変数の初期化はカウントしない―多分、ラベルの存在はラベルを過ぎるcode-movement最適化を防ぐだろう。）なので、例えば、&lt;c5&gt;goto&lt;/c5&gt;で次のケースの&lt;c6&gt;when&lt;/c6&gt;か「then」または「else」の条件分岐に飛ぶことは常に可能だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It is erroneous to depend on this order if the module is used more than once, however, since the phasers are only installed the first time they're noticed.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030324Z" creationid="Toshiyuki" creationdate="20130822T030324Z">
        <seg>（モジュールが2回以上使われるなら、この順番に頼るのは間違いだ。しかしながら、phasersはそれらが初めて気づいた時だけインストールされる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It is not clear that this is allowed, however.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（しかし、これが許されることは明白でない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Marking dynamic variables as readonly is very helpful in terms of sharing the same value among competing threads, since a readonly variable need not be locked.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（readonlyな変数がロックされる必要がない時から、readonlyであるように、動的変数に跡を残すことは同じ値を競争している糸で分配する観点から非常に役に立つ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(More generally, any container has a container type, including subroutines and modules.) The &lt;c0&gt;of&lt;/c0&gt; type is stored as its &lt;c1&gt;of&lt;/c1&gt; property, while the container type of the container is just the object type of the container itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T212922Z" creationid="Toshiyuki" creationdate="20140328T212922Z">
        <seg>（より一般化すると、どのようなコンテナもコンテナ型を持っています。それはサブルーチンとモジュールも含みます。）&lt;c0&gt;of&lt;/c0&gt;型は&lt;c1&gt;of&lt;/c1&gt;プロパティとして保存されます。コンテナの型はコンテナ自身のただのオブジェクト型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note also that the example above is not meant to spec how the test suite works.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（また、上の例がテストスイートが機能する仕様にとって意味されない点に注意しなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that both of these scans are done at compile time; if the scans fail, it's a compile-time semantic error.) Typically, such an outer block will be the block of a &lt;c5&gt;given&lt;/c5&gt; or a &lt;c6&gt;for&lt;/c6&gt; statement, but any block that sets the topic can be broken out of.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T165517Z" creationid="Toshiyuki" creationdate="20130812T165517Z">
        <seg>（両方のスキャンはコンパイル時に行われるので注意；もしスキャンが失敗したら、コンパイル時セマンティックエラーだ。）典型的には、そのようなブロックは&lt;c5&gt;given&lt;/c5&gt;か&lt;c6&gt;for&lt;/c6&gt;文のブロックだろう。しかしトピックをセットするどんなブロックでも脱出できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that fatal exception types can do the &lt;c2&gt;Resumable&lt;/c2&gt; role even if thrown via &lt;c3&gt;fail()&lt;/c3&gt;--when uncaught they just hit the outermost fatal handler instead of the outermost warning handler, so some inner scope has to explicitly treat them as warnings and resume them.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T115135Z" creationid="Toshiyuki" creationdate="20130817T115115Z">
        <seg>致命的な例外型は&lt;c3&gt;fail()&lt;/c3&gt;経由でスローされても&lt;c2&gt;Resumable&lt;/c2&gt;ロールを行えるので注意―キャッチされない時は最も外側の警告ハンドラの代わりに最も外側の致命的ハンドラをヒットするだけなので、いくつかの内側のスコープはそれらを警告と、それらを再会するとして明示的に扱う必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that the constant declarator always evaluates its initialization expression at compile time.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（一定の宣言が常にコンパイル時でその初期化表現を評価することに注意すべきである。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that the signature of a pointy block counts as part of the inner block, not the outer block.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（とがったブロックのシグネチャが内側ブロック（外側ブロックでない）の一部と見なされることに注意すべきである。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that this means Latin-1 can still be represented internally with 8-bit integers.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この手段ラテン語-1がまだ８ビット整数で内部的に表現されることができることに注意すべきである。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that, unlike C's idea of "falling through", subsequent &lt;c3&gt;when&lt;/c3&gt; conditions are evaluated.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115352Z" creationid="Toshiyuki" creationdate="20130813T115245Z">
        <seg>（C言語の「フォールスルー」の考えと違い、その後に続く&lt;c3&gt;when&lt;/c3&gt;の条件は評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note, however, that the value of a variable calculated at compile time may not persist under run-time cloning of any surrounding closure.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085255Z" creationid="Toshiyuki" creationdate="20130818T085255Z">
        <seg>（注意、けれども、コンパイル時に計算される変数の値はなにか一つの周囲のクロージャの実行時の複製まで残存しないだろう。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note: the implicit default binding of an outer &lt;c10&gt;$_&lt;/c10&gt; to an inner &lt;c11&gt;$_&lt;/c11&gt; can be emulated for a bare block, so that doesn't fall under the prohibition on bypassing formal binding.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T144409Z" creationid="Toshiyuki" creationdate="20130817T144409Z">
        <seg>（注意：外側の&lt;c10&gt;$_&lt;/c10&gt;の暗黙のデフォルトのバインディングから内側の&lt;c11&gt;$_&lt;/c11&gt;は裸のブロックのためにエミュレートできる。それゆえそれは正式のバインディングのバイパスの禁止に該当しない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Of course, any of these forms also work in the degenerate case of a slice containing a single index.) Note that these forms work by virtue of the fact that the subscript is the topmost previous operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>なお、これらの形は、添え字が一番上の前の演算子であるという事実によって動く（もちろん、これらの形のどれでも、一つのインデックスを含んでいるスライスの退歩したケースで動く。）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Or we use push semantics and &lt;c3&gt;$!&lt;/c3&gt; means &lt;c4&gt;@![*-1]&lt;/c4&gt;.) This might be more robust than merely making &lt;c5&gt;@!&lt;/c5&gt; a parameter to CATCH.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T152707Z" creationid="Toshiyuki" creationdate="20130817T152707Z">
        <seg>（または我々はpushセマンティクスを使い、&lt;c3&gt;$!&lt;/c3&gt;は&lt;c4&gt;@![*-1]&lt;/c4&gt;を意味する。）これは単に&lt;c5&gt;@!&lt;/c5&gt;をCATCHへのパラメータにするより強いかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Otherwise any &lt;c5&gt;die&lt;/c5&gt; would cause an infinite loop.) Instead we treasure them up and rethrow them to a handler further up.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T120951Z" creationid="Toshiyuki" creationdate="20130814T120951Z">
        <seg>（さもなければ&lt;c5&gt;die&lt;/c5&gt;は無限ループを引き起こすだろう。）その代わりとして我々はそれらを取っておき、さらに上のハンドラに再スローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Parens aren't considered an operator.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（括弧は演算子と考えられない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Rat64 will tend to be more accurate for numbers of normal or large magnitude, while Num64 may be more accurate for numbers of very small magnitude, since the Rat's size mismatch of numerator and denominator will eventually cost more accuracy than the Num's exponent overhead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Ratが分子のサイズ不適当な組合せである時から、Num64が非常に少ない大きさの番号のためにより正確である場合がある間、Rat64は通常であるかかなりの大きさの番号のためにより正確な傾向がある、そして、結局、分母はNumが頭上で主唱者であるより多くの正確さを犠牲にする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Really good programmers may occasionally do even better.) Mostly this just involves using enough bits that the stupidities of the algorithm don't matter much.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大部分はこれは、ちょうどアルゴリズムの愚かさがあまり重要でない十分なビットを使うことが必要である（本当に良いプログラマーは、よりよく時折しさえするかもしれない。）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Routines are considered mutable because they can be wrapped in place.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（それらが適所に包まれることができるので、ルーチンは変わりやすいと考えられる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See Definition of Success below for more.) &lt;c4&gt;temp&lt;/c4&gt; and &lt;c5&gt;let&lt;/c5&gt; temporize or hypotheticalize the value or the variable depending on whether you do assignment or binding.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T135926Z" creationid="Toshiyuki" creationdate="20130802T135926Z">
        <seg>（以下、詳細は成功の定義を参照）&lt;c4&gt;temp&lt;/c4&gt;と&lt;c5&gt;let&lt;/c5&gt;はあなたが割り当てるかバインドするかどうかに依存して値か変数を一時的にするか仮定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See S04 for how failures are handled.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（失敗が取り扱われる方法についてはS04を見なさい。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See below.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T123536Z" creationid="Toshiyuki" creationdate="20130813T123536Z">
        <seg>（以下を参照。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Such pseudo operators may also place restrictions on which meta-operators work on them.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（そのような疑似演算子はメタ演算子がそれらの上で動く規制も置くかもしれない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That is, in the abstract, they're all anonymous subroutines that take a snapshot of their lexical environment.) How a block is invoked and how its results are used are matters of context, but closures all work the same on the inside.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T120626Z" creationid="Toshiyuki" creationdate="20130729T120626Z">
        <seg>（それは抽象的には、それらは全てレキシカル環境のスナップショットを撮る無名サブルーチンだ。）ブロックがどのように呼び出され、結果がどのように使われるかはコンテキストの問題だが、クロージャは内部で全て同じに動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That is, it is a &lt;c12&gt;Mu&lt;/c12&gt; method, not a &lt;c13&gt;Failure&lt;/c13&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161841Z" creationid="Toshiyuki" creationdate="20130817T161841Z">
        <seg>（すなわち、それは&lt;c12&gt;Mu&lt;/c12&gt;メソッドで、&lt;c13&gt;Failure&lt;/c13&gt;メソッドではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That is, it's assumed to match at the beginning of any whitespace.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（つまり、それは何か空白文字の始めに合うとされる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c1&gt;repeat&lt;/c1&gt; keyword forces the conditional to be evaluated at the end of the loop, so it's still C's &lt;c2&gt;do-while&lt;/c2&gt; semantics.) Therefore, even under GNU style rules, the previous example may be rewritten into a very clear:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T054713Z" creationid="Toshiyuki" creationdate="20130810T053604Z">
        <seg>（&lt;c1&gt;repeat&lt;/c1&gt;キーワードは条件文をループの終わりで評価するようにさせるので、それはまだ C言語の&lt;c2&gt;do-while&lt;/c2&gt;セマンティクスだ。）したがって、GNUスタイルの規則でさえ、前の例はとてもわかりやすく書きなおされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c1&gt;while&lt;/c1&gt;'s declaration of &lt;c2&gt;$line&lt;/c2&gt; continues to be visible past the end of the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063315Z" creationid="Toshiyuki" creationdate="20130810T063300Z">
        <seg>（&lt;c1&gt;while&lt;/c1&gt;の&lt;c2&gt;$line&lt;/c2&gt;の宣言はブロックの終わりを過ぎても見え続ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c6&gt;Failure&lt;/c6&gt; may, however, be stored in any container whose type allows the &lt;c7&gt;Failure&lt;/c7&gt; role to be mixed in.) The &lt;c8&gt;.handled&lt;/c8&gt; method returns &lt;c9&gt;False&lt;/c9&gt; on failures that have not been handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161714Z" creationid="Toshiyuki" creationdate="20130817T161714Z">
        <seg>（&lt;c6&gt;Failure&lt;/c6&gt;はおそらく、どんな方法でも、&lt;c7&gt;Failure&lt;/c7&gt;ロールをミックスインされるために型が許可される何か一つのコンテナに格納される。）&lt;c8&gt;.handled&lt;/c8&gt;メソッドはハンドルされたことのない失敗で&lt;c9&gt;False&lt;/c9&gt;を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The cascade is basically counted as a single method call for the end-bracket rule.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（滝はエンドブラケット支配の一回のメソッド要請として基本的に計算に入れられる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The difference between Perl 5 and Perl 6 in this respect arises only because Perl 5 didn't have user-defined control structures, hence the sub's lexical scope was &lt;i0&gt;always&lt;/i0&gt; the innermost dynamic scope, so the preference to the lexical scope in the current sub was implicit.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T081757Z" creationid="Toshiyuki" creationdate="20130817T081757Z">
        <seg>（この関係のPerl 5とPerl 6の間の違いは唯一発生する。なぜならPerl 5はユーザー定義の制御構造を持たず、それゆえにsubのレキシカルスコープは&lt;i0&gt;常に&lt;/i0&gt;最も深いダイナミックスコープのようなので、現在のsubのレキシカルスコープの優先傾向は暗黙だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The fatarrow form is not allowed at all in operator position.) See S06 for the use of adverbs as named arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>挙げられた引数として副詞の用法については、S06を見なさい。（fatarrowの形は、交換台でまったく許されない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The latter approach should likely require explicit declaration for now, until we can demonstrate that it does not adversely impact the average programmer, and that it plays well with the concept of gradual typing.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（我々がそれが平均的プログラマに逆に衝撃を与えない、そして、それが段階的なタイピングの概念でうまくやることを証明することができるまで、後のアプローチは今のところ明示的宣言をたぶん必要としなければならない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The lexical codepoint declaration should probably specify which normalization form it prefers to view strings under.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（語彙的なコードポイント宣言は、それがどの正常化用紙の下で文字列を見るのを好むかについて、多分指定しなければならないだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The optimizer is also allowed to substitute such variants when it can determine that the final destination would store natively in any case, or that the variant could not possibly malfunction given the arguments.) [Conjecture: we could allow an 'N' metoperator to select the native variant on a case by case basis.]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（オプティマイザーはそれが最終仕向け地がいずれにせよ最適化されて保存する、または、変形が引数を与えられておそらく故障することができなかったと決定することができるそのような変形を代えるのも許される。）［推測する：我々は'N'メタ演算子にケースの基礎によってケースに関してネイティブ変形を選ばせておくことができた。］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The situation does not often arise for the slice modifiers above because they are usually used in list context, which operates at comma precedence.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（それらが通常リストコンテキストで使われるので、状況は上のスライス修飾子のためにしばしば起こらない。そして、それはコンマ優先順位で動く。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(There is a way to bind the underlying parcel using backslash, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（方法が、しかし、バックスラッシュを使っている根底にあるパーセルを結びつけるためにある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This extra identity component need not be output for debugging messages that assume the current address space, since it will be the same big number consistently, unless your process really is running under a NUMA.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（それが一貫して同じ大きい数である時から、この余分の単位元成分はあなたのプロセスがNUMAの下で本当に動作しない限り、現在のアドレス空間を引き受けるメッセージをデバッグするための出力である必要はない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This includes the names in all the packages within the global package.) If two different units use the same global name, they must generally be taken to refer to the same item, but only if the type signatures can be meshed (and augmentation rules followed, in the case of package names).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2つの異なる単位が同じグローバル名を使用するならば、しかし、型シグネチャがかみ合うことができる（そして、パッケージ名の場合、増加規則はあとに続いた）場合だけ、それらは同じアイテムに言及するために通常、とられなければならない（これは世界的なパッケージの範囲内で名前をすべてのパッケージに含む。）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This is almost never what you want, but if you want something polished, you can be more specific.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはほとんど、あなたが望むものでない、しかし、磨かれた何かを望むならば、あなたはよりはっきりしていることがありえる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unary uses of backslash may therefore never be followed by whitespace or they would be taken as an unspace.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（したがって、バックスラッシュを単一体の使う自由の後に空白文字が決して続かないかもしれない、または、それらはunspaceとしてとられる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unless, of course, there is an infix operator of that name beginning with dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（もちろん、それの中置演算子がない限り、ドットで始めを挙げなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unless, of course, you override the unspace rule itself...)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（もちろん、あなたがunspaceルール自体にオーバーライドしない限り、...）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unlike in Perl 5, where version numbers didn't autoquote.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Perl 5のとは異なり、そこでバージョン番号はautoquoteにそうしなかった。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Using the term "label" loosely, to include other solutions besides the label syntax, such as .gather and .take methods on some identity object.)]</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T195732Z" creationid="Toshiyuki" creationdate="20130810T195732Z">
        <seg>（「ラベル」という語句を緩く使う、ラベル文法に加えて他の解決策を付け加える、いくつかの識別オブジェクトでの.gatherと.takeメソッドのような 。）］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Usually this transformation happens at compile time.) If the first positional is followed by a colon instead of a comma, it is marked as the invocant in case it finds itself in a context that cares.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>位置最初の後にコンマの代わりにコロンが続くならば、気にかける前後関係にいるのに気づく場合に備えて、それはインボカントとして跡を残される（通常、この変化はコンパイル時で起こる。）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We promise not to break any existing top-level CPAN package, of course.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（我々は、もちろん、何か既存のトップレベルのCPANパッケージをあけないと約束する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We reserve the right to relax this if it turns out to be useful though.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（それがしかし役に立つことがわかるならば、我々はこれをリラックスさせる権利を保有する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Which defaults to graphemes.) Otherwise you'll need to coerce to the proper units:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さもなければあなたは、適当な単位に以下を強制する必要がある（そしてそれは書記素へのデフォルト。）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Yes, this may give fits to the P5-to-P6 translator, but I think it's worth it to separate the concepts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（はい、これはP6へのP5翻訳者に発作を与えるかもしれない、しかし、私は概念を切り離すことがそれの価値があると思う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You are still free to predeclare subroutines explicitly, of course.) The postdeclaration may be in any lexical or package scope that could have made the declaration visible to the provisional call had the declaration occurred before rather than after the provisional call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>postdeclarationは語彙的な何ででもあるかもしれない（もちろん、あなたはまだはっきりとpredeclareサブルーチンに自由である。）、または、暫定的な呼び出しの後よりはむしろ、宣言を暫定的な呼び出しに見えるようにすることができたパッケージスコープは宣言を起こっておいた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You can always establish a lexical scope explicitly by using the block form of argument.) As statement introducers, all these keywords must be followed by whitespace.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T081130Z" creationid="Toshiyuki" creationdate="20130811T081130Z">
        <seg>（ブロック形式の引数を使うことでいつでもレキシカルスコープを確立することができる。）文をもたらすものによって、これらすべてのキーワードは空白が続かなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You could write a macro that violates this, but resist the urge.) Variables that mediate between an outer statement and an inner block (such as loop variables) should generally be declared as formal parameters to that block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T123354Z" creationid="Toshiyuki" creationdate="20130729T123036Z">
        <seg>（あなたはこれを犯すマクロを書くことが可能だが、衝動を抑えてくれ。）外側の文と内側のブロック（ループ変数のような）の間を仲介する変数は一般的にはそのブロックの仮パラメータとして宣言されるべきだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You may be detecting a trend here...)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あなたは傾向をここで見つけているかもしれない...）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(see S12).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（S12を見る）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Int&lt;/a0&gt; literals consist of digits, and can contain underscores between any two digits.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T121811Z" creationid="yamato" creationdate="20140914T121811Z">
        <seg>&lt;a0&gt;Int&lt;/a0&gt;リテラルは数字で構成され、2つの数字の間にアンダースコアを含むことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Num&lt;/a0&gt; (floating point numbers) literals consist of &lt;a1&gt;Rat&lt;/a1&gt; or &lt;a2&gt;Int&lt;/a2&gt; literals followed by an &lt;c3&gt;e&lt;/c3&gt; and a (possibly negative) exponent.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T122602Z" creationid="yamato" creationdate="20140914T122602Z">
        <seg>&lt;a0&gt;Num&lt;/a0&gt;（浮動小数点）リテラルは&lt;a1&gt;Rat&lt;/a1&gt;または&lt;a2&gt;Int&lt;/a2&gt;リテラルの後に &lt;c3&gt;e&lt;/c3&gt;と（可能なら負の）指数が続く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Pair&lt;/a0&gt; objects can be created either with &lt;c1&gt;infix:ﾂｫ=&gt;ﾂｻ &lt;/c1&gt; (which auto-quotes the left-hand side if it is an identifier), or with the various colonpair forms.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T123214Z" creationid="yamato" creationdate="20140914T123214Z">
        <seg>&lt;a0&gt;Pair&lt;/a0&gt;オブジェクは&lt;c1&gt;infix:«=&gt;»&lt;/c1&gt; で（それは左側が識別子なら自動でクォートする）、または様々なコロンペア形式で作成できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Parcel&lt;/a0&gt; literals are: the empty pair of parens &lt;c1&gt;()&lt;/c1&gt;, a comma-separated list, or several quoting constructs</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124153Z" creationid="yamato" creationdate="20140914T124153Z">
        <seg>&lt;a0&gt;Parcel&lt;/a0&gt;リテラルは：空白の括弧のペア&lt;c1&gt;()&lt;/c1&gt;、コンマで区切られたリスト、またはいくつかのクオート構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Rat&lt;/a0&gt; (rational numbers) literals contain two integer parts joined by a dot.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T122058Z" creationid="yamato" creationdate="20140914T122058Z">
        <seg>&lt;a0&gt;Rat&lt;/a0&gt;（有理数）リテラルはドットで接続された2つの整数ペアを含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$!&lt;/c0&gt; is the error variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T113807Z" creationid="yamato" creationdate="20140914T113807Z">
        <seg>&lt;c0&gt;$!&lt;/c0&gt;はエラー変数だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$/&lt;/c0&gt; is the match variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T112652Z" creationid="yamato" creationdate="20140914T112652Z">
        <seg>&lt;c0&gt;$/&lt;/c0&gt;はマッチ変数だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$&lt;/c0&gt; always means a scalar variable, &lt;c1&gt;@&lt;/c1&gt; an array variable, and &lt;c2&gt;%&lt;/c2&gt; a hash variable, even when subscripting.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022212Z" creationid="Toshiyuki" creationdate="20140329T022212Z">
        <seg>&lt;c0&gt;$&lt;/c0&gt;は常にスカラー変数、&lt;c1&gt;@&lt;/c1&gt;は配列変数、&lt;c2&gt;%&lt;/c2&gt;はハッシュ変数を意味します（たとえ添字付けの場合でも）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$_&lt;/c0&gt; is the topic variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T110722Z" creationid="yamato" creationdate="20140914T110722Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;はトピック変数だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;$o.perl&lt;/c0&gt; returns a string that can be executed as Perl code, and reproduces the original object &lt;c1&gt;$o&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T105129Z" creationid="Toshiyuki" creationdate="20140112T140148Z">
        <seg>&lt;c0&gt;$o.perl&lt;/c0&gt;はPerlコードとして実行可能な文字列を返し、最初のオブジェクト&lt;c1&gt;$o&lt;/c1&gt;を再現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt; blocks set &lt;c1&gt;$_&lt;/c1&gt; to the exception that was caught.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T111657Z" creationid="yamato" creationdate="20140914T111657Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロックはキャッチされた例外を&lt;c1&gt;$_&lt;/c1&gt;にセットする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Int&lt;/c0&gt; automatically supports promotion to arbitrary precision, as well as holding &lt;c1&gt;Inf&lt;/c1&gt; and &lt;c2&gt;NaN&lt;/c2&gt; values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130411Z" creationid="Toshiyuki" creationdate="20140328T130411Z">
        <seg>&lt;c0&gt;Int&lt;/c0&gt;は&lt;c1&gt;Inf&lt;/c1&gt;値と&lt;c2&gt;NaN&lt;/c2&gt;値だけでなく、随意精度への昇格を自動的にサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Num&lt;/c0&gt; must support the largest native floating point format that runs at full speed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130641Z" creationid="Toshiyuki" creationdate="20140328T130641Z">
        <seg>&lt;c0&gt;Num&lt;/c0&gt;は最大速度で実行できるもっとも大きいネイティブの浮動小数点フォーマットをサポートしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Numeric&lt;/c0&gt; Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130101Z" creationid="Toshiyuki" creationdate="20140328T130101Z">
        <seg>&lt;c0&gt;Numeric&lt;/c0&gt;型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Rat&lt;/c0&gt; supports extended precision rational arithmetic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130731Z" creationid="Toshiyuki" creationdate="20140328T130731Z">
        <seg>&lt;c0&gt;Rat&lt;/c0&gt;は拡張精度有理数演算をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;[...]&lt;/c0&gt; creates an itemized array, and &lt;c1&gt;Array.new(...)&lt;/c1&gt; a non-itemized array.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T141522Z" creationid="yamato" creationdate="20140914T141522Z">
        <seg>&lt;c0&gt;[...]&lt;/c0&gt;はアイテム化された配列、そして&lt;c1&gt;Array.new(...)&lt;/c1&gt;はアイテム化されない配列を作る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;m/regex/&lt;/c0&gt; and &lt;c1&gt;/regex/&lt;/c1&gt; regex matches and &lt;c2&gt;s/regex/subst/&lt;/c2&gt; substitutions work on &lt;c3&gt;$_&lt;/c3&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T112632Z" creationid="yamato" creationdate="20140914T112632Z">
        <seg>&lt;c0&gt;m/regex/&lt;/c0&gt;と&lt;c1&gt;/regex/&lt;/c1&gt;の正規表現マッチと&lt;c2&gt;s/regex/subst/&lt;/c2&gt;の置換は&lt;c3&gt;$_&lt;/c3&gt;で機能する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;my Dog $spot&lt;/c0&gt; by itself does not automatically call a &lt;c1&gt;Dog&lt;/c1&gt; constructor.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133640Z" creationid="Toshiyuki" creationdate="20140327T133640Z">
        <seg>&lt;c0&gt;my Dog $spot&lt;/c0&gt;はそれ自体で&lt;c1&gt;Dog&lt;/c1&gt;のコンストラクタを呼びません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;$!&lt;/c1&gt; would then be sugar for &lt;c2&gt;@![0]&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T152257Z" creationid="Toshiyuki" creationdate="20130817T152257Z">
        <seg>&lt;c1&gt;$!&lt;/c1&gt;はその時&lt;c2&gt;@![0]&lt;/c2&gt;のシュガーだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c1&gt;@a[0]&lt;/c1&gt; returns one of them, and the assignment operator replaces the integer value stored in that container with the new one, &lt;c2&gt;42&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T135134Z" creationid="yamato" creationdate="20140914T135134Z">
        <seg>&lt;c1&gt;@a[0]&lt;/c1&gt;はそれらの1つを返し、そして割り当て演算子はそのコンテナに保存されている整数値を 新しい&lt;c2&gt;42&lt;/c2&gt;に置き換える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;$!&lt;/c2&gt; is a convenient link to the last failure, and only ever contains one exception, the most recent.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T151646Z" creationid="Toshiyuki" creationdate="20130817T151646Z">
        <seg>&lt;c2&gt;$!&lt;/c2&gt;は最後の失敗への便利なリンクで、一つだけの最も最近の例外を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c3&gt;$0&lt;/c3&gt;, &lt;c4&gt;$1&lt;/c4&gt;, &lt;c5&gt;$2&lt;/c5&gt;, etc., are aliases into the &lt;c6&gt;$/&lt;/c6&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090731Z" creationid="Toshiyuki" creationdate="20140329T090731Z">
        <seg>&lt;c3&gt;$0&lt;/c3&gt;、&lt;c4&gt;$1&lt;/c4&gt;、&lt;c5&gt;$2&lt;/c5&gt;などは&lt;c6&gt;$/&lt;/c6&gt;オブジェクトの別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;3e8&lt;/c4&gt; constructs a &lt;a5&gt;Num&lt;/a5&gt; with value &lt;c6&gt;3 * 10**8&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T122642Z" creationid="yamato" creationdate="20140914T122642Z">
        <seg>&lt;c4&gt;3e8&lt;/c4&gt;は&lt;c6&gt;3 * 10**8&lt;/c6&gt;という値の&lt;a5&gt;Num&lt;/a5&gt;を構成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c5&gt;Nil&lt;/c5&gt; also indicates a failed match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132843Z" creationid="Toshiyuki" creationdate="20140327T132843Z">
        <seg>&lt;c5&gt;Nil&lt;/c5&gt;は失敗したマッチも示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;CATCH&lt;/c0&gt; block handles only "bad" exceptions, and lets control exceptions pass unhindered.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125424Z" creationid="Toshiyuki" creationdate="20130816T125424Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロックは「悪い」例外だけ扱う。そして制御例外を妨げられないようにパスさせる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;CATCH&lt;/c0&gt; block is just a trait of the closure containing it, and is automatically called at the appropriate moment.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T075013Z" creationid="Toshiyuki" creationdate="20130818T075013Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロックはそれを含むクロージャのただのトレイトだ。そして適切な時に自動的に呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;CATCH&lt;/c0&gt; block sees the lexical scope in which it was defined, but its caller is the dynamic location that threw the exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115433Z" creationid="Toshiyuki" creationdate="20130814T115433Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロックはそれが定義されたレキシカルスコープをみる。しかしその呼び出し元は例外を投げたダイナミックロケーションだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;List&lt;/c0&gt; has the same attitude of indifference towards containers.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T134651Z" creationid="yamato" creationdate="20140914T134651Z">
        <seg>&lt;c0&gt;List&lt;/c0&gt;はコンテナに対して同じ無関心の態度をとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;Str&lt;/c0&gt; is a Unicode string object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T131121Z" creationid="Toshiyuki" creationdate="20140328T131121Z">
        <seg>&lt;c0&gt;Str&lt;/c0&gt;はユニコード文字列オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;gather&lt;/c0&gt; is not considered a loop, but it is easy to combine with a loop statement as in the examples above.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T040719Z" creationid="Toshiyuki" creationdate="20130811T040719Z">
        <seg>&lt;c0&gt;gather&lt;/c0&gt;はループと見なされないが、上述した例におけるループ文に結合するのは簡単だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;return&lt;/c0&gt; always exits from the lexically surrounding sub or method definition (that is, from a function officially declared with the &lt;c1&gt;sub&lt;/c1&gt;, &lt;c2&gt;method&lt;/c2&gt;, or &lt;c3&gt;submethod&lt;/c3&gt; keywords).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T044152Z" creationid="Toshiyuki" creationdate="20130817T044152Z">
        <seg>&lt;c0&gt;return&lt;/c0&gt;は常にレキシカルに囲っているsubまたはメソッドの定義から抜け出る（すなわち、&lt;c1&gt;sub&lt;/c1&gt;、&lt;c2&gt;method&lt;/c2&gt;、または&lt;c3&gt;submethod&lt;/c3&gt;キーワードで正式に定義されている機能から）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;return&lt;/c0&gt;, for example, is considered a form of abnormal control flow, since it can jump out of multiple levels of closures to the end of the scope of the current subroutine definition.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T124607Z" creationid="Toshiyuki" creationdate="20130816T124306Z">
        <seg>例えば&lt;c0&gt;return&lt;/c0&gt;はアブノーマルな制御フローの形式と見なされる。だからそれは多数のレベルのクロージャから現在のサブルーチンの定義のスコープの終端までジャンプできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c3&gt;once&lt;/c3&gt; runs separately for each clone, so separate clones can keep separate state variables:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030938Z" creationid="Toshiyuki" creationdate="20130822T030712Z">
        <seg>&lt;c3&gt;once&lt;/c3&gt;はそれぞれの複製で別々に実行するので、別々の複製は異なるstate変数を保持できる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c7&gt;when&lt;/c7&gt; statement implicitly does a "smart match" between the current topic (&lt;c8&gt;$_&lt;/c8&gt;) and the argument of the &lt;c9&gt;when&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T130150Z" creationid="Toshiyuki" creationdate="20130811T130150Z">
        <seg>&lt;c7&gt;when&lt;/c7&gt;文は現在のトピック（&lt;c8&gt;$_&lt;/c8&gt;）と&lt;c9&gt;when&lt;/c9&gt;の引数の間で暗黙に「スマートマッチ」を行う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;i0&gt;name&lt;/i0&gt; is anything that is a legal part of a variable name (not counting the sigil).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T093723Z" creationid="Toshiyuki" creationdate="20140329T093723Z">
        <seg>&lt;i0&gt;名前&lt;/i0&gt;は変数名（シギルは数えない）の有効な部分なら何でもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bare &lt;c0&gt;die&lt;/c0&gt;/&lt;c1&gt;fail&lt;/c1&gt; takes &lt;c2&gt;$!&lt;/c2&gt; as the default argument specifying the exception to be thrown or propagated outward to the caller's &lt;c3&gt;$!&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T165331Z" creationid="Toshiyuki" creationdate="20130817T165331Z">
        <seg>裸の&lt;c0&gt;die&lt;/c0&gt;/&lt;c1&gt;fail&lt;/c1&gt;はスローされるか外側に伝搬される呼び出し元の&lt;c3&gt;$!&lt;/c3&gt;を明示する&lt;c2&gt;$!&lt;/c2&gt;をデフォルトの引数としてとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bare closure (except the block associated with a conditional statement) without placeholder arguments that uses &lt;c0&gt;$_&lt;/c0&gt; (either explicitly or implicitly) is treated as though &lt;c1&gt;$_&lt;/c1&gt; were a formal parameter:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T125517Z" creationid="Toshiyuki" creationdate="20130729T125517Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;（明示的か暗黙的かどちらか）を使うプレースホルダー引数無しの裸のクロージャ（条件付きの文に関連付けられているブロックは除く）は&lt;c1&gt;$_&lt;/c1&gt;が仮パラメータかのように扱われる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bare closure also interpolates in double-quotish context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>裸のクロージャも、二重のquotish前後関係で改竄する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A buf type of known size defaults to a sequence of 0 values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既知のサイズのbuf型は、一連の0の値にデフォルトでなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A call may also be partially applied (primed) by using the &lt;c1&gt;.assuming&lt;/c1&gt; method:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T083749Z" creationid="Toshiyuki" creationdate="20140329T083749Z">
        <seg>呼び出しは&lt;c1&gt;.assuming&lt;/c1&gt;メソッドを用いて部分的に適用される（満たされる）こともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class is a module and thus can export stuff, but a class adds even more behavior to support Perl 6's standard class-based OO.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131700Z" creationid="Toshiyuki" creationdate="20140329T131700Z">
        <seg>クラスはモジュールなのでものをエクスポートすることができます。しかしPerl 6の標準のクラスベースのOOをサポートするためにより多くの動作をクラスは追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class is a module declared with the &lt;c0&gt;class&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131120Z" creationid="Toshiyuki" creationdate="20140329T131120Z">
        <seg>クラスは&lt;c0&gt;class&lt;/c0&gt;キーワードで宣言されるモジュールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class method may not be directly interpolated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスメソッドは、直接差し込まれないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure in a string establishes its own lexical scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列のクロージャは、それ自身のレキシカルスコープを確立する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A colon may never be used as the delimiter since it will always be taken to mean another adverb regardless of what's in front of it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それの前にあることに関係なくもう一つの副詞を意味することが常にされる時から、コロンがデリミタとして決して使われないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consequence of the above is that we can now say:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の結果は、我々が現在、以下のように言うことができるということである：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consequence of the preceding is that you cannot make a FatRat using colon notation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>先立つ結果は、あなたがFatRatをコロン表記法を使用しているようにすることができないということである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constructor is anything that returns an instance of the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T140821Z" creationid="Toshiyuki" creationdate="20140111T193158Z">
        <seg>コンストラクタは、クラスのインスタンスを返すものなら何でもそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A declaration nested within must not use the sigil if it wishes to refer to the same type, since the inner declaration would rebind the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>内部の宣言が型を再結合する時から、それが同一性に言及することを望むならば、入れ子にされる宣言はシギルを使ってはならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dot is never ambiguous because you have to tell it where the number ends:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが数がどこで終わるかについてそれに話さなければならないので、点は決してあいまいでない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A grapheme is what the novice user would think of as a character in their normal everyday life, including any diacritics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書記素は、彼らの通常の日常生活（何か発音区別符号を含む）で文字のように、初心者が考えるものである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A language that doesn't evolve, is a dead language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>進化しない言語は、死語である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A line ending with a closing brace "&lt;c0&gt;}&lt;/c0&gt;", followed by nothing but whitespace or comments, will terminate a statement if an end of statement can occur there.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T031036Z" creationid="Toshiyuki" creationdate="20130803T031036Z">
        <seg>閉じ括弧&lt;c0&gt;}&lt;/c0&gt;で終わり、次に何も続かない行末（空白文字とコメントは除く）は文の終了を発生させることができるなら文を終了する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A list of zero or more comma-separated objects may be grouped together by parentheses into a "parenthesis cell", or &lt;c0&gt;Parcel&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073616Z" creationid="Toshiyuki" creationdate="20140329T073616Z">
        <seg>0以上のコンマで区切られたオブジェクトは括弧によって“括弧セル”または&lt;c0&gt;Parcel&lt;/c0&gt;にグループ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A low-level explanation of Perl 6 containers</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T125640Z" creationid="yamato" creationdate="20140914T125640Z">
        <seg>Perl 6のローレベルの説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A multidimensional slice will be done with semicolons between individual slice sublists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多次元スライスは、個々のスライスサブリストの間でセミコロンでされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A non-scalar type may be qualified, in order to specify what type of value each of its elements stores:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その要素の各々がどんなタイプの値を保存するかについて指定するために、非スカラー型型は資格がある場合がある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parcel is immutable, which means you cannot change the number of elements in a parcel.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T134247Z" creationid="yamato" creationdate="20140914T134247Z">
        <seg>parcelは不変で、要素数を変えることができないことを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parcel may generally only be preserved as a part of an outer parcel or capture object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パーセルは、通常、外のパーセルの一部またはキャプチャーオブジェクトとして保たれるだけかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A popular example for this is:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T055640Z" creationid="yamato" creationdate="20140914T055640Z">
        <seg>ポピュラーな例はこうなる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A signature object (&lt;c0&gt;Signature&lt;/c0&gt;) may be created with colon-prefixed parens:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082134Z" creationid="Toshiyuki" creationdate="20140329T082134Z">
        <seg>シグネチャーオブジェクト（&lt;c0&gt;Signature&lt;/c0&gt;）はコロンを前につけた括弧で作成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single underscore is allowed only between any two digits in a literal number, where the definition of digit depends on the radix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一つのアンダーラインは文字通りの数で何の間でだけでも2桁許される、そこで、桁の定義は根次第である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch statement is a means of topicalizing, so the switch keyword is the English topicalizer, &lt;c0&gt;given&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125000Z" creationid="Toshiyuki" creationdate="20130811T125000Z">
        <seg>switch文はトピカライズの手段だ。そういうわけで、switchキーワードは英語のトピカライザー、&lt;c0&gt;given&lt;/c0&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A twigil forms part of the name of the variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182643Z" creationid="Toshiyuki" creationdate="20140111T182643Z">
        <seg>twigilは、変数の名前の一部をなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable may itself be bound to a container type that specifies how the container works, without specifying what kinds of things it contains.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132445Z" creationid="Toshiyuki" creationdate="20140327T132445Z">
        <seg>どんな種類のものを含むか指定することなく、どのように機能するか指定しているコンテナ型に変数がバインドされている場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable's type is a constraint indicating what sorts of values the variable may contain.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132054Z" creationid="Toshiyuki" creationdate="20140327T132054Z">
        <seg>変数の型は、どんな種類の値を含むかについて示している制約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variant of &lt;c0&gt;do&lt;/c0&gt; is &lt;c1&gt;gather&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152335Z" creationid="Toshiyuki" creationdate="20130810T152335Z">
        <seg>&lt;c0&gt;do&lt;/c0&gt;の変形は&lt;c1&gt;gather&lt;/c1&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A version literal is written with a 'v' followed by the version number in dotted form.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字通りの版は、ドットの形でバージョン番号が続く『v』で書かれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AUTHORS</seg>
      </tuv>
      <tuv lang="JA">
        <seg>著者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Absolute path of the perl executable that is currently running.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115725Z" creationid="yamato" creationdate="20140914T115725Z">
        <seg>現在実行しているperl実行ファイルの絶対パス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to S12, properties are actually implemented by a kind of mixin mechanism, and such mixins are accomplished by the generation of an individual anonymous class for the object (unless an identical anonymous class already exists and can safely be shared).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132615Z" creationid="Toshiyuki" creationdate="20140326T132615Z">
        <seg>S12によると、プロパティは実際のところ一種のミックスインメカニズムで実現されます。そのようなミックスインは個々のオブジェクト（同一の匿名クラスが既に存在し、安全に共有できるのでなければ）のための匿名クラスの生成によって達成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, line numbers are still counted if the unspace contains one or more newlines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その上、unspaceが一つ以上の改行文字を含むならば、線番号はまだ数えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the &lt;c0&gt;try&lt;/c0&gt; block or statement implicitly enforces a &lt;c1&gt;use fatal&lt;/c1&gt; context such that failures are immediately thrown as exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T123525Z" creationid="Toshiyuki" creationdate="20130813T123525Z">
        <seg>加えて、&lt;c0&gt;try&lt;/c0&gt;ブロックまたは文は暗黙的に失敗が例外として即時にスローされるように&lt;c1&gt;use fatal&lt;/c1&gt;コンテキストを強要する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you may insert extra whitespace using the unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その上、あなたは、unspaceを使っている余分の空白文字を付け加えるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adverbial Pair forms</seg>
      </tuv>
      <tuv lang="JA">
        <seg>副詞の一組の形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adverbial syntax will be described more fully later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>副詞の構文は、後でより完全に記述される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adverbs modify the meaning of various quoting forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>副詞は、いろいろな引合いに出している形の意味を修正する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adverbs on quotes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引用の副詞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After a call with parenthesized arguments, only the adverbial syntax may be used to pass additional arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧に入れられた引数による呼び出しの後、副詞の構文だけは、更なる引数を通過するのに用いられるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After a new numerator and denominator are determined, any sign is forced to be represented only by the numerator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい分子と分母が決定されたあと、何か符号は分子だけによって表現されることを強いられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all of the dependencies have completed, it's time to perform the current &lt;c0&gt;Task&lt;/c0&gt;'s task by invoking the &lt;c1&gt;&amp;!callback&lt;/c1&gt; attribute directly; this is the purpose of the parentheses.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T140645Z" creationid="Toshiyuki" creationdate="20140111T192539Z">
        <seg>全ての依存が完了した後は、現在の&lt;c0&gt;Task&lt;/c0&gt;の仕事を&lt;c1&gt;&amp;!callback&lt;/c1&gt;属性を直接起動して実行するときです；これは括弧の目的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After all, binding to a variable requires a lexpad entry for that variable, and while there is one for an array, there aren't lexpad entries for each array element (you cannot expand the lexpad at run time).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T140403Z" creationid="yamato" creationdate="20140914T140403Z">
        <seg>つまり、変数へのバインディングはその変数へのlexpadエントリーを必要とする。そしてその1つが配列のためにあり、それぞれの配列要素のためのlexpadエントリーは無い（lexpadを実行時に拡張することはできない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After creating a class, you can create instances of the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141612Z" creationid="Toshiyuki" creationdate="20140112T090546Z">
        <seg>クラスを作成した後に、あなたはクラスのインスタンスを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All IEEE modes must be lexically available via pragma except in cases where that would entail heroic efforts to bypass a braindead platform.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのIEEEモードは、それがbraindeadプラットホームを迂回する英雄的な努力を伴うケースを除いて、プラグマを通して辞書的に利用できなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All Unicode delimiters above Latin-1 are reserved for user-defined quotes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラテン語-1より上のすべてのユニコードデリミタは、ユーザー定義の引用のために予約されている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All abnormal control flow is, in the general case, handled by the exception mechanism (which is likely to be optimized away in specific cases.) Here "abnormal" means any transfer of control outward that is not just falling off the end of a block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T124319Z" creationid="Toshiyuki" creationdate="20130816T124219Z">
        <seg>全てのアブノーマルな制御フローは、一般の場合、例外メカニズムによって扱われる（それはたぶん特定のケースに最適化される）。ここで「アブノーマル」は何か一つの外側への制御の転送を意味する。そしてそれはブロックの終端から離れるだけではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All numbers representing digits must be less than the radix, or an error will result (at compile time if constant-folding can catch it, or at run time otherwise).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>桁を表現しているすべての数は根より少なくなければならない、または、エラーは起こる（定数畳込みが、あるいは、さもなければ実行時で、それを捕えることができるならばコンパイル時状態にある）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the adverbial forms (including the normal ones with identifier keys) are considered special tokens and are recognized in various positions in addition to term position.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>副詞形（識別子キーで通常のものを含む）の全ては、よく考えた特別なトークンで、項位置に加えていろいろな位置で公認である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All other radixes must either rely on the constant folding properties of ordinary multiplication and exponentiation, or supply the equivalent two numbers as part of the string, which will be interpreted as they would outside the string, that is, as decimal numbers by default:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の全ての根は普通の掛け算と累乗の定数畳込みプロパティに頼らなければならないか、デフォルトで十進数として、文字列（それらが文字列の外でそうして、それは解釈される）の一部として、つまり、等価2番号を供給しなければならない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All prefix sigil operators accept one positional argument, evaluated in item context as a rvalue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての接頭辞シギル演算子は1つの位置引数に応じる。そして、rvalueとしてアイテム前後関係で評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the uppercase adverbs are reserved for user-defined quotes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての大文字の副詞は、ユーザー定義の引用のために予約されている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All we know is that we have the promise to make the bits of it immutable as they become known.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々が知っているすべては、それらが明らかとなって、我々にはそれのビットを不変にするという約束があるということである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allomorphic Rats</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Allomorphicネズミ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allomorphic value semantics</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Allomorphic値意味論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also allowed in strings are leading plus or minus, and maybe a trailing Units type for an implied scaling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、入れられた文字列は、意味されたスケーリングのためにプラスまたはマイナスと多分後置単位型を導いているだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, individual subprocesses may not create new process variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、個々のサブプロセスは、新しいプロセス変数をつくらないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, it is allowed only on read/write dynamic variables, since the only reason to make a copy of the outer value would be because you'd want to override it later and then forget the changes at the end of the current dynamic scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、外の値のコピーを製作する唯一の理由があなたが後でそれにオーバーライドして、それから現在の動的スコープの終わりに変化を忘れたいだろうからである時から、それは読み出し／書き込み動的変数だけで許される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, if an object is being serialized to a form that does not preserve object identity, there is no requirement to preserve uniqueness, since in this case the object is really being translated to a value type representation, and reconstituted on the other end as a different unique object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは、オブジェクトがオブジェクト識別性を保たない形に順番に並べられているならば、本例でオブジェクトが本当に値タイプ代表に変形されていて、異なる独特のオブジェクトとして反対側で再構成されている時から、ユニークさを保存する必要性がない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, the compiler is allowed to recompile or re-examine the unit with the new type constraints to see if any issues are certain to arise at run time, in which case the compiler is free to complain.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは、コンパイラは何か問題が実行時で起こることは確かかどうか見るために新しい型制約で単位を再コンパイルするか、再検査するのを許可される、その場合には、コンパイラは不満を言うことができる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, the return type may be specified within the signature:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T230312Z" creationid="Toshiyuki" creationdate="20140328T230312Z">
        <seg>あるいは、戻り値の型はシグネチャで指定可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, the tables driving the current parser can be modified without derivation, but at least one level of anonymous derivation must intervene from the preceding Perl grammar, or you might be messing up someone else's grammar.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは、現在の構文解析器を駆動しているテーブルは起源なしで修正されることができる、しかし、少なくとも1レベルの匿名の起源は前のPerl文法から介入しなければならない、または、あなたは他の誰かの文法をだいなしにしているかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, the temporary grapheme ids may be hidden behind an abstraction layer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは、一時的な書記素IDは、抽象概念層の後に隠されるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternately, they may use some other less-official time mechanism to achieve steady clock behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは、それらは、落ち着いた時計ふるまいを成し遂げるために、若干の他のより公式でない時間メカニズムを使うかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although objects of type &lt;c0&gt;Scalar&lt;/c0&gt; are everywhere in Perl 6, you usually never see them directly as objects, because most operations &lt;e1&gt;decontainerize&lt;/e1&gt;, which means they act on the &lt;c2&gt;Scalar&lt;/c2&gt; container's contents instead of the container itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T131253Z" creationid="yamato" creationdate="20140914T131253Z">
        <seg>&lt;c0&gt;Scalar&lt;/c0&gt;型のオブジェクトはPerl 6の至る所にあるが、通常は直接それらをオブジェクトとして見ない。なぜならほとんどの演算が&lt;e1&gt;decontainerize&lt;/e1&gt;、&lt;c2&gt;Scalar&lt;/c2&gt;コンテナの内容がコンテナ自身の代わりに振る舞う、を行うからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although they may not be changed at runtime, the user is allowed to (re)define such constants.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T055928Z" creationid="yamato" creationdate="20140914T055928Z">
        <seg>それらは実行時に変更されないが、ユーザーがそのような定数を（再）定義することが許可される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although we say that the unspace hides the whitespace from the parser, it does not hide whitespace from the lexer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々がunspaceが空白文字を構文解析器から隠すと言うが、それは空白文字をlexerから隠さない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>常に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ampersand and invocation</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082723Z" creationid="Toshiyuki" creationdate="20140329T082723Z">
        <seg>アンパサンドと起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;Array&lt;/c0&gt; is just like a list, except that it forces all its elements to be containers.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T134925Z" creationid="yamato" creationdate="20140914T134925Z">
        <seg>&lt;c0&gt;Array&lt;/c0&gt;はリストのようだが、すべての要素にコンテナであることを強制する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;of&lt;/c0&gt; type on an array or hash specifies the type stored by each element:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T222144Z" creationid="Toshiyuki" creationdate="20140328T222144Z">
        <seg>配列またはハッシュでの&lt;c0&gt;of&lt;/c0&gt;型は個々の要素で保存される型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c1&gt;of&lt;/c1&gt; type is given as a prefix or with the &lt;c2&gt;of&lt;/c2&gt; keyword:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T213135Z" creationid="Toshiyuki" creationdate="20140328T213135Z">
        <seg>&lt;c1&gt;of&lt;/c1&gt;型は接頭辞または&lt;c2&gt;of&lt;/c2&gt;キーワードで与えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c2&gt;INIT&lt;/c2&gt; only runs once for all copies of a cloned closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030538Z" creationid="Toshiyuki" creationdate="20130822T030538Z">
        <seg>&lt;c2&gt;INIT&lt;/c2&gt;は全ての複製されたクロージャで1回だけ実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;i0&gt;identifier&lt;/i0&gt; is composed of an alphabetic character followed by any sequence of alphanumeric characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T092032Z" creationid="Toshiyuki" creationdate="20140329T092032Z">
        <seg>&lt;i0&gt;識別子&lt;/i0&gt;は英数字のシーケンスが続く英字で構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An argument is either of:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数は、以下のどちらでもある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An earlier section explained that declaring the class &lt;c0&gt;Task&lt;/c0&gt; installed a type object in the namespace.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141736Z" creationid="Toshiyuki" creationdate="20140112T090833Z">
        <seg>以前のセクションで、クラス&lt;c0&gt;Task&lt;/c0&gt;を宣言することが名前空間に型オブジェクトをインストールすると説明しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An exception handler is just a switch statement on an implicit topic that happens to be the current exception to be dealt with.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T130151Z" creationid="Toshiyuki" creationdate="20130813T130151Z">
        <seg>例外ハンドラは分配されて現在の例外になるために起こるトピックで暗黙に文をただスイッチする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An explicit placeholder may also be used:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T084207Z" creationid="Toshiyuki" creationdate="20130804T084207Z">
        <seg>明示的なプレースホルダーも使われる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier may also contain isolated apostrophes or hyphens provided the next character is alphabetic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T093347Z" creationid="Toshiyuki" creationdate="20140329T093347Z">
        <seg>識別子は次が英字になっている独立したアポストロフィーまたはハイフンも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier may be extended with multiple named identifier extensions, in which case the names matter but their order does not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子は複数の挙げられた識別子拡張で広げられるかもしれない、その場合には、名前は重要である、しかし、彼らの順序はそうしない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An implementation is free to silently ignore any other combinations or silently prefer one of the adverbs given above any other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装は、黙って他のどの組合せも無視するか、黙って、他のものより上に伝えられる副詞の1つを好むことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An indirect object that parses as more than one token must be placed in parentheses, followed by the colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のトークンとして解析する間接目的語は括弧に置かれなければならない。そして、コロンが続く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An undeclared bare identifier will always be taken to mean a subroutine name, and be parsed as a list operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言されていない裸の識別子は、常にサブルーチン名を意味するためにとられて、リスト演算子として解析される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unspace can suppress any of several whitespace dependencies in Perl.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unspaceは、Perlでいくつかの空白文字依存のどれでも抑制することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unspace may contain a comment, but a comment may not contain an unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unspaceはコメントを含むかもしれない、しかし、コメントはunspaceを含まないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124223Z" creationid="Toshiyuki" creationdate="20130811T124223Z">
        <seg>そして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And these are also equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、これらも等しい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Angle quotes (quote words)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>角度は、引用する（ワードを引合いに出す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another consequence of this is that any block just inside a left parenthesis is immediately called like a bare block, so a multidimensional list comprehension may be written using a block with multiple parameters fed by a &lt;c0&gt;for&lt;/c0&gt; modifier:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T125832Z" creationid="Toshiyuki" creationdate="20130810T125832Z">
        <seg>これのもう一つの結果は、左括弧内のどんなブロックも裸のブロックのように直ちに呼び出されるので、多次元リストの理解力は&lt;c0&gt;for&lt;/c0&gt;修飾子で与えられた複数パラメータ付きのブロックを使うことで書き直せる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another normal use of a you-don't-see-this-space is typically to put a dotted postfix on the next line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>you-don't-see-this-spaceのもう一つの通常使用は、一般的に、ドットの接尾辞を次行に置くことである：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any block object can be used, not just labels, so to return a value from this iteration of the current block you can say:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T102511Z" creationid="Toshiyuki" creationdate="20130806T102511Z">
        <seg>ラベルだけでなく任意のオブジェクトを使える。それゆえ、現在のブロックのこのイテレーションから値を返すためにあなたは次のように書くことができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any of the adverbial forms may be used as a function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>副詞形のどれでも、関数として使われるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any other use of the &lt;c5&gt;Failure&lt;/c5&gt; object to extract a normal value will throw its associated exception immediately.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T155735Z" creationid="Toshiyuki" creationdate="20130817T155735Z">
        <seg>通常の値を取り出すための何か他の&lt;c5&gt;Failure&lt;/c5&gt;オブジェクトの使用はそれに関連付けられた例外を即座にスローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any parcels in the returned list are normally flattened when bound into flat context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T204319Z" creationid="Toshiyuki" creationdate="20130810T204319Z">
        <seg>返されたリストのどんなパーセルでも、フラットコンテキストにバインドされた時に通常は平坦化される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any radix may include a fractional part.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何か根は、小数点部を含むかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any remaining special variables will be lexically scoped.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090525Z" creationid="Toshiyuki" creationdate="20140329T090525Z">
        <seg>残りの特殊変数はレキシカルスコープになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any resulting list arguments are then evaluated lazily.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それから、何か結果として生じるリスト引数は、ゆったりと評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any single decimal number may omit the brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何か一つの十進数は、ブラケットを省略するかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any such literal, when written without spaces, produces a pure numeric value without a stringy allomorphism.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スペースなしで書かれるとき、そのようなリテラルは繊維質の異形症なしで純粋な数値を生じる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name in rvalue context is parsed as a single type value and expects no arguments following it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>rvalue前後関係の任意型名は、シングル式値として解析されて、それの後、引数を予想しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type name used as a value is the undefined prototype object of that type, or &lt;i0&gt;type object&lt;/i0&gt; for short.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T134127Z" creationid="Toshiyuki" creationdate="20140327T134127Z">
        <seg>値として使われる型名は何でもその型の未定義のプロトタイプオブジェクト、略して&lt;i0&gt;型オブジェクト&lt;/i0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apart from &lt;c0&gt;CATCH&lt;/c0&gt; and &lt;c1&gt;CONTROL&lt;/c1&gt;, which can only occur once, most of these can occur multiple times within the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093455Z" creationid="Toshiyuki" creationdate="20130818T093455Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;と&lt;c1&gt;CONTROL&lt;/c1&gt;は別として、それは一回だけ起こる。それらの大部分はブロック内で複数回発生できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apostrophe separator</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000056Z" creationid="Toshiyuki" creationdate="20140329T000056Z">
        <seg>アポストロフィーセパレーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments bound to the formal parameters of a pointy block are by default readonly within the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112434Z" creationid="Toshiyuki" creationdate="20130810T112434Z">
        <seg>ポインティブロックの仮パラメータにバインドされた引数はブロック内ではデフォルトで読み取り専用だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments from the command line.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115104Z" creationid="yamato" creationdate="20140914T115104Z">
        <seg>コマンドラインの引数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T024550Z" creationid="yamato" creationdate="20140914T024550Z">
        <seg>配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array and Hash variables can be evaluated in item context by prefixing them with a single dollar sign:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列とハッシュ変数は、一つのドル記号でそれらを前に置くことによって、アイテム前後関係で評価されることができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array end index</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列端部インデックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a consequence, these all produce the same literal string:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、これらのすべては、同じリテラル文字列を生産する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a curious side note, Perl 6 supports binding to array elements:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T135922Z" creationid="yamato" creationdate="20140914T135922Z">
        <seg>珍しいサイドノートとして、Perl 6は配列要素へのバインディングをサポートする：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a postfix operator, a method call is one of those operators that is automatically primed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後置演算子として、メソッド呼び出しは、自動的に準備をされるそれらの演算子の1人である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result of these rules, you can write any arbitrary variable name as either of:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則の結果、あなたは以下のどちらとしてでも、何にでも任意の変数名を書くことができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, unspace is not allowed within a token.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、unspaceはトークンの中で許されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a side note, Perl 6 uses the C3 algorithm to linearize the multiple inheritance hierarchies, which is a significant improvement over Perl 5's approach to handling multiple inheritance.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T134000Z" creationid="Toshiyuki" creationdate="20140112T134000Z">
        <seg>傍注として、Perl 6は多重継承階層を線形化するためにC3アルゴリズムを使用します。そして、それは多重継承を取り扱うPerl 5のアプローチについての重要な改善です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a special case to support the use above, a backslash where a postfix is expected is considered a degenerate form of unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の使用をサポートする特例として、接尾辞が予想されるバックスラッシュは、unspaceに退歩した形を考えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a type it is abstract, and may not be instantiated as a defined object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型として、それは抽象的で、定義済みオブジェクトとして具体例をあげて示されないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in C, the parentheses are required if you supply the 3-part spec; however, the 3-part loop spec may be entirely omitted to write an infinite loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060500Z" creationid="Toshiyuki" creationdate="20130810T060138Z">
        <seg>C言語における3部構成の仕様を与えるなら括弧が要求される；けれども、3部構成の仕様は無限ループを書くためには完全に省略できるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Perl 5, "&lt;c0&gt;our $foo&lt;/c0&gt;" introduces a lexically scoped alias for a variable in the current package.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T131442Z" creationid="Toshiyuki" creationdate="20130802T131442Z">
        <seg>Perl 5における&lt;c0&gt;our $foo&lt;/c0&gt;は現在のパッケージに変数のためのレキシカルスコープな別名をもたらす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Perl 5, it is possible to &lt;c4&gt;goto&lt;/c4&gt; into a lexical scope, but only for lexical scopes that require no special initialization of parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T142000Z" creationid="Toshiyuki" creationdate="20130817T142000Z">
        <seg>Perl 5におけるレキシカルスコープへの&lt;c4&gt;goto&lt;/c4&gt;は可能だ。しかし特別なパラメータの初期化を必要としないレキシカルスコープのみだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Perl 5, many built-in functions simply return an undefined value when you ask for a value out of range, or the function fails somehow.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T151040Z" creationid="Toshiyuki" creationdate="20130817T151040Z">
        <seg>Perl 5にあるようなたくさんのビルトイン関数は、あなたが値が範囲外か問い合わせるか関数がなぜか失敗するときに単純に未定義値を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned before, a class can inherit from multiple classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T125536Z" creationid="Toshiyuki" creationdate="20140112T125536Z">
        <seg>前記したように、クラスは複数のクラスから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned earlier, the loop variable is named by passing a parameter to the closure:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T061134Z" creationid="Toshiyuki" creationdate="20130810T061134Z">
        <seg>前に簡単に述べたように、ループ変数はクロージャにパラメータを渡すことで名前が付けられる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with Perl 5 array interpolation, the elements are separated by a space.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlで5つが展開を配列して、要素はスペースで区切られる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with an ordinary &lt;c0&gt;while&lt;/c0&gt;, you may optionally bind the result of the conditional expression to a parameter of the block:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T054928Z" creationid="Toshiyuki" creationdate="20130810T054928Z">
        <seg>通常の&lt;c0&gt;while&lt;/c0&gt;のように、条件式の結果をブロックのパラメータに任意に結びつけるなら：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with any list operator, an immediate postfix operator is illegal unless it is a form of parentheses, whereas anything following whitespace will be interpreted as an argument list if possible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何かリスト演算子と同様に、それが括弧の形でない限り、即座の後置演算子は無効である、ところが、空白文字の後の何でもできれば引数の並びと解釈される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with buffers, various native types are automatically derived from native unsigned int types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バッファと同様に、いろいろなネイティブ型は、ネイティブ符号なしint型に自動的に由来する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with calls to &lt;c0&gt;return&lt;/c0&gt;, the warning control exception is an abstraction that the compiler is free to optimize away (along with the associated continuation) when the compiler or runtime can determine that the semantics would be preserved by merely printing out the error and going on.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T124211Z" creationid="Toshiyuki" creationdate="20130817T124211Z">
        <seg>&lt;c0&gt;return&lt;/c0&gt;の呼び出しのように、警告制御例外はコンパイラが自由に最適化して取り除く抽象化だ（関連付けられた継続と一緒に）コンパイラかランタイムが決定できるとき、そのセマンティクスは単にエラーと進行をプリントするために保存される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with conditionals, you may optionally bind the result of the conditional expression to a parameter of the block:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T144106Z" creationid="Toshiyuki" creationdate="20130809T144106Z">
        <seg>条件文のように、条件付きの式の結果をブロックのパラメータに任意にバインドするなら：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with modules, the public storage, interface, and name of the class is represented by a package and its name, which is usually (but not necessarily) a global name.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131404Z" creationid="Toshiyuki" creationdate="20140329T131404Z">
        <seg>モジュールと同様に、パブリックストレージ、インターフェース、クラス名はパッケージとその名前によって表され、それは通常（しかし必ずではなく）グローバル名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with ordinary loop controls, the label is searched for first lexically within the current subroutine, then dynamically outside of it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T131653Z" creationid="Toshiyuki" creationdate="20130817T131653Z">
        <seg>普通のループ制御のように、ラベルは最初に現在のサブルーチン内レキシカルに検索される。その時はそれの外側をダイナミックに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with other statement prefixes, these value-producing constructs may be placed in front of either a block or a statement:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T082956Z" creationid="Toshiyuki" creationdate="20130818T082956Z">
        <seg>他の文接頭辞の様に、それらの値を出す構造はブロックか文の前に配置することもできる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with rational literals, constant folding would produce the same complex number, but this form parses as a single term, ignoring surrounding precedence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>合理的なリテラルと同様に、定数畳込みは同じ複素数を生じる、しかし、この形はシングルとして項を解析する。そして、周囲の優先順位を無視する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the &lt;c7&gt;.leave&lt;/c7&gt; method, there is also a &lt;c8&gt;.succeed&lt;/c8&gt; method to break from a labelled block functioning as a switch:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120642Z" creationid="Toshiyuki" creationdate="20130813T120642Z">
        <seg>&lt;c7&gt;.leave&lt;/c7&gt;メソッドのように、switchとして機能するラベル付きブロックから抜けるための&lt;c8&gt;.succeed&lt;/c8&gt;メソッドもある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you can see, the extension of the name uses colon pair notation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ご覧の通り、名前の拡張は、コロン一組表記法を使用する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning and Binding to Array Variables</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T135156Z" creationid="yamato" creationdate="20140914T135156Z">
        <seg>配列変数への割り当てとバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning to a scalar variable and to an array variable both do basically the same thing: discard the old value(s), and enter some new value(s).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T135322Z" creationid="yamato" creationdate="20140914T135322Z">
        <seg>スカラー変数と配列変数への割り当ては基本的に同じことをする：古い値を捨て、新しい値を入れる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment to a hash produces an ordinary list context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュへの代入は、普通のリストコンテキストを生じる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigns &lt;c0&gt;42&lt;/c0&gt; to &lt;c1&gt;$num&lt;/c1&gt;, and both &lt;c2&gt;42&lt;/c2&gt; and &lt;c3&gt;"str"&lt;/c3&gt; to &lt;c4&gt;@array&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T025934Z" creationid="yamato" creationdate="20140914T025934Z">
        <seg>&lt;c0&gt;42&lt;/c0&gt;を&lt;c1&gt;$num&lt;/c1&gt;に、そして&lt;c2&gt;42&lt;/c2&gt;と&lt;c3&gt;"str"&lt;/c3&gt;の両方を&lt;c4&gt;@array&lt;/c4&gt;に割り当てる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At each point in the parse, the lexer knows which subset of the grammatical categories are possible at that point, and follows the longest-token rule across all the active alternatives, including those representing any grammatical categories that are ready to match.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>解析の各々の点で、lexerは、文法範疇のどのサブセットがそこであり得るかについてわかっていて、マッチに準備ができている何か文法範疇を表現しているそれらを含むすべての活発な選択肢全体で、最も長く形だけの規則に従う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At run time, &lt;c7&gt;succeed&lt;/c7&gt; uses a control exception to scan up the dynamic chain to find the call frame belonging to that same outer block, and when it has found that frame, it does a &lt;c8&gt;.leave&lt;/c8&gt; on it to unwind the call frames.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114158Z" creationid="Toshiyuki" creationdate="20130813T114158Z">
        <seg>実行時に、&lt;c7&gt;succeed&lt;/c7&gt;は同じ外側のブロックに属するコールフレームを探すためのダイナミックチェインをスキャンするために制御例外を使う。そしてそのフレームが見つかった時、コールフレームを巻き戻すために&lt;c8&gt;.leave&lt;/c8&gt;を行う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At run time, a variable appears as an entry in a &lt;e0&gt;lexical pad&lt;/e0&gt;, or &lt;e1&gt;lexpad&lt;/e1&gt; for short.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T130655Z" creationid="yamato" creationdate="20140914T130655Z">
        <seg>実行時、変数は&lt;e0&gt;lexical pad&lt;/e0&gt;または &lt;e1&gt;lexpad&lt;/e1&gt;のエントリーとして現れる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to say something like:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のような何かを言う試み：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attributes are variables that exists per instance of a class.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T051944Z" creationid="yamato" creationdate="20140914T051944Z">
        <seg>属性はクラスのインスタンスごとに存在する変数だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Autopriming of Unary and Binary Operators with Whatever</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同類をもつ単一体とバイナリの演算子のAutopriming</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backslash sequences</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バックスラッシュシーケンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backslashing</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Backslashing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backtracking control</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T021421Z" creationid="Toshiyuki" creationdate="20140222T021421Z">
        <seg>バックトラック制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bare identifiers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>裸の識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bare scalar variables always interpolate in double-quotish strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ぎりぎりのスカラー変数は、常に二重のquotish文字列で改竄する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic math operations are defined for instants and durations such that the sum of an instant and a duration is always an instant, while the difference of two instants is always a duration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2つの瞬間の違いが常に期間である間、瞬間と期間の合計が常に瞬間であるように、基本的な演算操作は瞬間と期間の間定義される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be also aware that one can not have placeholder variables with a single upper-case letter.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T063202Z" creationid="yamato" creationdate="20140914T063202Z">
        <seg>1文字の大文字のプレースホルダー変数を使うこともできない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;gather&lt;/c0&gt; evaluates its block or statement in sink context, this typically causes the &lt;c1&gt;take&lt;/c1&gt; function to be evaluated in sink context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T210403Z" creationid="Toshiyuki" creationdate="20130810T210403Z">
        <seg>&lt;c0&gt;gather&lt;/c0&gt;はそのブロックか文をsinkコンテキストで評価するので、これは典型的には&lt;c1&gt;take&lt;/c1&gt;関数がsinkコンテキストで評価されることを引き起こす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;when&lt;/c0&gt; statements are executed in order, the default must come last.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133337Z" creationid="Toshiyuki" creationdate="20130811T133337Z">
        <seg>なぜなら&lt;c0&gt;when&lt;/c0&gt;文は順番に実行されるので、defaultは最後に来なければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is possible to go to a label that is after the operation, and because Perl 6 does one-pass parsing, any &lt;c0&gt;goto&lt;/c0&gt; to a label that has not been yet declared (or is declared outside the outward lexical scope of the &lt;c1&gt;goto&lt;/c1&gt;) must enclose the label in quotes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T145112Z" creationid="Toshiyuki" creationdate="20130817T145112Z">
        <seg>なぜなら演算の後のラベルに行くことが可能で、Perl 6はワンパス解析を行うので、まだ定義されていない（または&lt;c1&gt;goto&lt;/c1&gt;の外側のレキシカルスコープの外に定義された）ラベルへのどれか一つの&lt;c0&gt;goto&lt;/c0&gt;はラベルをクオートで囲まなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of constant folding, you may often get away with leaving out the angles:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数畳込みのため、あなたは角度を無視してしばしば逃げのびるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of smart matching, ordinary &lt;c2&gt;when&lt;/c2&gt; statements are sufficiently powerful to pattern match the current exception against classes or patterns or numbers without any special syntax for exception handlers.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T134345Z" creationid="Toshiyuki" creationdate="20130813T134345Z">
        <seg>スマートマッチングにより、通常の&lt;c2&gt;when&lt;/c2&gt;文は現在のクラスまたはパターンまたは例外ハンドラのための何らかの特別な文法のない数字に対する例外にマッチするために十分にパワフルだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because subroutine declarations are expressions, not statements, this is now invalid:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T032106Z" creationid="Toshiyuki" creationdate="20130803T032106Z">
        <seg>サブルーチンの宣言は式であり文ではないので、これは今では無効だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because temporary values are biased in favor of correct semantics over compact storage, native numeric operators that might overflow must come in two variants, one which returns a guaranteed correct boxed value, and one of which returns a guaranteed fast native value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>テンポラリー値が集密書庫の上に正しい意味論に賛成して偏るので、あふれるかもしれないネイティブ算術演算子は2つの変形、保証された正しい箱入り値を返るものと保証された速いネイティブ値が返る一つで来なければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the actual variable can be hard to find when complex types are specified, there is a postfix form as well:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複素数型が指定されるとき実際の変数が見つけるのが難しくありえるので、接尾辞の形態が同様にある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the dispatcher will see the &lt;c0&gt;cook&lt;/c0&gt; method on &lt;c1&gt;Baker&lt;/c1&gt; before it moves up to the parent class the &lt;c2&gt;Baker&lt;/c2&gt;'s &lt;c3&gt;cook&lt;/c3&gt; method will be called.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144534Z" creationid="Toshiyuki" creationdate="20140112T125402Z">
        <seg>ディスパッチャーは親クラスの前に&lt;c1&gt;Baker&lt;/c1&gt;の&lt;c0&gt;cook&lt;/c0&gt;メソッドを見るので、&lt;c2&gt;Baker&lt;/c2&gt;の&lt;c3&gt;cook&lt;/c3&gt;メソッドが呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before you get too happy about this pragma, note that Perl 6 contains various parallel processing primitives that will tend to get blown up prematurely by thrown exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T172058Z" creationid="Toshiyuki" creationdate="20130817T172058Z">
        <seg>このプラグマでハッピーになる前に、Perl 6はスローされた例外によって早まって爆発しがちな様々な並行処理プリミティブを含むので注意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binding is different from assignment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バインディングは、割当てと異なる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binding to Array Elements</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T135757Z" creationid="yamato" creationdate="20140914T135757Z">
        <seg>配列の要素へのバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blob literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Blobリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both sides are in item context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>双方は、アイテム前後関係にある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both use the equal sign &lt;c2&gt;=&lt;/c2&gt; as operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T023520Z" creationid="yamato" creationdate="20140914T023520Z">
        <seg>両方とも等号&lt;c2&gt;=&lt;/c2&gt;を演算子として使用する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bracketing Characters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053433Z" creationid="Toshiyuki" creationdate="20140330T053433Z">
        <seg>ブラケット文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bracketing characters are defined as any Unicode characters with either bidirectional mirrorings or Ps/Pe/Pi/Pf properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧に入れている文字は、双方向性ミラーリングかPs/Pe/Pi/Pfプロパティによる何かユニコード文字と定義される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Brackets may be nested, following the same policy as ordinary quote brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>普通の引用が括弧に入れるのと同じ方針の後、ブラケットはネスト状である場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-In Data Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140325T141352Z" creationid="Toshiyuki" creationdate="20140325T141352Z">
        <seg>ビルトインデータ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-in Type Conventions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>組込み型規則</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Built-in object types start with an uppercase letter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビルトインオブジェクトタイプは、大文字から始める。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But &lt;c0&gt;state&lt;/c0&gt; automatically applies "once" semantics to any initializer, so this also works:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T031051Z" creationid="Toshiyuki" creationdate="20130822T031051Z">
        <seg>しかし&lt;c0&gt;state&lt;/c0&gt;はどんなイニシャライザにも自動的に「once」セマンティクスを適用するので、これも動作する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But as always, you must use them all:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152144Z" creationid="Toshiyuki" creationdate="20130810T152144Z">
        <seg>しかしいつも通り、それらを全て使う必要がある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But generally that means you should refactor instead.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115447Z" creationid="Toshiyuki" creationdate="20130813T115447Z">
        <seg>しかし一般には代わりにリファクターするべきだということを意味する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But if one of the elements happens to be a scalar container, you can still assign to it:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T134344Z" creationid="yamato" creationdate="20140914T134344Z">
        <seg>しかし要素の一つがスカラーコンテナなら、それへの割り当てはまだ可能だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But it allows modifying the length (for example with &lt;c1&gt;push&lt;/c1&gt;, &lt;c2&gt;pop&lt;/c2&gt;, &lt;c3&gt;shift&lt;/c3&gt; and &lt;c4&gt;unshift&lt;/c4&gt;), and it is also lazy.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T134818Z" creationid="yamato" creationdate="20140914T134818Z">
        <seg>しかしそれは長さの変更を許す（例えば&lt;c1&gt;push&lt;/c1&gt;、 &lt;c2&gt;pop&lt;/c2&gt;、&lt;c3&gt;shift&lt;/c3&gt;、&lt;c4&gt;unshift&lt;/c4&gt;）、そしてそれは怠惰でもある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But note that these don't do the same thing:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これらが同じことをしない点に注意する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But note that under the parenthesis-rewrite rule, a single value will still act like a single value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、括弧-書き換え規則の下で、一つの値がまだ一つの値のようなふりをする点に注意しなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But there are other applications too: a routine that serializes objects to a bunch of bytes needs to know the attributes of that object, which it can find out via introspection.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110443Z" creationid="Toshiyuki" creationdate="20140112T164306Z">
        <seg>しかし、他の適用もあります：多くのバイトにオブジェクトをシリアライズするルーチンはそのオブジェクトの属性を知っている必要があり、そしてそれはイントロスペクションを通して発見することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But these two are valid:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T032204Z" creationid="Toshiyuki" creationdate="20130803T032204Z">
        <seg>しかしこれら二つは有効だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But to do that, it may eventually have to peel back any number of layers of dynamic call frames internal to the subroutine's current call frame.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T003645Z" creationid="Toshiyuki" creationdate="20130728T003645Z">
        <seg>それを行うためには、結局は皮をむき、ダイナミックコールフレーム内部のたくさんのレイヤーからサブルーチンの現在のコールフレームへ戻らなければならないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But use of a &lt;c2&gt;default&lt;/c2&gt; block is good documentation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133703Z" creationid="Toshiyuki" creationdate="20130811T133703Z">
        <seg>しかし&lt;c2&gt;default&lt;/c2&gt;ブロックの使用はよいドキュメンテーションだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But you'll have to be sure to always put whitespace in front of it, or it would be interpreted as a postfix method call instead.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがそれの前に常に空白文字を置くことは確実でなければならない、または、それはその代わりに接尾辞メソッド呼び出しと解釈される。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default the innermost call frame matching the selection criteria will be exited.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T073639Z" creationid="Toshiyuki" creationdate="20130817T073639Z">
        <seg>デフォルトでは選択基準にマッチする最も深いコールフレームは抜けだされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default the second declaration will get a compiler warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T130008Z" creationid="Toshiyuki" creationdate="20130730T130008Z">
        <seg>デフォルトでは、二回目の宣言はコンパイラーの警告が出るだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, keys and values are separated by tab characters, and pairs are terminated by newlines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デフォルトで、キーと値はタブ文字で区切られる、そして、組は改行文字によって終了される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling a method on &lt;c0&gt;$_&lt;/c0&gt; can be shortened by leaving off the variable name:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T112515Z" creationid="yamato" creationdate="20140914T112515Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;でメソッドを呼ぶのは、変数名を除くことで短くすることができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CaptureCursors</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CaptureCursors</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certainly, it is difficult to give a unique name to every possible address space, let alone every possible address within every such a space.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>確かに、それはすべてのあり得るアドレス空間に固有の名に与えるのが難しくて、される単独であり得るアドレスそのようなすべてのスペース。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes from here to end-of-compilation unit can just assign or bind it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここから編集の終了単位への変化は、ちょうどそれを割り当てることができるか、結びつけることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes to run-time properties are done via mixin instead, so that the compiler can optimize based on declared traits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時プロパティへの変化はその代わりにミキシンを通してされる、そのため、コンパイラはに基づく宣言されたトレイトを最適化することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characters with no corresponding closing character do not qualify as opening brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応する終わりの文字のない文字は、左大括弧としての資格を得ない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T131047Z" creationid="Toshiyuki" creationdate="20140329T131047Z">
        <seg>クラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and Objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T174234Z" creationid="Toshiyuki" creationdate="20140111T174234Z">
        <seg>クラスとオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and modules may be viewed as differently tied packages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスとモジュールは、違って結合されたパッケージとして見られるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes get to decide which of their values are true and which are false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、彼らの値のうちどちらが真実か、そして、どちらが間違っているか決定するようになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code that is generated at run time can still fire off &lt;c0&gt;CHECK&lt;/c0&gt; and &lt;c1&gt;INIT&lt;/c1&gt; phasers, though of course those phasers can't do things that would require travel back in time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T092236Z" creationid="Toshiyuki" creationdate="20130818T092236Z">
        <seg>実行時に生成されるコードは&lt;c0&gt;CHECK&lt;/c0&gt;と&lt;c1&gt;INIT&lt;/c1&gt;　phasersをまだ発射できる。けれどももちろんそれらのphasersは時間内に行ったり来たりすることを要求することができない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coercions may also be specified on the return type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コアーションは、戻り型の上で指定されもするかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coercive type declarations</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053600Z" creationid="Toshiyuki" creationdate="20140330T053600Z">
        <seg>制約型宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Colon pairs (but not arrow pairs) are recognized within double angles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コロン組（しかし、矢組でなく）は、二重山形の中で認知される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining subscript adverbs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下に書いた副詞を結合すること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments always count as whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメントは、常に空白文字と見なされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Common roles include:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般のロールは以下を含む：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compile-time "constants"</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T022112Z" creationid="yamato" creationdate="20140914T022112Z">
        <seg>コンパイル時の「定数」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compile-time "constants" may be addressed via the &lt;c0&gt;?&lt;/c0&gt; twigil.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T054725Z" creationid="yamato" creationdate="20140914T054725Z">
        <seg>コンパイル時の「定数」は&lt;c0&gt;?&lt;/c0&gt;ツウィギルでアドレスされることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Complex literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複雑なリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Complex literals are similarly indicated by writing an addition or subtraction of two real numbers (again, without spaces around the operators) inside angles:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複雑なリテラルは、2実数の追加または引き算を書くことによって、同じように示される再び、スペースが演算子のあたりになくて、（）角度の中に：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional statement modifiers work as in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T103406Z" creationid="Toshiyuki" creationdate="20130804T103406Z">
        <seg>条件付き文の修飾子はPerl 5のように動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T042318Z" creationid="Toshiyuki" creationdate="20130803T042318Z">
        <seg>条件付きの文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conjecturally, we might also have other kinds of rules, such as tree rewrite rules:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>推測で、我々には他の種類の規則（例えば木書き換え規則）もあるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consent of the governed, and all that.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>支配するもの、その他の同意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the second method, &lt;c1&gt;add-dependency&lt;/c1&gt;, which adds a new task to this task's dependency list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185123Z" creationid="Toshiyuki" creationdate="20140111T185103Z">
        <seg>第2のメソッドを考慮してください、&lt;c1&gt;add-dependency&lt;/c1&gt;は新しい仕事をこの仕事の依存リストに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants (and enums) default to &lt;c1&gt;our&lt;/c1&gt; scoping so they can be accessed from outside the package.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T132343Z" creationid="Toshiyuki" creationdate="20130802T132127Z">
        <seg>定数（と列挙型）は&lt;c1&gt;our&lt;/c1&gt;スコープで初期化されるので、外側のパッケージからアクセスできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constraints and container types can be used together:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132506Z" creationid="Toshiyuki" creationdate="20140327T132506Z">
        <seg>制約とコンテナ型は一緒に使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructors</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T193050Z" creationid="Toshiyuki" creationdate="20140111T193050Z">
        <seg>コンストラクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructs marked with a &lt;c0&gt;*&lt;/c0&gt; have a run-time value, and if evaluated earlier than their surrounding expression, they simply save their result for use in the expression later when the rest of the expression is evaluated:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T082758Z" creationid="Toshiyuki" creationdate="20130818T082758Z">
        <seg>&lt;c0&gt;*&lt;/c0&gt;でマークされた構造は実行時の値を持つ。そしてそれらを囲う文より早く評価されたら、それらは文の残りが評価された時に後で文で使うために単純に結果を保存する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructs that count openers and closers assume that only the given opener is special.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オープナーとクローザーを数える構成概念は、所定のオープナーだけが特別であると仮定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constructs that seem like a good idea now, may turn out not to be such a good idea in the future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在良い考えのようである構成概念は、将来そのような良い考えでないことがわかるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consuming our class</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141603Z" creationid="Toshiyuki" creationdate="20140112T090531Z">
        <seg>自分のクラスを使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Container Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132156Z" creationid="Toshiyuki" creationdate="20140327T132156Z">
        <seg>コンテナ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Container types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224446Z" creationid="Toshiyuki" creationdate="20140328T224446Z">
        <seg>コンテナ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Containers enforce type safety on setting, whereas subroutines enforce type safety on return.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T223645Z" creationid="Toshiyuki" creationdate="20140328T223645Z">
        <seg>コンテナはセット時に型安全を強制するのに対し、サブルーチンはreturn時に型安全を強制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Containers of Native Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型のコンテナ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Context</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前後関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contrary to item assignment, it means that the type of the variable on the left always stays &lt;c2&gt;Array&lt;/c2&gt;, regardless of the type of the right-hand side.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T025543Z" creationid="yamato" creationdate="20140914T025543Z">
        <seg>アイテム割り当てとは逆に、右側の型に関係なく左の変数の型が常に&lt;c2&gt;Array&lt;/c2&gt;であり続けることを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control exceptions may be caught with a &lt;c1&gt;CONTROL&lt;/c1&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125447Z" creationid="Toshiyuki" creationdate="20130816T125447Z">
        <seg>制御例外は&lt;c1&gt;CONTROL&lt;/c1&gt;ブロックでキャッチできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conveniently, arrays and hashes interpolate with only whitespace separators by default, so the subsequent split on whitespace still works out.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>都合の良いことに、配列とハッシュはデフォルトで空白文字セパレーターだけで改竄するので、空白文字の以降の分裂はまだ外へ動く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, &lt;c2&gt;$x.substr&lt;/c2&gt; implies conversion to a string or buffer type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T233548Z" creationid="Toshiyuki" creationdate="20140328T233548Z">
        <seg>反対に、&lt;c2&gt;$x.substr&lt;/c2&gt;は文字列かバッファー型への変換を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversion functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>転換関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Counting of nested brackets applies only to pairs of brackets of the same length as the opening brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子になったブラケットのカウントは、左大括弧と同じ長さのブラケットの組だけにあてはまる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Crazy readers will wonder whether this means you could set an initial value for other lexicals in the compiling scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>狂った読者は、あなたがそうすることができたこの手段がスコープを編集する際に初期値を他のlexicalsに設定したかどうか疑問に思う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates an object of type &lt;c0&gt;Whatever&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124219Z" creationid="yamato" creationdate="20140914T124219Z">
        <seg>&lt;c0&gt;Whatever&lt;/c0&gt;型のオブジェクトを作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DYNAMIC</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DYNAMIC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarators generally make the colon optional:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082408Z" creationid="Toshiyuki" creationdate="20140329T082408Z">
        <seg>宣言文は一般にコロンを任意にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring a class creates a &lt;e0&gt;type object&lt;/e0&gt; which, by default, is installed into the current package (just like a variable declared with &lt;c1&gt;our&lt;/c1&gt; scope).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T181132Z" creationid="Toshiyuki" creationdate="20140111T181132Z">
        <seg>クラスの宣言は&lt;e0&gt;型オブジェクト&lt;/e0&gt;を作ります。それはデフォルトでは現在のパッケージに設置されます（ちょうど&lt;c1&gt;our&lt;/c1&gt;スコープで変数を宣言するように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring a custom constructor provides a simple way of declaring tasks along with their dependencies.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141645Z" creationid="Toshiyuki" creationdate="20140112T090658Z">
        <seg>カスタムコンストラクタを宣言することは、それらの従属物とともにタスクを宣言するシンプルな方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default encoding of Str.encode/Buf.decode/various IO methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115008Z" creationid="yamato" creationdate="20140914T115008Z">
        <seg>Str.encode/Buf.decode/様々なIOメソッドのデフォルトエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a container type is the Perl 6 equivalent to tying a variable in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224736Z" creationid="Toshiyuki" creationdate="20140328T224736Z">
        <seg>コンテナ型を定義することはPerl 5のタイ変数のPerl 6の同等物です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deleting or undefining such a container sets the contents back to the default value (or optionally removes it in cases where the default value can be autovivified on demand).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなコンテナを削除するか、undefiningすることは、デフォルト値（または、任意に、デフォルト値が要求に応じてautovivifiedされることができる場合、それを取り除く）まで、内容を戻す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delimiters of quoting forms</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書式を引用するデリミタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deprecations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非難</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dereferences</seg>
      </tuv>
      <tuv lang="JA">
        <seg>間接参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Despite not indicating a true subscript, the brackets are similarly parsed as postfix operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正確な添え字を示さないことにもかかわらず、ブラケットは後置演算子として同じように解析される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Despite the appearance as a subscripting form, these names are resolved not at run time but at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字付けの形としての出演にもかかわらず、これらの名前は、実行時でなくコンパイル時で分解される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different sigils imply different minimal abilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>異なるシギルは、異なる最小の能力を意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Direct lookup</seg>
      </tuv>
      <tuv lang="JA">
        <seg>直接ルックアップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disallowed forms</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認められなかった形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Double-underscore forms</seg>
      </tuv>
      <tuv lang="JA">
        <seg>倍のアンダーラインの形態</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the MI semantics, the new object is equally a string and a number, and can be bound as-is to either a string or a numeric parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MI意味論のために、新しいオブジェクトは等しく文字列と数で、現状のままで文字列か数値パラメーターの束縛を受けることがありえる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During execution, this will cause the caller sites to be recorded without any warnings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行の間、これは発信者サイトが何か警告なしで記録される原因になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic lookup</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ダイナミックな検索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic variable creation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動的変数創造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic variables</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T022123Z" creationid="yamato" creationdate="20140914T022123Z">
        <seg>動的変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic variables are looked up through the caller, not through the outer scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T042602Z" creationid="yamato" creationdate="20140914T042602Z">
        <seg>動的変数は外側のスコープではなく呼び出し元を通してルックアップされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each iteration's value is returned as a single "argument" object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T131157Z" creationid="Toshiyuki" creationdate="20130808T131157Z">
        <seg>それぞれの反復の値は一つの「引数」オブジェクトとして返される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of these allows an optional underscore after the radix prefix but before the first digit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの各々は、最初の桁の前に根接頭辞の後オプションのアンダーラインを以外許す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each subsequent clone gets an initial state that is one higher than the previous, and each clone maintains its own state of &lt;c0&gt;$x&lt;/c0&gt;, because that's what &lt;c1&gt;state&lt;/c1&gt; variables do.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T031421Z" creationid="Toshiyuki" creationdate="20130822T031421Z">
        <seg>それぞれの後に続く複製は前よりも1高い初期stateを得る。そしてそれぞれのクローンは独自の&lt;c0&gt;$x&lt;/c0&gt;のstateを&lt;c1&gt;state&lt;/c1&gt;変数がするように扱う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each such slice sub-parcel is evaluated lazily.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各スライス下位パーセルは、ゆったりと評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either fatarrow or adverbial pair notation may be used to pass named arguments as terms to a function or method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fatarrowか副詞の一組表記法は、関数またはメソッドへの項として名をつけられた引数を通過するのに用いられるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either way, each Positional or Associative element represents the entire contents of the corresponding Pod block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれの方法でも、各々の位置であるか結合要素は、対応するポッドブロックの全コンテンツを表現する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Embedded Comments</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053453Z" creationid="Toshiyuki" creationdate="20140330T053453Z">
        <seg>埋め込みコメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even in the absence of closure cloning, &lt;c0&gt;INIT&lt;/c0&gt; runs before the mainline code, while &lt;c1&gt;once&lt;/c1&gt; puts off the initialization till the last possible moment, then runs exactly once, and caches its value for all subsequent calls (assuming it wasn't called in sink context, in which case the &lt;c2&gt;once&lt;/c2&gt; is evaluated once only for its side effects).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130825T072119Z" creationid="Toshiyuki" creationdate="20130825T072119Z">
        <seg>クロージャの複製なしでも、&lt;c0&gt;INIT&lt;/c0&gt;はメインラインコードの前に実行する。&lt;c1&gt;once&lt;/c1&gt;が最後の可能な時まで延期する間、一度実行し、後の呼び出しのために値をキャッシュする（sinkコンテキストで呼ばれないと仮定し、&lt;c2&gt;once&lt;/c2&gt;が副作用のために1回だけ評価される場合）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every Pod block in the current file can be accessed via a Pod object, such as &lt;c1&gt;$=data&lt;/c1&gt;, &lt;c2&gt;$=SYNOPSIS&lt;/c2&gt; or &lt;c3&gt;=UserBlock&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T064155Z" creationid="yamato" creationdate="20140914T064155Z">
        <seg>現在のファイルの全てのPodブロックは&lt;c1&gt;$=data&lt;/c1&gt;、&lt;c2&gt;$=SYNOPSIS&lt;/c2&gt;、または&lt;c3&gt;=UserBlock&lt;/c3&gt;のようなPodオブジェクトでアクセスできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every block is a closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T115438Z" creationid="Toshiyuki" creationdate="20130729T115438Z">
        <seg>全てのブロックはクロージャだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every object can produce a "WHICH" value that uniquely identifies the object for hashing and other value-based comparisons.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T122046Z" creationid="Toshiyuki" creationdate="20140328T122046Z">
        <seg>全てのオブジェクトはハッシュと他の値ベースの比較のためにオブジェクトをユニークに識別する“WHICH”値を生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T121726Z" creationid="Toshiyuki" creationdate="20131027T121726Z">
        <seg>例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except as noted above, the parser always looks for the brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記したように以外は、構文解析器は常にブラケットを探す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except for '0' itself, numbers ignore leading zeros.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>『0』自体を除いて、数は頭のゼロを無視する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except for such formal parameter declarations, all lexically scoped declarations are visible from the point of declaration to the end of the enclosing block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T130432Z" creationid="Toshiyuki" creationdate="20130729T130432Z">
        <seg>このような仮パラメータ宣言を除いて、すべてのレキシカルスコープの宣言は宣言の時点から取り囲むブロックの終了ま可視だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except within a quote literal, a &lt;c0&gt;#&lt;/c0&gt; character always introduces a comment in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140830T105607Z" creationid="Toshiyuki" creationdate="20140830T105607Z">
        <seg>クォートリテラルを除き、Perl 6において&lt;c0&gt;#&lt;/c0&gt;文字は常にコメントの開始になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception handlers</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121138Z" creationid="Toshiyuki" creationdate="20130813T121138Z">
        <seg>例外ハンドラ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception handlers are supposed to reduce uncertainty, not increase it.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T091632Z" creationid="Toshiyuki" creationdate="20130818T091632Z">
        <seg>例外ハンドラは不確実に減らすと思われる。増加ではない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exceptions are not resumable in Perl 6 unless the exception object does the &lt;c1&gt;Resumable&lt;/c1&gt; role.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T114557Z" creationid="Toshiyuki" creationdate="20130817T114557Z">
        <seg>例外オブジェクトが&lt;c1&gt;Resumable&lt;/c1&gt;ロールを行わない限り例外はPerl 6で再開可能ではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit Parcel construction</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的パーセル構築</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit binding to an individual variable is considered a form of signature binding, which is to say a declarator puts implicit signature parens around the unparenthesized form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>個別変数へのバインディングがそうである完はシグネチャバインディングの形を考えた。そして、それは宣言がunparenthesizedされた形のまわりに潜在的なシグネチャ括弧を置くと言うことになっている：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit types are optional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T165359Z" creationid="Toshiyuki" creationdate="20140328T165359Z">
        <seg>型の明示は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exponentials</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指数関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions inside the signature are parsed as parameter declarations rather than ordinary expressions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082234Z" creationid="Toshiyuki" creationdate="20140329T082234Z">
        <seg>シグネチャーの中の式は普通の式よりもパラメータ宣言としてパースされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended identifiers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>External access to opaque objects is always through method calls, even for attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性のためにさえ、不透明オブジェクトへの外部のアクセスは、常にメソッド呼び出しを通してある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Favor $*EXECUTABLE because it is not guaranteed that the perl</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115953Z" creationid="yamato" creationdate="20140914T115953Z">
        <seg>$*EXECUTABLEを支持せよ。なぜならperl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Filehandles are a notable exception.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ファイルハンドルは、顕著な例外である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Files</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally &lt;c0&gt;$o.^methods(:local)&lt;/c0&gt; produces a list of methods that can be called on &lt;c1&gt;$o&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T151752Z" creationid="Toshiyuki" creationdate="20140112T153139Z">
        <seg>最後に&lt;c0&gt;$o.^methods(:local)&lt;/c0&gt;は&lt;c1&gt;$o&lt;/c1&gt;で呼び出すことができるメソッドのリストを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the &lt;c0&gt;perform&lt;/c0&gt; method call recursively calls the &lt;c1&gt;perform&lt;/c1&gt; method on the various other dependencies in order, giving the output:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T092751Z" creationid="Toshiyuki" creationdate="20140112T092751Z">
        <seg>最後に&lt;c0&gt;perform&lt;/c0&gt;メソッドは&lt;c1&gt;perform&lt;/c1&gt;メソッドを様々な従属オーダーに対して呼び出し、出力を得ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the method sets the &lt;c2&gt;$!done&lt;/c2&gt; attribute to &lt;c3&gt;True&lt;/c3&gt;, so that subsequent invocations of &lt;c4&gt;perform&lt;/c4&gt; on this object (if this &lt;c5&gt;Task&lt;/c5&gt; is a dependency of another &lt;c6&gt;Task&lt;/c6&gt;, for example) will not repeat the task.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T050133Z" creationid="Toshiyuki" creationdate="20140111T192928Z">
        <seg>最後にメソッドは&lt;c2&gt;$!done&lt;/c2&gt;属性に&lt;c3&gt;True&lt;/c3&gt;をセットします。そのためこのオブジェクトの以降の&lt;c4&gt;perform&lt;/c4&gt;の実行（例えばもしこの&lt;c5&gt;Task&lt;/c5&gt;が他の&lt;c6&gt;Task&lt;/c6&gt;の依存だったら)は仕事を繰り返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, declaring this routine as a method adds it to the list of methods for the current class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185257Z" creationid="Toshiyuki" creationdate="20140111T185257Z">
        <seg>1番目に、このルーチンをメソッドと宣言することは、現在のクラスのためにそれをメソッドのリストに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it checks if the task has already completed by checking the &lt;c0&gt;$!done&lt;/c0&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T190640Z" creationid="Toshiyuki" creationdate="20140111T190640Z">
        <seg>最初に、それは仕事がすでに終わっているか&lt;c0&gt;$!done&lt;/c0&gt;属性を調べて確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flattening, Items and Containers</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T140735Z" creationid="yamato" creationdate="20140914T140735Z">
        <seg>フラット化、アイテムとコンテナ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For &lt;c0&gt;Scalar&lt;/c0&gt; it means "replace the previously stored value with the new one".</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T131835Z" creationid="yamato" creationdate="20140914T131835Z">
        <seg>&lt;c0&gt;Scalar&lt;/c0&gt;にとってはそれは「前に保存された値を新しいものと入れ替える」ということを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Perl 6 we have to make this preference for lexotic behavior explicit.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T081915Z" creationid="Toshiyuki" creationdate="20130817T081915Z">
        <seg>Perl 6ではこの優先傾向を明示的なレギゾチックな振る舞いのために作る必要がある。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a container, however, use of a coercion type as the &lt;c0&gt;of&lt;/c0&gt; coerces upon setting rather than returning the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224441Z" creationid="Toshiyuki" creationdate="20140328T224441Z">
        <seg>コンテナについては、&lt;c0&gt;of&lt;/c0&gt;としての型の強制の使用は値を返すよりもセットする方に強制されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a list of those special variables see &lt;a0&gt;Compile-time "constants"&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T060253Z" creationid="yamato" creationdate="20140914T060253Z">
        <seg>これらの特殊変数については&lt;a0&gt;Compile-time "constants"&lt;/a0&gt;を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all builtin operations, all &lt;c0&gt;Str&lt;/c0&gt; positions are reported as position objects, not integers.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T133559Z" creationid="Toshiyuki" creationdate="20140328T133559Z">
        <seg>全ての組み込み演算のために、全ての&lt;c0&gt;Str&lt;/c0&gt;の位置は整数ではなく位置オブジェクトとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For all quoting constructs that use user-selected brackets, you can open with multiple identical bracket characters, which must be closed by the same number of closing brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザーを選ばれたブラケットを使う構成物を引合いに出しているすべてのために、あなたは複数の同一のブラケット文字で始めることができる。そして、それは同じ数の右大括弧によって閉じられなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For any given Ps character, the next Pe codepoint (in numerical order) is assumed to be its matching character even if that is not what you might guess using left-right symmetry.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ピコセカンド文字を与えられる何のためにでも、たとえそれがあなたが左の右対称性を使って推測するかもしれないものでないとしても、次のペーコードポイント（番号順で）はそのマッチする文字であるとされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For any item in the list that appears to be numeric, the literal is stored as an object with both a string and a numeric nature, where the string nature always returns the original string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数であるように見えるリストの何かアイテムのために、リテラルは文字列と数の自然によるオブジェクトとして保存される、そこで、文字列自然は常に元の文字列を返る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For any statement, prefixing with a &lt;c0&gt;do&lt;/c0&gt; allows you to return the value of that statement and use it in an expression:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T121351Z" creationid="Toshiyuki" creationdate="20130810T121351Z">
        <seg>どんな文でも、&lt;c0&gt;do&lt;/c0&gt;を前につけるとその値を返し、式として使えるようになる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example &lt;a0&gt;Array&lt;/a0&gt; variables (&lt;c1&gt;@&lt;/c1&gt; sigil) empty themselves on list assignment, and then put all the values from the right-hand side into themselves.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T024937Z" creationid="yamato" creationdate="20140914T024857Z">
        <seg>例えば&lt;a0&gt;Array&lt;/a0&gt;変数（&lt;c1&gt;@&lt;/c1&gt;シギル）はリスト割り当て時に自身を空にし、右側のすべての値を自身に配置する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, since Perl requires an absence of whitespace between a noun and a postfix operator, using unspace lets you line up postfix operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、Perlが名詞と後置演算子の間で空白文字の欠如を必要とする時から、unspaceを使うことはあなたに後置演算子を一列に並べさせる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, types such as &lt;c2&gt;Int&lt;/c2&gt; and &lt;c3&gt;Str&lt;/c3&gt; refer to the type object of one of the Perl 6 built- in classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045033Z" creationid="Toshiyuki" creationdate="20140111T181352Z">
        <seg>例えば&lt;c2&gt;Int&lt;/c2&gt;と&lt;c3&gt;Str&lt;/c3&gt;のような型はPerl 6の組み込みクラスの一つの型オブジェクトを参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T071641Z" creationid="Toshiyuki" creationdate="20140309T071641Z">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For explicit returns, &lt;c0&gt;return-rw&lt;/c0&gt; instead of &lt;c1&gt;return&lt;/c1&gt; must be used.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T132607Z" creationid="yamato" creationdate="20140914T132607Z">
        <seg>明示的リターンのため、&lt;c1&gt;return&lt;/c1&gt;の代わりに&lt;c0&gt;return-rw&lt;/c0&gt;が使われなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For finer-grained control of which iterations return values, use &lt;c0&gt;gather&lt;/c0&gt; and &lt;c1&gt;take&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T141605Z" creationid="Toshiyuki" creationdate="20130809T141605Z">
        <seg>値を返す反復のきめ細かな制御のために、&lt;c0&gt;gather&lt;/c0&gt;と&lt;c1&gt;take&lt;/c1&gt;を使え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For graphemes that have no precomposed form, a temporary private id should be assigned that uniquely identifies the grapheme.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>precomposedされた形がない書記素のために、書記素をユニークに識別する一時的な個人的なIDは、割り当てられなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, &lt;c0&gt;$x.abs&lt;/c0&gt; implies conversion to an appropriate numeric type if &lt;c1&gt;$x&lt;/c1&gt; is "cool" but doesn't already support a method of that name.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T233441Z" creationid="Toshiyuki" creationdate="20140328T233441Z">
        <seg>例えば、もし&lt;c1&gt;$x&lt;/c1&gt;が“cool”だが既にその名前のメソッドをサポートしない場合、&lt;c0&gt;$x.abs&lt;/c0&gt;は適切な数値型への変換を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, &lt;c0&gt;next&lt;/c0&gt; with a label will prefer to exit a loop lexotically, but if there is no loop with an appropriate label in the lexical context, it will then scan upward dynamically through the call frames for any loop with the appropriate label, even though that loop will not be lexically visible.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T053246Z" creationid="Toshiyuki" creationdate="20130728T053246Z">
        <seg>例えばラベルと一緒の&lt;c0&gt;next&lt;/c0&gt;はレギゾチックにループを抜ける方を好む。しかしループのないレキシカルコンテキストでラベルが割り当てられているなら、それはコールフレームを通ってラベルの割り当てられたどんなループでも動的に上方へスキャンするだろう。しかしながらループはレキシカルな可視ではないだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a &lt;c0&gt;return&lt;/c0&gt; statement always returns from the lexically scoped subroutine that surrounds it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T001641Z" creationid="Toshiyuki" creationdate="20130727T170533Z">
        <seg>例えば&lt;c0&gt;return&lt;/c0&gt;文は常にそれを囲むレキシカルスコープなサブルーチンから戻ってくる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a &lt;c2&gt;CHECK&lt;/c2&gt; block is called at the end of compiling a compilation unit.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T080355Z" creationid="Toshiyuki" creationdate="20130818T080355Z">
        <seg>例えば、&lt;c2&gt;CHECK&lt;/c2&gt;ブロックはコンパイル単位をコンパイルする終端で呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you ask for the positions of matches done by a substitution, the answers are reported in terms of the original string (which may now be inaccessible!), not as positions within the modified string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、あなたが代用によってされるマッチの位置を求めるならば、改訂文字列の範囲内の位置ではなく、答えは元の文字列（そしてそれは、現在近づきがたい場合がある！）に関して報告される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, unlike normal lexically scope variables, dynamic variables search up the dynamic call stack for a variable of a particular name, but at each "stop" along the way, they are actually looking in the lexical "pad" associated with that particular dynamic scope's call frame.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T155130Z" creationid="Toshiyuki" creationdate="20130727T155130Z">
        <seg>例えば通常のレキシカルなスコープの変数と違い、ダイナミックな変数は特定の名前の変数のためにダイナミックコールスタックをそれぞれの「ストップ」まで道々探すけれども、実際は特定のダイナミックスコープのコールフレームに関連付けられたレキシカル「パッド」を見ている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more details on objects, classes and their attributes see &lt;a5&gt;objects&lt;/a5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T054348Z" creationid="yamato" creationdate="20140914T054348Z">
        <seg>オブジェクト、クラス、それらの属性についての詳細は&lt;a5&gt;objects&lt;/a5&gt;を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on the match variable see &lt;a3&gt;$/&lt;/a3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T061640Z" creationid="yamato" creationdate="20140914T061640Z">
        <seg>マッチ変数の情報は&lt;a3&gt;$/&lt;/a3&gt;を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For multiline comments it is recommended (but not required) to use two or more brackets both for visual clarity and to avoid relying too much on internal bracket counting heuristics when commenting code that may accidentally miscount single brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一つのブラケットを偶然に数え誤るかもしれないコードを注釈するとき、マルチラインコメントのために、それは視覚の明快さのために両方とも複数のブラケットを使って、あまりにたくさん発見的教授法を含む内部のブラケットに頼ることを避けると勧められる（しかし、必要でない）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some syntactic purposes, Perl distinguishes bracketing characters from non-bracketing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>若干の構文法の目的のために、Perlは非夾叉法から文字を括弧に入れることを識別する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For splitting into sort positions, if any alphabetics (including underscore) are immediately adjacent to a number, a dot is assumed between them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>並換え位置に分かれるために、何かalphabetics（アンダーラインを含む）がすぐ数に隣接してあるならば、点はそれらの間で装われる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the lexotic return of &lt;c2&gt;next&lt;/c2&gt;, the control exception will contain the identity of the loop scope to be exited (since the label was already "used up" to discover that identity), but for the dynamic fallback, the exception will contain only the loop label to be matched dynamically.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T115017Z" creationid="Toshiyuki" creationdate="20130729T115017Z">
        <seg>レギゾチックなリターンの&lt;c2&gt;next&lt;/c2&gt;では、制御例外は終了されるループスコープの識別子を含んでいるだろう。しかしダイナミックなフォールバックでは、その例外は動的にマッチされるループラベルだけが含まれているだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For those graphemes that have a precomposed form, use of that codepoint is suggested.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>precomposedされた形があるそれらの書記素のために、そのコードポイントの使用は、提案される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forcing capture context</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制キャプチャー前後関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From there it continues to scan outward to find the innermost block outside the &lt;c3&gt;when&lt;/c3&gt; that defines &lt;c4&gt;$_&lt;/c4&gt;, either explicitly or implicitly.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T114431Z" creationid="Toshiyuki" creationdate="20130812T114431Z">
        <seg>そこからそれは&lt;c4&gt;$_&lt;/c4&gt;を定義する&lt;c3&gt;when&lt;/c3&gt;の外側の最も深いブロックを探すために外側にスキャンを続ける。明示的か暗黙的に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function calls</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼出し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further call frames up the caller stack may be located by use of the &lt;c0&gt;callframe&lt;/c0&gt; function:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T073303Z" creationid="Toshiyuki" creationdate="20130817T073303Z">
        <seg>呼び出し元のスタックより上のコールフレームは&lt;c0&gt;callframe&lt;/c0&gt;関数の使用によって配置することもできる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further compounding the difficulty is that every dynamic scope's outer call frame is associated with a lexical scope somewhere, so you can't just consider one kind of scoping or the other in isolation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T152246Z" creationid="Toshiyuki" creationdate="20130727T152246Z">
        <seg>それ以上に難しさをより一層ひどくするのは、それぞれのダイナミックスコープの外側のコールフレームがレキシカルスコープの何処かに関連付けられていることだ。そういう訳で、あなたは一種類のスコープどちらかだけを分離して考えることはできない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, constructors are ordinary methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T193208Z" creationid="Toshiyuki" creationdate="20140111T193208Z">
        <seg>さらにまた、コンストラクタは普通のメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, the type declaration on this attribute indicates that the array may only hold instances of the &lt;c1&gt;Task&lt;/c1&gt; class (or some subclass of it).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045530Z" creationid="Toshiyuki" creationdate="20140111T183110Z">
        <seg>さらにまた、この属性の上の型宣言は、配列が&lt;c1&gt;Task&lt;/c1&gt;クラス（またはそれの若干のサブクラス）のインスタンスをだけを持つことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General radices</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般根</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generalized quotes may now take adverbs:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全般的な引用は、現在副詞をとるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally you don't need to worry about this unless you're defining a control construct.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125602Z" creationid="Toshiyuki" creationdate="20130816T125602Z">
        <seg>一般に、あなたが制御構造を定義するのでなければこれに関して心配する必要はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T232202Z" creationid="Toshiyuki" creationdate="20140328T232202Z">
        <seg>ジェネリック型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given &lt;c0&gt;sink&lt;/c0&gt;, there's no need for an "else" clause on Perl 6's loops, and the &lt;c1&gt;sink&lt;/c1&gt; construct works in any list, not just &lt;c2&gt;for&lt;/c2&gt; loops.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T080818Z" creationid="Toshiyuki" creationdate="20140329T080818Z">
        <seg>&lt;c0&gt;sink&lt;/c0&gt;があればPerl 6のループで“else”節は必要なく、&lt;c1&gt;sink&lt;/c1&gt;構造は&lt;c2&gt;for&lt;/c2&gt;ループだけでなくどんなリストでも動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given an object &lt;c0&gt;$p&lt;/c0&gt;, and the class definitions from the previous sections, we can ask it a few questions:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T150205Z" creationid="Toshiyuki" creationdate="20140112T135528Z">
        <seg>オブジェクト&lt;c0&gt;$p&lt;/c0&gt;と前のセクションからのクラス定義を与えられたとすると、我々はそれに少しの質問を尋ねることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Globals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammars</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T132534Z" creationid="Toshiyuki" creationdate="20140321T132534Z">
        <seg>グラマー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammatical Categories</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文法範疇</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handled exceptions break out past this implicit rethrow.) Hence, &lt;c7&gt;CATCH&lt;/c7&gt; is unlike all other switch statements in that it treats code inside a &lt;c8&gt;default&lt;/c8&gt; block differently from code that's after all the &lt;c9&gt;when&lt;/c9&gt; blocks but not in a &lt;c10&gt;default&lt;/c10&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T105620Z" creationid="Toshiyuki" creationdate="20130814T105620Z">
        <seg>扱われる例外は暗黙の再スローを過ぎて抜けだす。）その後、&lt;c7&gt;CATCH&lt;/c7&gt;は他のすべてのswitch文と違って&lt;c8&gt;default&lt;/c8&gt;ブロック内のコードを違うように扱う。結局&lt;c9&gt;when&lt;/c9&gt;ブロックで&lt;c10&gt;default&lt;/c10&gt;ブロックではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash assignment</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュ割当て</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash binding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash subscripts and bare keys</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュ添え字と裸のキー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hashes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence numeric coercions such as &lt;c2&gt;+"42foo"&lt;/c2&gt; can be forced to return &lt;c3&gt;42&lt;/c3&gt; after issuing a warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T074800Z" creationid="Toshiyuki" creationdate="20130818T074800Z">
        <seg>その後、&lt;c2&gt;+"42foo"&lt;/c2&gt;のような数値強制は警告を出す後に&lt;c3&gt;42&lt;/c3&gt;を返すように強要できる。 after issuing a warning.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence these declare the same variables with the same scope as the preceding example, but run the statements as a whole at the indicated time:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T084908Z" creationid="Toshiyuki" creationdate="20130818T084908Z">
        <seg>その後、それらはすぐ前の例と同じスコープと同じ値を宣言する。しかし示された時に全体として文を実行する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, it allows an optional argument to specify the meaning exactly if it cannot be known from context.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それゆえに、必ずしも前後関係からはわかることができないならば、それは任意の引数を意味を指定させる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, the &lt;c0&gt;leave&lt;/c0&gt; function:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T072226Z" creationid="Toshiyuki" creationdate="20130817T072226Z">
        <seg>それゆえに、&lt;c0&gt;leave&lt;/c0&gt;関数は：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, your environment variables are effectively declared without the sigil:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それゆえに、あなたの環境変数は、シギルなしで効果的に宣言される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それゆえに：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here &lt;c0&gt;@a&lt;/c0&gt; is flattened out in the second line.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T141143Z" creationid="yamato" creationdate="20140914T141143Z">
        <seg>ここで&lt;c0&gt;@a&lt;/c0&gt;は2行目でフラット化される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here after the initial binding, the lexpad entries for &lt;c0&gt;$a&lt;/c0&gt; and &lt;c1&gt;$b&lt;/c1&gt; both point to the same scalar container, so assigning to one variable also changes the contents of the other.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T133652Z" creationid="yamato" creationdate="20140914T133652Z">
        <seg>最初のバインドで&lt;c0&gt;$a&lt;/c0&gt;と&lt;c1&gt;$b&lt;/c1&gt; の両方のlexpadエントリーは同じスカラーコンテナをポイントし、一方の変数への割り当てはもう片方の内容も変更する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some of the names of parse rules in STD:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>STDの解析規則の名前のいくらかは、ここにある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are some possibilities:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>若干の可能性は、ここにある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here as part of the interpolation syntax it doesn't even imply package.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは展開構文の一部として、それはパッケージさえ意味しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here you can find an overview of different kinds of terms.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T121639Z" creationid="yamato" creationdate="20140914T121639Z">
        <seg>ここでは異なる種類の項の概要を見ることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Heredoc boundaries are suppressed, however, so you can split excessively long heredoc intro lines like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、ヒアドキュメント境界線は抑制されるので、あなたはこのように極端に長いヒアドキュメントイントロ行を分割することができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Heredocs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Heredocs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Heredocs allow optional whitespace both before and after terminating delimiter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Heredocsは、デリミタを終了した前に、そして、それ後にオプションの空白文字を許す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hierarchical types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T225105Z" creationid="Toshiyuki" creationdate="20140328T225105Z">
        <seg>階層型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How many spaces is a tab in a heredoc or virtual margin?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114848Z" creationid="yamato" creationdate="20140914T114848Z">
        <seg>ヒアドキュメントまたは仮想マージンのタブのスペースの数は？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How these are resolved depends on what they are eventually bound to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらが解決される方法は、結局、それらが密接に結びつくもの次第である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Perl will try to make those look like their corresponding uppercase types if you treat them that way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがそのようにそれらを扱うならば、Perlはそれらを彼らの対応する大文字の型のように見えさせようとする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a &lt;c2&gt;take&lt;/c2&gt; function that is not in sink context gathers its return objects &lt;i3&gt;en passant&lt;/i3&gt; and also returns them unchanged.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T213004Z" creationid="Toshiyuki" creationdate="20130810T213004Z">
        <seg>しかしながら、sinkコンテキストでない&lt;c2&gt;take&lt;/c2&gt;関数はリターンオブジェクトを&lt;i3&gt;ついでに&lt;/i3&gt;集め、そしてそれらを不変で返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a &lt;c3&gt;CATCH&lt;/c3&gt; must not behave that way, so we say that a &lt;c4&gt;CATCH&lt;/c4&gt; block never attempts to handle any exception thrown within its own dynamic scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T120608Z" creationid="Toshiyuki" creationdate="20130814T120608Z">
        <seg>しかしながら、&lt;c3&gt;CATCH&lt;/c3&gt;はそのように振舞ってはならない。それゆえ、&lt;c4&gt;CATCH&lt;/c4&gt;ブロックは決して独自のダイナミックスコープの範囲内で投げられた何か一つの例外をハンドルしようとしないといえる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a type object responds to the function call interface, so you may use the name of a type with parentheses as if it were a function, and any argument supplied to the call is coerced to the type indicated by the type object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、型オブジェクトは関数呼出しインタフェースに反応するので、まるでそれが関数であるように、あなたは括弧で型の名前を使用するかもしれない、そして、呼び出しに供給される何か引数は型オブジェクトによって示される型に強制される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, each slice dimension evaluates its sublist in normal list context, so functions called as part of a subscript don't see a lol context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、各々のスライス次元は通常のリストコンテキストでそのサブリストを評価するので、添え字の一部として呼ばれる関数はlol前後関係がわからない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in that case &lt;c5&gt;&amp;foo&lt;/c5&gt; by itself is not sufficient to uniquely name a specific function.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T083442Z" creationid="Toshiyuki" creationdate="20140329T083429Z">
        <seg>しかし、その場合&lt;c5&gt;&amp;foo&lt;/c5&gt;自身は特定の関数にユニークに名前を付けるのに十分ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in that case you have to pay attention to precedence and associativity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、その場合、あなたは優先順位と結合性に注意を払わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's not an error when prefixed by a &lt;c0&gt;do&lt;/c0&gt;, or when followed by a statement modifier:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T151708Z" creationid="Toshiyuki" creationdate="20130810T151708Z">
        <seg>けれども、&lt;c0&gt;do&lt;/c0&gt;によって前に付けられる時、または文修飾子が続く時はエラーではない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's sometimes better to use Pod comments because they are implicitly line-oriented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、それらが暗黙のうちに行を指向するので、ポッドコメントを使うことは、時々よりよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, no guarantee of memory contiguity can be made for non-native types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、メモリ接近の保証は、ネイティブでない型のために作られることができない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, no interpolated postfix may start with a backslash, so any backslash or unspace is not recognized, but instead will be assumed to be part of the string outside of the interpolation, and subject to the normal backslashing rules of that quote context:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、差し込まれた接尾辞はバックスラッシュから始めないかもしれないので、何かバックスラッシュまたはunspaceは認知されなくて、その代わりに、展開の外の、そして、その引用前後関係の通常のbackslashingしている原則を前提として文字列の一部であるとされる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, other forms of unspace may usefully be preceded by whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、unspaceの他の形は、有効に空白文字の後にあるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, recursive calls to the same clone use the same state variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133530Z" creationid="Toshiyuki" creationdate="20130802T133530Z">
        <seg>しかしながら、同一のクローンの再帰的呼び出しは同じstate変数を使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, some built-in concepts such as filehandles are more object-oriented in a user-visible way than in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、ファイルハンドルのような若干のビルトインコンセプトは、Perl 5でよりユーザー見える方法で、オブジェクト指向である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, that's likely to be visually confused with a following &lt;c0&gt;while&lt;/c0&gt; loop at the best of times, so it's also allowed to put the loop conditional at the front, with the same meaning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T053609Z" creationid="Toshiyuki" creationdate="20130809T152726Z">
        <seg>しかしながら、&lt;c0&gt;while&lt;/c0&gt;ループが続くのは多分視覚的にわかりにくいので、同じ意味でループ条件を前に置くことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, that's probably overkill.]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、それは多分過剰であるだろう。］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the labeled forms can use method call syntax: &lt;c3&gt;LABEL.next&lt;/c3&gt;, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T042110Z" creationid="Toshiyuki" creationdate="20130806T042110Z">
        <seg>しかし、ラベル付きの形式はメソッド呼び出し文法を使用出来る：&lt;c3&gt;LABEL.next&lt;/c3&gt;など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the name is introduced into the scope of the declaration itself, so it may be used to call itself recursively:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021832Z" creationid="Toshiyuki" creationdate="20140329T021832Z">
        <seg>しかし名前は宣言自体に導入されているので、自分自身を再帰的に呼び出すのに使えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the new semantics of autothrowing when sink eats a Failure means we won't have many unthrown exceptions waiting around to be handled at the end of the block anymore.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T153700Z" creationid="Toshiyuki" creationdate="20130817T153700Z">
        <seg>しかしながら、sinkがFailureを食べるときの自動スローの新しいセマンティクスは我々がたくさんのブロックの終端で待つハンドルされるスローされない例外を持ちたくないことを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are two important differences.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185217Z" creationid="Toshiyuki" creationdate="20140111T185217Z">
        <seg>しかし2つの重要な違いがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are two ways to stretch the construct out visually.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、2つの方法が、視覚的に構成概念を伸ばすためにある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there have to be some culturally enforced standards on which constructs capture which exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080123Z" creationid="Toshiyuki" creationdate="20130817T080123Z">
        <seg>けれども、構造がその例外を捕らえるいくつかの文化的に強要された標準がある必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this attribute represents an array of items, so it requires the &lt;c0&gt;@&lt;/c0&gt; sigil.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182936Z" creationid="Toshiyuki" creationdate="20140111T182936Z">
        <seg>しかし、この属性は配列のアイテムを表すので、&lt;c0&gt;@&lt;/c0&gt;シギルを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this comma is allowed only when the first pair occurs where a term is expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、項が予想される所で最初の一組が起こる時だけ、このコンマは許される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this is likely to fail on autochomped filehandles, so use the &lt;c0&gt;for&lt;/c0&gt; loop instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063749Z" creationid="Toshiyuki" creationdate="20130810T063749Z">
        <seg>しかしながら、これは自動でchompされたファイルハンドルではおそらく失敗するので、代わりに&lt;c0&gt;for&lt;/c0&gt;ループを使え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, use of &lt;c0&gt;$_&lt;/c0&gt; with a conditional or conditionally repeating statement's block is &lt;i1&gt;not&lt;/i1&gt; considered sufficiently explicit to turn a 0-ary block into a 1-ary function, so all these methods use the same invocant:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T095940Z" creationid="Toshiyuki" creationdate="20130804T095940Z">
        <seg>しかしながら、0のブロックを1の関数に変えるために&lt;c0&gt;$_&lt;/c0&gt;を条件付きまたは条件付きで繰り返すブロックで使うことは十分に明白とは見なされない。だから全てのこれらのメソッドは同じインボカントを使う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, we're rather liberal in what we consider a name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、我々は、名前を何であると考えるかについて、むしろ寛大である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you may omit the parentheses on the conditional:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T044327Z" creationid="Toshiyuki" creationdate="20130803T044327Z">
        <seg>けれども、括弧は条件付きで省略できる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a &lt;c1&gt;try&lt;/c1&gt; block or statement prefix catches an exception, that exception is stored in &lt;c2&gt;$!&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T113944Z" creationid="yamato" creationdate="20140914T113944Z">
        <seg>もし&lt;c1&gt;try&lt;/c1&gt;ブロックまたは文接頭語が例外をキャッチすると、その例外は&lt;c2&gt;$!&lt;/c2&gt;に保存される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a buf type is initialized with a Unicode string value, the string is decomposed into Unicode codepoints, and each codepoint shoved into an integer element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>buf型がユニコード文字列値で初期化されるならば、文字列はユニコードコードポイントに分解される、そして、各々のコードポイントは整数要素に押した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a character is already used in Ps/Pe/Pi/Pf mappings, then any entry in BidiMirroring is ignored (both forward and backward mappings).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字がPs/Pe/Pi/Pfマッピングですでに使われるならば、BidiMirroringの何かエントリーは無視される（両方のマスト傾斜角マッピング）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a given token may be interpreted as either a postfix operator or an infix operator, the infix operator requires space before it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>所定のトークンが後置演算子かインフィックスオペレータと解釈されるならば、インフィックスオペレータはそれの前にスペースを必要とする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a line is deemed to have less whitespace than the terminator, only whitespace is removed, and a warning may be issued.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>線がターミネータより少ない空白文字を持っていると考えられるならば、空白文字だけは削除される、そして、警告は発されるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a term is not expected at this point, it is a syntax error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>項がこの点で期待されないならば、それは構文エラーである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any arguments are supplied to the &lt;c9&gt;succeed&lt;/c9&gt; function, they are passed out via the &lt;c10&gt;leave&lt;/c10&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114350Z" creationid="Toshiyuki" creationdate="20130813T114350Z">
        <seg>何か一つの引数が&lt;c9&gt;succeed&lt;/c9&gt;関数に与えられたら、それらは&lt;c10&gt;leave&lt;/c10&gt;メソッド経由で渡される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any exceptions are returned as not handled, the exception thrower keeps looking for a higher dynamic scope for a spot to unwind to.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T112836Z" creationid="Toshiyuki" creationdate="20130814T112836Z">
        <seg>もし何か一つの例外がハンドルされないとして返されるなら、例外を投げるものはスポットして巻き戻すためにより高いダイナミックスコープを探し続ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any other conversion is desired, it must be specified explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何か他の転換が要求されるならば、それははっきりと指定されなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If continuations are used, the &lt;c0&gt;.resume&lt;/c0&gt; call will simply goto the continuation in question, and the lambda's callframe is abandoned.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T114130Z" creationid="Toshiyuki" creationdate="20130814T114130Z">
        <seg>もし継続が使われたら、&lt;c0&gt;.resume&lt;/c0&gt;呼び出しは単純に問題の継続に飛び、 そのlambdaのコールフレームは破棄される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If followed by a block it does not parse as a list operator or even as a prefix unary; it will never look for any additional expression following the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124145Z" creationid="Toshiyuki" creationdate="20130811T124145Z">
        <seg>もしブロックが続くリスト演算子か単項の接頭辞としてパースしないなら；ブロックに続く追加のどんな式も探さないだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If further separation is desired, an unspace or embedded comment may be used as described above, as long as no whitespace occurs outside the unspace or embedded comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる区切りが要求されるならば、空白文字がunspaceまたは埋め込みコメントの外で起こらない限り、unspaceまたは埋め込みコメントが先に述べたように使われるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If instead of the above you say:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T074109Z" creationid="Toshiyuki" creationdate="20130817T074109Z">
        <seg>上述の代わりに次のように書くなら：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If instead the users of this object should be able to reset a task's completion state (perhaps to perform it again), you can change the attribute declaration:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184737Z" creationid="Toshiyuki" creationdate="20140111T184737Z">
        <seg>その代わりにこのオブジェクトのユーザーが仕事の完成状態（おそらく再びそれを実行するために）をリセットすることができるべきであるならば、あなたは属性宣言を変えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is left blank, the value is &lt;c0&gt;Bool::True&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T123824Z" creationid="yamato" creationdate="20140914T123824Z">
        <seg>左が空白なら値は&lt;c0&gt;Bool::True&lt;/c0&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is not, it is compiled as a provisional function call of the list operator form, which may or may not have an argument list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでないならば、それはリスト演算子形式の暫定的な関数呼び出しとして編集される。そして、それは引数の並びを持つかもしれないか、持たないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no exception was caught, &lt;c3&gt;$!&lt;/c3&gt; is set to the &lt;c4&gt;Any&lt;/c4&gt; type object.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114022Z" creationid="yamato" creationdate="20140914T114022Z">
        <seg>例外がキャッチされなければ&lt;c3&gt;$!&lt;/c3&gt;は&lt;c4&gt;Any&lt;/c4&gt;型オブジェクトにセットされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no explicit handler handles it, the implicit outermost exception handler will eventually decide to abort and print all unhandled exceptions passed in as its current &lt;c0&gt;@!&lt;/c0&gt; list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T073531Z" creationid="Toshiyuki" creationdate="20130818T073531Z">
        <seg>もし明示的なハンドラがそれをハンドルしないなら、暗黙の最も外側の例外ハンドラは結局無視して現在の&lt;c0&gt;@!&lt;/c0&gt;リストとして渡される全てのハンドルされない例外をプリントすると決定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no type can represent it exactly, it should be returned as either a Rat or a Num, whichever is more accurate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型が必ずしもそれを表現することができないならば、それはRatかNum（より正確であるものはどれでも）として返納印でなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If none of the cases in the &lt;c3&gt;CATCH&lt;/c3&gt; handles the exception, the exception will be rethrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T134608Z" creationid="Toshiyuki" creationdate="20130813T134608Z">
        <seg>&lt;c3&gt;CATCH&lt;/c3&gt;の例外を扱うケースがないなら、例外は再スローされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If nothing in the context is being compiled, an exception is thrown.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前後関係の何も編集されていないならば、例外は投げられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If so, there's nothing to do.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T190659Z" creationid="Toshiyuki" creationdate="20140111T190659Z">
        <seg>もしそうなら、することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If such ids are assigned consistently throughout the process, comparison of two graphemes is no more difficult than the comparison of two integers, and comparison of base characters no more difficult than a direct lookup into the id-to-NFD table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなIDがプロセスを通して一貫して割り当てられるならば、2つの書記素の比較は2整数の比較とNFDへのIDテーブルへの直接ルックアップと同様、難しくないベース文字の比較と同様、難しくない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that's not intended, you must use whitespace between the adverb and the opening bracket.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが意図されないならば、あなたは副詞と左大括弧の間で空白文字を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c7&gt;gather&lt;/c7&gt; contains no &lt;c8&gt;take&lt;/c8&gt; lexically, it by definition cannot be the lexotic target of any &lt;c9&gt;take&lt;/c9&gt;, so it can only harvest dynamic &lt;c10&gt;take&lt;/c10&gt; calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T160429Z" creationid="Toshiyuki" creationdate="20130810T160429Z">
        <seg>&lt;c7&gt;gather&lt;/c7&gt;が&lt;c8&gt;take&lt;/c8&gt;をレキシカルに含んでいないなら、定義によってどんな&lt;c9&gt;take&lt;/c9&gt;のレギゾチックターゲットにもなれない。なので動的な&lt;c10&gt;take&lt;/c10&gt;呼び出しだけ収納できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the conditional does not execute any branch, the return value is &lt;c0&gt;()&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T050026Z" creationid="Toshiyuki" creationdate="20130803T050026Z">
        <seg>もし条件がいずれの分岐も実行しないなら、返り値は&lt;c0&gt;()&lt;/c0&gt;になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the failure throws its exception and the exception resumes, the thrower by default returns the null string (&lt;c0&gt;''&lt;/c0&gt;) to whatever caused the failure to throw its exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T074133Z" creationid="Toshiyuki" creationdate="20130818T074133Z">
        <seg>もし失敗が例外をスローして例外が再開するなら、スロー元はデフォルトで例外をスローするための失敗を引き起こすならなんでもnull文字列（&lt;c0&gt;''&lt;/c0&gt;）を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the object is of that class, or of an inheriting class, it returns true.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T105031Z" creationid="Toshiyuki" creationdate="20140112T135810Z">
        <seg>オブジェクトがそのクラスの、または継承しているクラスであれば、それは真を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the preceding portion is null, it means the package is unspecified and must be searched for according to the nature of what follows.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の部分が無効であるならば、それはパッケージが明らかでなくて、あとに続くことの性質に一致することを求めて捜されなければならないことを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the program has a scope that wants a codepoint view rather than a grapheme view, the string visible to that lexical scope must also be translated to universal form, just as with output translation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラムが書記素見方よりもむしろコードポイント見方が欲しいスコープを持つならば、ちょうど出力翻訳と同様に、そのレキシカルスコープに見える文字列は一般的な形にも変形されなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the size is specified, the initializing string is truncated or 0-padded as necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サイズが指定されるならば、初期化している文字列は頭を切って短くされるか、必要に応じて0パッドを入れられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the size of the buf type is not specified, it takes its length from the initializing string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>buf型のサイズが指定されないならば、それは長さを初期化している文字列から引く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the smart match fails, control proceeds the next statement normally, which may or may not be a &lt;c0&gt;when&lt;/c0&gt; statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T132125Z" creationid="Toshiyuki" creationdate="20130811T132125Z">
        <seg>もしスマートマッチが失敗したら、制御は通常通り次の文へ進み、そしてそれは&lt;c0&gt;when&lt;/c0&gt;文になるかどうかわからない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the smart match succeeds, &lt;c10&gt;when&lt;/c10&gt;'s associated block is executed, and the innermost surrounding block that has &lt;c11&gt;$_&lt;/c11&gt; as one of its formal parameters (either explicit or implicit) is automatically broken out of.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T130833Z" creationid="Toshiyuki" creationdate="20130811T130833Z">
        <seg>もしスマートマッチが成功したら、&lt;c10&gt;when&lt;/c10&gt;に関連付けられたブロックは実行され、&lt;c11&gt;$_&lt;/c11&gt;を仮パラメータ（明示的か暗黙的）の一つとして持つ最も深い部分を囲うブロックは自動的に切り離される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value is not found, it returns failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値が見つからないならば、それは失敗を返る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the warning exception supports the &lt;c2&gt;.resume_value&lt;/c2&gt; method, that will be the value of the failure after it has resumed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130811Z" creationid="Toshiyuki" creationdate="20130817T130811Z">
        <seg>もし警告例外が&lt;c2&gt;.resume_value&lt;/c2&gt;メソッドをサポートするなら、それが再開された後に失敗の値になるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are any unhandled &lt;c1&gt;@!&lt;/c1&gt; exceptions, or if any exceptions were caught by the inner SIMPLECATCH (which does nothing but runs its push code, which should not produce any exceptions), then the CATCH block returns them to the exception thrower.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T111820Z" creationid="Toshiyuki" creationdate="20130814T111820Z">
        <seg>もしハンドルされない&lt;c1&gt;@!&lt;/c1&gt;例外があるなら、または何か一つの例外が内側のSIMPLECATCHにキャッチされるなら（それは何もしないがプッシュコードを実行する。そしてそれはどんな例外も引き起こすべきではない）、CATCHブロックは例外を投げるものにそれを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no statements in the block at all, the result is also &lt;c1&gt;()&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T022654Z" creationid="Toshiyuki" creationdate="20130803T022654Z">
        <seg>ブロックに文が全くないなら、その結果も&lt;c1&gt;()&lt;/c1&gt;になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no argument in the parentheses, the type object returns itself:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数が括弧でないならば、型オブジェクトはそれ自体返る：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no such lexically scoped outer loop in the current subroutine, then a fallback search is made outward through the dynamic scopes in the same way Perl 5 does.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T081114Z" creationid="Toshiyuki" creationdate="20130817T081114Z">
        <seg>もし現在のサブルーチンにそのようなレキシカルスコープの外側のループがないなら、フォールバックの検索はダイナミックスコープを通して外側にPerl 5と同じ方法で行われる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If two units provide package names with incompatible type signatures, the compilation of the unit fails.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2つの単位がパッケージ名に非互換の型シグネチャを提供するならば、単位の編集は失敗する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If used in a context where it doesn't make sense, a compile-time exception of type &lt;a1&gt;X::Syntax::NoSelf&lt;/a1&gt; is thrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124644Z" creationid="yamato" creationdate="20140914T124644Z">
        <seg>意味のないコンテキストで使われるとコンパイル時例外&lt;a1&gt;X::Syntax::NoSelf&lt;/a1&gt;がスローされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If used in an argument list, all of these forms count as named arguments, with the exception of &lt;c0&gt;'quoted string' =&gt; $value &lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124002Z" creationid="yamato" creationdate="20140914T124002Z">
        <seg>引数リストで使われるなら、これらの全ての形式は名前付き引数とみなされる。&lt;c0&gt;'quoted string' =&gt; $value &lt;/c0&gt;を除いて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you &lt;i2&gt;don't&lt;/i2&gt; deal with the failures as data, then sink context will automatically throw any unhandled &lt;c3&gt;Failure&lt;/c3&gt; that you try to discard.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T175500Z" creationid="Toshiyuki" creationdate="20130817T175500Z">
        <seg>もしデータとして失敗に対処しないなら、 あなたが破棄しようと試みるハンドルされないどれか一つの&lt;c3&gt;Failure&lt;/c3&gt;をsinkコンテキストは自動的にスローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you declare a lexical twice in the same scope, it is the same lexical:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125859Z" creationid="Toshiyuki" creationdate="20130730T125859Z">
        <seg>もしもあなたがレキシカルを同じスコープで二回定義したら、それは同じレキシカルだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you decrement the element it becomes false and is automatically deleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが要素をデクリメントするならば、それは間違ったようになって、自動的にアンインストール済みである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a &lt;c5&gt;CATCH&lt;/c5&gt; block within the &lt;c6&gt;try&lt;/c6&gt;, it replaces the default &lt;c7&gt;CATCH&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T122130Z" creationid="Toshiyuki" creationdate="20130813T122130Z">
        <seg>もし&lt;c5&gt;CATCH&lt;/c5&gt;ブロックを&lt;c6&gt;try&lt;/c6&gt;内に定義すると、デフォルトの&lt;c7&gt;CATCH&lt;/c7&gt;を差し替える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don't want this to happen, use &lt;c4&gt;$!x&lt;/c4&gt; and &lt;c5&gt;$!y&lt;/c5&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T061330Z" creationid="yamato" creationdate="20140914T061330Z">
        <seg>これが起こらないようにしたいなら&lt;c4&gt;$!x&lt;/c4&gt;と&lt;c5&gt;$!y&lt;/c5&gt;を代わりに使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have a switch that is the main block of a &lt;c0&gt;for&lt;/c0&gt; loop that uses &lt;c1&gt;$_&lt;/c1&gt; as its loop variable, and you break out of the switch either implicitly or explicitly (that is, the switch "succeeds"), control merely goes to the end of that block, and thence on to the next iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115936Z" creationid="Toshiyuki" creationdate="20130813T115936Z">
        <seg>もし&lt;c1&gt;$_&lt;/c1&gt;をループ変数として使っている&lt;c0&gt;for&lt;/c0&gt;ループのメインブロックとなっているswitchを持っており、switchを暗黙か明示的に抜けるなら（すなわち、switchが「成功する」）、制御は単にブロックの終わりに行き、そこから次のループの反復に行く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have self-declared a parameter using &lt;c5&gt;$^a&lt;/c5&gt; once you may refer to it using only &lt;c6&gt;$a&lt;/c6&gt; thereafter.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T062814Z" creationid="yamato" creationdate="20140914T062814Z">
        <seg>もしあなたが自身で定義した&lt;c5&gt;$^a&lt;/c5&gt;を一度使ったパラメータを持っているなら、あとで&lt;c6&gt;$a&lt;/c6&gt;だけを使ってそれを参照するかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to force inner context to item (scalar), we now have convenient single-character context specifiers such as + for numbers and ~ for strings:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがアイテム（段階的な）に内部の前後関係を強制する必要があるならば、我々には現在文字列のために数と~のために+のような便利な単一キャラクター前後関係指示子がある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to have double quotes that don't interpolate curlies, you can explicitly remove the capability:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>curliesを差し込まないダブルクォートを持っている必要があるならば、あなたは機能をはっきりと除去することができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you rely on &lt;c0&gt;$_&lt;/c0&gt; as the implicit parameter to a block, then &lt;c1&gt;$_&lt;/c1&gt; is considered read/write by default.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113936Z" creationid="Toshiyuki" creationdate="20130810T113936Z">
        <seg>もし&lt;c0&gt;$_&lt;/c0&gt;をブロックの暗黙のパラメータとして当てにするなら、&lt;c1&gt;$_&lt;/c1&gt;はデフォルトでread/writeと見なされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you say</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが言うならば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you say:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが以下のように言うならば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you take multiple items in a comma list (since it is, after all, a list operator), they will be wrapped up in a &lt;c0&gt;Parcel&lt;/c0&gt; object for return as the next argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T201027Z" creationid="Toshiyuki" creationdate="20130810T201027Z">
        <seg>もしコンマリストで複数のアイテムをとるなら（だから、結局、リスト演算子）、それらは次の引数として返すために&lt;c0&gt;Parcel&lt;/c0&gt;オブジェクトにラップされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you test a &lt;c0&gt;Failure&lt;/c0&gt; for &lt;c1&gt;.defined&lt;/c1&gt; or &lt;c2&gt;.Bool&lt;/c2&gt;, the &lt;c3&gt;Failure&lt;/c3&gt; marks itself as &lt;i4&gt;handled&lt;/i4&gt;; the exception acts as a relatively harmless undefined value thereafter.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T155554Z" creationid="Toshiyuki" creationdate="20130817T155554Z">
        <seg>もし&lt;c0&gt;Failure&lt;/c0&gt;を&lt;c1&gt;.defined&lt;/c1&gt;または&lt;c2&gt;.Bool&lt;/c2&gt;のためにテストするなら、 &lt;c3&gt;Failure&lt;/c3&gt;はそれ自身を&lt;i4&gt;handled&lt;/i4&gt;としてマークする；例外はその後は相対的に無害な未定義値としてふるまう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a &lt;c0&gt;for&lt;/c0&gt; loop with a parameter named &lt;c1&gt;$_&lt;/c1&gt; (either explicitly or implicitly), that parameter can function as the topic of any &lt;c2&gt;when&lt;/c2&gt; statements within the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T111358Z" creationid="Toshiyuki" creationdate="20130812T111358Z">
        <seg>もし&lt;c0&gt;for&lt;/c0&gt;ループを名前付きパラメータ&lt;c1&gt;$_&lt;/c1&gt;（明示的か暗黙的）と共に使うなら、そのパラメータはループ内のどんな&lt;c2&gt;when&lt;/c2&gt;文のトピックとしても機能できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use integers as arguments where position objects are expected, it will be assumed that you mean the units of the current lexically scoped Unicode abstraction level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが位置オブジェクトが予想される引数として整数を使うならば、あなたが現在の辞書的に捜し出されたユニコード抽象概念レベルの単位を意味すると仮定される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want it to be available, you must rewrite it as an explicit block using curlies:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T115013Z" creationid="Toshiyuki" creationdate="20130810T115013Z">
        <seg>もし使用できるようにしたいなら、カーリーブラケットを使って明白なブロックとして書き直す必要がある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want notifications of some sort back to the pit crew, you'll have to arrange them yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ピットクルーに何らかの通知を返して欲しいならば、あなたは自分でそれらを手配しなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want the latter semantics for some reason, use a temporary:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが何かの理由で後の意味論を望むならば、テンポラリーを使いなさい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to abbreviate further, just define a macro:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがさらに簡約したいならば、ちょうどマクロを定義しなさい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to continue the expression after the statement, or if you want to attach multiple statements, you must either use the curly form or surround the entire expression in brackets of some sort:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T122313Z" creationid="Toshiyuki" creationdate="20130810T121937Z">
        <seg>もし文の後に式を続けたい、または複数の文を付け加えたいなら、カーリー形式か全体の式をブラケットで囲むかしなければならない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wish to return a closure from a function, you must use an explicit prefix such as &lt;c0&gt;return&lt;/c0&gt; or &lt;c1&gt;sub&lt;/c1&gt; or &lt;c2&gt;-&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T150911Z" creationid="Toshiyuki" creationdate="20130810T150911Z">
        <seg>もし関数からクロージャを返したければ、&lt;c0&gt;return&lt;/c0&gt;または&lt;c1&gt;sub&lt;/c1&gt;または&lt;c2&gt;-&gt;&lt;/c2&gt;のような明白な接頭辞を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you write</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T133215Z" creationid="yamato" creationdate="20140914T133215Z">
        <seg>次のように書くなら</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you've read and understood the previous explanations, it is now time to wonder how this can possibly work.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T140107Z" creationid="yamato" creationdate="20140914T140107Z">
        <seg>あなたが前の説明を読んで理解したなら、これがどのようにして動作が可能なのか疑問に思う時だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you've referred to &lt;c0&gt;$x&lt;/c0&gt; prior to the first declaration, and the compiler tentatively bound it to &lt;c1&gt;$OUTER::x&lt;/c1&gt;, then it's an error to declare it, and the compiler is required to complain at that point.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T131017Z" creationid="Toshiyuki" creationdate="20130730T131017Z">
        <seg>もしあなたが最初の宣言の前に&lt;c0&gt;$x&lt;/c0&gt;を参照し、コンパイラがそれを仮に&lt;c1&gt;$OUTER::x&lt;/c1&gt;にバインドしたら、それを宣言することはエラーであり、コンパイラがその時点で文句を言う必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If, instead of throwing a warning directly, the program calls &lt;c1&gt;fail()&lt;/c1&gt; with a resumable exception, the throwing of the warning is delayed until first use (or the caller's policy) requires it to be thrown.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130550Z" creationid="Toshiyuki" creationdate="20130817T130550Z">
        <seg>もし代わりに例外を直接スルーするなら、プログラムは&lt;c1&gt;fail()&lt;/c1&gt;を再開可能な例外と共に呼ぶ。警告のスローは最初の使用（または呼び出し元のポリシー）がスローを要求するまで延ばされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignore the &lt;c0&gt;new&lt;/c0&gt; method temporarily; it's a special type of method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185008Z" creationid="Toshiyuki" creationdate="20140111T185008Z">
        <seg>&lt;c0&gt;new&lt;/c0&gt;メソッドは一旦無視してください；それは特別なタイプのメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Immutable types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不変の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit Topical Method Calls</seg>
      </tuv>
      <tuv lang="JA">
        <seg>陰の時事的なメソッドは訪問する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 5, a bare block is deemed to be a do-once loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T120255Z" creationid="Toshiyuki" creationdate="20130810T120255Z">
        <seg>Perl 5では、裸のブロックはdo-onceループと判断される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, control flow is designed to do what the user expects most of the time, but this implies that we must consider the declarative nature of labels and blocks and combine those with the dynamic nature of the call stack.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T170258Z" creationid="Toshiyuki" creationdate="20130727T170258Z">
        <seg>Perl 6では制御フローはユーザーが殆どの場合期待する通りにデザインされているが、これは宣言的な性質のラベルとブロックとコールスタックの動的な性質とそれらを結びつけることについて我々が考えなければならないことを伴う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Perl 6, the bare block is not a do-once.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T120317Z" creationid="Toshiyuki" creationdate="20130810T120317Z">
        <seg>Perl 6では裸のブロックはdo-onceではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a boolean context, a Hash object is true if there are any pairs in the hash.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090056Z" creationid="Toshiyuki" creationdate="20140329T090056Z">
        <seg>ブールコンテキストでは、ハッシュに何らかのペアがあればハッシュオブジェクトは真です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a code like</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T131308Z" creationid="yamato" creationdate="20140914T131308Z">
        <seg>次のようなコードで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition one can add new identifier terms with the syntax</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124429Z" creationid="yamato" creationdate="20140914T124429Z">
        <seg>その上、新しい識別子項を以下の構文で追加できる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to &lt;c0&gt;next&lt;/c0&gt;, &lt;c1&gt;last&lt;/c1&gt;, and &lt;c2&gt;redo&lt;/c2&gt;, Perl 6 also supports &lt;c3&gt;goto&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T131449Z" creationid="Toshiyuki" creationdate="20130817T131449Z">
        <seg>&lt;c0&gt;next&lt;/c0&gt;、&lt;c1&gt;last&lt;/c1&gt;、&lt;c2&gt;redo&lt;/c2&gt;に加えてPerl 6は&lt;c3&gt;goto&lt;/c3&gt;もサポートする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to priming a method call without an invocant, such primed methods are handy anywhere a smartmatcher is expected:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インボカントなしでメソッド呼び出しの準備をすることに加えて、そのような準備をされたメソッドは、すぐ手近に、スマートマッチャーが予想される場所である：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, for constant subscripts, it is guaranteed to resolve the symbol at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのうえ、固定添え字のために、コンパイル時でシンボルを解決することは、保証される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all these cases, the type produced will be the narrowest of Int, Rat, or Num that can accurately represent the number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのこれらのケースに、生み出される型は、Int、Ratまたは数を正確に表現することができるNumで最も狭い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, all formal parameters are the equivalent of &lt;c0&gt;my&lt;/c0&gt; variables within the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T125913Z" creationid="Toshiyuki" creationdate="20130729T125913Z">
        <seg>いずれにせよ、全ての仮パラメータはブロック内の&lt;c0&gt;my&lt;/c0&gt;変数と同等だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, array indexes must behave as such a 'value list context', since you can't directly index an array with anything other than a number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、あなたが数以外の何でも配列に直接索引付けすることができない時から、配列の添字はそのような『値リストコンテキスト』としてふるまわなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, codepoint scope should never see any temporary grapheme ids.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、コードポイントスコープは、何かテンポラリー書記素IDに決して遭遇してはならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, it declares that you don't care about the evaluation order, only the result order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、それは、あなたは評価順序（結果順序だけ）が好きでないと断言する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, the minimal container role implied by the sigil is checked at binding time at the latest, and may fail earlier (such as at compile time) if a semantic error can be detected sooner.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、シギルによってほのめかされる最小のコンテナロールは、遅くともバインディング時でチェックされて、意味上の誤りがよりすぐに見つけられることができるならば以前に失敗する場合がある（例えばコンパイル時で）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, the overriding design principle here is that no unhandled exception is ever dropped on the floor, but propagated outward until it is handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T182231Z" creationid="Toshiyuki" creationdate="20130817T182231Z">
        <seg>いずれにせよ、ここでのオーバーライドのデザイン原理は、ハンドルされない例外は常に床に落ちる。しかしハンドルされるまで外側に伝搬される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, use of such an intuited value as a string will reproduce the original string including any leading or trailing whitespace:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、文字列のような直観された値の使用は、何か主要なまたは後置空白文字を含む元の文字列を複製する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In boolean contexts, a true value is returned if and only if there are any elements in the container.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022628Z" creationid="Toshiyuki" creationdate="20140329T022628Z">
        <seg>ブール値コンテキストでは何らかの要素がコンテナにあれば真を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case multiple dispatch determines that it could dispatch as either string or number, a tie results, which may result in an ambiguous dispatch error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のディスパッチがそれがどちらの文字列または数としてでも指名することができたと決定する場合に備えて、タイは起こる。そして、それは結果としてあいまいなディスパッチエラーになるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the value may be rebound to a different object, just as a hash element may.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、ちょうどハッシュ要素がそうするかもしれなくて、値は異なるオブジェクトに再結合されるかもしれない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In declarative constructs bare sigils may be used as placeholders for anonymous variables:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>叙述的な構成概念において、裸のシギルが、無名変数のためのプレースホールダーとして使われるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case this sets the &lt;c0&gt;of&lt;/c0&gt; property of the container to &lt;c1&gt;Dog&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T213252Z" creationid="Toshiyuki" creationdate="20140328T213252Z">
        <seg>いずれもコンテナの&lt;c0&gt;of&lt;/c0&gt;プロパティに&lt;c1&gt;Dog&lt;/c1&gt;をセットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, no bare parcel object is seen as a normal bound argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、裸のパーセルオブジェクトは、通常の縛られた引数とみなされない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, the values are returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、値は返納印である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, most of these phasers will take either a block or a thunk (known as a &lt;i0&gt;blast&lt;/i0&gt; in the vernacular).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T083300Z" creationid="Toshiyuki" creationdate="20130818T083300Z">
        <seg>実際は、大部分のphasersはブロックかサンク（固有の言葉で&lt;i0&gt;blast&lt;/i0&gt;として知られる）をとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, something along the lines of</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T060758Z" creationid="yamato" creationdate="20140914T060758Z">
        <seg>実際、行に沿う何か</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, this construct would be relatively useless if you could bind only boolean values as parameters, since within the closure you already know whether it evaluated to true or false.) Binding within an &lt;c1&gt;else&lt;/c1&gt; automatically binds the value tested by the previous &lt;c2&gt;if&lt;/c2&gt; or &lt;c3&gt;elsif&lt;/c3&gt;, which, while known to be false, might nevertheless be an &lt;i4&gt;interesting&lt;/i4&gt; value of false.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T084044Z" creationid="Toshiyuki" creationdate="20130804T084044Z">
        <seg>実際は、もしあなたがブール値をパラメータとしてしかバインドしないなら、この構成物は相対的に役に立たない。だから、あなたはクロージャの範囲内でそれが真か偽で評価されるかすでに知っている。&lt;c1&gt;else&lt;/c1&gt;のバインドは値を前にテストした&lt;c2&gt;if&lt;/c2&gt;か&lt;c3&gt;elsif&lt;/c3&gt;に自動的にバインドし、偽と判明している間、&lt;i4&gt;面白い&lt;/i4&gt;偽の値にも関わらず。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, this mechanism is probably used by the exporter to bind names into the importer's namespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、このメカニズムは、輸出者によって輸入業者の名前空間に名前を結びつけるのに多分用いられるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, for most iterated solutions you should consider using a &lt;c2&gt;for&lt;/c2&gt; loop instead (see below).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T145855Z" creationid="Toshiyuki" creationdate="20130809T145855Z">
        <seg>一般に、最も繰り返される解決法のためにあなたは&lt;c2&gt;for&lt;/c2&gt;ループを代わりに使うことを検討すべきだ（下記参照）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, initializing phasers execute in order declared, while finalizing phasers execute in the opposite order.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130820T124713Z" creationid="Toshiyuki" creationdate="20130820T124713Z">
        <seg>一般にphasersの初期化は宣言順に実行し、ファイナライズは逆順に実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, whitespace is optional in Perl 6 except where it is needed to separate constructs that would be misconstrued as a single token or other syntactic unit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般に、それが単一トークンまたは他の構文単位として誤解される構成物を切り離すために必要な場合を除き、空白文字はPerl 6でオプションである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In item context, the implied grouping parentheses are still there, so</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アイテム前後関係では、そう、意味されたグループ括弧は、まだそこにある</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In item context, variables such as &lt;c3&gt;@array&lt;/c3&gt; and &lt;c4&gt;%hash&lt;/c4&gt; simply return themselves as &lt;c5&gt;Array&lt;/c5&gt; and &lt;c6&gt;Hash&lt;/c6&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022325Z" creationid="Toshiyuki" creationdate="20140329T022325Z">
        <seg>アイテムコンテキストでは&lt;c3&gt;@array&lt;/c3&gt;と&lt;c4&gt;%hash&lt;/c4&gt;のような変数は単にそれら自身を&lt;c5&gt;Array&lt;/c5&gt;と&lt;c6&gt;Hash&lt;/c6&gt;のオブジェクトとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many ways, this looks a lot like a &lt;c0&gt;sub&lt;/c0&gt; declaration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185203Z" creationid="Toshiyuki" creationdate="20140111T185203Z">
        <seg>様々な点でこれは&lt;c0&gt;sub&lt;/c0&gt;宣言に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most interesting programs the dynamic scopes are nested quite differently from the lexical scopes, so it's important to distinguish carefully which kind of scoping we're talking about.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T145648Z" creationid="Toshiyuki" creationdate="20130727T145648Z">
        <seg>最も興味深いプログラムでは、ダイナミックスコープはレキシカルスコープと全く違うように入れ子になっている。そういうわけで、我々が話しているようなスコープとは注意深く区別することが大切だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most other matters type names and package names are interchangeable.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大部分の他の問題では、タイプ名とパッケージ名は、交換可能である。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In no case may any of the top-level components be separated by whitespace or unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いかなる場合も、トップレベルの構成要素の何も、空白文字またはunspaceによって切り離されないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric context (i.e. when cast into &lt;c0&gt;Int&lt;/c0&gt; or &lt;c1&gt;Num&lt;/c1&gt;), a &lt;c2&gt;Hash&lt;/c2&gt; object becomes the number of pairs contained in the hash.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090003Z" creationid="Toshiyuki" creationdate="20140329T090003Z">
        <seg>数値コンテキスト（すなわち&lt;c0&gt;Int&lt;/c0&gt;または&lt;c1&gt;Num&lt;/c1&gt;にキャストする時）では、&lt;c2&gt;Hash&lt;/c2&gt;オブジェクトはハッシュに含まれるペアの数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In numeric contexts, the number of elements in the container is returned.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022543Z" creationid="Toshiyuki" creationdate="20140329T022543Z">
        <seg>数値コンテキストではコンテナの要素数が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to interpolate an entire array, it's necessary now to subscript with empty brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての配列を差し込むために、それは空のブラケットで現在添え字に必要である：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to interpolate an entire hash, it's necessary to subscript with empty braces or angles:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ハッシュを差し込むために、それは空のブレースまたは角度で添え字に必要である：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to interpolate the result of a method call without arguments, it's necessary to include parentheses or extend the call with something ending in brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数なしでメソッド呼び出しの結果を差し込むために、括弧を含むか、ブラケットで終わっている何かで呼び出しを延長することが、必要である：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to interpolate the result of a sub call, it's necessary to include both the sigil and parentheses:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下位呼び出しの結果を差し込むために、シギルと括弧を含むことが、必要である：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, a dot following a number can only be a decimal point if the following character is a digit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えると、以下の文字が桁であるならば、数の後の点は小数点でありえるだけである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, it first tries this form:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080933Z" creationid="Toshiyuki" creationdate="20130817T080933Z">
        <seg>言い換えれば、最初にこの形式を試す：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, this is legal:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えると、これは合法的である：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, you may not use incompatible global types to provide a union type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えると、共用体型を提供するために、非互換の世界的な型を使わなくてもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular,</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124152Z" creationid="Toshiyuki" creationdate="20130811T124152Z">
        <seg>特に、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, a list of pairs will interpolate with a tab between the key and value, and a newline after the pair.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、組のリストは、キーと値の間のタブと一組の後の改行文字で改竄する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, end-of-line comments do not treat backslash as significant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、重要であるように、行末コメントはバックスラッシュを扱わない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, there is a natural conflict between postfix operators and infix operators, either of which may occur after a term.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、後置演算子と中置演算子の自然な対立がある。そして、そのいずれかが項の後起こる場合がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, this frees up the block form after a method name, so it allows us to parse a block as a method argument:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、これはメソッド名の後ブロックの形を解放するので、それは我々がメソッド引数としてブロックを解析するのを許す：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, this means that &lt;c3&gt;once&lt;/c3&gt; can make use of any parameters passed in on the first call, whereas &lt;c4&gt;INIT&lt;/c4&gt; cannot.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130825T072440Z" creationid="Toshiyuki" creationdate="20130825T072440Z">
        <seg>特に、&lt;c3&gt;once&lt;/c3&gt;は最初の呼び出しで任意のパラメータを使えるようにするのに対し、&lt;c4&gt;INIT&lt;/c4&gt;はできない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, we now generally use &lt;c3&gt;for&lt;/c3&gt; to iterate filehandles.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T150043Z" creationid="Toshiyuki" creationdate="20130809T150043Z">
        <seg>特に、我々は現在一般的に&lt;c3&gt;for&lt;/c3&gt;をファイルハンドルを反復するために使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, though, you're safest using matching characters with Ps/Pe/Pi/Pf properties, though ASCII angle brackets are a notable exception, since they're bidirectional but not in the Ps/Pe/Pi/Pf sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際には、しかし、それらが双方向性であるが、Ps/Pe/Pi/Pfセットでない時から、ASCIIかぎ括弧が顕著な例外であるけれども、あなたはマッチする文字を使用してPs/Pe/Pi/Pfプロパティにとって最も安全である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In string contexts, lists and list-like objects automatically stringify to appropriate (white-space separated) string values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022516Z" creationid="Toshiyuki" creationdate="20140329T022516Z">
        <seg>文字列コンテキストでは、リストとリストのようなオブジェクトは自動的に適切な（空白で区切られた）文字列値に文字列化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the absence of a universal naming scheme, it can only be made improbable that two addresses from two different spaces will collide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的な命名スキームがない場合、2つの異なるスペースからの2アドレスが衝突することは、ありそうもなくなることができるだけである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the absence of explicit control flow terminating the block early, the return value of a block is the value of its final statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T165145Z" creationid="Toshiyuki" creationdate="20130802T165145Z">
        <seg>ブロックを早期に終える明白な制御フローがない場合、ブロックの返り値は最後の文の値だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the abstract, Perl is written in Unicode, and has consistent Unicode semantics regardless of the underlying text representations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>抽象的に、Perlにはユニコードに書かれて、根底にある文字列内部表現に関係なく一貫したユニコード意味論がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of &lt;c0&gt;my $x&lt;/c0&gt;, the lexpad entry for the variable &lt;c1&gt;$x&lt;/c1&gt; is a pointer to an object of type &lt;c2&gt;Scalar&lt;/c2&gt;, usually just called &lt;e3&gt;the container&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T130924Z" creationid="yamato" creationdate="20140914T130924Z">
        <seg>&lt;c0&gt;my $x&lt;/c0&gt;の場合、変数&lt;c1&gt;$x&lt;/c1&gt;のためのlexpadエントリーは&lt;c2&gt;Scalar&lt;/c2&gt;型オブジェクトのポインタで、通常は単に&lt;e3&gt;コンテナ&lt;/e3&gt;と呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case where you want all your parameters to default to &lt;c0&gt;rw&lt;/c0&gt;, you may use the visually suggestive double-ended arrow to indicate that values flow both ways:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113722Z" creationid="Toshiyuki" creationdate="20130810T113722Z">
        <seg>このケースで全てのパラメータを&lt;c0&gt;rw&lt;/c0&gt;としたいなら、値の流れを視覚的に表す両頭矢印を使ってもよい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first place, not all objects are in the same memory space (see the literature on NUMA, for instance), and two objects should not accidentally have the same identity merely because they were stored at the same offset in two different memory spaces.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第一に、すべてのオブジェクトが同じメモリ空間（たとえば、NUMAについての文献を見る）にあるというわけではない、そして、単にそれらが2つの異なるメモリ空間に同じオフセットで保存されたのでだけ、2つのオブジェクトには同じアイデンティティが偶然にあってはならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the identifier form a colonpair, the optional value can be any circumfix.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T123744Z" creationid="yamato" creationdate="20140914T123744Z">
        <seg>コロンペアの形式の識別子でオブションの値は何らかのcircumfixでありえる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In theory, any user-defined control construct can catch any control exception it likes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T075745Z" creationid="Toshiyuki" creationdate="20130817T075735Z">
        <seg>理論的には、どれか一つのユーザー定義の制御構造はそれのように制御例外をキャッチできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these examples, the first argument to the function is a parcel in all but the first case, where it is simply the literal integer 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの例では、関数に対する最初の引数は最初のケース以外はのパーセルである、そこで、それは単に文字通りの整数1である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the &lt;c3&gt;!&lt;/c3&gt; twigil emphasizes that this attribute is private to the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182723Z" creationid="Toshiyuki" creationdate="20140111T182723Z">
        <seg>この場合、&lt;c3&gt;!&lt;/c3&gt; twigilは属性がクラスにプライベートであることを強調します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Individual arguments in a parcel or capture composer are parsed as ordinary expressions, and any functions mentioned are called immediately, with each function's results placed as an argument (often a subparcel, if the function returns multiple values) within the outer parcel (or capture).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パーセルまたはキャプチャーコンポーザーの個々の引数は普通の表現として解析される、そして、各機能の結果が外のパーセル（またはキャプチャー）の中の引数（しばしばsubparcelファンクションリターン多値ならば）とわかって、記載の何か関数はすぐに呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Individual objects can override the class definition:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>個々のオブジェクトは、クラス定義にオーバーライドすることができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Infinity and NaN</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無限とNaN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheritance</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T092803Z" creationid="Toshiyuki" creationdate="20140112T092803Z">
        <seg>継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside a method, &lt;c0&gt;self&lt;/c0&gt; refers to the invocant (i.e. the object the method was called on).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124540Z" creationid="yamato" creationdate="20140914T124540Z">
        <seg>メソッド内で&lt;c0&gt;self&lt;/c0&gt;はインボカントを参照する（すなわちメソッドが呼ばれたオブジェクト）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the &lt;c0&gt;CATCH&lt;/c0&gt; block, the exception in question is bound to &lt;c1&gt;$_&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T130230Z" creationid="Toshiyuki" creationdate="20130813T130230Z">
        <seg>&lt;c0&gt;CATCH&lt;/c0&gt;ブロック内部で、問題の例外は&lt;c1&gt;$_&lt;/c1&gt;にバインドされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the subroutine, the lexpad entry for &lt;c0&gt;$a&lt;/c0&gt; points to the same container that &lt;c1&gt;$x&lt;/c1&gt; points to outside the subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T132130Z" creationid="yamato" creationdate="20140914T132130Z">
        <seg>サブルーチン内で&lt;c0&gt;$a&lt;/c0&gt;のためのlexpadエントリーはサブルーチンの外をポイントする&lt;c1&gt;$x&lt;/c1&gt;と同じコンテナをポイントする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instantiated objects default to true unless the class overrides the definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスが定義にオーバーライドしない限り、具体例をあげて示されたオブジェクトは真にデフォルトでなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead &lt;c0&gt;do {...}&lt;/c0&gt; is the do-once loop (which is another reason you can't put a statement modifier on it; use &lt;c1&gt;repeat&lt;/c1&gt; for a test-at-the-end loop).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T121058Z" creationid="Toshiyuki" creationdate="20130810T121058Z">
        <seg>代わりに&lt;c0&gt;do {...}&lt;/c0&gt;はdo-onceループだ（それは文修飾子を置くことができないもう一つの理由だ；&lt;c1&gt;repeat&lt;/c1&gt;をtest-at-the-endループのために使え）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of</seg>
      </tuv>
      <tuv lang="JA">
        <seg>の代わりに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of defining macros directly you may also mix in one or more grammar rules by lexically scoped declaration of a new sublanguage:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>直接マクロを定義する代わりに、あなたは新しい部分言語の辞書的に捜し出された宣言によって、一つ以上の文法規則も混ぜるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of the &lt;c2&gt;!&lt;/c2&gt; twigil, this twigil is &lt;c3&gt;.&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T183241Z" creationid="Toshiyuki" creationdate="20140111T183241Z">
        <seg>&lt;c2&gt;!&lt;/c2&gt; twigilの代わりにこのtwigilは&lt;c3&gt;.&lt;/c3&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, objects of various types can carry type information while nevertheless remaining undefined themselves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、それでも自分自身未定義ままの間、様々な型のオブジェクトは型情報をもたらすことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, use a &lt;c1&gt;NEXT&lt;/c1&gt; block within the body of the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130901Z" creationid="Toshiyuki" creationdate="20130808T130901Z">
        <seg>代わりに、&lt;c1&gt;NEXT&lt;/c1&gt;ブロックをループの本体内で使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you must assign directly using the package name to get that to work:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、あなたは、仕事にそれを得るためにパッケージ名を直接使用することを割り当てなければならない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you should write the more Pascal-like &lt;c0&gt;repeat&lt;/c0&gt; loop:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T151411Z" creationid="Toshiyuki" creationdate="20130809T151411Z">
        <seg>代わりとして、よりパスカル的な&lt;c0&gt;repeat&lt;/c0&gt;ループを書くべきだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolating into a single-quoted string</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一つの引用符付きの文字列への補間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolating into names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前への補間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interpolation rules</seg>
      </tuv>
      <tuv lang="JA">
        <seg>展開規則</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introspection</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043536Z" creationid="Toshiyuki" creationdate="20140322T043536Z">
        <seg>イントロスペクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introspection is the process of gathering information about some objects in your program, not by reading the source code, but by querying the object (or a controlling object) for some properties, like its type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T050723Z" creationid="Toshiyuki" creationdate="20140112T135453Z">
        <seg>イントロスペクションはソースコードを読むことによってでなく、いくつかのプロパティ（その型のような）のためにオブジェクト（またはコントロールしているオブジェクト）に問い合わせることによって、あなたのプログラムのいくつかのオブジェクトに関する情報を収集するプロセスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introspection is very useful for debugging, and for learning the language and new libraries.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110329Z" creationid="Toshiyuki" creationdate="20140112T160539Z">
        <seg>イントロスペクションはデバッギングのために、そして言語と新しいライブラリを学ぶために非常に有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invariant sigils</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021914Z" creationid="Toshiyuki" creationdate="20140329T021914Z">
        <seg>不変のシギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also gives us a reasonable way of visually isolating any known literal format as a single syntactic unit:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それも、我々に一つの構文法の単位として何か既知の文字通りのフォーマットを視覚的に孤立させることの合理的な方法を与える：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also makes the &lt;c8&gt;try&lt;/c8&gt; keyword redundant, because any block can function as a &lt;c9&gt;try&lt;/c9&gt; block if you put a &lt;c10&gt;CATCH&lt;/c10&gt; block within it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T122339Z" creationid="Toshiyuki" creationdate="20130813T122339Z">
        <seg>それはまた&lt;c8&gt;try&lt;/c8&gt;キーワードを冗長にさせる。なぜならどんなブロックでも&lt;c10&gt;CATCH&lt;/c10&gt;ブロックを中に置けば&lt;c9&gt;try&lt;/c9&gt;ブロックとして機能できるからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also never looks for arguments, so the next token should be an operator or terminator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それも引数を決して探さないので、次のトークンは演算子またはターミネータでなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It declares the new type name in the same scope as that of the associated declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、関連した宣言のそれと同じスコープで、新しいタイプ名を宣言する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It either returns an unthrown exception, or throws the exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T170453Z" creationid="Toshiyuki" creationdate="20130817T170453Z">
        <seg>それはスローされない例外または例外をスローする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It explains the levels of indirection involved in dealing with variables and container elements.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T130045Z" creationid="yamato" creationdate="20140914T130045Z">
        <seg>それは変数とコンテナ要素を処理することに関係している間接手段のレベルを説明する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has dependent tasks:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T091854Z" creationid="Toshiyuki" creationdate="20140112T091854Z">
        <seg>それは、従属する仕事を持っています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a transitive contextualizer insofar as iterators will have to pass on the policy to subiterators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>反復子が保険証書をsubiteratorsに渡さなければならない限り、それは他動的なcontextualizerである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is allowed to have a cascade of argumentless methods as long as the last one ends with parens:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後のものが括弧で終わる限り、それはたくさんのargumentlessなメソッドがあるのを許される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to interpolate multiple codepoints that do not resolve to a single character:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一文字に分解しない複数のコードポイントを差し込むことも、あり得る：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is created by the comma operator, and often delimited by round parenthesis -- hence the name.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T134148Z" creationid="yamato" creationdate="20140914T134148Z">
        <seg>それはコンマ演算子で作成され、しばしば丸括弧で区切られる―このための名前だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is erroneous to pass such a non-dimensional number to a routine that would interpret it with the wrong units.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>間違った単位でそれを解釈するルーチンにそのような無次元数を通過することは、誤りである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is given as a trait of the variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224539Z" creationid="Toshiyuki" creationdate="20140328T224539Z">
        <seg>それは変数のトレイトとして与えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is illegal to assign or bind a dynamic variable that does not already exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すでに存在しない動的変数を割り当てるか、結びつけることは、無効である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is illegal to return from the closure if that &lt;c0&gt;Routine&lt;/c0&gt; no longer owns a call frame in the current call stack.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T045817Z" creationid="Toshiyuki" creationdate="20130817T045817Z">
        <seg>&lt;c0&gt;Routine&lt;/c0&gt;が現在のコールスタックでもうコールフレームを所持していないならクロージャから戻るのは不当だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not the most general type, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、それは最も一般的な型でない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is often convenient to have names that contain arbitrary characters or other data structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意の文字またはその他のデータ構造を含む名前を持つことは、しばしば便利である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is particularly important to be able to handle exceptions in-band when you are trying to perform parallel operations, so that the failure of one computation does not result in fratricide of all its fellow computations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが並行オペレーションを行おうとしているとき、帯域内例外を取り扱うことができることは特に重要である、そのため、1つの計算の失敗が結果としてすべてのその仲間の計算の兄弟殺しになるというわけではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to create "variables" in Perl 6 that do not have sigils:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T033310Z" creationid="yamato" creationdate="20140914T033243Z">
        <seg>Perl 6でシギルを持たない「変数」を作ることが可能だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to fail with a resumable exception, such as a warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T073634Z" creationid="Toshiyuki" creationdate="20130818T073634Z">
        <seg>警告のように、再開可能な例外と共に失敗することが可能だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is relatively easy to smartmatch these constant objects against pairs to check various attributes such as name, version, or authority:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの定数がいろいろな属性（例えば名前、バージョンまたは権限）をチェックするために組に対して反対することは、スマートマッチに比較的容易である：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is suggested that all graphemes be translated on input to unique grapheme numbers and represented as integers within some kind of uniform array for fast substr access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての書記素がユニークな書記素番号への入力で変形されて、速いsubstrアクセスのための何らかの均一な配列の中の整数として表現されることを示唆される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the default parameter for blocks that do not have an explicit signature, so constructs like &lt;c1&gt;for @array { ... }&lt;/c1&gt; and &lt;c2&gt;given $var { ... }&lt;/c2&gt; binds to &lt;c3&gt;$_&lt;/c3&gt; simply by invoking the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T111614Z" creationid="yamato" creationdate="20140914T111614Z">
        <seg>それは明示的シグネチャを持たないブロックのためのデフォルトパラメータで、&lt;c1&gt;for @array { ... }&lt;/c1&gt;や&lt;c2&gt;given $var { ... }&lt;/c2&gt;のような構造はブロックを起動することで単純に&lt;c3&gt;$_&lt;/c3&gt;へバインドする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the unit type, but includes units that are containers of multiple values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは単位型であるが、多値のコンテナである単位を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may not be followed by any dereferencers, since you can always put them inside the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが常にそれらをクロージャに入れることができる時から、それの後に何かdereferencersが続かないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may not be shared, at least not without explicit consent of all parties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>少なくともすべての党の明示的同意なしででない、それは共有されないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It means "there is no value here".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132653Z" creationid="Toshiyuki" creationdate="20140327T132653Z">
        <seg>それは「ここに値はない」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It merely assigns an undefined &lt;c2&gt;Dog&lt;/c2&gt; prototype object to &lt;c3&gt;$spot&lt;/c3&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133740Z" creationid="Toshiyuki" creationdate="20140327T133728Z">
        <seg>それは単に未定義の&lt;c2&gt;Dog&lt;/c2&gt;プロトタイプオブジェクトを&lt;c3&gt;$spot&lt;/c3&gt;に割り当てるだけです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It merely changes the work-ahead policy for the value generator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、単に仕事前進方針を値発生器と交換するだけである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It only depends on the $.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T041420Z" creationid="yamato" creationdate="20140914T041420Z">
        <seg>それは$だけに依存する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns &lt;c10&gt;True&lt;/c10&gt; for handled exceptions and for all non-&lt;c11&gt;Failure&lt;/c11&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161809Z" creationid="Toshiyuki" creationdate="20130817T161809Z">
        <seg>それはハンドルされる例外と全ての非&lt;c11&gt;Failure&lt;/c11&gt;オブジェクトのために&lt;c10&gt;True&lt;/c10&gt;を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns other objects unchanged.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、他のオブジェクトに不変であると返る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It showcases custom constructors, private and public attributes, methods and various aspects of signatures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044921Z" creationid="Toshiyuki" creationdate="20140111T175137Z">
        <seg>それは、シグネチャーのカスタムコンストラクタ、プライベートとパブリック属性、メソッドといろいろな側面を公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It stores the result of each regex match, and usually contains objects of type &lt;a1&gt;Match&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T112758Z" creationid="yamato" creationdate="20140914T112758Z">
        <seg>それはそれぞれの正規表現のマッチを保存し、通常は&lt;a1&gt;Match&lt;/a1&gt;型オブジェクトを含んでいる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It takes no parameters, working instead with the object's attributes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T190552Z" creationid="Toshiyuki" creationdate="20140111T190552Z">
        <seg>それはパラメータをとりません。そして、オブジェクトの属性でその代わりに作業します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will not automatically dereference to its contents unless placed explicitly in some kind of dereferencing context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>はっきりと何らかの間接参照前後関係に置かれない限り、それは自動的に内容に間接参照を遺贈しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It works exactly like &lt;c3&gt;temp&lt;/c3&gt;, except that the value will be restored only if the current block exits unsuccessfully.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T134934Z" creationid="Toshiyuki" creationdate="20130802T134934Z">
        <seg>現在のブロックを失敗して抜ける場合だけ値が復元されることを除き、ちょうど&lt;c3&gt;temp&lt;/c3&gt;のよに動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's always spelled &lt;c1&gt;for&lt;/c1&gt; in Perl 6, so it always takes a list as an argument:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060854Z" creationid="Toshiyuki" creationdate="20130810T060854Z">
        <seg>Perl 6では常に&lt;c1&gt;for&lt;/c1&gt;と綴られるので、常に引数としてリストを取る：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's as if you had written:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184235Z" creationid="Toshiyuki" creationdate="20140111T184235Z">
        <seg>それは次のように書いたかのようです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's illegal to use the colon in place of the comma anywhere except after the first argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の引数の後あること以外は、どこでもコンマの代わりにコロンを使うことは無効である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's not an error to pass parameters to such a block either:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T151941Z" creationid="Toshiyuki" creationdate="20130810T151941Z">
        <seg>そのようなブロックにパラメータを渡すのはどちらもエラーではない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's not very much code, and yet the result is interesting and, at times, useful.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T044926Z" creationid="Toshiyuki" creationdate="20140111T175149Z">
        <seg>それはあまりコードでありませんが、結果は面白くて、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Item and List Assignment</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021643Z" creationid="yamato" creationdate="20140914T021643Z">
        <seg>アイテムとリストの割り当て</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Item assignment places the value from the right-hand side into the variable (container) on the left.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T024906Z" creationid="yamato" creationdate="20140914T024410Z">
        <seg>アイテム割り当ては左側の変数（コンテナ）に右側の値を配置する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Item containers prevent flattening, thus allowing the programmer to write nested data structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T141303Z" creationid="yamato" creationdate="20140914T141303Z">
        <seg>アイテムコンテナはフラット化を防ぐ。したがってネストしてあデータ構造をプログラマに書くことを許す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterable types may have multiple iterators (lists) running across them simultaneously, but an iterator/list itself has only one thread of consumption.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Iterableな型には同時にそれらに出会っている複数の反復子（リスト）があるかもしれない、しかし、反復子/リストそのものは消費の1つのスレッドだけを持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterations that return &lt;c0&gt;()&lt;/c0&gt; (such as by calling &lt;c1&gt;next&lt;/c1&gt; with no extra return arguments) return that &lt;c2&gt;()&lt;/c2&gt; as the next value, which will therefore disappear when interpolated in flat context, but will interpolate an empty &lt;c3&gt;Parcel&lt;/c3&gt; into slice context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T141044Z" creationid="Toshiyuki" creationdate="20130809T141044Z">
        <seg>&lt;c0&gt;()&lt;/c0&gt;を返す反復（&lt;c1&gt;next&lt;/c1&gt;を余分なリターン引数なしに呼ぶような）は&lt;c2&gt;()&lt;/c2&gt;を次の値として返す。それによってフラットコンテキストに保管された時に見えなくなる。しかしスライスコンテキストでは空の&lt;c3&gt;Parcel&lt;/c3&gt;を補完する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterators feeding a list are allowed to process in batches, even when stored within an array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の中で格納されるときでも、リストを供給している反復子はバッチでプロセスまで許される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as a &lt;c2&gt;my&lt;/c2&gt; variable can not be accessed from the outside of its declared scope, attributes are not accessible outside of the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182227Z" creationid="Toshiyuki" creationdate="20140111T182227Z">
        <seg>&lt;c2&gt;my&lt;/c2&gt;変数が宣言されたスコープの外側からアクセス出来ないように、属性はクラスの外からアクセスできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just subscript the package object itself as a hash object, the key of which is the variable name, including any sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ちょうどそれ自体ハッシュオブジェクト（キー）としてのパッケージオブジェクトが変数名（何かシギルを含む）である添え字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lazy flattening</seg>
      </tuv>
      <tuv lang="JA">
        <seg>怠惰な平坦化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Leading and trailing whitespace is ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>主要なおよび後置空白文字は無視される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Leading whitespace equivalent to the indentation of the delimiter will be removed from all preceding lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デリミタのインデントへの主要な空白文字等価物は、すべての前の線から取り除かれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Less obviously, so does a &lt;c3&gt;gather&lt;/c3&gt;; if a &lt;c4&gt;gather&lt;/c4&gt; lexically contains any &lt;c5&gt;take&lt;/c5&gt; calls, it is marked as lexotic-only, and it will be invisible to a dynamic &lt;c6&gt;take&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T160003Z" creationid="Toshiyuki" creationdate="20130810T160003Z">
        <seg>あまり明らかでない、それゆえ&lt;c3&gt;gather&lt;/c3&gt;を行う；もし&lt;c4&gt;gather&lt;/c4&gt;が何か一つの&lt;c5&gt;take&lt;/c5&gt;呼び出しをレキシカルに含んでいるなら、それはlexotic-onlyとしてマークされる。そしてダイナミックな&lt;c6&gt;take&lt;/c6&gt;には不可視になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexical Conventions</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053423Z" creationid="Toshiyuki" creationdate="20140330T053423Z">
        <seg>レキシカルの規則</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexically scoped parser changes should temporize the modification.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書的に捜し出された構文解析器変化は一時しのぎをしなければならない修正。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexicals may not "leak" from a block to any other external scope (at least, not without some explicit aliasing action on the part of the block, such as exportation of a symbol from a module).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T124829Z" creationid="Toshiyuki" creationdate="20130730T124829Z">
        <seg>レキシカルはブロックから他の外部スコープへは「リーク」しない（少なくともモジュールからのシンボルのエクスポートのような、ブロック部分のいくつかの明示的なエイリアシングが無い場合）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexing in Perl 6 is controlled by a system of grammatical categories.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6のLexingは、文法範疇のシステムによって支配される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexotic operators in Perl 6 include:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T010307Z" creationid="Toshiyuki" creationdate="20130728T010307Z">
        <seg>Perl 6のレギゾチック演算子は以下を含む：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like &lt;c2&gt;do&lt;/c2&gt;, it is followed by a statement or block, and executes it once.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152531Z" creationid="Toshiyuki" creationdate="20130810T152531Z">
        <seg>&lt;c2&gt;do&lt;/c2&gt;のように、それには文かブロックが続き、一回実行する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like named parameters in a call, there is no order in handling multiple adverbs with subscripts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>呼び出しの挙げられたパラメータのように、順序が、添え字で複数の副詞を取り扱う際にない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise a routine can return a container if it is marked as &lt;c0&gt;is rw&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T132403Z" creationid="yamato" creationdate="20140914T132403Z">
        <seg>同様に&lt;c0&gt;is rw&lt;/c0&gt;とマークされているならルーチンはコンテナを返すことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise any non-alphanumeric character is assumed to be equivalent to a dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、何か非英数字文字は、点に等しいとされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise any subscripting operation on &lt;c19&gt;Nil&lt;/c19&gt; returns &lt;c20&gt;Nil&lt;/c20&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133123Z" creationid="Toshiyuki" creationdate="20140327T133123Z">
        <seg>どうように&lt;c19&gt;Nil&lt;/c19&gt;での添字付け演算子も&lt;c20&gt;Nil&lt;/c20&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, discarding the failure in sink context produces an immediate exception.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、不履行シンク前後関係を放棄することは、即時の例外を生じる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, temporization is never needed for &lt;c1&gt;statement_control:&lt;for&gt;&lt;/c1&gt; because it always calls a closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T120043Z" creationid="Toshiyuki" creationdate="20130810T120043Z">
        <seg>同様に、&lt;c1&gt;statement_control:&lt;for&gt;&lt;/c1&gt;のためにテンポラリー化は決して必要ない。なぜならそれは常にクロージャを呼び出すからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, we can just remember the gather's result parcel by binding and later coercing it:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T040204Z" creationid="Toshiyuki" creationdate="20130811T040204Z">
        <seg>同様に、我々はちょうどgatherの結果のパーセルをバインドと後での強制によって覚えることができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List assignment and binding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リスト割当てとバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List assignment is also implicitly eager.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リスト割当ても、暗黙のうちに熱心である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List assignment leaves the choice of what to do to the variable on the left.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T024545Z" creationid="yamato" creationdate="20140914T024545Z">
        <seg>リスト割り当ては左の変数に何をすべきかという選択肢を残す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List assignment works much like it does in Perl 5, copying the values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがPerl 5でするように、リスト割当ては非常に動く。そして、値をコピーする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List context in Perl 6 is by default lazy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6のリストコンテキストは、デフォルトで怠惰である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List sorting</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストソーティング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List stringification</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022409Z" creationid="Toshiyuki" creationdate="20140329T022409Z">
        <seg>リストの文字列化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lists</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literals</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T120105Z" creationid="Toshiyuki" creationdate="20140329T120105Z">
        <seg>リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literals, on the other hand, may default to native storage formats if they reasonably can.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが合理的にそうすることができるならば、リテラルは、他方、ネイティブ記憶領域フォーマットにデフォルトでなるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looking at it the other way, all arguments that don't actually need to be wrapped up in a parcel are considered degenerate parcels in their own right when it comes to binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その他の方法でそれを見て、実はパーセルに包まれる必要はないすべての引数は、バインディングに関しては右のよく考えた退歩したパーセルである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop commands like &lt;c1&gt;next&lt;/c1&gt; are abnormal, but looping because you hit the end of the block is not.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125031Z" creationid="Toshiyuki" creationdate="20130816T125031Z">
        <seg>&lt;c1&gt;next&lt;/c1&gt;のようなループコマンドはアブノーマルだ。しかしあなたがブロックの終端をヒットするルーピングは違う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop modifiers &lt;c0&gt;next&lt;/c0&gt;, &lt;c1&gt;last&lt;/c1&gt;, and &lt;c2&gt;redo&lt;/c2&gt; also work much as in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T041904Z" creationid="Toshiyuki" creationdate="20130806T041904Z">
        <seg>ループ修飾子&lt;c0&gt;next&lt;/c0&gt;、&lt;c1&gt;last&lt;/c1&gt;、&lt;c2&gt;redo&lt;/c2&gt;もPerl 5と同様に動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130805T161445Z" creationid="Toshiyuki" creationdate="20130805T161445Z">
        <seg>ループ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Looping statement modifiers are the same as in Perl 5 except that, for ease of writing list comprehensions, a looping statement modifier is allowed to contain a single conditional statement modifier:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T041823Z" creationid="Toshiyuki" creationdate="20130806T041823Z">
        <seg>ループ文修飾子はPerl 5と同様だ。リストを書く可読性のために、ループ文修飾子はひとつの条件文修飾子を含むことが許可されることを除けば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Magic command-line input handle.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115052Z" creationid="yamato" creationdate="20140914T115052Z">
        <seg>マジックコマンドライン入力ハンドル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Magical access to documentation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ドキュメンテーションへの不思議な接近</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Magical lexically scoped values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不思議な辞書的に捜し出された値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Maintaining a particular grapheme/id mapping over the life of the process may have some GC implications for long-running processes, but most processes will likely see a limited number of non-precomposed graphemes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロセスの人生の間特定の書記素/IDマッピングを維持することは長時間にわたるプロセスへの若干のGC含みがあるかもしれない、しかし、大部分のプロセスは限られた数の非precomposedされた書記素にたぶん遭遇する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many constructs define a particular interplay of lexical and dynamic features.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T153018Z" creationid="Toshiyuki" creationdate="20130727T153018Z">
        <seg>多くの構成物がレキシカルとダイナミックの機能の特定の相互作用を定義する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of the special variables of Perl 5 are going away.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090305Z" creationid="Toshiyuki" creationdate="20140329T090305Z">
        <seg>Perl 5の多くの特殊変数は無くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Match objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T024614Z" creationid="Toshiyuki" creationdate="20140222T024614Z">
        <seg>マッチオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matches of constant pairs on constant objects may all be resolved at compile time, so dead code can be eliminated by the optimizer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>恒常的なオブジェクトの一定の組のマッチのすべてはコンパイル時で分解されるかもしれないので、不要コードはオプティマイザーによって除かれることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matching a string against that regex searches for that string:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140321T022431Z" creationid="Toshiyuki" creationdate="20140115T143522Z">
        <seg>その正規表現と文字列をマッチングすることは、その文字列を捜します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Meaning</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T232450Z" creationid="Toshiyuki" creationdate="20140221T232450Z">
        <seg>意味</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method calls</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドは訪問する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184849Z" creationid="Toshiyuki" creationdate="20140111T184849Z">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods on Arrays</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T141203Z" creationid="Toshiyuki" creationdate="20140327T141203Z">
        <seg>配列のメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Missing final positions are assumed to be '.0'.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>なくなった最終位置は、'.0'であるとされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifiers</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140222T015922Z" creationid="Toshiyuki" creationdate="20140222T015922Z">
        <seg>修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules with such strange versions can still be used by Perl since by default Perl imports external modules by exact version number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デフォルトによってPerlが正確なバージョン番号によって外端モジュールを輸入する時から、そのような変なバージョンによるモジュールがまだPerlによって使われることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More abstractly, any declarations associated with those textual blocks are also considered to be part of the lexical scope, and this is where the term earns the "lexical" part of its name, in the sense that lexical scoping actually does define the "lexicon" for the current chunk of code, insofar as the definitions of variables and routines create a local domain-specific language.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T140658Z" creationid="Toshiyuki" creationdate="20130727T140145Z">
        <seg>より抽象的には、それらのテキストブロックに関連付けられた宣言は全てレキシカルスコープの一部とみなされ、そしてこれは名前のレキシカル部分を得る場所でもある。という訳で、変数とルーチンの定義が局所的なドメイン固有言語を創造する限りにおいて、レキシカルスコープは現在のコードのチャンクのための辞書を実際に定義する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More generally, a parcel is transmuted to a capture any time it is bound to a complete signature.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より通常、それが完全なシグネチャの束縛を受ける何か時、パーセルはキャプチャーに変えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More precisely, it first scans outward (lexically) for the innermost containing &lt;c2&gt;when&lt;/c2&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T113612Z" creationid="Toshiyuki" creationdate="20130812T113612Z">
        <seg>より正確には、それは最初に&lt;c2&gt;when&lt;/c2&gt;ブロックを含む最も深い部分を外側へ（レキシカルに）スキャンする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More specifically, these are the methods that are culturally universal, insofar as the typical user will expect the name of the method to imply conversion to a particular built-in type that understands the method in question.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より詳しくは、典型的ユーザーがメソッドの名前が問題のメソッドを理解する特定の組込み型への転換を意味すると思う限り、これらは文化的に一般的であるメソッドである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More specifically, when you write:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T105641Z" creationid="Toshiyuki" creationdate="20130814T105641Z">
        <seg>より明白には、あなたが次のように書くとき：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most Unix systems can count clock ticks, even if POSIX time types get confused.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえPOSIX回の型が混乱するとしても、大部分のUnixシステムはクロック単位を数えることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most list contexts are flat rather than sliced, so the boundaries between individual &lt;c2&gt;take&lt;/c2&gt; calls usually disappear.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T205908Z" creationid="Toshiyuki" creationdate="20130810T205908Z">
        <seg>最も多いリストコンテキストはスライスよりもフラットなので、個々の&lt;c2&gt;take&lt;/c2&gt;呼び出しの間の境界は普通は見えなくなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the built-in numeric operators fall into this category.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大部分のビルトイン算術演算子は、このカテゴリーに分類される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the non-value-producing phasers may also be so used:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085336Z" creationid="Toshiyuki" creationdate="20130818T085336Z">
        <seg>大部分の値を出さないphasersも使うことができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most symbolic references are done with this notation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大部分の記号参照は、この表記法でされる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most syntactic constructs in Perl 6 can be categorized in &lt;e0&gt;terms&lt;/e0&gt; and &lt;a1&gt;operators&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T121603Z" creationid="yamato" creationdate="20140914T121603Z">
        <seg>Perl 6の大部分の構文法の構造は&lt;e0&gt;項&lt;/e0&gt;と&lt;a1&gt;演算子&lt;/a1&gt;に分類できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mostly that just means you can't write:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大部分はあなたが書くことができないその正当な手段：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Much like &lt;c0&gt;return&lt;/c0&gt; may only return from an "official" subroutine or method, a loop exit like &lt;c1&gt;next&lt;/c1&gt; should be caught by the construct the user expects it to be caught by.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T080353Z" creationid="Toshiyuki" creationdate="20130817T080353Z">
        <seg>とても似ている&lt;c0&gt;return&lt;/c0&gt;は「公式な」サブルーチンかメソッドからだけ戻れる。&lt;c1&gt;next&lt;/c1&gt;のようなループの脱出はユーザーがキャッチされると期待する構造にキャッチされるべきだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multidimensional slices and parcels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多次元スライスとパーセル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiline Comments</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053441Z" creationid="Toshiyuki" creationdate="20140330T053441Z">
        <seg>複数行コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple Inheritance</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T125409Z" creationid="Toshiyuki" creationdate="20140112T125409Z">
        <seg>多重継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple dereferencers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のdereferencers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple dereferencers may be stacked as long as each one ends in some kind of bracket or is a bare method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれが何らかのブラケットで終わるか、裸のメソッドである限り、複数のdereferencersは積み重なるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple parameters may be passed, in which case the list is traversed more than one element at a time:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T061613Z" creationid="Toshiyuki" creationdate="20130810T061613Z">
        <seg>複数のパラメータが渡されるようなら、その場合はリストは一度に一つ以上の要素を横断される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutable types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変わりやすい型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Name Equivalence of Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053537Z" creationid="Toshiyuki" creationdate="20140330T053537Z">
        <seg>型の名前同一性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T091745Z" creationid="Toshiyuki" creationdate="20140329T091745Z">
        <seg>名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names and Variables</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000030Z" creationid="Toshiyuki" creationdate="20140329T000030Z">
        <seg>名前と変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names may also be declared in the signature of a function.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021445Z" creationid="Toshiyuki" creationdate="20140329T021445Z">
        <seg>名前は関数のシグネチャーでも宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Native buf Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブbuf型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Native types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Native types are primarily intended for declaring compact array storage, that is, a sequence of storage locations of the specified type laid out in memory contiguously without pointer indirection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ネイティブ型は、主にコンパクトな配列記憶領域（つまり、ポインター間接的行動なしで隣接してメモリで配置される指定された型の一連の記憶場所）を宣言することを意図される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New quoting constructs may be declared as macros:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい引合いに出している構成概念は、マクロと宣言されるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next to assignment, Perl 6 also supports &lt;e0&gt;binding&lt;/e0&gt; with the &lt;c1&gt;:=&lt;/c1&gt; operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T133018Z" creationid="yamato" creationdate="20140914T133018Z">
        <seg>割り当ての次に、Perl 6は&lt;c1&gt;:=&lt;/c1&gt;演算子による&lt;e0&gt;バインディング&lt;/e0&gt;もサポートする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nil</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Nil</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No additional context is applied by the &lt;c1&gt;take&lt;/c1&gt; operator, since all context is lazy in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T201307Z" creationid="Toshiyuki" creationdate="20130810T201307Z">
        <seg>&lt;c1&gt;take&lt;/c1&gt;演算子によって追加のコンテキストが何も適用されないので、Perl 6では全てのコンテキストはレイジーだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No flattening happens to a lazy list until it is bound to the signature of a function or method at call time (and maybe not even then).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが呼び出し時間（そして、多分均一でないそれから）に関数またはメソッドのシグネチャの束縛を受けるだろうまで、平坦化は怠惰なリストに起こらない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No intervening whitespace</seg>
      </tuv>
      <tuv lang="JA">
        <seg>中の空白文字でない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No magical syntax at a distance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>少し離れた不思議な構文でない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No other expressions interpolate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のいかなる表現も改竄しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No temporization is necessary with the explicit form since &lt;c0&gt;$_&lt;/c0&gt; is a formal parameter to the block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T115601Z" creationid="Toshiyuki" creationdate="20130810T115601Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;をブロックの仮パラメータにしてから明白な形式でテンポラリー化は必要ない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-closure-returning Operators with *</seg>
      </tuv>
      <tuv lang="JA">
        <seg>*をもつ非クロージャ返っている演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-container types define truthiness much as Perl 5 does.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5がそうして、非コンテナ型はtruthinessを非常に定義する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>None of these notations work in normal Perl code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの表記法のどれも、通常のPerlコードで動かない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nor should we be encouraging people to think of object locations that way in any case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、我々は人々がいずれにせよそのようにオブジェクト場所について考えるのを奨励していてはならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal flat list context ignores parcel boundaries and flattens the list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T135641Z" creationid="Toshiyuki" creationdate="20130808T131930Z">
        <seg>通常のフラットリストコンテキストはパーセルの境界を無視し、リストを平坦化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal names and variables are declared using a &lt;i0&gt;scope declarator&lt;/i0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021409Z" creationid="Toshiyuki" creationdate="20140329T021409Z">
        <seg>通常の名前と変数は&lt;i0&gt;スコープ宣言&lt;/i0&gt;で宣言されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that Perl 5's special rule causing</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T111901Z" creationid="Toshiyuki" creationdate="20130810T111627Z">
        <seg>次のことにも注意。Perl 5の特別な規則で</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that this is still a subset of the versioning schemes seen in the real world.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、これがまだ、リアルワールドで見られるバージョニングスキームのサブセットである点に注意しなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note how the attributes are declared as &lt;c0&gt;$.x&lt;/c0&gt; and &lt;c1&gt;$.y&lt;/c1&gt; but are still accessed via &lt;c2&gt;$!x&lt;/c2&gt; and &lt;c3&gt;$!y&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T053401Z" creationid="yamato" creationdate="20140914T053401Z">
        <seg>&lt;c0&gt;$.x&lt;/c0&gt;と&lt;c1&gt;$.y&lt;/c1&gt;として宣言された属性は &lt;c2&gt;$!x&lt;/c2&gt;と&lt;c3&gt;$!y&lt;/c3&gt;によってアクセスし続けることができるので注意が必要だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note how the last pair assume that an implicit .0 sorts after anything alphabetic, and that alphabetic is defined according to Unicode, not just according to ASCII.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の一組がそれを潜在的な.0とみなす方法が何の後ででもソートすることを注意するアルファベットの、まったくアルファベットの、ちょうどASCIIによればでない、定義済みに一致することは、ユニコードにある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T163309Z" creationid="Toshiyuki" creationdate="20130817T163309Z">
        <seg>ただし注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;c0&gt;$x&lt;/c0&gt; is also initialized to the &lt;c1&gt;Int&lt;/c1&gt; type object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132547Z" creationid="Toshiyuki" creationdate="20140327T132547Z">
        <seg>&lt;c0&gt;$x&lt;/c0&gt;は&lt;c1&gt;Int&lt;/c1&gt;型オブジェクトにも初期化されるので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;c0&gt;CATCH&lt;/c0&gt; blocks &lt;e1&gt;do not&lt;/e1&gt; set &lt;c2&gt;$!&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114114Z" creationid="yamato" creationdate="20140914T114114Z">
        <seg>注意として&lt;c0&gt;CATCH&lt;/c0&gt;ブロックは&lt;c2&gt;$!&lt;/c2&gt;をセット&lt;e1&gt;しない&lt;/e1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a capture is not considered a kind of parcel, so does not flatten in flat context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャーがパーセルの1種類考えられなくて、それで、平らな前後関係で平らにならないことに注意すべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that all those &lt;c0&gt;$=someBlockName&lt;/c0&gt; support the &lt;c1&gt;Positional&lt;/c1&gt; and the &lt;c2&gt;Associative&lt;/c2&gt; role.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T064603Z" creationid="yamato" creationdate="20140914T064603Z">
        <seg>それらの全ての&lt;c0&gt;$=someBlockName&lt;/c0&gt;は&lt;c1&gt;Positional&lt;/c1&gt;と&lt;c2&gt;Associative&lt;/c2&gt;ロールをサポートしている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that any &lt;c0&gt;die&lt;/c0&gt; in the catch lambda eventually rethrows outside the lambda as a new exception, but not until the current exception handler has a chance to handle all exceptions that came in via &lt;c1&gt;@!&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T113621Z" creationid="Toshiyuki" creationdate="20130814T113621Z">
        <seg>catch lambdaのどれかひとつの&lt;c0&gt;die&lt;/c0&gt;がlambdaを新しい例外として結局外側に再スローする。しかし現在の例外ハンドラが&lt;c1&gt;@!&lt;/c1&gt;を経て入るすべての例外をハンドルする機会を持つまでではない。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that any construct in the statement_prefix category defines special syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T121430Z" creationid="Toshiyuki" creationdate="20130811T121430Z">
        <seg>statement_prefixカテゴリーのどんな構成物も特別な文法を定義するので注意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that even though &lt;c2&gt;$^second&lt;/c2&gt; appears before &lt;c3&gt;$^first&lt;/c3&gt; in the code, &lt;c4&gt;$^first&lt;/c4&gt; is still the first formal parameter to that block.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T062351Z" creationid="yamato" creationdate="20140914T062351Z">
        <seg>コードの中で&lt;c2&gt;$^second&lt;/c2&gt;が&lt;c3&gt;$^first&lt;/c3&gt;の前に現れたとしても、&lt;c4&gt;$^first&lt;/c4&gt;は最初の仮パラメータのままなので注意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that since these are type names, parentheses must always be used to call them as coercers, since the listop form is not allowed for coercions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>listopの形がコアーションのために許されない時から、これらがタイプ名である時から、括弧が常に強制者としてそれらを呼ぶのに用いられなければならない点に注意しなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that some of these produce correspondingly named operators, but not all of them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの生産物の一部が対応してそれらの全てでなく、演算子の名前を挙げたことに注意すべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that subroutine signatures allow passing around of containers:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T132202Z" creationid="yamato" creationdate="20140914T131922Z">
        <seg>サブルーチンシグネチャにコンテナを渡すことが許される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that temporizations that are undone upon scope exit must be prepared to be redone if a continuation within that scope is taken.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T155653Z" creationid="Toshiyuki" creationdate="20130802T155653Z">
        <seg>スコープの終了でなされないテンポライゼーションは、そのスコープ内の継続が取られるならやり直すために準備されなければならないことに注意しろ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &lt;c0&gt;take&lt;/c0&gt; itself is in sink context in this example because the &lt;c1&gt;for&lt;/c1&gt; loop is in the sink context provided inside the gather.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T040458Z" creationid="Toshiyuki" creationdate="20130811T040458Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;自体はこの例ではsinkコンテキストにある。なぜならgather内に与えられた&lt;c1&gt;for&lt;/c1&gt;ループがsinkコンテキストにあるからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the final period above is not taken as part of the expression since it doesn't introduce a bracketed dereferencer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが括弧に入れられたdereferencerを導入しない時から、上記の最後の期間が表現の一部としてかかられないことに注意すべきである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the inside of the brackets is not an expression, and you may not interpolate there, since that would be a double interpolation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブラケットの内部が表現でないことに注意すべきである、そして、それが二重の補間法である時から、そこで改竄しなくてもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the item assignment has tighter precedence than list assignment, and also tighter than the comma.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T025754Z" creationid="yamato" creationdate="20140914T025754Z">
        <seg>アイテム割り当てがリスト割り当てとコンマより高い優先順位を持つことに注意するべきだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value being evaluated for truth and subsequently bound is not necessarily a value of type &lt;c0&gt;Bool&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T070604Z" creationid="Toshiyuki" creationdate="20130804T070604Z">
        <seg>真偽のために評価される、そしてその後に続いてバインドされる値は&lt;c0&gt;Bool&lt;/c0&gt;型である必要性はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is not like declaring a public attribute, as some languages allow; you really get &lt;e0&gt;both&lt;/e0&gt; a private storage location and a method, without having to write the method by hand.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045857Z" creationid="Toshiyuki" creationdate="20140111T184503Z">
        <seg>これはいくつかの言語が許すようなパブリックな属性を宣言するものではないので注意してください；あなたは手でメソッドを書くことなく、本当に&lt;e0&gt;両方の&lt;/e0&gt;プライベートな記録場所とメソッドを得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is one of those cases in which it is fine to have whitespace before the unspace, since we're only trying to suppress the newline transition, not all whitespace as in the case of postfix parsing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々が改行文字移行（接尾辞構文解析の場合のようにすべての空白文字でない）を抑制しようとしているだけの時から、これがunspaceの前に空白文字を持つために天気がよいそれらのケースの1つである点に注意しなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that trailing dots are not allowed, so you have to write &lt;c0&gt;1.0&lt;/c0&gt; instead of &lt;c1&gt;1.&lt;/c1&gt; (this rule is important because there are infix operators starting with a dot, for example the &lt;c2&gt;..&lt;/c2&gt; &lt;a3&gt;Range&lt;/a3&gt; operator).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T122329Z" creationid="yamato" creationdate="20140914T122329Z">
        <seg>後置のドットは許されない。なので&lt;c1&gt;1.&lt;/c1&gt;の代わりに&lt;c0&gt;1.0&lt;/c0&gt;と書かなければならない（ドットで始まる中置演算子があるのでこの規則は重要だ。例えば&lt;c2&gt;..&lt;/c2&gt;&lt;a3&gt;レンジ&lt;/a3&gt;演算子）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that type objects are not classes, but may be used to name classes when the type's associated meta-object allows it:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型オブジェクトがクラスでなくて、型の関連したメタオブジェクトがそれを許すとき名前クラスに使われるかもしれないことに注意すべきである：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that using the &lt;c0&gt;.&lt;/c0&gt; twigil has created a method that will provide with readonly access to the attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184701Z" creationid="Toshiyuki" creationdate="20140111T184701Z">
        <seg>&lt;c0&gt;.&lt;/c0&gt; twigilを使うと属性への読み取り専用アクセスのメソッドを作るので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that whitespace is not allowed before that, hence</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それゆえに、空白文字がそれの前に許されないことに注意すべきである</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085411Z" creationid="Toshiyuki" creationdate="20130818T085411Z">
        <seg>注意、けれども、その</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that repeated autoboxing and unboxing can make your program much slower, compared to a program that makes consistent use of either native types or object types.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>なお、しかし、それはautoboxingすることを繰り返した、そして、ネイティブ型かオブジェクトタイプを一貫して利用するプログラムと比較して、箱から出すことはあなたのプログラムを非常により遅くすることができる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that subclasses may override those methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T061232Z" creationid="yamato" creationdate="20140914T061232Z">
        <seg>しかしサブクラスがそれらのメソッドをオーバーライドするかもしれないので注意。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that these do not create &lt;a0&gt;containers&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T035007Z" creationid="yamato" creationdate="20140914T035007Z">
        <seg>しかしこれらが&lt;a0&gt;コンテナ&lt;/a0&gt;を作成しない点に注意が必要だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nothing is ever bound implicitly, however, and many conditionals would simply bind &lt;c0&gt;True&lt;/c0&gt; or &lt;c1&gt;False&lt;/c1&gt; in an uninteresting fashion.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T145004Z" creationid="Toshiyuki" creationdate="20130809T145004Z">
        <seg>これまでに何も暗黙にバインドされていない、どんな方法でも、そして多数の条件文が単純に&lt;c0&gt;True&lt;/c0&gt;か&lt;c1&gt;False&lt;/c1&gt;をつまらないやり方でバインドする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how the custom constructor and sensible use of whitespace allows a layout which makes task dependencies clear.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T142230Z" creationid="Toshiyuki" creationdate="20140314T142230Z">
        <seg>カスタムコンストラクタと気の利いた空白の使い方がタスクの依存を明白にレイアウトしていることに気づいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now all the methods made available by both the Programmer class and the Cook class are available from the GeekCook class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T134302Z" creationid="Toshiyuki" creationdate="20140112T134302Z">
        <seg>現在、ProgrammerクラスとCookクラスによって利用可能となるすべてのメソッドは、GeekCookクラスから入手可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now any object of type Programmer can make use of the methods and accessors defined in the Employee class as though they were from the Programmer class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T121712Z" creationid="Toshiyuki" creationdate="20140112T121542Z">
        <seg>Programmer型のオブジェクトならなんでも、Employeeクラスのメソッドとアクセサが使えます。それらがProgrammerクラスであったかのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric Coercion of StrPos or StrLen</seg>
      </tuv>
      <tuv lang="JA">
        <seg>StrPosまたはStrLenの数の強制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Numeric型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric and boolean context of hashes</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T085841Z" creationid="Toshiyuki" creationdate="20140329T085841Z">
        <seg>ハッシュの数値とブールコンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric and string conversions use these lazy warnings to allow (but not require) failsoft semantics.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T131145Z" creationid="Toshiyuki" creationdate="20130817T131145Z">
        <seg>数値と文字列の変換はフェールソフトセマンティクスを許可する（しかし要求されない）ためにlazy warningsを使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numerics in Perl are not designed to give the identical answer everywhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlの数字は、至る所で同一の答えをするようになっていない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Object Oriented Programming provides the concept of inheritance as one of the mechanisms to allow for code reuse.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T142325Z" creationid="Toshiyuki" creationdate="20140112T092844Z">
        <seg>オブジェクト指向プログラミングは、コードの再利用を可能にするメカニズムの1つとして継承の概念を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Obviously, any temporary grapheme ids must be translated back to some universal form (such as NFD) on output, and normal precomposed graphemes may turn into either NFC or NFD forms depending on the desired output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明らかに、何かテンポラリー書記素IDは出力の上で若干の一般的な形（例えばNFD）へ変形されなければならない、そして、通常のprecomposedされた書記素はNFCか所望出力次第であるNFDの形態に変わるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, an explicit &lt;c4&gt;next&lt;/c4&gt; might be clearer than a &lt;c5&gt;succeed&lt;/c5&gt; if you really want to go directly to the next iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120420Z" creationid="Toshiyuki" creationdate="20130813T120420Z">
        <seg>当然、明示的な&lt;c4&gt;next&lt;/c4&gt;は&lt;c5&gt;succeed&lt;/c5&gt;よりもはっきりしているかもしれない。もしあなたが本当に次の反復に直接行きたいと思うなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, such a dimensional number will fail if used on a string that doesn't provide the appropriate abstraction level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もちろん、適正抽象概念レベルを提供しない文字列で使われるならば、そのような次元の数は失敗する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型の</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Often-Used Variables</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T022013Z" creationid="yamato" creationdate="20140914T022001Z">
        <seg>頻繁に使用される変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Old disambiguation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>古い一義化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, &lt;c6&gt;succeed&lt;/c6&gt; can take an optional argument giving the value for that iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120526Z" creationid="Toshiyuki" creationdate="20130813T120526Z">
        <seg>一方では、&lt;c6&gt;succeed&lt;/c6&gt;はループの反復のための変数を与える任意の引数をとることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, Perl doesn't use indentation as syntax, so you are free to use any amount of whitespace anywhere that whitespace makes sense.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他方、Perlは構文としてインデントを使わないので、あなたはどんなに多くの空白文字でも空白文字が意味をなすどこでも使って結構である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if a statement_prefix is followed by a non-block statement, all nested blockless statement_prefixes will terminate at the same statement ending:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124551Z" creationid="Toshiyuki" creationdate="20130811T124551Z">
        <seg>一方では、もしstatement_prefixの後にブロックでない文が続くなら、全ての入れ子になったブロックなしのstatement_prefixesは同じ文の末端で終わるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if you backslash the parcel:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他方で、もしもである、あなたバックスラッシュは、パーセルである：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One additional level of control is the notion of &lt;i0&gt;lazy warnings&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130107Z" creationid="Toshiyuki" creationdate="20130817T130107Z">
        <seg>制御の追加のレベルは&lt;i0&gt;lazy warnings&lt;/i0&gt;の考えだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One is to look ahead for the newline and grab the lines corresponding to the heredoc, and then parse the rest of the original line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>人は改行文字の前に見ることになっていて、heredocと一致している線をつかむことになっている、そして、残りの原線を解析しなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One other difference from Perl 5 is that the default is not to undefine a variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140100Z" creationid="Toshiyuki" creationdate="20130802T140100Z">
        <seg>一つPerl 5と違うことは、デフォルトは変数を未定義にしないことだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One purpose of this is to facilitate compile-time analysis of multi-method dispatch, when the user prefers angle notation as the most readable way to represent a list of numbers, which it often is.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザーが最も読み込み可能な方法としての角度表記法が数（それはしばしばそうである）のリストを表現するのを好むとき、これの1つの目的はマルチメソッドディスパッチのコンパイル時分析を容易にすることである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-pass heredoc parsing</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワンパスheredoc構文解析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-pass parsing</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053343Z" creationid="Toshiyuki" creationdate="20140330T053343Z">
        <seg>ワンパス構文解析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-pass parsing is fundamental to knowing exactly which language you are dealing with at any moment, which in turn is fundamental to allowing unambiguous language mutation in any desired direction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワンパス構文解析はあなたがいつ何時対処しているかについて、正確にわかっていることの基本となる。そして、それはつぎには、何か望ましい方向で明白な言語変化を許すことの基本となる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only &lt;c14&gt;Failure&lt;/c14&gt; objects need to store the actual status however; other types just return &lt;c15&gt;True&lt;/c15&gt;.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T161959Z" creationid="Toshiyuki" creationdate="20130817T161959Z">
        <seg>&lt;c14&gt;Failure&lt;/c14&gt;だけが実際のステータスを格納することを必要とする；他の型はただ&lt;c15&gt;True&lt;/c15&gt;を返す。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only argumentless phasers may use the statement form.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085659Z" creationid="Toshiyuki" creationdate="20130818T085659Z">
        <seg>引数なしのphasersだけが文形式を使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only base 10 (in any form) allows an additional exponentiator starting with 'e' or 'E'.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ベース10（どんな形でも）だけは、更なるexponentiatorが『e』または『E』から始めているのを許す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T015005Z" creationid="Toshiyuki" creationdate="20140322T015005Z">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131027T041918Z" creationid="Toshiyuki" creationdate="20131027T041918Z">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators with idiosyncratic Whatever</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特有のWhateverをもつ演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Whitespace and Exclusions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプションの空白文字と除外</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional whitespace</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプションの空白文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or if acronyms make you happy, there are a variety to pick from:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または、頭字語があなたを幸せにするならば、以下から拾い上げる多様性がある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or just think of it as a sound a cow makes, which simultaneously means everything and nothing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または、ちょうど音としてそれの牛を製造（すべてと何も同時に意味しない）と考えなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or whatever.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または、いったい何。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordinary package-qualified names look like they do in Perl 5:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらがPerl 5でするように、普通のパッケージ-修飾された名前は見る：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordinary sigils indicate normally scoped variables, either lexical or package scoped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>普通のシギルは通常捜し出された変数を示す。そして、語彙的であるか、捜し出されて一括である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other adverbs are also allowed, as are multiple heredocs within the same expression:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の副詞も許される。そして、そのことは同じ表現の範囲内の複数のheredocsである：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other all-caps names are semi-reserved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のオールキャプス名は、半確保される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other compile-time constants:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114628Z" creationid="yamato" creationdate="20140914T114628Z">
        <seg>他のコンパイル時定数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other kinds of phasers can be installed as well; these are automatically called at various times as appropriate, and some of them respond to various control exceptions and exit values.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T081130Z" creationid="Toshiyuki" creationdate="20130818T081130Z">
        <seg>他の種類のphasersは同様にうまくインストールされる；それらは適切に様々なタイミングで自動的に呼ばれ、それらのいくつかは様々な制御例外と抜け出る値に応答する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other languages (such as regexes) allow you to backslash a space character for various reasons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の言語（例えば正規表現）は、賛成にいろいろな空白文字が論じるバックスラッシュに、あなたを許す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other match variables are aliases to elements of &lt;c0&gt;$/&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T113753Z" creationid="yamato" creationdate="20140914T113753Z">
        <seg>他のマッチ変数は&lt;c0&gt;$/&lt;/c0&gt;の要素への別名だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other methods on lists also return flat lists/parcels, so for example</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T141918Z" creationid="yamato" creationdate="20140914T141918Z">
        <seg>リストの他のメソッドもフラットなlists/parcelsを返す。例として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other postfix operators may also make use of unspace:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の後置演算子は、unspaceを使用もするかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise the postfix dot will be taken to be the start of some kind of method call syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さもなければ、接尾辞点は、何らかのメソッド呼び出し構文の始まりであるとみなされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise the value will be the null string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T130827Z" creationid="Toshiyuki" creationdate="20130817T130827Z">
        <seg>さもなければ値はnull文字列になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the method performs all of the task's dependencies, using the &lt;c0&gt;for&lt;/c0&gt; construct to iterate over all of the items in the &lt;c1&gt;@!dependencies&lt;/c1&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T191724Z" creationid="Toshiyuki" creationdate="20140111T191724Z">
        <seg>一方、メソッドは全ての仕事の依存を実行します。&lt;c0&gt;for&lt;/c0&gt;構造を使ってすべての&lt;c1&gt;@!dependencies&lt;/c1&gt;属性のアイテムを繰り返し実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Inherited Methods</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144319Z" creationid="Toshiyuki" creationdate="20140314T144319Z">
        <seg>継承したメソッドのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Package lookup</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パッケージ検索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Package-qualified names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パッケージ-修飾された名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameter types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T230823Z" creationid="Toshiyuki" creationdate="20140328T230806Z">
        <seg>パラメーターの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters may be given types, just like any other variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T230903Z" creationid="Toshiyuki" creationdate="20140328T230903Z">
        <seg>パラメータは他の変数のように型を与えられることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parametric types are named using square brackets, so:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータの型は、そう、角括弧を使って挙げられる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parcels</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073359Z" creationid="Toshiyuki" creationdate="20140329T073359Z">
        <seg>パーセル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parcels, parameters, and Captures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パーセル、パラメータとキャプチャー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Path to the current executable as it was typed in on the</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115532Z" creationid="yamato" creationdate="20140914T115532Z">
        <seg>現在の実行ファイルのパス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pattern matching is the process of applying these patterns to actual text to look for matches.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T163801Z" creationid="Toshiyuki" creationdate="20140115T143212Z">
        <seg>パターンマッチは、マッチを探すためにこれらのパターンを実際のテキストに適用するプロセスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perhaps the symbolic ref form will admit real objects in a pinch.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>おそらく、記号的な参照用紙は、いざという時には実物体を認める。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 5's "&lt;c0&gt;local&lt;/c0&gt;" function has been renamed to &lt;c1&gt;temp&lt;/c1&gt; to better reflect what it does.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133905Z" creationid="Toshiyuki" creationdate="20130802T133905Z">
        <seg>Perl 5の&lt;c0&gt;local&lt;/c0&gt;関数は何をするのかより良く表すように&lt;c1&gt;temp&lt;/c1&gt;に名前を変更した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 Terms</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T121332Z" creationid="yamato" creationdate="20140914T121332Z">
        <seg>Perl 6の項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 Variables</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021202Z" creationid="yamato" creationdate="20140914T021202Z">
        <seg>Perl 6の変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 currently recognizes decimal numbers and the null key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は、現在十進数とヌルキーを認知する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 does not have a single value representing undefinedness.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は、未定義を表現している一つの値も持たない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 generalizes this notion to any kind of whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6は、この概念をどんな空白文字にでも一般化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has &lt;c0&gt;Failure&lt;/c0&gt; objects, known as "unthrown exceptions" (though really a &lt;c1&gt;Failure&lt;/c1&gt; merely contains an unthrown exception), which know whether they have been handled or not.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T151438Z" creationid="Toshiyuki" creationdate="20130817T151438Z">
        <seg>Perl 6は&lt;c0&gt;Failure&lt;/c0&gt;オブジェクト、「スローされない例外」を持つ（実際は&lt;c1&gt;Failure&lt;/c1&gt;は単にスローされない例外を含む）。それはそれらがハンドルされたかどうか知っている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has a rich set of literal forms, many of which can be used for textual input as well.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T120253Z" creationid="Toshiyuki" creationdate="20140329T120253Z">
        <seg>Perl 6はリテラルの形式の豊富なセットを持っており、それらの多くが原文の入力に同様に使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has an optional type system that helps you write safer code that performs better.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140325T141840Z" creationid="Toshiyuki" creationdate="20140325T141556Z">
        <seg>Perl 6はより良く動作する安全なコードを書くのに役立つ任意指定の型システムを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 has several ways of performing partial function application.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6には、部分関数アプリケーションを実行することのいくつかの方法がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 includes a system of &lt;b0&gt;sigils&lt;/b0&gt; to mark the fundamental structural type of a variable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000343Z" creationid="Toshiyuki" creationdate="20140329T000343Z">
        <seg>Perl 6は変数の基本的な構造上の型を表示するために&lt;b0&gt;シギル&lt;/b0&gt;システムを含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 intrinsically supports big integers and rationals through its system of type declarations.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130220Z" creationid="Toshiyuki" creationdate="20140328T130220Z">
        <seg>Perl 6は型宣言のシステムによって大きい整数と有理数をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is an OO engine, but you're not generally required to think in OO when that's inconvenient.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6はオブジェクト指向エンジンである、しかし、あなたはそれが不便であるオブジェクト指向で考えることを一般に要求されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 is rather more liberal than many languages in the area of constructors.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T140742Z" creationid="Toshiyuki" creationdate="20140111T193128Z">
        <seg>Perl 6は、コンストラクタにおいては多くの言語より自由がききます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 may automatically generate accessor methods for you though.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T054159Z" creationid="yamato" creationdate="20140914T054159Z">
        <seg>しかしPerl 6は自動的にアクセサメソッドを生成するかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 supports the ability for one class to inherit from one or more classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T143758Z" creationid="Toshiyuki" creationdate="20140112T092958Z">
        <seg>Perl 6は、1つのクラスが1またはそれ以上のクラスから継承する機能をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6 supports the notion of &lt;b0&gt;properties&lt;/b0&gt; on various kinds of objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131839Z" creationid="Toshiyuki" creationdate="20140326T131839Z">
        <seg>Perl 6は様々なオブジェクトで&lt;b0&gt;プロパティ&lt;/b0&gt;の概念をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl 6, like many other languages, uses the &lt;c0&gt;class&lt;/c0&gt; keyword to introduce a new class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T180049Z" creationid="Toshiyuki" creationdate="20140111T180049Z">
        <seg>Perl 6は多くの他の言語のように、新しいクラスを導入するために&lt;c0&gt;class&lt;/c0&gt;キーワードを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl can count Unicode line and paragraph separators as line markers, but that behavior had better be configurable so that Perl's idea of line numbers matches what your editor thinks about Unicode lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perlはユニコード行とパラグラフセパレーターをラインマーカーとして計算に入れることができる、しかし、行番号についてのPerlの考えがあなたの編集者がユニコード行について考えるものにマッチするように、そのふるまいは可変だった方がよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl supports generic types through what are called "roles" which represent capabilities or interfaces.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T125916Z" creationid="Toshiyuki" creationdate="20140328T125750Z">
        <seg>Perlは機能またはインターフェースを表す“ロール”と呼ばれるものを通してジェネリック型をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl variables have two associated types: their "of type" and their "container type".</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T165628Z" creationid="Toshiyuki" creationdate="20140328T165628Z">
        <seg>Perlの変数は2つの関連する型を持ちます：それらの“型”とそれらの“コンテナ”です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Phasers marked with a &lt;c3&gt;*&lt;/c3&gt; can be used for their return value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T081415Z" creationid="Toshiyuki" creationdate="20130818T081415Z">
        <seg>&lt;c3&gt;*&lt;/c3&gt;でマークされたPhasersはそれらの返り値として使用できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Placeholder variables syntactically cannot have any type constraints.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T063050Z" creationid="yamato" creationdate="20140914T063050Z">
        <seg>プレースホルダー変数は構文上、型制約を持つことができない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please be aware that twigils have no influence over whether the primary sigil interpolates.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T041112Z" creationid="yamato" creationdate="20140914T041112Z">
        <seg>ツウィギルが第1のシギルを補完するかどうかに対する影響力を持たないので注意が必要だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note that this abbreviation allows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この省略形が以下を許す点に注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pod sections may be used reliably as multiline comments in Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポッドセクションが、Perl 6のマルチラインコメントとして、信頼できるように使われるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pod variables</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120911Z" creationid="yamato" creationdate="20140914T120911Z">
        <seg>Pod変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pointy blocks and bare closures are transparent to &lt;c4&gt;return&lt;/c4&gt;, in that the &lt;c5&gt;return&lt;/c5&gt; statement still means &lt;c6&gt;&amp;?ROUTINE.leave&lt;/c6&gt; from the &lt;c7&gt;Routine&lt;/c7&gt; that existed in dynamic scope when the closure was cloned.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T044655Z" creationid="Toshiyuki" creationdate="20130817T044655Z">
        <seg>ポインティブロックと裸のクロージャは&lt;c4&gt;return&lt;/c4&gt;には明白だ。&lt;c5&gt;return&lt;/c5&gt;文はまだ	クロージャが複製された時ダイナミックスコープに抜け出た&lt;c7&gt;Routine&lt;/c7&gt;から&lt;c6&gt;&amp;?ROUTINE.leave&lt;/c6&gt;することを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postcircumfixes (with or without the dot) are also autoprimed, so we have</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Postcircumfixes（点の有無にかかわらず）もautoprimedされるので、我々はそうした</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix operators may never have intervening space, though they may have an intervening dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが間のドットを持っているかもしれないけれども、後置演算子は間のスペースを決して持っていないかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pre-defined radix prefixes include:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらかじめ定義された根接頭辞は以下を含む：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Presumably multiple dispatch could sort this out.]</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T103253Z" creationid="Toshiyuki" creationdate="20130806T103253Z">
        <seg>多分、マルチディスパッチはこれを選り分けできる。]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Process ID of the current process.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115426Z" creationid="yamato" creationdate="20140914T115426Z">
        <seg>現在のプロセスID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties applied to objects constructed at compile-time, such as variables and classes, are also called &lt;b0&gt;traits&lt;/b0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132801Z" creationid="Toshiyuki" creationdate="20140326T132801Z">
        <seg>変数やクラスのように、コンパイル時に構成されるオブジェクトに適用されるプロパティは&lt;b0&gt;トレイト&lt;/b0&gt;とも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties are like object attributes, except that they're managed by the individual object rather than by the object's class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131958Z" creationid="Toshiyuki" creationdate="20140326T131958Z">
        <seg>プロパティはオブジェクト属性のようですが、それらはクラスよりもむしろ個々のオブジェクトによって管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties on Objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131852Z" creationid="Toshiyuki" creationdate="20140326T131852Z">
        <seg>オブジェクトのプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pseudo-packages</seg>
      </tuv>
      <tuv lang="JA">
        <seg>擬似パッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Put spaces to override that:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>置かれたスペースは、以下にオーバーライドすることになっている</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Q forms</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Qの形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Quotes from Macros</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マクロからの引用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Quoting Constructs</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T122709Z" creationid="yamato" creationdate="20140914T122709Z">
        <seg>クォート構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Radix interpolation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>根展開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Radix markers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>根目印</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather they set &lt;c3&gt;$_&lt;/c3&gt; inside the block to the caught exception.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114228Z" creationid="yamato" creationdate="20140914T114228Z">
        <seg>むしろそれらは&lt;c3&gt;$_&lt;/c3&gt;をキャッチされた例外の内側のブロックにセットする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rational literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>合理的なリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rational literals are indicated by separating two integer literals (in any radix) with a slash, and enclosing the whole in angles:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>合理的なリテラルは、スラッシュで2つの整数リテラル（何か根の）を切り離して、全体を角度に入れることによって示される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of syntax, adverbs used as named arguments (in either term or infix position) generally show up as optional named parameters to the function in question--even if the function is an operator or macro.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構文に関係なく、一般に名をつけられた引数（どちらの項または挿入辞位置ででも）として使われる副詞は ― たとえ関数が演算子またはマクロであるとしても ― 問題の関数へのオプションの挙げられたパラメータとして現れる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of the &lt;c3&gt;take&lt;/c3&gt;'s immediate context, the object returned is also added to the list of values being gathered, which is returned by the &lt;c4&gt;gather&lt;/c4&gt; as a lazy list (that is, an iterator, really), with each argument element of that list corresponding to one &lt;c5&gt;take&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T204205Z" creationid="Toshiyuki" creationdate="20130810T204205Z">
        <seg>&lt;c3&gt;take&lt;/c3&gt;の直接のコンテキストに関わらず、返されたオブジェクトも集められた値のリストに追加され、それは&lt;c4&gt;gather&lt;/c4&gt;によってレイジーリストとして返される（すなわち、本当にイテレータ）そのリストの一つの&lt;c5&gt;take&lt;/c5&gt;に対応するそれぞれの引数の要素と一緒に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regular expressions are a computer science concept where simple patterns describe the format of text.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140320T163659Z" creationid="Toshiyuki" creationdate="20140115T143159Z">
        <seg>正規表現は、単純なパターンがテキストのフォーマットを記述するコンピューターサイエンス概念です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember, no implicit block scopes.) It is also possible to write</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063626Z" creationid="Toshiyuki" creationdate="20130810T063626Z">
        <seg>暗黙のブロックスコープはないことを覚えておくこと。）それは次のようにも書ける。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replacing the &lt;c4&gt;!&lt;/c4&gt; with a &lt;c5&gt;.&lt;/c5&gt; both declares the attribute &lt;c6&gt;$!done&lt;/c6&gt; and an accessor method named &lt;c7&gt;done&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184217Z" creationid="Toshiyuki" creationdate="20140111T184217Z">
        <seg>&lt;c4&gt;!&lt;/c4&gt;を&lt;c5&gt;.&lt;/c5&gt;に置き換えると属性&lt;c6&gt;$!done&lt;/c6&gt;とアクセサメソッド&lt;c7&gt;done&lt;/c7&gt;を両方宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resumable exceptions may also be implemented by simply marking the current exception as "resumed", in which case the original exception thrower simply returns to the code that threw the resumable exception, rather than unwinding before returning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T114629Z" creationid="Toshiyuki" creationdate="20130814T114629Z">
        <seg>再開可能な例外は現在の例外を単純に「resumed」としてマーキングして実装される。その場合に初期の例外を投げるものは再開可能な例外を投げたコードを単純に返す。返す前に巻き戻すよりも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resumable exceptions may or may not leave normally depending on the implementation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T113840Z" creationid="Toshiyuki" creationdate="20130814T113840Z">
        <seg>再開可能な例外が普通に去るかどうかは実装に依存する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returning a container is how &lt;c0&gt;is rw&lt;/c0&gt; attribute accessors work.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T132833Z" creationid="yamato" creationdate="20140914T132833Z">
        <seg>コンテナを返すことは&lt;c0&gt;is rw&lt;/c0&gt;属性アクセサが動作する方法だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns Euler's number</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124912Z" creationid="yamato" creationdate="20140914T124912Z">
        <seg>オイラー数を返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a pseudo-random &lt;a0&gt;Num&lt;/a0&gt; in the range &lt;c1&gt;0..^1&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124756Z" creationid="yamato" creationdate="20140914T124756Z">
        <seg>&lt;c1&gt;0..^1&lt;/c1&gt;の間の擬似ランダム&lt;a0&gt;Num&lt;/a0&gt;を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns an &lt;a0&gt;Instant&lt;/a0&gt; object representing the current time.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124713Z" creationid="yamato" creationdate="20140914T124713Z">
        <seg>現在の時間を表す&lt;a0&gt;Instant&lt;/a0&gt;オブジェクトを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the imaginary unit (for &lt;a0&gt;Complex&lt;/a0&gt; numbers).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124955Z" creationid="yamato" creationdate="20140914T124955Z">
        <seg>虚数単位（&lt;a0&gt;Complex&lt;/a0&gt;数のための）を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number &lt;c0&gt;pi&lt;/c0&gt;, i.e. the ratio between circumference and diameter of a circle.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124852Z" creationid="yamato" creationdate="20140914T124852Z">
        <seg>円周率&lt;c0&gt;pi&lt;/c0&gt;を返す、すなわち円の円周と直径の間の比率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Roles</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140113T080142Z" creationid="Toshiyuki" creationdate="20140113T080142Z">
        <seg>ロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar containers</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T130934Z" creationid="yamato" creationdate="20140914T130934Z">
        <seg>スカラーコンテナ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scope declarators</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021303Z" creationid="Toshiyuki" creationdate="20140329T021303Z">
        <seg>スコープ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, a method places its invocant into the special variable &lt;c3&gt;self&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185538Z" creationid="Toshiyuki" creationdate="20140111T185538Z">
        <seg>第2に、メソッドはそのインボカントを特殊変数&lt;c3&gt;self&lt;/c3&gt;に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Secondary sigils (twigils) have no influence over whether the primary sigil interpolates.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二のシギル（twigils）は、主要なシギルが改竄するかどうかに対する影響力を持たない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a2&gt;Quoting Constructs&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T122833Z" creationid="yamato" creationdate="20140914T122833Z">
        <seg>&lt;a2&gt;Quoting Constructs&lt;/a2&gt;を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a5&gt;operators&lt;/a5&gt; for more details.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T025948Z" creationid="yamato" creationdate="20140914T025948Z">
        <seg>詳細は&lt;a5&gt;operators&lt;/a5&gt;を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more about binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バインディングについてより多くについてはS06を見なさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more details on the syntax for parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータのために構文上で詳細はS06を見なさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S06 for more on function parameters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T130016Z" creationid="Toshiyuki" creationdate="20130729T130016Z">
        <seg>関数のパラメータについてより詳しくはS06を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S09 for more on slicing.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スライスの詳細についてS09を見なさい。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S09を見なさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S11 for more on using versioned modules.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>versionedされたモジュールを使用することの詳細について、S11を見なさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S12 for more about roles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ロールについてより多くについてはS12を見なさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S12 for more on that.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それの詳細についてS12を見なさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See S26 for more on embedded documentation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>埋め込みドキュメンテーションの詳細についてS26を見なさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also the documentation in &lt;a0&gt;List&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T023116Z" creationid="yamato" creationdate="20140914T023116Z">
        <seg>&lt;a0&gt;List&lt;/a0&gt;のドキュメントを参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below for more on this.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これの詳細について下記を見なさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See below.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130917Z" creationid="Toshiyuki" creationdate="20130808T130917Z">
        <seg>以下を参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See previous section for discussion of ways to return from catch lambdas.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T124949Z" creationid="Toshiyuki" creationdate="20130817T124949Z">
        <seg>キャッチlambdaから返す方法の議論は前のセクションを参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Separate clones of the closure get separate state variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133323Z" creationid="Toshiyuki" creationdate="20130802T133323Z">
        <seg>異なるクロージャのクローンは異なるstate変数を得る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigilless variables</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021659Z" creationid="yamato" creationdate="20140914T021659Z">
        <seg>シギルなしの変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000155Z" creationid="Toshiyuki" creationdate="20140329T000155Z">
        <seg>シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils are now invariant.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T022027Z" creationid="Toshiyuki" creationdate="20140329T021935Z">
        <seg>シギルは現在は不変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils indicate interface</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シギルは、インターフェースを示す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils indicate overall interface, not the exact type of the bound object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シギルは、全体的なインターフェース（縛られたオブジェクトの正確な型でない）を示す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sigils used as functions with parenthesis also force context, so these also work:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧に対する関数としても使われるシギルは前後関係を強制するので、これらも動く：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signature objects</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグネチャオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signature objects bound to type variables (as in the example above) may be used within other signatures to apply additional type constraints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数（上の例の場合のように）を入力するにちがいないシグネチャオブジェクトが、更なる型制約を適用するために、他のシグネチャの範囲内で使われるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;c0&gt;do&lt;/c0&gt; is defined as going in front of a statement, it follows that it can always be followed by a statement label.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T130303Z" creationid="Toshiyuki" creationdate="20130810T130303Z">
        <seg>&lt;c0&gt;do&lt;/c0&gt;は文の前の出発として定義されるので、常に文ラベルが続くことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;c1&gt;when&lt;/c1&gt; statements are presumed to be executed in order like normal statements, it's not required that all the statements in a switch block be &lt;c2&gt;when&lt;/c2&gt; statements (though it helps the optimizer to have a sequence of contiguous &lt;c3&gt;when&lt;/c3&gt; statements, because then it can arrange to jump directly to the first appropriate test that might possibly match.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133157Z" creationid="Toshiyuki" creationdate="20130811T133157Z">
        <seg>&lt;c1&gt;when&lt;/c1&gt;文は通常の文のように順番に実行されると仮定されるので、switchブロックのすべての文が&lt;c2&gt;when&lt;/c2&gt;文になる必要はない（それは連続の&lt;c3&gt;when&lt;/c3&gt;のシーケンスを持つためにオプティマイザを助ける。なぜならマッチできると思われる最初の適切なテストに直接ジャンプするようにアレンジできるからだ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since Pod chunks count as whitespace to the language, they are also swallowed up by unspace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポッド塊が言語への空白文字と見なされるので、それらはunspaceによってものみこまれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since a bare expression may be used as a statement, you may use &lt;c0&gt;do&lt;/c0&gt; on an expression, but its only effect is to function as an unmatched left parenthesis, much like the &lt;c1&gt;$&lt;/c1&gt; operator in Haskell.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T124326Z" creationid="Toshiyuki" creationdate="20130810T123311Z">
        <seg>裸の式は文として使われると思われるので、&lt;c0&gt;do&lt;/c0&gt;を式で使うだろう。しかしそれの唯一の効果は左括弧が対応がとれていない関数だ。Haskellの&lt;c1&gt;$&lt;/c1&gt;演算子にとても似ている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since all exception handlers run in the dynamic scope of the throw, that reduces to simply returning from the &lt;c1&gt;warn&lt;/c1&gt; function most of the time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T124718Z" creationid="Toshiyuki" creationdate="20130817T124718Z">
        <seg>全ての例外ハンドラはスローのダイナミックスコープで実行するので、それは大抵の場合&lt;c1&gt;warn&lt;/c1&gt;関数から単純に返すように変える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since bracketed expressions consider their insides to be statements, this works out consistently even where you might expect problems:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T031831Z" creationid="Toshiyuki" creationdate="20130803T031831Z">
        <seg>括弧に入れられた式はそれらの内部を文とみなすので、あなたが問題を予期している所でも一貫して上手くいく：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since leaving a block is considered a successful return, breaking out of one with &lt;c11&gt;succeed&lt;/c11&gt; is also considered a successful return for the purposes of &lt;c12&gt;KEEP&lt;/c12&gt; and &lt;c13&gt;UNDO&lt;/c13&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114609Z" creationid="Toshiyuki" creationdate="20130813T114609Z">
        <seg>ブロックを去ることは成功したリターンとみなされるので、&lt;c11&gt;succeed&lt;/c11&gt;で脱出することも&lt;c12&gt;KEEP&lt;/c12&gt;と&lt;c13&gt;UNDO&lt;/c13&gt;の目的のための成功したリターンとみなされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since parentheses are generally reserved just for precedence grouping, they merely autointerpolate in flat list context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧が通常、ちょうど優先順位グループのために予約されているので、それらは単に平らなリストコンテキストでautointerpolateするだけである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the loop executes once before evaluating the condition, the bound parameter will be undefined that first time through the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T055600Z" creationid="Toshiyuki" creationdate="20130810T055600Z">
        <seg>条件を評価する前にループを1回実行するので、結び付けられたパラメータはループの初回に未定義にされるだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the syntax for method calls is distinguished from sub calls, it is only unrecognized sub calls that must be treated specially.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド呼び出しのための構文が下位呼び出しを区別されるので、それは特別に扱われなければならない認められていない下位呼び出しだけである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since there are so many match rules whose symbol is an identifier, we allow a shorthand:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シンボルが識別子であるそれほど多くのマッチ規則があるので、我々は短縮形を許す：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since warnings are processed using the standard control exception mechanism, they may be intercepted and either suppressed or fatalized anywhere within the dynamic scope by supplying a suitable &lt;c0&gt;CONTROL&lt;/c0&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T115816Z" creationid="Toshiyuki" creationdate="20130817T115816Z">
        <seg>警告は標準の制御例外メカニズムを使って処理されるので、それらは横取りされることもでき、適切な&lt;c0&gt;CONTROL&lt;/c0&gt;ブロックの供給によるダイナミックスコープ内で抑制されるかどこでも致命的にされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single-line Comments</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053448Z" creationid="Toshiyuki" creationdate="20140330T053448Z">
        <seg>ラインコメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slangs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>俗語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slice context turns any parcel objects into &lt;c0&gt;Seq&lt;/c0&gt; objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T132209Z" creationid="Toshiyuki" creationdate="20130808T132209Z">
        <seg>スライスコンテキストはどんなパーセルオブジェクトでも&lt;c0&gt;Seq&lt;/c0&gt;オブジェクトに変える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slicing is specified by the nature of the subscript, not by the sigil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シギルによってでなく、スライスは添え字の性質によって指定される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slicing syntax is covered in S09.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構文をスライスすることは、S09でカバーされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Slurpy Parameters</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T181947Z" creationid="Toshiyuki" creationdate="20140104T181947Z">
        <seg>Slurpyなパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140105Z" creationid="Toshiyuki" creationdate="20130802T140105Z">
        <seg>つまり</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So &lt;c0&gt;[1, 2, 3].join(',')&lt;/c0&gt; produces &lt;c1&gt;"1,2,3"&lt;/c1&gt; as a result, as one might hope.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T141738Z" creationid="yamato" creationdate="20140914T141738Z">
        <seg>なので&lt;c0&gt;[1, 2, 3].join(',')&lt;/c0&gt;は結果として期待したように&lt;c1&gt;"1,2,3"&lt;/c1&gt;を生み出す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So do the implicit conditionals implied by short-circuit operators.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130805T160823Z" creationid="Toshiyuki" creationdate="20130805T160823Z">
        <seg>このように、暗黙の条件は短絡演算子によって暗に意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if you examine the &lt;c2&gt;ENTER&lt;/c2&gt; trait of a block, you'll find that it's really a list of phasers rather than a single phaser.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130820T124134Z" creationid="Toshiyuki" creationdate="20130820T124134Z">
        <seg>もし&lt;c2&gt;ENTER&lt;/c2&gt;ブロックのトレイトを調査するなら、あなたは単独のphaserよりも本当のphaserのリストだと気づくだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So logically, if the &lt;c1&gt;CATCH&lt;/c1&gt; block throws its own exception, you would expect the &lt;c2&gt;CATCH&lt;/c2&gt; block to catch its own exception recursively forever.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T120157Z" creationid="Toshiyuki" creationdate="20130814T120157Z">
        <seg>論理的には、もし&lt;c1&gt;CATCH&lt;/c1&gt;ブロックが独自の例外を投げるなら、あなたは&lt;c2&gt;CATCH&lt;/c2&gt;ブロックがその独自の例外を再帰的に絶えずキャッチすると期待するだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So switching behavior is actually caused by the &lt;c6&gt;when&lt;/c6&gt; statements in the block, not by the nature of the block itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T130033Z" creationid="Toshiyuki" creationdate="20130811T130033Z">
        <seg>それゆえ、switchの振る舞いは実際はブロックの&lt;c6&gt;when&lt;/c6&gt;文によって引き起こされ、ブロック自身の性質によってではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the block in the code</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T062032Z" creationid="yamato" creationdate="20140914T062032Z">
        <seg>それでコードのブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the object in question is of class &lt;c0&gt;Employee&lt;/c0&gt; or one that inherits from it, but not &lt;c1&gt;GeekCook&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T151656Z" creationid="Toshiyuki" creationdate="20140112T135850Z">
        <seg>それで、問題のオブジェクトはクラス&lt;c0&gt;Employee&lt;/c0&gt;またはそれから継承したもので、&lt;c1&gt;GeekCook&lt;/c1&gt;ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the old &lt;c6&gt;next LINE&lt;/c6&gt; syntax is still allowed but really does something like &lt;c7&gt;LINE.next(())&lt;/c7&gt; underneath.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T102156Z" creationid="Toshiyuki" creationdate="20130806T102156Z">
        <seg>それゆえ、&lt;c6&gt;next LINE&lt;/c6&gt;という文法はまだ許可される。しかし本当は表面化に&lt;c7&gt;LINE.next(())&lt;/c7&gt;のようなことをしている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the parcel doesn't care about whether its elements are values or containers, they just store and retrieve whatever was given to them.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T134553Z" creationid="yamato" creationdate="20140914T134553Z">
        <seg>parcelは要素が値かコンテナか気にしないので、与えられたものを何でも格納・読み出すだけだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So these are all equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それで、これらのすべては等しい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So these are in sorted version order:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それで、これらはソートされたバージョン順序である：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So they aren't really traits, exactly--they add themselves onto a list stored in the actual trait.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093613Z" creationid="Toshiyuki" creationdate="20130818T093613Z">
        <seg>それらは実際にはトレイトでないので、まさに―それらは実際のトレイトに格納されたリストに自身を加える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So we will say that it is erroneous for a library writer to mix dynamic gather with callbacks unless those callbacks are somehow "ungathered" to the outer dynamic scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T161444Z" creationid="Toshiyuki" creationdate="20130810T161444Z">
        <seg>そういうわけでダイナミックなgatherをコールバックと混ぜるのはライブラリ作者には誤りだと我々は言う。それらのコールバックが外側のダイナミックスコープにどういうわけか「ungathered」でない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So we write those as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々がそれらを書くように、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So when you say</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それで、あなたが言うとき、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some bindings are sensitive to multiple dimensions while others are not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他がそうでない間、若干のバインディングは複数の次元に敏感である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some combinations make sense, such as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、若干の組合せは意味をなす：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some examples of how listops, methods and labels interact syntactically:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>listops、メソッドとラベルがどのように構文的に相互作用するかという若干の例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some languages such as C allow you to escape newline characters to combine lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cのようないくらかの言語は、行を結合するために改行文字をエスケープすることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some object types can behave as value types.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T121805Z" creationid="Toshiyuki" creationdate="20140328T121805Z">
        <seg>いくつかのオブジェクト型は値型として振る舞うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of the statement prefixes also behave a little bit like phasers, but they run in-line with the executable code, so they are spelled in lowercase.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T081828Z" creationid="Toshiyuki" creationdate="20130818T081828Z">
        <seg>いくつかの文接頭辞も少しphasersのようにふるまう。しかしそれらは実行可能なコードとともにインラインを実行する。なのでそれらは小文字で綴る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of these operators also fall back to a purely dynamic interpretation if the lexotic interpretation doesn't work.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T012428Z" creationid="Toshiyuki" creationdate="20130728T012428Z">
        <seg>これらの演算子の幾つかは、レギゾチックな解釈が正常に動作しない場合に純粋な動的解釈に逆戻りすることもある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some of these phasers also have corresponding traits that can be set on variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093015Z" creationid="Toshiyuki" creationdate="20130818T093015Z">
        <seg>phasersのいくつかは変数にセットできる対応するトレイトも持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some people like to say "everything is an object", but in fact a variable is not a user-exposed object in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T130314Z" creationid="yamato" creationdate="20140914T130314Z">
        <seg>一部の人々は「全てがオブジェクトだ」と言うのが好きだ。しかし実際はPerl 6で変数はユーザーにさらされたオブジェクトではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Something like:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のような何か：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes it's clearer to keep the sigil with the variable name, so an alternate way to write this is:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>時々、変数名でシギルを保つことはより明白であるので、これを書く交互の方法は以下の通りである：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sorting a list of pairs should sort on their keys by default, then on their values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>組のリストがデフォルトによる彼らのキーの上で、それから彼らの値の上でソートしなければならないソート。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special Variables</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021826Z" creationid="yamato" creationdate="20140914T021826Z">
        <seg>特殊変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special variables</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090220Z" creationid="Toshiyuki" creationdate="20140329T090220Z">
        <seg>特殊変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying a dispatch candidate</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T083236Z" creationid="Toshiyuki" creationdate="20140329T083236Z">
        <seg>ディスパッチ候補を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standard error filehandle.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115145Z" creationid="yamato" creationdate="20140914T115145Z">
        <seg>標準エラーファイルハンドル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standard input filehandle.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115117Z" creationid="yamato" creationdate="20140914T115117Z">
        <seg>標準入力ファイルハンドル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standard output filehandle.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115130Z" creationid="yamato" creationdate="20140914T115130Z">
        <seg>標準出力ファイルハンドル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting with class</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T180001Z" creationid="Toshiyuki" creationdate="20140111T180001Z">
        <seg>クラスで始める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Still it's easy to observe how different they are:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T135420Z" creationid="yamato" creationdate="20140914T135420Z">
        <seg>それらの違いを観察するのはまだ簡単だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strict lookup</seg>
      </tuv>
      <tuv lang="JA">
        <seg>厳しい検索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals are most often created with &lt;c0&gt;'&lt;/c0&gt; or &lt;c1&gt;"&lt;/c1&gt;, but strings are actually a powerful sub-language of Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T122823Z" creationid="yamato" creationdate="20140914T122823Z">
        <seg>文字列リテラルはしばしば&lt;c0&gt;'&lt;/c0&gt;または&lt;c1&gt;"&lt;/c1&gt;で作成される。しかし文字列は実際はPerl 6の強力なサブ言語だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T020250Z" creationid="Toshiyuki" creationdate="20140322T020250Z">
        <seg>文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings, the &lt;c0&gt;Str&lt;/c0&gt; Type</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T131040Z" creationid="Toshiyuki" creationdate="20140328T131040Z">
        <seg>文字列、&lt;c0&gt;Str&lt;/c0&gt;型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings, the Str Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列、Str型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sub calls</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下位呼び出し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subroutines may also make use of placeholder variables but only if they do not have an explicit parameter list.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T062915Z" creationid="yamato" creationdate="20140914T062915Z">
        <seg>明示的なパラメータリストを持っていない場合のみ、サブルーチンでプレースホルダー変数を使うようにできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript adverbs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下に書いた副詞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripting such a list does not imply subscripting back into the original object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストのような添え字付けは、最初のオブジェクトへと添え字付けを意味しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T030020Z" creationid="Toshiyuki" creationdate="20140329T030020Z">
        <seg>添字付け</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts are always evaluated in list context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T031657Z" creationid="Toshiyuki" creationdate="20140329T031657Z">
        <seg>添字付けは常にリストコンテキストで評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts have list context</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字には、リストコンテキストがある</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts now consistently dereference the container produced by whatever was to their left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は、彼らの左にあったものは何によってでも生産されるコンテナを現在一貫して間接参照する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a cursor is essentially a pattern-matching state.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなカーソルは、基本的にパターンマッチング州である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a declaration could be applied to input translation as well.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような宣言は、同様に翻訳を入力するために適用されることができた。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a scalar variable is always treated as a singular item in any kind of list context, regardless of whether the object is essentially composite or unitary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトが基本的に合成であるか単位を構成するか否かを問わず、そのようなスカラー変数は常にどんなリストコンテキストの他に類のないアイテムとでもみなされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such constructs will thus need to be deprecated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような構成概念は、このように廃止必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124621Z" creationid="Toshiyuki" creationdate="20130811T124621Z">
        <seg>Switch文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switching parsers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切換パーサー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Symbol</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124718Z" creationid="Toshiyuki" creationdate="20140322T124718Z">
        <seg>シンボル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Symbol tables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シンボルテーブル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Systems which cannot officially provide a steady time base, such as POSIX systems, will simply have to make their best guess as to the correct atomic time when asked to interconvert between cultural time and atomic time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文化的な時間と原子時間の間でinterconvertに尋ねられるとき、安定したタイムベース（例えばPOSIXシステム）を公式に提供することができないシステムは単に彼らのベストを正しい原子時間に関して推測させなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TITLE</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タイトル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Terms</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T121318Z" creationid="yamato" creationdate="20140914T121318Z">
        <seg>項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is,</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060536Z" creationid="Toshiyuki" creationdate="20130810T060536Z">
        <seg>すなわち、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, if &lt;c0&gt;$a&lt;/c0&gt; interpolates, so do &lt;c1&gt;$^a&lt;/c1&gt;, &lt;c2&gt;$*a&lt;/c2&gt;, &lt;c3&gt;$=a&lt;/c3&gt;, &lt;c4&gt;$?a&lt;/c4&gt;, &lt;c5&gt;$.a&lt;/c5&gt;, etc.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T041341Z" creationid="yamato" creationdate="20140914T041341Z">
        <seg>つまり、&lt;c0&gt;$a&lt;/c0&gt;を補完すると&lt;c1&gt;$^a&lt;/c1&gt;、&lt;c2&gt;$*a&lt;/c2&gt;、&lt;c3&gt;$=a&lt;/c3&gt;、&lt;c4&gt;$?a&lt;/c4&gt;、&lt;c5&gt;$.a&lt;/c5&gt;のようになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, if you open with one of the alternatives, all other alternatives are treated as non-bracketing characters within that construct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>つまり、あなたが選択肢の1つで始めるならば、他の全ての選択肢はその構成概念の範囲内で文字を非括弧に入れることとみなされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, precedence decisions do not cross a &lt;c2&gt;do&lt;/c2&gt; boundary, and the missing "right paren" is assumed at the next statement terminator or unmatched bracket.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T124306Z" creationid="Toshiyuki" creationdate="20130810T124306Z">
        <seg>すなわち、優先順位の決定は&lt;c2&gt;do&lt;/c2&gt;の境界を横切らず、欠けた「右括弧」は次の文の終止符か対応のとれていないブラケットと仮定される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the construct:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113956Z" creationid="Toshiyuki" creationdate="20130810T113956Z">
        <seg>すなわち、構成物：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the following are all identical in meaning:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>つまり、以下のすべては、意味で同一である：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the stack is not unwound until some exception handler chooses to unwind it by "handling" the exception in question.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115741Z" creationid="Toshiyuki" creationdate="20130814T115741Z">
        <seg>すなわち、そのスタックはいくつかの例外ハンドラが問題の例外を「ハンドリング」することによってそれを巻き戻すために選ばれるまで巻き戻されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, these are not necessarily byte positions--an integer position just counts over the number of underlying positions, where one position means one cell of the underlying integer type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>つまり、これらが必ずしもバイト位置であるというわけではない－整数位置はちょうど下にある位置の数以上数える、そこで、1つの位置は根底にある整数型の1つのセルを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, these two statements are equivalent:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T031141Z" creationid="Toshiyuki" creationdate="20130803T031141Z">
        <seg>つまり、これら二つの文は同等だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is: a variable with the same name of the desired block and a &lt;c4&gt;=&lt;/c4&gt; twigil.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T064351Z" creationid="yamato" creationdate="20140914T064351Z">
        <seg>すなわち：望むブロックと同じ名前の&lt;c4&gt;=&lt;/c4&gt;ツウィギル付きの変数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means that &lt;c1&gt;degrees&lt;/c1&gt; and &lt;c2&gt;ﾎｸ&lt;/c2&gt; above actually directly represent &lt;c3&gt;Int&lt;/c3&gt;s.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120503Z" creationid="yamato" creationdate="20140914T040130Z">
        <seg>それは実際に&lt;c1&gt;degrees&lt;/c1&gt;と&lt;c2&gt;θ&lt;/c2&gt;が直接&lt;c3&gt;Int&lt;/c3&gt;を表現することを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means that flattening list context iterates over them as if there was no container boundary:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T141107Z" creationid="yamato" creationdate="20140914T141107Z">
        <seg>それはリストコンテキストのフラット化は、コンテナの境界が無いかのようにそれらを繰り返すということを意味する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That should now be written:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112113Z" creationid="Toshiyuki" creationdate="20130810T111931Z">
        <seg>それは今は書き直されるべきだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The "point of declaration" is the moment the compiler sees "&lt;c0&gt;my $foo&lt;/c0&gt;", not the end of the statement as in Perl 5, so</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125416Z" creationid="Toshiyuki" creationdate="20130730T125416Z">
        <seg>「宣言のポイント」はコンパイラが「&lt;c0&gt;my $foo&lt;/c0&gt;」を見る時点であり、Perl 5における文の終わりではない。つまり</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The .WHICH Method for Value Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型のための.WHICHメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The .fmt method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>.fmtメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The .gist method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>.gistメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The .perl method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>.perlメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The :val modifier</seg>
      </tuv>
      <tuv lang="JA">
        <seg>:val修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;!&lt;/c0&gt; Sigil</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021723Z" creationid="yamato" creationdate="20140914T021723Z">
        <seg>&lt;c0&gt;!&lt;/c0&gt;シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;$Package'var&lt;/c0&gt; syntax is gone.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000110Z" creationid="Toshiyuki" creationdate="20140329T000110Z">
        <seg>&lt;c0&gt;$Package'var&lt;/c0&gt;構文はなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;%&lt;/c0&gt; and &lt;c1&gt;@&lt;/c1&gt; sigils in Perl 6 generally indicate flattening.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T140912Z" creationid="yamato" creationdate="20140914T140912Z">
        <seg>Perl 6の&lt;c0&gt;%&lt;/c0&gt;と&lt;c1&gt;@&lt;/c1&gt;シギルは一般にフラット化を示す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&amp;&lt;/c0&gt; sigil indicates that this attribute represents something invocable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182550Z" creationid="Toshiyuki" creationdate="20140111T182550Z">
        <seg>&lt;c0&gt;&amp;&lt;/c0&gt;シギルは属性が何かを起動可能であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;*&lt;/c0&gt; Sigil</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021715Z" creationid="yamato" creationdate="20140914T021715Z">
        <seg>&lt;c0&gt;*&lt;/c0&gt;シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.&lt;/c0&gt; Sigil</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021737Z" creationid="yamato" creationdate="20140914T021737Z">
        <seg>&lt;c0&gt;.&lt;/c0&gt;シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.&lt;/c0&gt; twigil isn't really for variables at all.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T060727Z" creationid="yamato" creationdate="20140914T060727Z">
        <seg>&lt;c0&gt;.&lt;/c0&gt;ツウィギルは変数のためではまったくない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.WHAT&lt;/c0&gt; method returns the type object associated with the object &lt;c1&gt;$o&lt;/c1&gt;, which tells the exact type of &lt;c2&gt;$o&lt;/c2&gt;: in this case &lt;c3&gt;Programmer&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T140110Z" creationid="Toshiyuki" creationdate="20140112T140110Z">
        <seg>&lt;c0&gt;.WHAT&lt;/c0&gt;メソッドはオブジェクト&lt;c1&gt;$o&lt;/c1&gt;と結びつけられる型オブジェクトを返します。そして、それは&lt;c2&gt;$o&lt;/c2&gt;の正確な型を教えます：この場合は&lt;c3&gt;Programmer&lt;/c3&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.WHICH&lt;/c0&gt; Method for Value Types</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T121731Z" creationid="Toshiyuki" creationdate="20140328T121731Z">
        <seg>値型のための&lt;c0&gt;.WHICH&lt;/c0&gt;メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.fmt&lt;/c0&gt; method</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T025540Z" creationid="Toshiyuki" creationdate="20140329T025540Z">
        <seg>&lt;c0&gt;.fmt&lt;/c0&gt;メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;.handled&lt;/c0&gt; method is &lt;c1&gt;rw&lt;/c1&gt;, so you may mark an exception as handled by assigning &lt;c2&gt;True&lt;/c2&gt; to it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T162419Z" creationid="Toshiyuki" creationdate="20130817T162419Z">
        <seg>&lt;c0&gt;.handled&lt;/c0&gt;メソッドは&lt;c1&gt;rw&lt;/c1&gt;なので、&lt;c2&gt;True&lt;/c2&gt;を割り当てることで例外がハンドルされたとマークすることもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;:&lt;/c0&gt; Sigil</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021801Z" creationid="yamato" creationdate="20140914T021801Z">
        <seg>&lt;c0&gt;:&lt;/c0&gt;シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;:&lt;/c0&gt; twigil declares a formal named parameter to a block or subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T063456Z" creationid="yamato" creationdate="20140914T063456Z">
        <seg>&lt;c0&gt;:&lt;/c0&gt;ツウィギルはブロックやサブルーチンに対して名前付き仮パラメータを宣言する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt; &lt;/c0&gt; twigil is just an alias for &lt;c1&gt;$/&lt;...&gt; &lt;/c1&gt; where &lt;c2&gt;$/&lt;/c2&gt; is the match variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T061620Z" creationid="yamato" creationdate="20140914T061620Z">
        <seg>&lt;c0&gt;&lt; &lt;/c0&gt;ツウィギルは&lt;c1&gt;$/&lt;...&gt; &lt;/c1&gt;の別名で、&lt;c2&gt;$/&lt;/c2&gt;はマッチ変数だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;&lt;/c0&gt; Sigil</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021744Z" creationid="yamato" creationdate="20140914T021744Z">
        <seg>&lt;c0&gt;&lt;&lt;/c0&gt;シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;=&lt;/c0&gt; Sigil</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021809Z" creationid="yamato" creationdate="20140914T021809Z">
        <seg>&lt;c0&gt;=&lt;/c0&gt;シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;=&lt;/c0&gt; twigil is used to access Pod variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T064006Z" creationid="yamato" creationdate="20140914T064006Z">
        <seg>&lt;c0&gt;=&lt;/c0&gt;ツウィギルはPod変数にアクセスするのに使用される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;?&lt;/c0&gt; Sigil</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021730Z" creationid="yamato" creationdate="20140914T021730Z">
        <seg>&lt;c0&gt;?&lt;/c0&gt;シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Cool&lt;/c0&gt; module also contains all multisubs of last resort; these are automatically searched if normal multiple dispatch does not find a viable candidate.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T233824Z" creationid="Toshiyuki" creationdate="20140328T233824Z">
        <seg>&lt;c0&gt;Cool&lt;/c0&gt;モジュールは最後の手段の全てのマルチサブを含みます；通常のマルチディスパッチが可能な候補を見つけなければ、それらは自動的に検索されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Cool&lt;/c0&gt; type is derived from &lt;c1&gt;Any&lt;/c1&gt;, and contains all the methods that are "cool" (as in, "I'm cool with an argument of that type.").</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T232612Z" creationid="Toshiyuki" creationdate="20140328T232612Z">
        <seg>&lt;c0&gt;Cool&lt;/c0&gt;型は&lt;c1&gt;Any&lt;/c1&gt;から派生し、“cool”（“私はその型の引数にクールです”）なメソッドを全て含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Grammar.parse&lt;/c0&gt; method also sets the caller's &lt;c1&gt;$/&lt;/c1&gt; to the resulting &lt;a2&gt;Match&lt;/a2&gt; object.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T113719Z" creationid="yamato" creationdate="20140914T113719Z">
        <seg>&lt;c0&gt;Grammar.parse&lt;/c0&gt;メソッドも呼び出し元の&lt;c1&gt;$/&lt;/c1&gt;に結果の&lt;a2&gt;Match&lt;/a2&gt;オブジェクトをセットする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;StrPos&lt;/c0&gt; Type</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T133413Z" creationid="Toshiyuki" creationdate="20140328T133413Z">
        <seg>&lt;c0&gt;StrPos&lt;/c0&gt;型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;^&lt;/c0&gt; Sigil</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021752Z" creationid="yamato" creationdate="20140914T021752Z">
        <seg>&lt;c0&gt;^&lt;/c0&gt;シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;^&lt;/c0&gt; twigil declares a formal positional parameter to blocks or subroutines.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T061931Z" creationid="yamato" creationdate="20140914T061755Z">
        <seg>&lt;c0&gt;^&lt;/c0&gt;ツウィギルはブロックとサブルーチンに狩りの位置パラメータを宣言する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;anon&lt;/c0&gt; declarator allows a declaration to provide a name that can be used in error messages, but that isn't put into any external symbol table:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T021656Z" creationid="Toshiyuki" creationdate="20140329T021656Z">
        <seg>&lt;c0&gt;anon&lt;/c0&gt;宣言はエラーメッセージに使用できる名前を提供するための宣言を可能にしますが、それはどの外部のシンボルテーブルにも置かれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;fail&lt;/c0&gt; function responds to the caller's &lt;c1&gt;use fatal&lt;/c1&gt; state.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T170326Z" creationid="Toshiyuki" creationdate="20130817T170326Z">
        <seg>&lt;c0&gt;fail&lt;/c0&gt;関数は呼び出し元の&lt;c1&gt;use fatal&lt;/c1&gt;状態に応答する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;for&lt;/c0&gt; statement</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060619Z" creationid="Toshiyuki" creationdate="20130810T060619Z">
        <seg>&lt;c0&gt;for&lt;/c0&gt;文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;gather&lt;/c0&gt; statement prefix</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T152216Z" creationid="Toshiyuki" creationdate="20130810T152216Z">
        <seg>&lt;c0&gt;gather&lt;/c0&gt;文プレフィックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;if&lt;/c0&gt; and &lt;c1&gt;unless&lt;/c1&gt; statements work much as they do in Perl 5.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T042914Z" creationid="Toshiyuki" creationdate="20130803T042914Z">
        <seg>&lt;c0&gt;if&lt;/c0&gt;文と&lt;c1&gt;unless&lt;/c1&gt;文はPerl 5のように動作する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;is rw&lt;/c0&gt; trait causes the generated accessor method to return something external code can modify to change the value of the attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184845Z" creationid="Toshiyuki" creationdate="20140111T184845Z">
        <seg>&lt;c0&gt;is rw&lt;/c0&gt;トレイトは発生するアクセッサ・メソッドにコードが属性の値を変えるために修正することができる外部の何かを返させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;loop&lt;/c0&gt; statement is the C-style &lt;c1&gt;for&lt;/c1&gt; loop in disguise:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T055854Z" creationid="Toshiyuki" creationdate="20130810T055854Z">
        <seg>&lt;c0&gt;loop&lt;/c0&gt;文はC言語スタイルの&lt;c1&gt;for&lt;/c1&gt;ループを装う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;of&lt;/c0&gt; type specifies what kinds of values may be stored in the variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T213053Z" creationid="Toshiyuki" creationdate="20140328T213053Z">
        <seg>&lt;c0&gt;of&lt;/c0&gt;型はどのような種類の値が変数に保存されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;repeat&lt;/c0&gt; statement</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T150051Z" creationid="Toshiyuki" creationdate="20130809T150051Z">
        <seg>&lt;c0&gt;repeat&lt;/c0&gt;文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;returns&lt;/c0&gt; declarations is an alias for the &lt;c1&gt;of&lt;/c1&gt; type of a subroutine.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T223849Z" creationid="Toshiyuki" creationdate="20140328T223849Z">
        <seg>&lt;c0&gt;returns&lt;/c0&gt;宣言はサブルーチンの&lt;c1&gt;of&lt;/c1&gt;型の別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;sink&lt;/c0&gt; statement prefix will eagerly evaluate any block or statement, throw away the results, and instead return the empty &lt;c1&gt;Parcel&lt;/c1&gt; value, &lt;c2&gt;()&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T080120Z" creationid="Toshiyuki" creationdate="20140329T080120Z">
        <seg>&lt;c0&gt;sink&lt;/c0&gt;ステートメントプレフィックスは何らかのブロックまたはステートメントを評価して結果を捨て、その代わりに空の&lt;c1&gt;Parcel&lt;/c1&gt;値、&lt;c2&gt;()&lt;/c2&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;take&lt;/c0&gt; function essentially has two contexts simultaneously, the context in which the &lt;c1&gt;gather&lt;/c1&gt; is operating, and the context in which the &lt;c2&gt;take&lt;/c2&gt; is operating.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T035625Z" creationid="Toshiyuki" creationdate="20130811T035625Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;関数は本質的に同時に二つのコンテキストを持つ。&lt;c1&gt;gather&lt;/c1&gt;が動作中のコンテキスト、&lt;c2&gt;take&lt;/c2&gt;が動作中のコンテキスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;take&lt;/c0&gt; function is lexotic if there is a visible outer &lt;c1&gt;gather&lt;/c1&gt;, but falls back to purely dynamic if not.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T154155Z" creationid="Toshiyuki" creationdate="20130810T154155Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;関数は、可視の外側の&lt;c1&gt;gather&lt;/c1&gt;があるならレギゾチックだ。 しかしそうでないなら純粋なダイナミックに戻る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;take&lt;/c0&gt; operation may be defined internally using resumable control exceptions, or dynamic variables, or pigeons carrying clay tablets.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T041108Z" creationid="Toshiyuki" creationdate="20130811T041108Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;の動作は再動作可能な制御例外、または動的変数、または粘土板を運ぶハトを使って内部的に定義されているだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;unless&lt;/c0&gt; statement does not allow an &lt;c1&gt;elsif&lt;/c1&gt; or &lt;c2&gt;else&lt;/c2&gt; in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T045700Z" creationid="Toshiyuki" creationdate="20130804T045700Z">
        <seg>Perl 6では&lt;c0&gt;unless&lt;/c0&gt;文は&lt;c1&gt;elsif&lt;/c1&gt;または&lt;c2&gt;else&lt;/c2&gt;を許可しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;while&lt;/c0&gt; and &lt;c1&gt;until&lt;/c1&gt; statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T142714Z" creationid="Toshiyuki" creationdate="20130809T142714Z">
        <seg>&lt;c0&gt;while&lt;/c0&gt;と&lt;c1&gt;until&lt;/c1&gt;文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;while&lt;/c0&gt; and &lt;c1&gt;until&lt;/c1&gt; statements work as in Perl 5, except that you may leave out the parentheses around the conditional:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T143804Z" creationid="Toshiyuki" creationdate="20130809T143804Z">
        <seg>&lt;c0&gt;while&lt;/c0&gt;と&lt;c1&gt;until&lt;/c1&gt;文はPerl 5のように動作する。条件文の周囲の括弧を省略するかもしれない場合を除いて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;~&lt;/c0&gt; Sigil</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021816Z" creationid="yamato" creationdate="20140914T021816Z">
        <seg>&lt;c0&gt;~&lt;/c0&gt;シギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;~&lt;/c0&gt; twigil is for referring to sublanguages (called slangs).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T110403Z" creationid="yamato" creationdate="20140914T110403Z">
        <seg>&lt;c0&gt;~&lt;/c0&gt;ツウィギルはサブ言語（slang）を参照するためのものだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;!&lt;/c1&gt; character is a &lt;e2&gt;twigil&lt;/e2&gt;, or secondary sigil.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182628Z" creationid="Toshiyuki" creationdate="20140111T182628Z">
        <seg>&lt;c1&gt;!&lt;/c1&gt;文字は&lt;e2&gt;twigil&lt;/e2&gt;、または第2のシギルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;given&lt;/c1&gt; block is just one way to set the current topic, but a switch statement can be any block that sets &lt;c2&gt;$_&lt;/c2&gt;, including a &lt;c3&gt;for&lt;/c3&gt; loop (assuming one of its loop variables is bound to &lt;c4&gt;$_&lt;/c4&gt;) or the body of a method (if you have declared the invocant as &lt;c5&gt;$_&lt;/c5&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125816Z" creationid="Toshiyuki" creationdate="20130811T125816Z">
        <seg>&lt;c1&gt;given&lt;/c1&gt;ブロックは現在のトピックをセットする一つの方法だ。しかしswitch文は&lt;c2&gt;$_&lt;/c2&gt;をセットするどんなブロックにもなれる。&lt;c3&gt;for&lt;/c3&gt;ループ（ループ変数の一つが&lt;c4&gt;$_&lt;/c4&gt;にバインドされていると仮定する）またはメソッドの本体（もしインボカントを&lt;c5&gt;$_&lt;/c5&gt;として宣言しているなら）を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;:local&lt;/c2&gt; named argument limits the returned methods to those defined in the &lt;c3&gt;Employee&lt;/c3&gt; class, and excludes the inherited methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T155918Z" creationid="Toshiyuki" creationdate="20140112T155918Z">
        <seg>&lt;c2&gt;:local&lt;/c2&gt;という名前付き引数は&lt;c3&gt;Employee&lt;/c3&gt;クラスに定義されているメソッドに限定し、継承したメソッドを除いて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;~~&lt;/c2&gt; smart-match operator sets &lt;c3&gt;$_&lt;/c3&gt; on the right-hand side expression to the value of the left-hand side.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T112013Z" creationid="yamato" creationdate="20140914T112013Z">
        <seg>&lt;c2&gt;~~&lt;/c2&gt;スマートマッチ演算子は左側の値に右側の式の&lt;c3&gt;$_&lt;/c3&gt;をセットする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;.next&lt;/c4&gt; and &lt;c5&gt;.last&lt;/c5&gt; methods take an optional argument giving the final value of that loop iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T101538Z" creationid="Toshiyuki" creationdate="20130806T101538Z">
        <seg>&lt;c4&gt;.next&lt;/c4&gt;と&lt;c5&gt;.last&lt;/c5&gt;メソッドはそのループのイテレーションの最終値を与える任意の引数をとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Buf Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Buf型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The COMPILING pseudopackage</seg>
      </tuv>
      <tuv lang="JA">
        <seg>COMPILING擬似パッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Cool class (and package)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T232404Z" creationid="Toshiyuki" creationdate="20140328T232404Z">
        <seg>Coolクラス（とパッケージ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Current Working Directory.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115220Z" creationid="yamato" creationdate="20140914T115220Z">
        <seg>現在の作業ディレクトリ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HOW Method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HOWメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HyperWhatever Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HyperWhatever型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Mu type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Mu型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ObjAt Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ObjAt型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The P6opaque Datatype</seg>
      </tuv>
      <tuv lang="JA">
        <seg>P6opaqueデータ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The PROCESS package</seg>
      </tuv>
      <tuv lang="JA">
        <seg>PROCESSパッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Perl 6 equivalent to Perl 5's &lt;c0&gt;eval {...}&lt;/c0&gt; is &lt;c1&gt;try {...}&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121703Z" creationid="Toshiyuki" creationdate="20130813T121703Z">
        <seg>Perl 5の&lt;c0&gt;eval {...}&lt;/c0&gt;に対するPerl 6の同等物は&lt;c1&gt;try {...}&lt;/c1&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Relationship of Blocks and Declarations</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T115332Z" creationid="Toshiyuki" creationdate="20130729T115332Z">
        <seg>ブロックと宣言の関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Relationship of Blocks and Statements</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T155712Z" creationid="Toshiyuki" creationdate="20130802T155712Z">
        <seg>ブロックと文の関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The STD::Regex grammar also adds these:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>STD::Regex文法も、これらを加える：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The StrLen Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>StrLen型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The StrPos Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>StrPos型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Whatever Object</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Whateverオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The WhateverCode Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>WhateverCode型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The anonymous enum function</seg>
      </tuv>
      <tuv lang="JA">
        <seg>匿名のenum関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The answer is that binding to array elements is recognized at the syntax level, and instead of emitting code for a normal binding operation, a special method on the array is called that knows how to do the binding itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T140721Z" creationid="yamato" creationdate="20140914T140721Z">
        <seg>答えは配列要素へのバインディングは構文レベルで認知されるということだ。そして通常のバインディング演算のコードを発行する代わりに、それ自身をどのようにバインドするか知っている特別なメソッドが配列で呼び出される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The answer is yes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>答えは、はいである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array knows that it is extensible, and calls the iterator as it needs more elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列は、それが伸長可能で、より多くの要素を必要として反復子を呼ぶということを知っている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment operator asks the container on the left to store the value on its right.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T131637Z" creationid="yamato" creationdate="20140914T131637Z">
        <seg>割り当て演算子は右の値を保存するために左にコンテナを求める。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The backslash is always removed in this case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バックスラッシュは、常にこの場合削除される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The biggest difference between constructors in Perl 6 and constructors in languages such as C# and Java is that rather than setting up state on a somehow already magically created object, Perl 6 constructors actually create the object themselves.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141259Z" creationid="Toshiyuki" creationdate="20140111T193722Z">
        <seg>Perl 6とC#やJavaのような言語との間の大きな違いは、何故かすでにマジカルに作成されたオブジェクトの状態をセットするよりも、Perl 6は実際にそれら自身でオブジェクトを作成することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The block that follows may contain arbitrary code, just as with any other block, but classes commonly contain state and behavior declarations.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T180245Z" creationid="Toshiyuki" creationdate="20140111T180245Z">
        <seg>続くブロックは何か他のブロックのように不定のコードを含みます。しかしクラスは一般に状態と振る舞いの宣言を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The boxed object types may carry more detailed information on where overflow or underflow occurred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>箱入りオブジェクトタイプは、オーバーフローかアンダーフローがどこで起こったかについて、より多くの詳細をもたらすかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The caller's lexical scope is allowed to hide any user-defined variable from you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>発信者のレキシカルスコープは、何か利用者変数をあなたから隠させておかれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The choice any particular implementation makes is specifically &lt;i1&gt;not&lt;/i1&gt; part of the definition of Perl 6, and you should not rely on it in portable code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T041448Z" creationid="Toshiyuki" creationdate="20130811T041448Z">
        <seg>どんな特定の実装の選択も明確にPerl 6の定義の一部ではない。そして移植可能なコード内でそれに頼るべきではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler is free to infer what type information it can from the types you supply, but it will not complain about missing type information unless you ask it to.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140325T142047Z" creationid="Toshiyuki" creationdate="20140325T141831Z">
        <seg>コンパイラがあなたが供給できる型から型情報を推測するのは自由です。しかしあなたがそれを尋ねない限り、欠けている型情報について不満を言いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complex type defaults to NaN + NaN\i.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複素数型は、NaN + NaN\iにデフォルトでなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constructor captures these into the &lt;c1&gt;@dependencies&lt;/c1&gt; slurpy array and passes them as named parameters to &lt;c2&gt;bless&lt;/c2&gt; (note that &lt;c3&gt;:&amp;callback&lt;/c3&gt; uses the name of the variable--minus the sigil--as the name of the parameter).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141539Z" creationid="Toshiyuki" creationdate="20140112T090513Z">
        <seg>コンストラクタはそれらをslurpyな配列&lt;c1&gt;@dependencies&lt;/c1&gt;にキャプチャーし、&lt;c2&gt;bless&lt;/c2&gt;に名前付きパラメータとして渡します（&lt;c3&gt;:&amp;callback&lt;/c3&gt;は変数名を使うので注意してください ― シギル無しで ― パラメータの名前として）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The container object itself then becomes undefined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それから、コンテナオブジェクトそのものは、未定義になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The container type specifies how the variable itself is implemented.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224517Z" creationid="Toshiyuki" creationdate="20140328T224517Z">
        <seg>コンテナ型は変数自体がどのように実装されるか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The context in which a subscript is evaluated is no longer controlled by the sigil either.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字が評価される前後関係は、シギルによってももはやコントロールされない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The control lambda is logically separate from the catch lambda, though an implementation is allowed to combine them if it is careful to retain separate semantics for catch and control exceptions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T125641Z" creationid="Toshiyuki" creationdate="20130817T125641Z">
        <seg>制御lambdaはキャッチlambdaとは論理的に異なる。けれどもキャッチと制御例外のセマンティクスを別々に注意して保持するなら実装を結合することは許可される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current package is searched last.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>カレントパッケージは、最後に捜される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current topic is always aliased to the special variable &lt;c0&gt;$_&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125321Z" creationid="Toshiyuki" creationdate="20130811T125321Z">
        <seg>現在のトピックは常に特殊変数&lt;c0&gt;$_&lt;/c0&gt;にエイリアスされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The currently known exceptions to this are where the parser must:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構文解析器がそうしなければならない所で、これに対する現在既知の例外はそうである：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default case:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133227Z" creationid="Toshiyuki" creationdate="20130811T133227Z">
        <seg>defaultケース：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default floating-point modes do not throw exceptions but rather propagate Inf and NaN.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デフォルト浮動小数点モードは例外を投げなくて、むしろ最大下界とナンを繁殖させる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definitions of alphabetic and numeric include appropriate Unicode characters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T092741Z" creationid="Toshiyuki" creationdate="20140329T092658Z">
        <seg>英字と数字の定義は適切なユニコード文字も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The distinction whether an &lt;c3&gt;=&lt;/c3&gt; means item or list assignment is based on the syntax of the left-hand side.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T024034Z" creationid="yamato" creationdate="20140914T024034Z">
        <seg>&lt;c3&gt;=&lt;/c3&gt;がアイテム割り当て、リスト割り当てのどちらを意味するかは左側の構文に基づいて区別される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The double-underscore forms are going away:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>倍のアンダーラインの形態は去っている：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The downside of this approach is a slight restriction--you may not use the actual text of the heredoc in code that must run before the line finishes parsing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このアプローチの不利な面はわずかな規制である－線が構文解析を終える前に、走らなければならないコードでheredocの実際のテキストを使わなくてもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The eager operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>eager演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The element is deleted only if the adverb is true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>副詞が真実の場合だけ、要素はアンインストール済みである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The eventual binding context thus determines whether to throw away or keep the groupings resulting from each individual &lt;c1&gt;take&lt;/c1&gt; call.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T205608Z" creationid="Toshiyuki" creationdate="20130810T205608Z">
        <seg>最終のバインディングコンテキストはグルーピングを捨てるか保つか決める。それぞれの個々の&lt;c1&gt;take&lt;/c1&gt;呼び出しからの結果として。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above uses the class name &lt;c4&gt;Task&lt;/c4&gt; so that other code can refer to it later, such as to create class instances by calling the &lt;c5&gt;new&lt;/c5&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045042Z" creationid="Toshiyuki" creationdate="20140111T181518Z">
        <seg>他のコードが後でそれを参照することができるように、上の例はクラス名&lt;c4&gt;Task&lt;/c4&gt;を使います、例えば&lt;c5&gt;new&lt;/c5&gt;メソッドを呼ぶことによってクラスインスタンスを作るために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below demonstrates the &lt;c0&gt;Baker&lt;/c0&gt; class overriding the &lt;c1&gt;Cook&lt;/c1&gt;'s &lt;c2&gt;cook&lt;/c2&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144449Z" creationid="Toshiyuki" creationdate="20140112T124052Z">
        <seg>下の例は&lt;c1&gt;Cook&lt;/c1&gt;クラスの&lt;c2&gt;cook&lt;/c2&gt;メソッドをオーバーライドする&lt;c0&gt;Baker&lt;/c0&gt;クラスを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example code includes attributes (state), introduced through the &lt;c1&gt;has&lt;/c1&gt; keyword, and behaviors introduced through the &lt;c2&gt;method&lt;/c2&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T180908Z" creationid="Toshiyuki" creationdate="20140111T180908Z">
        <seg>例のコードは属性（状態）を含み、&lt;c1&gt;has&lt;/c1&gt;キーワードで導入されます。そして振る舞いは&lt;c2&gt;method&lt;/c2&gt;キーワードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example's constructor turns positional arguments into named arguments, so that the class can provide a nice constructor for its users.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141436Z" creationid="Toshiyuki" creationdate="20140112T035603Z">
        <seg>例のコンストラクタは位置依存パラメータを名前付きパラメータに変換します。なのでクラスはユーザーに良いコンストラクタを提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception thrower looks up the call stack for a catch lambda that returns () to indicate all exceptions are handled, and then it is happy, and unwinds the stack to that point.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T112512Z" creationid="Toshiyuki" creationdate="20130814T112512Z">
        <seg>例外を投げるものは全ての例外がハンドルされることを示すために()を返すlambdaをキャッチするためにコールスタックを探す。そしてそのときハッピーで、その点にスタックを巻き戻す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exceptions will be noted as we go.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々が行って、例外は注意される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression inside is evaluated in string item context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>中の表現は、文字列項目前後関係で評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fact that a parameter is being bound implies that there is an outer capture being bound to a signature.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータが結びつけられているという事実は、シグネチャに密接に結びついている外のキャプチャーがあることを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fact that the &lt;c0&gt;.&lt;/c0&gt; twigil just does a method call also implies that the following is possible too.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T061444Z" creationid="yamato" creationdate="20140914T061444Z">
        <seg>実際、&lt;c0&gt;.&lt;/c0&gt;ツウィギルは以下が可能なようにメソッドを呼び出すだけだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fatarrow construct may be used only where a term is expected because it's considered an expression in its own right, since the fatarrow itself is parsed as a normal infix operator (even when autoquoting an identifier on its left).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fatarrow自体が通常のインフィックスオペレータ（その左で識別子をautoquotingするときでも）として解析される時から、それがそれ自身のものの表現を正しいと考えたので項が予想される所でだけ、fatarrow構成概念が使われるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first declaration specifies instance storage for a callback -- a bit of code to invoke in order to perform the task that an object represents:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182453Z" creationid="Toshiyuki" creationdate="20140111T182453Z">
        <seg>最初の宣言は、コールバックのためにインスタンス・ストレージを指定します－オブジェクトが表す仕事を実行するために呼び出すわずかなコード：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first parameter is the callback (the thing to do to execute the task).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141503Z" creationid="Toshiyuki" creationdate="20140112T035629Z">
        <seg>最初のパラメータはコールバック（タスクを実行するためのもの）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first such declaration within a scope is assumed to be an unbound type, and takes the actual type of its associated argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スコープの中の第1のそのような宣言は、束縛を解かれた型であるとされて、その関連した引数の実際の型をする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first three lines inside the class block all declare attributes (called &lt;e0&gt;fields&lt;/e0&gt; or &lt;e1&gt;instance storage&lt;/e1&gt; in other languages).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182038Z" creationid="Toshiyuki" creationdate="20140111T182038Z">
        <seg>クラスブロック内の最初の3行は全て属性を宣言します（他の言語では&lt;e0&gt;フィールド&lt;/e0&gt;または&lt;e1&gt;インスタンスストレージ&lt;/e1&gt;と呼ばれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first time &lt;c0&gt;&amp;say-all&lt;/c0&gt; is called, it prints "1, 10, 100" just as one would expect.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T043557Z" creationid="yamato" creationdate="20140914T043557Z">
        <seg>最初に&lt;c0&gt;&amp;say-all&lt;/c0&gt;が呼ばれ、「1, 10, 100」を予期する通りに出力する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two tests each smart-match against a class name.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T104937Z" creationid="Toshiyuki" creationdate="20140112T135621Z">
        <seg>最初の2つは各々のクラス名に対してスマートマッチをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The flattening or slicing of any such returned parcel will be dependent on how the &lt;c2&gt;gather&lt;/c2&gt;'s return iterator is iterated (with &lt;c3&gt;.get&lt;/c3&gt; vs &lt;c4&gt;.getarg&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T201914Z" creationid="Toshiyuki" creationdate="20130810T201914Z">
        <seg>そのような返されたパーセルの平坦化またはスライシングは&lt;c2&gt;gather&lt;/c2&gt;の返したイテレータがどのように反復するかに依存している（&lt;c3&gt;.get&lt;/c3&gt;対&lt;c4&gt;.getarg&lt;/c4&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following are useful:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下は役に立つ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following examples all do the same, and do not flatten:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T141327Z" creationid="yamato" creationdate="20140914T141327Z">
        <seg>以下の例はすべて同じでフラット化を行わない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following means the same as the previous example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下は、前の例と同じことを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following program shows how a dependency handler might look in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T174417Z" creationid="Toshiyuki" creationdate="20140111T174417Z">
        <seg>以下のプログラムはPerl 6で依存ハンドラがどのように見えるか示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following pseudo-package names are reserved at the front of a name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の疑似パッケージ名は、名前の先頭に確保される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following relative names are also reserved but may be used anywhere in a name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の関係名が確保されもするが、名前でどこでも使われるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following return objects that contain all pertinent info:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての関係する情報を含む以下の戻りオブジェクト：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following roles are supported:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のロールはサポートされる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following treats every other value in &lt;c1&gt;@values&lt;/c1&gt; as modifiable:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113118Z" creationid="Toshiyuki" creationdate="20130810T113118Z">
        <seg>次のコードは&lt;c1&gt;@values&lt;/c1&gt;の値を一つ置きに変更可能として扱う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function (or listop) form always exits from the innermost block, returning its arguments as the final value of the block exactly as &lt;c1&gt;return&lt;/c1&gt; does.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T071452Z" creationid="Toshiyuki" creationdate="20130817T071429Z">
        <seg>関数（またはリスト演算子）形式は常に最も深いブロックから抜け出し、&lt;c1&gt;return&lt;/c1&gt;がするようにブロックの最後の値としてその引数を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function in question neither knows nor cares how weird the original syntax was.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>問題の関数は、知りもしなく、最初の構文がどれくらい怪しくもあったかについて気にしない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general loop statement</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T055617Z" creationid="Toshiyuki" creationdate="20130810T055617Z">
        <seg>一般のループ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general radix form of a number involves prefixing with the radix in adverbial form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>番号の一般根の形態は、副詞形で根でプレフィクシングを含む：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic string-to-number converter will recognize all of these forms (including the * form, since constant folding is not available to the run time).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的な数への文字列コンバータは、これらの形（*の形を含む、定数畳込みが実行時が利用できない時から）の全てを認知する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hyper operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>hyper演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The identifier is not subject to keyword or even macro interpretation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子は、キーワードまたはマクロ字句解釈さえ受けない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implicit break (what &lt;c2&gt;succeed&lt;/c2&gt; does explicitly) of a &lt;c3&gt;when&lt;/c3&gt; block is abnormal.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T125233Z" creationid="Toshiyuki" creationdate="20130816T125233Z">
        <seg>&lt;c3&gt;when&lt;/c3&gt;ブロックの暗黙の中断（&lt;c2&gt;succeed&lt;/c2&gt;は明示的に行う）はアブノーマルだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implicit break of a normal &lt;c0&gt;when&lt;/c0&gt; block works the same way, returning the value of the entire block (normally from its last statement) via an implicit &lt;c1&gt;succeed&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T114905Z" creationid="Toshiyuki" creationdate="20130813T114905Z">
        <seg>通常の&lt;c0&gt;when&lt;/c0&gt;ブロックの暗黙の脱出は同じ方法の動作で、暗黙の&lt;c1&gt;succeed&lt;/c1&gt;を経て全体のブロック（通常はその最後の文）の値を返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializing expression is evaluated at &lt;c0&gt;BEGIN&lt;/c0&gt; time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T131959Z" creationid="Toshiyuki" creationdate="20130802T131959Z">
        <seg>初期化式は&lt;c0&gt;BEGIN&lt;/c0&gt;時に評価される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intent of all this is to make sure that prereleases sort before releases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>こんな意図は、リリースの前にそのプレリリースタイプを確かにすることである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key type of a hash may be specified as a shape trait--see S09.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T223509Z" creationid="Toshiyuki" creationdate="20140328T223509Z">
        <seg>ハッシュのキーの型はshapeトレイトとして指定されます ― S09を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyword for individual cases is &lt;c1&gt;when&lt;/c1&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T125157Z" creationid="Toshiyuki" creationdate="20130811T125157Z">
        <seg>個々のケースのキーワードは&lt;c1&gt;when&lt;/c1&gt;だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lexical scope supplies the declared target for the dynamic operation.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T004107Z" creationid="Toshiyuki" creationdate="20130728T004107Z">
        <seg>レキシカルスコープは動的な操作のために宣言されたターゲットを供給する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The list is evaluated lazily by default, so instead of using a &lt;c0&gt;while&lt;/c0&gt; to read a file a line at a time as you would in Perl 5:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T062615Z" creationid="Toshiyuki" creationdate="20130810T062615Z">
        <seg>デフォルトではリストは不精に評価されるので、Perl 5ではファイルを一行ずつ読み込むために代わりに&lt;c0&gt;while&lt;/c0&gt;を使う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop conditional on a &lt;c4&gt;repeat&lt;/c4&gt; block is required, so it will be recognized even if you put it on a line by its own:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T152109Z" creationid="Toshiyuki" creationdate="20130809T152109Z">
        <seg>&lt;c4&gt;repeat&lt;/c4&gt;ブロックのループ条件が必要なので、 それを独自の行に置いても評価される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The magic input handle</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マジックの入力ハンドル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method form will leave any block in the dynamic scope that can be named as an object and that responds to the &lt;c2&gt;.leave&lt;/c2&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T071918Z" creationid="Toshiyuki" creationdate="20130817T071918Z">
        <seg>メソッド形式はオブジェクトとして名前付けでき、&lt;c2&gt;.leave&lt;/c2&gt;メソッドに応答するダイナミックスコープの何か一つのブロックを抜け出すだろう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method is called in item context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドは、アイテム前後関係で呼ばれる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method itself takes the passed parameter--which must be an instance of the &lt;c0&gt;Task&lt;/c0&gt; class--and &lt;c1&gt;push&lt;/c1&gt;es it onto the invocant's &lt;c2&gt;@!dependencies&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T140805Z" creationid="Toshiyuki" creationdate="20140111T190502Z">
        <seg>メソッド自身は渡されたパラメータを受け取ります ― それは&lt;c0&gt;Task&lt;/c0&gt;クラスのインスタンスでなければなりません ― そしてそれをインボカントの&lt;c2&gt;@!dependencies&lt;/c2&gt;属性に&lt;c1&gt;プッシュ&lt;/c1&gt;します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most basic one is &lt;e0&gt;Parcel&lt;/e0&gt;, short for &lt;e1&gt;Parenthesis cell&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T133948Z" creationid="yamato" creationdate="20140914T133948Z">
        <seg>最も基本的なのは&lt;e0&gt;Parcel&lt;/e0&gt;、&lt;e1&gt;Parenthesis cell&lt;/e1&gt;の略だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name itself returns that type object:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前そのものは、その型オブジェクトを返る：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the perl executable that is currently running.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115749Z" creationid="yamato" creationdate="20140914T115749Z">
        <seg>現在実行しているperl実行ファイルの名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new &lt;c0&gt;constant&lt;/c0&gt; declarator introduces a compile-time constant, either a variable or named value, which may be initialized with a pseudo-assignment:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T131802Z" creationid="Toshiyuki" creationdate="20130802T131802Z">
        <seg>新しい&lt;c0&gt;constant&lt;/c0&gt;宣言は変数または名前付きの値にコンパイル時の定数をもたらし、擬似割り当てで初期化されるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new type name is introduced immediately, so two such types in the same signature must unify compatibly if they have the same name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいタイプ名はすぐに持ち出されるので、それらには同じ名前があるならば、同じシグネチャのそのような2つの型は両立できるようにひとつにならなければならない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The null pseudo-package is reserved to mean the same search list as an ordinary name search.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無効な擬似パッケージは、普通の名前検索と同じ検索リストを意味するために確保される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The numerator should in general be twice the size of the denominator to support user expectations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分子は、一般にユーザー予想をサポートする分母のサイズの2倍でなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The numeric type chosen depends on the appearance of the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>選ばれる数値型は、文字通りのものの様子次第である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The old disambiguation syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>旧一義化構文：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only remaining difficulty arises if both the user and a library writer attempt to use dynamic gather with user-defined callbacks that contain &lt;c11&gt;take&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T160934Z" creationid="Toshiyuki" creationdate="20130810T160934Z">
        <seg>ユーザーとライブラリ作者がダイナミックなgatherを&lt;c11&gt;take&lt;/c11&gt;を含むユーザー定義のコールバックと使用しようと試みるなら、唯一残っている難しさが生じる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output can look like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T104840Z" creationid="Toshiyuki" creationdate="20140112T135553Z">
        <seg>出力はこのようになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parens are, of course, required if there is more than one parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のパラメータがあるならば、括弧は、もちろん、必要とされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parenthesized form of type coercion may be used in declarations where it makes sense to accept a wider set of types but coerce them to a narrow type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型強制の括弧に入れられた形が、型のより広いセットを受け入れるが、狭い型にそれらを強制することが意味をなす宣言において使われるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous value of &lt;c0&gt;$_&lt;/c0&gt; is not available within the loop.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114904Z" creationid="Toshiyuki" creationdate="20130810T114904Z">
        <seg>&lt;c0&gt;$_&lt;/c0&gt;の前の値はループ内では使用できない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process as a whole may place restrictions on the mutability of process variables as seen by the individual subprocesses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>個々のサブプロセスによって見られるように、プロセスは規制をプロセス変数の移り気に全体として置くかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pseudo-subscripts need not be simple scalars.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>疑似添え字は、単純なスカラーである必要はない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The race operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>race演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rationale for this function is that there are many cases where the programmer or user is forced to use a string type to represent a value that is intended to become a numeric type internally.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数のための正当性は、プログラマーまたはユーザーが内部的に数値型になることを意図される値を表現するために文字列型を使うことを強制される多くのケースがあるということである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the parameters are dependent &lt;c0&gt;Task&lt;/c0&gt; instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T090212Z" creationid="Toshiyuki" creationdate="20140112T090212Z">
        <seg>残りのパラメータは従属する&lt;c0&gt;Task&lt;/c0&gt;のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of a conditional statement is the result of the block chosen to execute.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T044423Z" creationid="Toshiyuki" creationdate="20130803T044423Z">
        <seg>条件文の結果はブロックが実行に選んだ結果になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same methods apply to strings as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同法は、同様に文字列にあてはまる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second declaration also uses the private twigil:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182749Z" creationid="Toshiyuki" creationdate="20140111T182749Z">
        <seg>2回目の宣言も、プライベートtwigilを使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second method contains the main logic of the dependency handler:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T190532Z" creationid="Toshiyuki" creationdate="20140111T190532Z">
        <seg>第2のメソッドは、依存ハンドラーのメインのロジックを含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second time though, it prints "1, 11, 101".</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T043906Z" creationid="yamato" creationdate="20140914T043906Z">
        <seg>しかし2度目は「1, 11, 101」と出力する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics of &lt;c0&gt;INIT&lt;/c0&gt; and &lt;c1&gt;once&lt;/c1&gt; are not equivalent to each other in the case of cloned closures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130822T030444Z" creationid="Toshiyuki" creationdate="20130822T030444Z">
        <seg>&lt;c0&gt;INIT&lt;/c0&gt;と&lt;c1&gt;once&lt;/c1&gt;のセマンティクスは他のそれぞれの複製されたクロージャとは同等ではない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sigil serves both as rough type constraint, and as an indicator as to whether the contents of the variable flatten in list context.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T023046Z" creationid="yamato" creationdate="20140914T023046Z">
        <seg>シギルはおおまかな型成約と、変数の内容がリストコンテキストでフラットになるかどうかに関する指標として役立つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest case of a regex is a constant string.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124243Z" creationid="Toshiyuki" creationdate="20140115T143508Z">
        <seg>正規表現で最も単純なケースは固定文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The statement form can be particularly useful to expose a lexically scoped declaration to the surrounding lexical scope without "trapping" it inside a block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T084118Z" creationid="Toshiyuki" creationdate="20130818T084118Z">
        <seg>文形式はブロック内の「トラッピング」なしのレキシカルスコープで囲まれた宣言を公開するのに便利だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax of calling method with &lt;c0&gt;.^&lt;/c0&gt; instead of a single dot means that it is actually a method call on the &lt;e1&gt;meta class&lt;/e1&gt;, which is a class managing the properties of the &lt;c2&gt;Employee&lt;/c2&gt; class - or any other class you are interested in.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T151834Z" creationid="Toshiyuki" creationdate="20140112T160227Z">
        <seg>シングルドットの代わりの&lt;c0&gt;.^&lt;/c0&gt;は実際は&lt;e1&gt;メタクラス&lt;/e1&gt;のメソッドコールで、それは&lt;c2&gt;Employee&lt;/c2&gt;のプロパティを管理します ― またはあなたが興味のある他のクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax of individual adverbs is the same everywhere in Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>個々の副詞の構文は、至る所でPerl 6の同じことである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The system's local timezone.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115201Z" creationid="yamato" creationdate="20140914T115201Z">
        <seg>システムローカルのタイムゾーン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third attribute represents the state of completion of a task:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T183131Z" creationid="Toshiyuki" creationdate="20140111T183131Z">
        <seg>第3の属性は、仕事の完成の状態を表します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third time &lt;c3&gt;&amp;say-all&lt;/c3&gt; is called &lt;c4&gt;$*dynamic1&lt;/c4&gt; isn't 11 anymore, but &lt;c5&gt;$*dynamic2&lt;/c5&gt; is still 101.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T050107Z" creationid="yamato" creationdate="20140914T050107Z">
        <seg>3度目の&lt;c3&gt;&amp;say-all&lt;/c3&gt;はもはや11でない&lt;c4&gt;$*dynamic1&lt;/c4&gt;で呼ばれるが&lt;c5&gt;$*dynamic2&lt;/c5&gt;は101のままだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two dynamic variables are looked up in the callers scope and therefore have the values 11 and 101.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T045714Z" creationid="yamato" creationdate="20140914T045714Z">
        <seg>2つの動的変数は呼び出し元のスコープでルックアップされる。したがって11と101という値を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type inside the parens indicates the acceptable set of types that are allowed to be bound or assigned to this location via coercion.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧の中の型は、結びつけられるか、強制を通してこの場所に割り当てさせられておかれる型の許容できるセットを示す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unhandled list is a dynamic variable so that it's easy for .resume to manipulate it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115244Z" creationid="Toshiyuki" creationdate="20130814T115244Z">
        <seg>ハンドルされないリストはダイナミックな変数なので.resumeがそれを扱うのは簡単だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The usage message generated from the signatures of MAIN subs.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114933Z" creationid="yamato" creationdate="20140914T114933Z">
        <seg>MAINサブルーチンのシグネチャによって生成される使用法メッセージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value added is one more than the previous key or pair's value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えられる値は、前のキーまたは一組の値より、1である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a loop statement is the list of values from each iteration.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T131033Z" creationid="Toshiyuki" creationdate="20130808T131033Z">
        <seg>ループ文の値はそれぞれの反復の値のリストになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the &lt;c1&gt;:!identifier&lt;/c1&gt; form is &lt;c2&gt;Bool::False&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T123845Z" creationid="yamato" creationdate="20140914T123845Z">
        <seg>&lt;c1&gt;:!identifier&lt;/c1&gt;形式の値は&lt;c2&gt;Bool::False&lt;/c2&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the conditional expression may be optionally bound to a closure parameter:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T045847Z" creationid="Toshiyuki" creationdate="20130804T045847Z">
        <seg>条件式の値はクロージャのパラメータに任意に結び付けられるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned by the &lt;c0&gt;take&lt;/c0&gt; to the &lt;c1&gt;take&lt;/c1&gt;'s own context is that same returned argument (which is ignored when the &lt;c2&gt;take&lt;/c2&gt; is in sink context).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T203222Z" creationid="Toshiyuki" creationdate="20130810T203222Z">
        <seg>&lt;c0&gt;take&lt;/c0&gt;から&lt;c1&gt;take&lt;/c1&gt;自身のコンテキストに返された値は返された同じ引数だ（それは&lt;c2&gt;take&lt;/c2&gt;がsinkコンテキストの時は無視される）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word &lt;c2&gt;returns&lt;/c2&gt; is allowed as an alias for &lt;c3&gt;of&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T212945Z" creationid="Toshiyuki" creationdate="20140328T212945Z">
        <seg>&lt;c2&gt;returns&lt;/c2&gt;が&lt;c3&gt;of&lt;/c3&gt;の別名として使用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then if the denominator exceeds the storage size of the unsigned integer used, the fraction is reduced via gcd.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、分母が使われる符号のない整数の記憶装置の大きさを超えるならば、分数はgcdを通して約分される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a number of positional container types with slightly different semantics in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T133923Z" creationid="yamato" creationdate="20140914T133923Z">
        <seg>Perl 6には意味論の少し異なる位置コンテナタイプがいくつかある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are built-in identifier terms in Perl 6, which are listed below.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124356Z" creationid="yamato" creationdate="20140914T124356Z">
        <seg>Perl 6ではビルトインの識別子項があり、以下に記載されている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no barewords in Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>barewordsが、Perl 6でない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no exceptions based on whether an argument is wanted or not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数が求められているかどうかに基づく例外が、ない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no signed buf types provided as built-ins, but you may say</seg>
      </tuv>
      <tuv lang="JA">
        <seg>内蔵として提供される署名されたbuf型がない、しかし、あなたは言うかもしれない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several use cases for this, if you know you're going to initialize the memory otherwise, or you're doing some form of memory mapping.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが特にメモリを初期化することになるということを知っているならば、いくつかの使用事例がこれのためにある、または、あなたは何らかのメモリマッピングをしている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three special variables that are available in every block:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T110659Z" creationid="yamato" creationdate="20140914T110659Z">
        <seg>ブロックごとに利用できる3つの特殊変数がある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three ways to declare formal parameters to a closure.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T123503Z" creationid="Toshiyuki" creationdate="20130729T123503Z">
        <seg>クロージャに仮パラメータを宣言する方法が3つある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two forms of comment based on &lt;c1&gt;#&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki Yamato" changedate="20140830T110244Z" creationid="Toshiyuki Yamato" creationdate="20140830T110233Z">
        <seg>&lt;c1&gt;#&lt;/c1&gt;ベースのコメントには2つの形式があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two possible ways to parse heredocs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2つのあり得る方法が、heredocsを解析するためにある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two types of assignment, &lt;e0&gt;item assignment&lt;/e0&gt; and &lt;e1&gt;list assignment&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T023432Z" creationid="yamato" creationdate="20140914T023432Z">
        <seg>&lt;e0&gt;アイテム割り当て&lt;/e0&gt;と&lt;e1&gt;リスト割り当て&lt;/e1&gt;という2種類の割り当てがある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There does not seem to be a prevailing term in the industry for this, so we've coined the term &lt;i1&gt;lexotic&lt;/i1&gt; to refer to these strange operations that perform a dynamic operation with a lexical target in mind.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130728T010232Z" creationid="Toshiyuki" creationdate="20130728T005906Z">
        <seg>これに関して業界で一般的な語句が無いように思う。そういうわけで、レキシカルなターゲットを考慮して動的な操作を行うこれらの奇妙な操作を言及するために、我々は&lt;i1&gt;レギゾチック&lt;/i1&gt;という語句を作った。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a &lt;c0&gt;when&lt;/c0&gt; statement modifier, but it does not have any breakout semantics; it is merely a smartmatch against the current topic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121031Z" creationid="Toshiyuki" creationdate="20130813T121031Z">
        <seg>&lt;c0&gt;when&lt;/c0&gt;文修飾子があるが、なんの脱出のセマンティクスも持たない。それは単に現在のトピックに反してスマートマッチする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a need to distinguish list assignment from list binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リスト割当てとリストバインディングを区別する必要が、ある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a new &lt;c0&gt;state&lt;/c0&gt; declarator that introduces a lexically scoped variable like &lt;c1&gt;my&lt;/c1&gt; does, but with a lifetime that persists for the life of the closure, so that it keeps its value from the end of one call to the beginning of the next.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T133110Z" creationid="Toshiyuki" creationdate="20130802T133110Z">
        <seg>新しい&lt;c0&gt;state&lt;/c0&gt;宣言は&lt;c1&gt;my&lt;/c1&gt;がするようなレキシカルスコープの変数をもたらす。しかしライフタイムがクロージャの寿命の間持続するので、呼び出しの終わりから次の呼び出しまで値を保持する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a slight exception though: if you call a method on an itemized container, it will generally behave as if it weren't itemized.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T141645Z" creationid="yamato" creationdate="20140914T141645Z">
        <seg>しかし少し例外がある：アイテム化されたコンテナでメソッドを呼ぶなら、それはアイテム化されていなかったように振る舞う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a special value named &lt;c0&gt;Nil&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T132633Z" creationid="Toshiyuki" creationdate="20140327T132633Z">
        <seg>&lt;c0&gt;Nil&lt;/c0&gt;という名前の特殊な値があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a &lt;c2&gt;let&lt;/c2&gt; prefix operator that sets a hypothetical value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T134150Z" creationid="Toshiyuki" creationdate="20130802T134150Z">
        <seg>仮想の値をセットする&lt;c2&gt;let&lt;/c2&gt;接頭演算子もある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no &lt;c0&gt;foreach&lt;/c0&gt; statement any more.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060705Z" creationid="Toshiyuki" creationdate="20130810T060705Z">
        <seg>今や&lt;c0&gt;foreach&lt;/c0&gt;文は存在しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no corresponding native &lt;c1&gt;str&lt;/c1&gt; type.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T131141Z" creationid="Toshiyuki" creationdate="20140328T131141Z">
        <seg>対応するネイティブ&lt;c1&gt;str&lt;/c1&gt;型はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no hash subscript autoquoting in Perl 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 6でautoquotingしているハッシュ添え字が、ない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no longer a &lt;c0&gt;continue&lt;/c0&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130739Z" creationid="Toshiyuki" creationdate="20130808T130739Z">
        <seg>もはや&lt;c0&gt;continue&lt;/c0&gt;ブロックはない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no such thing as a hash list context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュリストコンテキストなんてものが、ない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is now a generalized adverbial form of Pair notation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一組表記法の全般的な副詞形が、現在ある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may be whitespace before the opening delimiter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白文字が、始めのデリミタの前にあるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's no reason to exclude any useful epoch that is well characterized in atomic seconds.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>原子秒でよく特徴づけられる少しも役に立つエポックを除外する理由が、ない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore the same things that apply to variables declared using the &lt;c1&gt;^&lt;/c1&gt; twigil apply also to them (with the exception that they are not positional and therefore not ordered using Unicode order, of course).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T063925Z" creationid="yamato" creationdate="20140914T063925Z">
        <seg>したがって、&lt;c1&gt;^&lt;/c1&gt;ツウィギルを使って宣言される変数に適用されることは それらにも適用される（それらが位置ではなくユニコード順にならないことを除いて）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140104T201344Z" creationid="Toshiyuki" creationdate="20140104T201344Z">
        <seg>したがって：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These Pod objects can be used as Positionals (indexed by their block sequence).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのポッドオブジェクトが、Positionals（彼らのブロック溶着方法によって索引付けされる）として使われることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These adverbial forms all weed out non-existing entries if the adverb is true; if not, they leave them in, just as an ordinary slice would.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T084850Z" creationid="Toshiyuki" creationdate="20140329T084715Z">
        <seg>副詞が真である場合はこれらの副詞形式は存在しないエントリーを全て除きます。そうでなければ、通常のスライスのようにそれらを残します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These all mean the same thing:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのすべては、同じものを意味する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are all the same name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、すべての同じ名前である：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are all the same:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、それでもなお以下の通りである：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are all values that are known to the compiler, and may in fact be dynamically scoped within the compiler itself, and only appear to be lexically scoped because dynamic scopes of the compiler resolve to lexical scopes of the program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、コンパイラに知られていて、コンパイラそのものの範囲内で実際ダイナミックに捜し出されるかもしれないすべての値で、コンパイラの動的スコープがプログラムのレキシカルスコープに分解するので辞書的に捜し出されるように見えるだけである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are extended with the same two-element list:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、同じ2-要素リストで広げられる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are storage locations that every instance of a class will obtain.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182109Z" creationid="Toshiyuki" creationdate="20140111T182109Z">
        <seg>これらは、クラスのすべてのインスタンスが得るだろう記憶場所です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These auto-called blocks are known as &lt;i1&gt;phasers&lt;/i1&gt;, since they generally mark the transition from one phase of computing to another.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T080249Z" creationid="Toshiyuki" creationdate="20130818T080249Z">
        <seg>これらの自動呼び出しされるブロックは&lt;i1&gt;phasers&lt;/i1&gt;として知られる。だから一つの計算フェーズから他への移行を一般的にマークする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These can be given meaning via the MMD system, if not the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラとまではいかないが、これらはMMDシステムによって意味を与えられることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These combinations are considered legal and mean the following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの組合せは合法的であると考えられて、以下を意味する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These comments work exactly like ordinary comments in Perl code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのコメントは、Perlコードで普通のコメントのように正確に動く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These conceptual types include:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの概念上の型は以下を含む：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constructs establish a dynamic scope without necessarily establishing a lexical scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T080849Z" creationid="Toshiyuki" creationdate="20130811T080849Z">
        <seg>これらの構成物はレキシカルスコープを確立する必要なしに動的スコープを確立する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These forms produce regex literals.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T122916Z" creationid="yamato" creationdate="20140914T122916Z">
        <seg>これらの形式は正規表現リテラルを作り出す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These forms require an identifier to serve as the key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの形は、キーとして用いられることを識別子に要求する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These have the advantage of passing the variable in question into the closure as its topic:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T093134Z" creationid="Toshiyuki" creationdate="20130818T093134Z">
        <seg>そのトピックとしてのクロージャ内の問題の変数に渡すアドバンテージをそれらは持つ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These items each specify a task that must be completed before the present one can complete.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T183034Z" creationid="Toshiyuki" creationdate="20140111T183034Z">
        <seg>これらのアイテムは、完了することができる現在の前に完了しなければならない仕事を各々指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These might look like it is using pairs, but it is really equivalent to</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それのようなこれらの力ルックは組を使っている、しかし、それは本当に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These name the same module:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、同じモジュールを挙げる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These need not be identical contexts, since they may bind or coerce the resulting parcels differently:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T035929Z" creationid="Toshiyuki" creationdate="20130811T035929Z">
        <seg>それらは同一のコンテキストを必要としない。だから結果として生じるパーセルを違うようにバインドするか強制する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These roles are generally not used directly as object types.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T130018Z" creationid="Toshiyuki" creationdate="20140328T130018Z">
        <seg>これらのロールがオブジェクト型として直接使われることは通常ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These typed objects typically represent uninitialized values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの入力されたオブジェクトは、初期化されていない値を概して表現する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These types do (at least) the following roles:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型は、以下のロールをする（少なくとも）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの最新版は記録されない－概要がそのApocalypseと一致しないならば、Synopsisが正しいと仮定しなさい。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These will be interpreted as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、通訳される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are considered complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、完全であると考えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are designed to give the typical programmer the tools to achieve a good enough answer most of the time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、典型的プログラマーにほとんど良い十分な答えを成し遂げるためのツールを与えるようになっている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are known to the compiler and may not be modified after being compiled in.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T055215Z" creationid="yamato" creationdate="20140914T055215Z">
        <seg>それらはコンパイラに知られていて、コンパイル後に修正されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can interpolate in strings if called with parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧で呼ばれるならば、それらは文字列で改竄することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They count as whitespace equivalent to newline for purposes of separation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、分離のための改行文字への空白文字等価物と見なされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They may be directly accessed from within the class via &lt;c0&gt;!&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T052058Z" creationid="yamato" creationdate="20140914T052058Z">
        <seg>それらは&lt;c0&gt;!&lt;/c0&gt;によってクラス内部から直接アクセスされるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They may be used in bare blocks to declare formal parameters to that block.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T062017Z" creationid="yamato" creationdate="20140914T062017Z">
        <seg>それらは裸のブロックで仮パラメータを宣言するのに使われる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They parse the same as phasers:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T082139Z" creationid="Toshiyuki" creationdate="20130818T082139Z">
        <seg>それらはphasersと同じにパースする：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They work only in interpolations and regexes and the like.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、展開と正規表現などだけで動く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of these as setting the default radix, not forcing it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それを強制しなくて、デフォルト根をセットするように、これらについて考えなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;e3&gt;encapsulation&lt;/e3&gt; is one of the key principles of object oriented design.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T182300Z" creationid="Toshiyuki" creationdate="20140111T182300Z">
        <seg>この&lt;e3&gt;カプセル化&lt;/e3&gt;は、オブジェクト指向デザインの重要な原則の1つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows type objects to be assigned to scalars, but to disappear in non-scalar contexts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、型オブジェクトがスカラーに割り当てられるが、非スカラーコンテキストで消えるのを許可する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to use sigils as coercion operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、強制演算子としてシギルを使うことができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also means that calling the &lt;c0&gt;.list&lt;/c0&gt; method flattens out an itemized container:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T141842Z" creationid="yamato" creationdate="20140914T141842Z">
        <seg>&lt;c0&gt;.list&lt;/c0&gt;メソッドを呼ぶことでもアイテム化されたコンテナをフラット化する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This article started as a conversion on IRC explaining the difference between the &lt;c0&gt;Array&lt;/c0&gt; and the &lt;c1&gt;List&lt;/c1&gt; type in Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T125833Z" creationid="yamato" creationdate="20140914T125833Z">
        <seg>本稿は&lt;c0&gt;Array&lt;/c0&gt;と&lt;c1&gt;List&lt;/c1&gt;型の違いを説明するIRCの変換としてスタートした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This basically gives us list comprehensions as rvalue expressions:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T125239Z" creationid="Toshiyuki" creationdate="20130810T125239Z">
        <seg>これは基本的に右辺値の式としてリストの理解力を我々に与える：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be a bit cumbersome, so in the particular case of labels, the label that is already visible in the current lexical scope is considered a kind of pseudo object specifying a potential dynamic context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T074045Z" creationid="Toshiyuki" creationdate="20130817T074045Z">
        <seg>これは少し扱いづらい。そういうわけでラベルの特定の場合、現在のレキシカルスコープのすでに可視のラベルは潜在的なダイナミックコンテキストを示す擬似オブジェクトの一種とみなされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful to peg some behavior to an empty list while still returning an empty list:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T080629Z" creationid="Toshiyuki" creationdate="20140329T080629Z">
        <seg>これは空のリストを返している間に何らかの振る舞いを空のリストに釘付けるのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can completely change the interpretation of any subsequent adverbs as well as the quoted material itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、何か以降の副詞ならびに引用された資料自体の字句解釈を完全に変えることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This construct only allows you to attach a single statement to the end of an expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T121759Z" creationid="Toshiyuki" creationdate="20130810T121759Z">
        <seg>この構成は単独の文の式の末尾だけで可能だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This could be done by pushing the resumed exception onto the unhandled list, and then the thrower checking to see if there is only a single resumed exception in the "unhandled" list.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T115100Z" creationid="Toshiyuki" creationdate="20130814T115100Z">
        <seg>これはハンドルされないリストの上に再開された例外をプッシュすることで行われ、そのとき例外を投げるものは一つだけの再開された例外が「ハンドルされない」リストにあるなら見るためにチェックする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document summarizes Apocalypse 2, which covers small-scale lexical items and typological issues.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このドキュメントはApocalypse 2を要約する。そして、それは小規模の語彙項目とタイプの問題を取り上げる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This dynamic control is orthogonal to any lexically scoped warning controls, which merely decide whether to call &lt;c1&gt;warn()&lt;/c1&gt; in the first place.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T120128Z" creationid="Toshiyuki" creationdate="20130817T120128Z">
        <seg>ダイナミックな制御はどんなレキシカルスコープの警告制御にも直交する。そしてそれは単に&lt;c1&gt;warn()&lt;/c1&gt;を呼ぶかどうか最初の場所で決定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This fixup is done only for provisional calls.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このfixupは、暫定的な呼び出しのためにだけされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives Perl 6 programs the flexibility to handle exceptions either in-band or out-of-band.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、帯域内であるか帯域外例外を取り扱うために、Perl 6プログラムに柔軟性を与える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens both for standard methods defined via the method keyword and for methods generated through other means such as attribute accessors.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144130Z" creationid="Toshiyuki" creationdate="20140112T093159Z">
        <seg>これはmethodキーワードを通して定義される標準的なメソッドのために、そして、属性アクセッサのような他の手段によって発生するメソッドのために起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has the added benefit of limiting the scope of the &lt;c0&gt;$line&lt;/c0&gt; parameter to the block it's bound to.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T063058Z" creationid="Toshiyuki" creationdate="20130810T063058Z">
        <seg>これはブロックにバインドされた&lt;c0&gt;$line&lt;/c0&gt;パラメータのスコープを制限するという追加の利点を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが、含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes &lt;c0&gt;$_&lt;/c0&gt; and &lt;c1&gt;@_&lt;/c1&gt;, as well as the new &lt;c2&gt;$/&lt;/c2&gt;, which is the return value of the last regex match.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090703Z" creationid="Toshiyuki" creationdate="20140329T090703Z">
        <seg>これは&lt;c0&gt;$_&lt;/c0&gt;と&lt;c1&gt;@_&lt;/c1&gt;だけでなく新しい&lt;c2&gt;$/&lt;/c2&gt;、最後の正規表現マッチの戻り値も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes the second section of the Unicode BidiMirroring data table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ユニコードBidiMirroringデータテーブルの市場第二部を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This internal symbol table is used to detect undeclared variables, and to tie the code generation for the variable to the correct scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T130555Z" creationid="yamato" creationdate="20140914T130555Z">
        <seg>この内部シンボルテーブルは宣言されていない変数を見つけ、変数を正しいスコープに結合するコード生成に用いられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a per-scope data structure that stores a pointer for each variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T130738Z" creationid="yamato" creationdate="20140914T130738Z">
        <seg>これはそれぞれの変数のポインタを保存するスコープごとのデータ構造だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an unchanging deep rule, but the surface ramifications of it change as various operators and macros are added to or removed from the language, which we expect to happen because Perl 6 is designed to be a mutable language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは変わらない深いルールである、しかし、いろいろな演算子とマクロが言語に加えられるか、それから取り除かれて、それの表面の結果は変わる、そしてそれは、Perl 6が変わりやすい言語であるようになっているので、我々は起こると思っている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because &lt;c1&gt;$lexical&lt;/c1&gt; isn't looked up in the caller's scope but in the scope &lt;c2&gt;&amp;say-all&lt;/c2&gt; was defined in.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T044914Z" creationid="yamato" creationdate="20140914T044914Z">
        <seg>これは&lt;c1&gt;$lexical&lt;/c1&gt;が呼び出し元のスコープではなく&lt;c2&gt;&amp;say-all&lt;/c2&gt;が定義されたスコープをルックアップするためである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because in Perl 6 all attributes are private and can be directly accessed within the class by using &lt;c4&gt;$!attribute-name&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T053905Z" creationid="yamato" creationdate="20140914T053905Z">
        <seg>これはPerl 6の全ての属性はプライベートで、&lt;c4&gt;$!attribute-name&lt;/c4&gt;を使ってクラス内で直接アクセスできるためだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because the &lt;c0&gt;Scalar&lt;/c0&gt; container type hides itself well, but &lt;c1&gt;Array&lt;/c1&gt; makes no such effort.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T135516Z" creationid="yamato" creationdate="20140914T135516Z">
        <seg>これは&lt;c0&gt;Scalar&lt;/c0&gt;コンテナ型がうまく隠れるからだ。しかし&lt;c1&gt;Array&lt;/c1&gt;はそのような努力をしない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because the placeholder variables are sorted in Unicode order.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T062441Z" creationid="yamato" creationdate="20140914T062441Z">
        <seg>これは、プレースホルダー変数がユニコード順でソートされるからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is defined as the textually last statement of its top-level list of statements; any statements embedded within those top-level statements are in their own lower-level list of statements and, while they may be a final statement in their subscope, they're not considered the final statement of the outer block in question.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T015413Z" creationid="Toshiyuki" creationdate="20130803T015413Z">
        <seg>これは文の最上位リストの最後のテキスト文として定義される；それら最上位の文に埋め込まれた任意の文がそれらのより低いレベルのリストにあり、そしてそれらがサブスコープの最後の文かもしれないなら、それらは問題の外側のブロックの最後の文とみなされない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is disallowed in favor of being to able to catch some Perl 5-isms.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T063414Z" creationid="yamato" creationdate="20140914T063414Z">
        <seg>これは若干のPerl 5-ismsを捉えて賛同するために認められていない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is equivalent to</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T113741Z" creationid="Toshiyuki" creationdate="20130810T113741Z">
        <seg>これは以下と同等だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is how Perl 5 does it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、Perl 5がそれをする方法である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is how internal routines can deal with parcels as real objects.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、内部のルーチンが実物体としてパーセルに対処することができる方法である。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is implemented via multiple inheritance, to truly represent the allomorphic nature of a literal value that has not committed to which type the user intends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本当に、ユーザーがどの型を意図するかについて、専念しなかったリテラル値のallomorphicな性質を表現するために、これは多重継承を通して実装される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not the fault of the universe, which is not fooled (neglecting relativistic considerations).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは宇宙の誤りでない。そして、それは馬鹿にされない（相対論的な考慮点を怠る）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful for list comprehensions:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121125Z" creationid="Toshiyuki" creationdate="20130813T121125Z">
        <seg>これは特にリストの理解の役に立つ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful for the do-once block, since it is officially a loop and can take therefore loop control statements.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T130634Z" creationid="Toshiyuki" creationdate="20130810T130634Z">
        <seg>これは特にdo-onceブロックに役に立ち、正式なループなのでループ制御文をとることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is resolved at compile time because the variable name is a constant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数名が定数であるので、これはコンパイル時で解決される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is subtly different from Perl 5's behavior, which was to return the value of the last expression evaluated, even if that expression was just a conditional.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T020026Z" creationid="Toshiyuki" creationdate="20130803T020026Z">
        <seg>これは文が条件付きだけであっても最後に評価された文が返されるというPerl 5の振る舞いと微妙に異なる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the hard lesson of Perl 5's source filters and other multi-pass parsing mistakes.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは難しいレッスンであるPerl 5が、ソースフィルタである、そして、他のマルチパス構文解析は誤認する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true for normal blocks too.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T062933Z" creationid="yamato" creationdate="20140914T062933Z">
        <seg>これは通常のブロックについてもそうだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true of all the standard container types except Scalar, which always defers the definition of truth to its contents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはスカラー以外はすべての標準的なコンテナ型にとって真実である。そして、それは常に真実の定義をその内容に延期する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is typically used to pass an extra block:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、余分のブロックを通り過ぎるのに典型的に用いられる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This iteration places each item--each a &lt;c2&gt;Task&lt;/c2&gt; object--into the topic variable, &lt;c3&gt;$_&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T140958Z" creationid="Toshiyuki" creationdate="20140111T191905Z">
        <seg>この繰り返しはそれぞれのアイテムを ― それぞれの&lt;c2&gt;Task&lt;/c2&gt;オブジェクトを ― トピック変数&lt;c3&gt;$_&lt;/c3&gt;に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of list should not be confused with the flattening list context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073716Z" creationid="Toshiyuki" creationdate="20140329T073716Z">
        <seg>この種のリストはフラット化リストコンテキストと混同されるべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to keep track of what you last "took":</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T213301Z" creationid="Toshiyuki" creationdate="20130810T213301Z">
        <seg>これはあなたが最後に取ったのは何か追い続けるのを簡単にする：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may be overridden by attaching a &lt;c1&gt;.resume_value&lt;/c1&gt; to the warning.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T074213Z" creationid="Toshiyuki" creationdate="20130818T074213Z">
        <seg>これは&lt;c1&gt;.resume_value&lt;/c1&gt;を警告に付け加えることでオーバーライドすることもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means a list can contain infinite generators without blowing up.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストがそうすることができるこの手段は、爆発することなく、無限の発電機を含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that &lt;c1&gt;CATCH&lt;/c1&gt; and &lt;c2&gt;CONTROL&lt;/c2&gt; always require a block, since they take an argument that sets &lt;c3&gt;$_&lt;/c3&gt; to the current topic, so that the innards are able to behave as a switch statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T090602Z" creationid="Toshiyuki" creationdate="20130818T090602Z">
        <seg>これは&lt;c1&gt;CATCH&lt;/c1&gt;と&lt;c2&gt;CONTROL&lt;/c2&gt;が常にブロックを要求することを意味する。それらは&lt;c3&gt;$_&lt;/c3&gt;を現在のトピックにセットする引数をとるので、内部はswitch文として振る舞うことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T025806Z" creationid="yamato" creationdate="20140914T025806Z">
        <seg>これは以下を意味する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism is really only good for objects that know how to return a boolean value and still remain themselves.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T145534Z" creationid="Toshiyuki" creationdate="20130809T145534Z">
        <seg>この仕組みは本当にブール値をどのように返すのか知っていてそれら自身がまだ残るオブジェクトにだけ良い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This meta class enables other ways of introspection too:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T110318Z" creationid="Toshiyuki" creationdate="20140112T160339Z">
        <seg>このメタクラスはイントロスペクションの他の方法も利用可能にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This name equivalence of parametric types extends only to parameters that can be considered immutable (or that at least can have an immutable snapshot taken of them).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータの型のこの名前同値は、不変である（または、それは不変のスナップショットをそれらの撮って少なくともおくことができる）と考えられることができるパラメータだけに及ぶ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This name is to be thought of semantically, not syntactically.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この名前は、構文的にでなく、意味論的に、考えられることになっている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator is agnostic towards flattening or slicing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子は、平らになるか、切る方へ不可知論者である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This policy also applies to new one-to-many mappings introduced in the future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この方針も、将来持ち出される新しい１対多のマッピングにあてはまる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This prints:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140221T233849Z" creationid="Toshiyuki" creationdate="20140221T233849Z">
        <seg>これは次のように出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This produces the output:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20131026T015809Z" creationid="Toshiyuki" creationdate="20131026T015809Z">
        <seg>これは次のように出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This recursively flattens all parcels into a 1-dimensional list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、1次元リストにすべてのパーセルを再帰的に平らにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rewrite happens after variables are looked up in their lexical scope, and after declarator install any variables into the lexical scope, with the result that</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数が彼らのレキシカルスコープで調べられて、宣言の後レキシカルスコープに何か変数をインストールしたあと、このリライトは起こる、結果でその</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scalar attribute (with the &lt;c0&gt;$&lt;/c0&gt; sigil) has a type of &lt;c1&gt;Bool&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T183219Z" creationid="Toshiyuki" creationdate="20140111T183219Z">
        <seg>このスカラー属性（&lt;c0&gt;$&lt;/c0&gt;シギル）は&lt;c1&gt;Bool&lt;/c1&gt;型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section is about a convenient syntactic sugar for that.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このセクションは、それのために便利な構文法のシュガーについてである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This stems from the fact that we declared a new dynamic variable &lt;c6&gt;$*dynamic1&lt;/c6&gt; in the block and did not assign to the old variable as we did with &lt;c7&gt;$*dynamic2&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T051730Z" creationid="yamato" creationdate="20140914T051730Z">
        <seg>我々が新しい動的変数&lt;c6&gt;$*dynamic1&lt;/c6&gt;をブロックで宣言し、古い変数&lt;c7&gt;$*dynamic2&lt;/c7&gt;にしたような割り当てをしなかったことによりこれが生じる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tends to be more efficient since it only has to do one mixin at the end of the block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがブロックの終わりに1つのミキシンをしなければならないだけの時から、これはより効率的な傾向がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type object is a kind of "empty instance" of the class, specifically an instance without any state.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141759Z" creationid="Toshiyuki" creationdate="20140112T090914Z">
        <seg>この型オブジェクトは、クラス（特に何の状態のないインスタンスも）の一種の「空インスタンス」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type object is an "empty instance" of the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T135218Z" creationid="Toshiyuki" creationdate="20140111T181204Z">
        <seg>この型オブジェクトはクラスの「空のインスタンス」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those always start with a colon, and then are followed either by an identifier or the name of an already existing variable (whose name sans the sigil is used as the key, and value of the variable is used as the value of the pair).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T123609Z" creationid="yamato" creationdate="20140914T123609Z">
        <seg>それらは常にコロンで始まり、識別子またはすでに存在する変数名が続く（その名前はシギルがキーに使われ、変数の値がペアの値になる）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those that apply to some object such as a filehandle will instead be attributes of the appropriate object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ファイルハンドルのような若干のオブジェクトにあてはまるものは、その代わりに適切なオブジェクトの属性である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those that are truly global will have global alphabetic names, such as &lt;c0&gt;$*PID&lt;/c0&gt; or &lt;c1&gt;@*ARGS&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T090447Z" creationid="Toshiyuki" creationdate="20140329T090447Z">
        <seg>それらの本当にグローバルなものはアルファベットの名前、&lt;c0&gt;$*PID&lt;/c0&gt;または&lt;c1&gt;@*ARGS&lt;/c1&gt;のようなものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Though certain control statements could conceivably be parsed in a self-contained way, for visual consistency all statement-terminating blocks that end in the middle of a line &lt;i0&gt;must&lt;/i0&gt; be terminated by semicolon unless they are naturally terminated by some other statement terminator:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T042251Z" creationid="Toshiyuki" creationdate="20130803T042251Z">
        <seg>確実な制御文はおそらく自己完結的な方法でパースできるだろうが、視覚的な一貫性のために、いくつかの他の文末によって自然に終えるのでない限り、行の中間で終わる全ての終端ブロックは&lt;i0&gt;必ず&lt;/i0&gt;セミコロンで終わらなければならない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Though perhaps not with attosecond accuracy...)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アト秒精度でおそらくないけれども、...）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus any instance of the &lt;c1&gt;Task&lt;/c1&gt; class can call this method with the &lt;c2&gt;.&lt;/c2&gt; method call operator.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T185456Z" creationid="Toshiyuki" creationdate="20140111T185456Z">
        <seg>したがって&lt;c1&gt;Task&lt;/c1&gt;クラスのどのインスタンスでも&lt;c2&gt;.&lt;/c2&gt;メソッド呼び出し演算子でこのメソッドを呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the iteration construct calls the &lt;c5&gt;.perform()&lt;/c5&gt; method on every &lt;c6&gt;Task&lt;/c6&gt; object in the &lt;c7&gt;@!dependencies&lt;/c7&gt; attribute of the current invocant.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T140612Z" creationid="Toshiyuki" creationdate="20140111T192248Z">
        <seg>したがって、繰り返し構造は&lt;c5&gt;.perform()&lt;/c5&gt;メソッドを&lt;c7&gt;@!dependencies&lt;/c7&gt;属性の全ての&lt;c6&gt;Task&lt;/c6&gt;オブジェクトを現在のインボカントに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus you can say</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T134947Z" creationid="yamato" creationdate="20140914T134947Z">
        <seg>このように書くことができる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To coerce your return value, use a coercion type:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140328T224039Z" creationid="Toshiyuki" creationdate="20140328T224039Z">
        <seg>戻り値を強制するために、型の自動変換を使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a single task with no dependencies, write:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T090746Z" creationid="Toshiyuki" creationdate="20140112T090746Z">
        <seg>従属物なしでシングルタスクを作るためには次のように書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do direct lookup in a package's symbol table without scanning, treat the package name as a hash:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ウイルスチェックなしでパッケージのシンボルテーブルで直接ルックアップをして、パッケージ名をハッシュとみなすこと：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do that, the type may be refined by using a signature literal as a postfix operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうするために、型は後置演算子として文字通りのシグネチャを用いて洗練されているかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To force a single value to become a composite object in item context, either add a comma inside parens, or use an appropriate constructor or composer for clarity as well as correctness:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一つの値にアイテム前後関係のコンポジットオブジェクトになることを強制するために、括弧内部にコンマを加えるか、明快さならびに正しさのために適切なコンストラクタまたはコンポーザーを使いなさい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To format a hash value or list of pairs, include formats for both key and value in the first string: &lt;c1&gt;.fmt('%s: %s', "\n")&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T030013Z" creationid="Toshiyuki" creationdate="20140329T030013Z">
        <seg>ハッシュ値かペアのリストをフォーマットするために、キーと値の両方のフォーマットを最初の文字列に含めてください：&lt;c1&gt;.fmt('%s: %s', "\n")&lt;/c1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To format an array value separated by commas, supply a second argument: &lt;c0&gt;.fmt('%03d', ', ')&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T025840Z" creationid="Toshiyuki" creationdate="20140329T025840Z">
        <seg>配列値をコンマで区切るには第二の引数を与えてください：&lt;c0&gt;.fmt('%03d', ', ')&lt;/c0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get a formatted representation of any scalar value, use the &lt;c0&gt;.fmt('%03d')&lt;/c0&gt; method to do an implicit &lt;c1&gt;sprintf&lt;/c1&gt; on the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T025737Z" creationid="Toshiyuki" creationdate="20140329T025737Z">
        <seg>スカラー値のフォーマットされた表現を得るために、値上で暗黙の&lt;c1&gt;sprintf&lt;/c1&gt;を行う&lt;c0&gt;.fmt('%03d')&lt;/c0&gt;メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get the number of elements in an array, use the &lt;c0&gt;.elems&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T141234Z" creationid="Toshiyuki" creationdate="20140327T141234Z">
        <seg>配列の要素数を得るために&lt;c0&gt;.elems&lt;/c0&gt;メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ignore all unhandled exceptions, use an empty &lt;c4&gt;default&lt;/c4&gt; case.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T135119Z" creationid="Toshiyuki" creationdate="20130813T135119Z">
        <seg>全てのハンドルされない例外を無視するために、空の&lt;c4&gt;default&lt;/c4&gt;ケースを使え。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To illustrate, just try assigning to one after you've defined it:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T040549Z" creationid="yamato" creationdate="20140914T040549Z">
        <seg>実例を示すために、それを定義したあと、何かを割り当ててみる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To jump into the next &lt;c4&gt;when&lt;/c4&gt; block without testing its condition, you must use a &lt;c5&gt;goto&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115331Z" creationid="Toshiyuki" creationdate="20130813T115331Z">
        <seg>条件をテストせずに次の&lt;c4&gt;when&lt;/c4&gt;ブロックにジャンプするには&lt;c5&gt;goto&lt;/c5&gt;を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a slice subscript return something other than values, append an appropriate adverb to the subscript.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T084149Z" creationid="Toshiyuki" creationdate="20140329T084149Z">
        <seg>スライス添字に値と別の何かを返させるために、添字に適切な副詞を追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To mark them all as handled you must access them individually via the implicit loop of a CATCH block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T164623Z" creationid="Toshiyuki" creationdate="20130817T164623Z">
        <seg>それらを全てハンドルされたとしてマークするためにはCATCHブロックの暗黙のループ経由で個別にアクセスしなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To place a non-&lt;c0&gt;Array&lt;/c0&gt; into an array variable, binding works:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T135552Z" creationid="yamato" creationdate="20140914T135552Z">
        <seg>non-&lt;c0&gt;Array&lt;/c0&gt;を配列変数に入れるためにバインディングが機能する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent lazy lists for leaking out unexpectedly, the inside of a &lt;c11&gt;try&lt;/c11&gt; is always considered an eager context, unless the &lt;c12&gt;try&lt;/c12&gt; itself is in a sink context, in which case the inside of &lt;c13&gt;try&lt;/c13&gt; is also in sink context.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T123141Z" creationid="Toshiyuki" creationdate="20130813T123141Z">
        <seg>レイジーなリストが思いがけなく漏れるのを防ぐために、&lt;c11&gt;try&lt;/c11&gt;の内部は常にeagerコンテキストとみなされる。その&lt;c12&gt;try&lt;/c12&gt;自身がsinkコンテキストでなく、&lt;c13&gt;try&lt;/c13&gt;の内部もsinkコンテキストの場合でない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To process two arrays in parallel use the &lt;c0&gt;zip&lt;/c0&gt; function to generate a list that can be bound to the corresponding number of parameters:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T062101Z" creationid="Toshiyuki" creationdate="20130810T062101Z">
        <seg>二つの配列を並行して処理するために&lt;c0&gt;zip&lt;/c0&gt;関数を使用してパラメータの数が一致するようにバインド可能なリストを生成する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To return a value (to the dynamical caller) from any pointy block or bare closure, you either just let the block return the value of its final expression, or you can use &lt;c0&gt;leave&lt;/c0&gt;, which comes in both function and method forms.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T071032Z" creationid="Toshiyuki" creationdate="20130817T071032Z">
        <seg>何か一つのポインティブロックか裸のクロージャから値を返すために（ダイナミックな呼び出し元へ）、ブロックが最後の文の値を返すようにするだけか、関数かメソッド形式の&lt;c0&gt;leave&lt;/c0&gt;を使うことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To return from your immediate caller, you can say:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T072429Z" creationid="Toshiyuki" creationdate="20130817T072429Z">
        <seg>あなたの呼び出し元から直接に返すなら、次のようにできる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To specify a base other than ten, use the colonpair form &lt;c0&gt;:radix&lt;number&gt; &lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T121934Z" creationid="yamato" creationdate="20140914T121934Z">
        <seg>10以外の基数を指定するために&lt;c0&gt;:radix&lt;number&gt; &lt;/c0&gt;というコロンペアを使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To the extent allowed by sublanguages' parsers, Perl is parsed using a one-pass, predictive parser.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>部分言語のパーサーによって許される範囲で、Perlはワンパス（予測型構文解析法）を使って解析される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To the heredoc parser that just looks like:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ちょうど以下のように見えるヒアドキュメント構文解析器に：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Topical methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>時事的なメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traits</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132622Z" creationid="Toshiyuki" creationdate="20140326T132622Z">
        <seg>トレイト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traits cannot be changed at run-time.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T132814Z" creationid="Toshiyuki" creationdate="20140326T132814Z">
        <seg>トレイトは実行時に変更できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Twigil Scope</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T041636Z" creationid="yamato" creationdate="20140914T041636Z">
        <seg>ツウィギルスコープ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Twigils</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T014611Z" creationid="Toshiyuki" creationdate="20140329T014611Z">
        <seg>ツウィギル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Twigils influence the scoping of a variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T040640Z" creationid="yamato" creationdate="20140914T040640Z">
        <seg>ツウィギルは変数のスコーピングに影響する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two distinct classes are never considered equivalent even if they have the same attributes because classes are not considered immutable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスが不変であると考えられないのでたとえそれらには同じ属性があるとしても、2つの異なったクラスは等しいと決して考えられない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two or more adverbs can always be strung together without intervening punctuation anywhere a single adverb is acceptable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>副詞が常にそうであることがありえる二個以上は、一つの副詞が許容できる場所を中の句読点なしでつなぎ合わせた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Objects</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T133511Z" creationid="Toshiyuki" creationdate="20140327T133511Z">
        <seg>型オブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type objects are &lt;e0&gt;undefined&lt;/e0&gt;, in the sense that they return &lt;c1&gt;False&lt;/c1&gt; if you call the &lt;c2&gt;.defined&lt;/c2&gt; method on them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T181652Z" creationid="Toshiyuki" creationdate="20140111T181652Z">
        <seg>型オブジェクトは&lt;e0&gt;undefined&lt;/e0&gt;です。それらに対して&lt;c2&gt;.defined&lt;/c2&gt;メソッドを呼び出すと&lt;c1&gt;False&lt;/c1&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type objects sometimes stringify to their name in parens, to indicate undefinedness.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトが括弧で彼らの名前に時々stringifyする型（未定義を示すために）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typeglobs are gone.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Typeglobsはなくなる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types are officially compared using name equivalence rather than structural equivalence.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140326T131645Z" creationid="Toshiyuki" creationdate="20140326T125818Z">
        <seg>型は構造よりも名前の同一性を使って比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types as Constraints</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140327T131937Z" creationid="Toshiyuki" creationdate="20140327T131937Z">
        <seg>制約としての型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Undefined types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>未定義型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscore is always considered alphabetic.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T092733Z" creationid="Toshiyuki" creationdate="20140329T092733Z">
        <seg>アンダースコアは常に英字とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscores</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アンダーライン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately this suffers from the problem pervasive in Perl 5 of multi-pass parsing, which is masked somewhat because there's no way to hide a newline in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残念なことに、これはマルチパス構文解析のPerl 5で全面的な問題で苦しむ。そして、方法がPerl 5で改行文字を隠すためにないので、それはいくぶん覆い隠される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, dinner never magically happens.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141955Z" creationid="Toshiyuki" creationdate="20140112T091405Z">
        <seg>残念なことに、夕食は決して魔法のようには出できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode Semantics</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコード意味論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode codepoints</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコードコードポイント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode horizontal whitespace is counted as whitespace, but it's better not to use thin spaces where they will make adjoining tokens look like a single token.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>横空白文字がそうであるユニコードは空白文字と見なされた、しかし、それらが隣接しているトークンを単一トークンのように見えさせる薄いスペースを使わない方が良い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Units of Position Arguments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>位置引数の単位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike &lt;c0&gt;try&lt;/c0&gt;, the presence of a &lt;c1&gt;CATCH&lt;/c1&gt; block does not imply &lt;c2&gt;use fatal&lt;/c2&gt; semantics for failures; you may, however, use either an explicit &lt;c3&gt;try&lt;/c3&gt; block around the &lt;c4&gt;CATCH&lt;/c4&gt; or an explicit &lt;c5&gt;use fatal&lt;/c5&gt; to guarantee that failures are thrown eagerly rather than lazily.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T121559Z" creationid="Toshiyuki" creationdate="20130814T121559Z">
        <seg>&lt;c0&gt;try&lt;/c0&gt;と違い、&lt;c1&gt;CATCH&lt;/c1&gt;ブロックの存在は失敗のための暗黙の&lt;c2&gt;use fatal&lt;/c2&gt;セマンティクスを行わない；あなたは多分、けれども、&lt;c4&gt;CATCH&lt;/c4&gt;の周りの明示的な&lt;c3&gt;try&lt;/c3&gt;ブロックか明示的な&lt;c5&gt;use fatal&lt;/c5&gt;を失敗がスローされることを保証するために使うだろう。レイジーよりも熱心に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike &lt;c3&gt;do&lt;/c3&gt;, it evaluates the statement or block in sink (void) context; its return value is instead specified by calling the &lt;c4&gt;take&lt;/c4&gt; list prefix operator one or more times within the scope (either lexical or dynamic) of the &lt;c5&gt;gather&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T153248Z" creationid="Toshiyuki" creationdate="20130810T153248Z">
        <seg>&lt;c3&gt;do&lt;/c3&gt;と違い、それは文またはブロックをsink（void）コンテキストで評価する；それの返り値は&lt;c4&gt;take&lt;/c4&gt;リストプレフィックス演算子を&lt;c5&gt;gather&lt;/c5&gt;のスコープ内（レキシカルかダイナミック）で1回以上呼ぶことで代わりに明示される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Perl 5's &lt;c0&gt;do-while&lt;/c0&gt; loop, this is a real loop block now, so &lt;c1&gt;next&lt;/c1&gt;, &lt;c2&gt;last&lt;/c2&gt;, and &lt;c3&gt;redo&lt;/c3&gt; work as expected.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T151638Z" creationid="Toshiyuki" creationdate="20130809T151638Z">
        <seg>Perl 5の&lt;c0&gt;do-while&lt;/c0&gt;ループと違い、これは今実際のループブロックなので、&lt;c1&gt;next&lt;/c1&gt;、&lt;c2&gt;last&lt;/c2&gt;、そして&lt;c3&gt;redo&lt;/c3&gt;が期待通りに機能する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, applying a statement modifier to a &lt;c0&gt;do&lt;/c0&gt; block is specifically disallowed:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130809T151326Z" creationid="Toshiyuki" creationdate="20130809T151326Z">
        <seg>Perl 5と違い、&lt;c0&gt;do&lt;/c0&gt;ブロックに文修飾子を適用することは明確に禁じられている：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, if a final statement in Perl 6 is a conditional that does not execute any of its branches, it doesn't matter what the value of the conditional is, the value of that conditional statement is always &lt;c0&gt;()&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130803T020936Z" creationid="Toshiyuki" creationdate="20130803T020936Z">
        <seg>Perl 5と違い、Perl 6の最後の文が条件付きでいずれかの分岐を実行しない場合、条件の値が何かを問題とせず、その条件付き文は常に&lt;c0&gt;()&lt;/c0&gt;だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, if a sigil is followed by comma, semicolon, a colon not followed by an identifier, or any kind of bracket or whitespace (including Unicode brackets and whitespace), it will be taken to be a sigil without a name rather than a punctuational variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5のとは異なり、シギルの後にコンマ、セミコロン、識別子が続かないコロンまたはブラケットまたは空白文字（ユニコードブラケットと空白文字を含む）の何か種類が続くならば、punctuationalな変数よりもむしろ名前のないシギルであることはとられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, the notation &lt;c0&gt;&amp;foo&lt;/c0&gt; merely stands for the &lt;c1&gt;foo&lt;/c1&gt; function as a &lt;c2&gt;Routine&lt;/c2&gt; object without calling it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T082931Z" creationid="Toshiyuki" creationdate="20140329T082931Z">
        <seg>Perl 5と異なり、表記法&lt;c0&gt;&amp;foo&lt;/c0&gt;はそれを呼び出すことのない&lt;c2&gt;Routine&lt;/c2&gt;オブジェクトとして単に&lt;c1&gt;foo&lt;/c1&gt;関数を表すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, there are (by policy) no implicit blocks around standard control structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130729T122034Z" creationid="Toshiyuki" creationdate="20130729T122034Z">
        <seg>Perl 5と異なり、標準の制御構造の周りに暗黙のブロックは（ポリシーとして）無い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike in Perl 5, you may no longer put whitespace between a sigil and its following name or construct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Perl 5のとは異なり、シギルとその以下の名前または構成概念の間に空白文字をもはや置かなくてもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike many other languages, Perl 6 specifies exception handlers by placing a &lt;c0&gt;CATCH&lt;/c0&gt; block &lt;i1&gt;within&lt;/i1&gt; that block that is having its exceptions handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T121517Z" creationid="Toshiyuki" creationdate="20130813T121517Z">
        <seg>他の言語と違い、Perl 6は扱われる例外を持つ&lt;c0&gt;CATCH&lt;/c0&gt;ブロックをそのブロック&lt;i1&gt;内&lt;/i1&gt;に配置することで例外ハンドラを明示する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike with loop controls, however, scanning a scope includes a scan of any lexical scopes included within the current candidate scope.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T141842Z" creationid="Toshiyuki" creationdate="20130817T141842Z">
        <seg>ループ制御と違い、けれども、スコープをスキャンすることは現在の候補のスコープ内を含む何か一つのレキシカルスコープのスキャンを含む。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unspaces</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Unspaces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unthrown exceptions are meant to provide a failsoft mechanism in which failures can be treated as data and dealt with one by one, without aborting execution of what may be perfectly valid parallel computations.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T174650Z" creationid="Toshiyuki" creationdate="20130817T173036Z">
        <seg>スローされない例外はフェールソフトメカニズムを供給するように意図される。その失敗はデータとして扱うことができ、一つづつ分配できる。完璧に正しい並行計算の実行の中止なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Untyped arrays and hashes are still perfectly acceptable, but have the same performance issues they have in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Untyped配列とハッシュには、まだ完全に許容できるが、それらにはPerl 5である同じ性能の問題がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140212Z" creationid="Toshiyuki" creationdate="20130802T140212Z">
        <seg>使え</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c1&gt;$Package::var&lt;/c1&gt; instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000122Z" creationid="Toshiyuki" creationdate="20140329T000122Z">
        <seg>&lt;c1&gt;$Package::var&lt;/c1&gt;を代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use closure curlies instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりにクロージャcurliesを使いなさい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use curlies to interpolate the values of expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表現の値を差し込むために、curliesを使いなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use curlies.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>curliesを使いなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use curlies:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使用curlies：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of a placeholder parameter in statement-level blocks triggers a syntax error, because the parameter is not out front where it can be seen.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T151548Z" creationid="Toshiyuki" creationdate="20130810T151548Z">
        <seg>文レベルのブロックでのプレースホルダーパラメータの使用は文法エラーを引き起こす。なぜならそれが見える場所でパラメータは前に出ていないからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of a signature that does not unambiguously select a single multi results in failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一つのマルチも明白に選ばないシグネチャの使用は、結果として失敗になる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the functional form on anything that is not a string will throw an exception explaining that the user has confused a number with the textual representation of a number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列でない何の関数形式の使用でも、ユーザーが数を数の原文の表現と混同したと説明している例外を投げる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use some variant of</seg>
      </tuv>
      <tuv lang="JA">
        <seg>若干の変形を使いなさい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-defined classes don't derive from &lt;c5&gt;Cool&lt;/c5&gt; by default, so such classes are also unaffected by changes to &lt;c6&gt;Cool&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T000024Z" creationid="Toshiyuki" creationdate="20140329T000024Z">
        <seg>デフォルトでユーザー定義のクラスは&lt;c5&gt;Cool&lt;/c5&gt;から継承しないので、そのようなクラスは&lt;c6&gt;Cool&lt;/c6&gt;による変化の影響を受けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User-selected Brackets</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140330T053508Z" creationid="Toshiyuki" creationdate="20140330T053508Z">
        <seg>ユーザー選択のブラケット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the &lt;c4&gt;.&lt;/c4&gt; method call operator without specifying an explicit invocant uses the current topic as the invocant.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T140536Z" creationid="Toshiyuki" creationdate="20140111T192122Z">
        <seg>&lt;c4&gt;.&lt;/c4&gt;メソッドコールを明示的なインボカントなしに呼び出すと、現在のトピックがインボカントになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>VERSION</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values with these types autobox to their uppercase counterparts when you treat them as objects:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型autoboxがあなたがそれらをオブジェクトとみなす彼らの大文字の対応する物へにある値：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variable</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140309T004120Z" creationid="Toshiyuki" creationdate="20140309T004120Z">
        <seg>変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variable names start with a special character called a &lt;e0&gt;sigil&lt;/e0&gt;, followed optionally by a second special character named &lt;e1&gt;twigil&lt;/e1&gt;, and then an &lt;e2&gt;identifier&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T022837Z" creationid="yamato" creationdate="20140914T022837Z">
        <seg>変数名は&lt;e0&gt;シギル&lt;/e0&gt;と呼ばれる特殊文字で始まり、その次に&lt;e1&gt;ツウィギル&lt;/e1&gt;という第2の特殊文字が任意で付加され、最後に&lt;e2&gt;識別子&lt;/e2&gt;が続く。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T021148Z" creationid="yamato" creationdate="20140914T021148Z">
        <seg>変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables Containing Undefined Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>未定義値を含んでいる変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables declared using this form are a type of placeholder variables too.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T063529Z" creationid="yamato" creationdate="20140914T063529Z">
        <seg>この形式で宣言される変数も一種のプレースホルダー変数だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables of non-native types start out containing a type object of the appropriate type unless explicitly initialized to a defined value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>はっきりと定義済み値に初期化されない限り、ネイティブでない型の変数は適正型の型オブジェクトを含んで始める。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables of the form &lt;c1&gt;$^variable&lt;/c1&gt; are a type of placeholder variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T061842Z" creationid="yamato" creationdate="20140914T061842Z">
        <seg>&lt;c1&gt;$^variable&lt;/c1&gt;という形式の変数はプレースホルダー変数の一種だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables whose names are visible at the point of the call but that come from outside that lexical scope are controlled by the scope in which they were originally declared as dynamic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前が呼び出しの際に見える、しかし、そのレキシカルスコープの外でから来る変数は、ダイナミックであるように、それらが当初宣言されたスコープによってコントロールされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バージョンリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Warnings are produced in Perl 6 by throwing a resumable control exception to the outermost scope, which by default prints the warning and resumes the exception by extracting a resume continuation from the exception, which must be supplied by the &lt;c0&gt;warn()&lt;/c0&gt; function (or equivalent).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T114421Z" creationid="Toshiyuki" creationdate="20130817T114421Z">
        <seg>Perl 6では再開可能な制御例外を最も外側のスコープに投げることで警告が引き起こされる。その警告はデフォルトで警告をプリントし、&lt;c0&gt;warn()&lt;/c0&gt;関数（または同等のもの）から供給されなければならない例外から再開可能な継続取り出すことで例外を再開する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also do not want to allow accidental identity collisions with values that really are numbers (or strings, or any other mundane value type).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々も、本当に数（または文字列または少しも他のありふれた値型）である値との偶発的なアイデンティティ衝突を許したくない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also use the term "dynamic scoping" in the standard fashion to indicate the nested call frames that are created and destroyed every time a function or method is called.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130727T144249Z" creationid="Toshiyuki" creationdate="20130727T143959Z">
        <seg>我々はまた、関数かメソッドが呼ばれるたびに作成と破棄が行われる入れ子になったコールフレームを示すために「ダイナミックスコープ」という語句を標準的な方法で使う。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can't really rely on end-of-routine cleanup to deal with failures that are returned as normal data, unless we go with the overhead of a lexical &lt;c6&gt;@!&lt;/c6&gt; variable.]</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T155218Z" creationid="Toshiyuki" creationdate="20130817T155218Z">
        <seg>我々は本当に通常のデータとして返される失敗に対処するためのルーチン終了のクリーンアップを頼りにすることはできない。レキシカルな&lt;c6&gt;@!&lt;/c6&gt;変数へオーバーヘッドとともに行くのでない限り。］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We may add more of them in the future, so you can protect yourself from future collisions by using mixed case on your top-level packages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々は将来それらのより多くを加えるかもしれないので、あなたはトップレベルのパッケージで入り混じったケースを用いて将来の衝突から身を守ることができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We should probably at least issue warnings, though, if the GC eventually collects a failure that was never handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T154727Z" creationid="Toshiyuki" creationdate="20130817T154727Z">
        <seg>たぶん我々は少なくとも警告を出すべきだ。しかしながら、もしGCが結局は決してハンドルされない失敗を集めるなら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We use the phrase "lexical scoping" in its industry-standard meaning to indicate those blocks that surround the current textual location.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140830T111514Z" creationid="Toshiyuki" creationdate="20130727T114316Z">
        <seg>我々は「レキシカルスコープ」という言い回しを業界標準の「現在の位置のテキストを囲んでいるブロック」という意味で使用する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, it doesn't really fall back, since a &lt;c2&gt;take&lt;/c2&gt; knows at compile time whether it is being used lexically or dynamically.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T155030Z" creationid="Toshiyuki" creationdate="20130810T155030Z">
        <seg>さて、それは本当は戻らない。&lt;c2&gt;take&lt;/c2&gt;がレキシカルかダイナミックに使われるかどうかコンパイル時に知る時から。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What exactly that means is up to the container type.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T131712Z" creationid="yamato" creationdate="20140914T131712Z">
        <seg>それが正確に意味するものはコンテナ型次第だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is a variable?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T130101Z" creationid="yamato" creationdate="20140914T130101Z">
        <seg>変数とは何か？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is the current set of interwoven languages?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114615Z" creationid="yamato" creationdate="20140914T114615Z">
        <seg>混合された言語の現在のセットは何か？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a class inherits from another class that informs the method dispatcher to follow the inheritance chain to look for a method to dispatch.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144059Z" creationid="Toshiyuki" creationdate="20140112T093116Z">
        <seg>クラスがもう一つのクラスを継承するとき、それはディスパッチするためのメソッドを探すために継承チェーンを追従するようにメソッド・ディスパッチャーに知らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a class inherits from multiple classes the dispatcher knows to look at both classes when looking up a method to search for.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144739Z" creationid="Toshiyuki" creationdate="20140112T132902Z">
        <seg>クラスが複数のクラスから継承するとき、ディスパッチャーは捜すメソッドを見るときに両方のクラスを見ることを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function or method returns an object you don't know about, finding its type with &lt;c0&gt;.WHAT&lt;/c0&gt;, a construction recipe for it with &lt;c1&gt;.perl&lt;/c1&gt; and so on you'll get a good idea what this return value is.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T152409Z" creationid="Toshiyuki" creationdate="20140112T161304Z">
        <seg>関数またはメソッドがあなたの知らないオブジェクトを返すとき、&lt;c0&gt;.WHAT&lt;/c0&gt;でその型を見つけ、&lt;c1&gt;.perl&lt;/c1&gt;でその構造を、そしてこの戻り値が何であるかという良いアイデアを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When binding a value or a container to a variable, the lexpad entry of the variable is modified (and not just the container it points to).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T133207Z" creationid="yamato" creationdate="20140914T133207Z">
        <seg>値またはコンテナを変数にバインドする時、変数のlexpadエントリーは変更される（そしてそれをポイントする単なるコンテナではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When bound into a lol context, however, the parcel objects become real &lt;c0&gt;List&lt;/c0&gt; objects that keep their identity as discrete sublists.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T204650Z" creationid="Toshiyuki" creationdate="20130810T204650Z">
        <seg>lolコンテキストにバインドされるとき、どんな方法でも、パーセルオブジェクトは不連続のサブリストとしてそれらの識別子を持つ本当の&lt;c0&gt;List&lt;/c0&gt;オブジェクトになる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When bound to a slurpy parameter, a capture flattens the rest of its positional arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>slurpyパラメータに密接に結びつくとき、キャプチャーは残りのその位置引数を平らにする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When execution finishes, a report should be printed to STDERR stating which deprecated features where called where.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行が終わるとき、レポートはそこで呼ばれる所で、どちらが機能を非難したかについて告示しているSTDERRに出力されなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in doubt, the attempt is made to parse an argument list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不確かなとき、試みは引数の並びを解析させられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When pattern matching a signature against a cursor, you get a new cursor back which tells you the new position in the base capture.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>カーソルとシグネチャを比べることをパターン化するとき、あなたはベースキャプチャーであなたに新しい位置を教える新しいカーソルを取り戻す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When phasers are in different modules, the &lt;c3&gt;INIT&lt;/c3&gt; and &lt;c4&gt;END&lt;/c4&gt; phasers are treated as if declared at &lt;c5&gt;use&lt;/c5&gt; time in the using module.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130820T125044Z" creationid="Toshiyuki" creationdate="20130820T125044Z">
        <seg>phasersが異なるモジュールにある時、&lt;c3&gt;INIT&lt;/c3&gt;と&lt;c4&gt;END&lt;/c4&gt; phasersはモジュールを使う&lt;c5&gt;use&lt;/c5&gt;時に宣言されたかのように扱われる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When reaching for multiple inheritance it is good practice to consider whether the design wouldn't be better realized by using roles, which are generally safer because they force the class author to explicitly resolve conflicting method names.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T145912Z" creationid="Toshiyuki" creationdate="20140112T135351Z">
        <seg>デザインがロールを用いてよりよく実現されないかどうかにかかわらず、多重継承に至ることを考慮するのはよい習慣です（それらが明示的に矛盾するメソッド名を解決することをクラス作成者を強要するので、それは一般により安全です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the compiler encounters a variable declaration like &lt;c0&gt;my $x&lt;/c0&gt;, it registers it in some internal symbol table.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T130418Z" creationid="yamato" creationdate="20140914T130418Z">
        <seg>コンパイラが&lt;c0&gt;my $x&lt;/c0&gt;のような変数宣言に遭遇するとき、それを内部のシンボルテーブルに登録する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the demand for the race list drops, hung threads may be killed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>レースリストを求める要求が減少するとき、掛けられた糸は殺されるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as statement modifiers on implicit blocks (thunks), &lt;c0&gt;for&lt;/c0&gt; and &lt;c1&gt;given&lt;/c1&gt; privately temporize the current value of &lt;c2&gt;$_&lt;/c2&gt; for the left side of the statement and restore the original value at loop exit:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114751Z" creationid="Toshiyuki" creationdate="20130810T114751Z">
        <seg>文修飾子が暗黙のブロック（サンク）で使われるとき、&lt;c0&gt;for&lt;/c0&gt;と&lt;c1&gt;given&lt;/c1&gt;は左側の文の現在の&lt;c2&gt;$_&lt;/c2&gt;の値をひそかに一時的とし、ループの終了時に初期値を復元する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you say:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが以下のように言うとき：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When, however, you say something like:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたが以下のような何かを言うとき：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever an exception occurs during the execution of a handler, it is pushed onto the end of the &lt;c0&gt;@*undead&lt;/c0&gt; array for later processing by an outer handler.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T111145Z" creationid="Toshiyuki" creationdate="20130814T111145Z">
        <seg>ハンドラの実行中に例外が起こる時はいつでも、外側のハンドラに処理されて後で&lt;c0&gt;@*undead&lt;/c0&gt;配列の終端にプッシュされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where an infix operator is expected, the adverb is always taken as modifying the nearest preceding operator that is not hidden within parentheses, and if you string together multiple such pairs, you may not put commas between, since that would cause subsequent pairs to look like terms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インフィックスオペレータが待たれている所で、括弧の範囲内で隠されない最も近い前の演算子を修正するように、副詞は常にとられる、そして、あなたがチェーン店をつなぎ合わせる、そのような一組、それが以降の組が項のように見える原因になる時から、コンマを置かなくてもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whereas</seg>
      </tuv>
      <tuv lang="JA">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether any given argument is flattened will depend on its eventual binding, and in general cannot be known at parcel/capture composition time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何かされた引数が平らにされるかどうかはその最終的なバインディングに依存する、そして、中で、一般はパーセル/キャプチャー構成時間にわかっていることができない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether that is regarded as one character or two depends on the Unicode support level of the current lexical scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが一体となって注意されるかどうかにかかわらず、文字または2は現在のレキシカルスコープのユニコード支持線次第である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which OS distribution am I compiling under</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115327Z" creationid="yamato" creationdate="20140914T115319Z">
        <seg>どのOS向けにコンパイルされたか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which Perl am I compiled for?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115405Z" creationid="yamato" creationdate="20140914T115405Z">
        <seg>どのPerlでコンパイルされたか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which block am I in?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114526Z" creationid="yamato" creationdate="20140914T114526Z">
        <seg>どのブロックの中にいるのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which class am I in?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114744Z" creationid="yamato" creationdate="20140914T114744Z">
        <seg>度のクラスの中にいるのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which file am I in?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114443Z" creationid="yamato" creationdate="20140914T114443Z">
        <seg>どのファイルの中なのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which grammar am I in?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114811Z" creationid="yamato" creationdate="20140914T114811Z">
        <seg>どの文法の中にいるのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which is why assignment to &lt;c2&gt;$a&lt;/c2&gt; also modifies the contents of &lt;c3&gt;$x&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T132305Z" creationid="yamato" creationdate="20140914T132305Z">
        <seg>それが&lt;c2&gt;$a&lt;/c2&gt;への割り当てが&lt;c3&gt;$x&lt;/c3&gt;の内容も変更する理由だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which kernel am I compiled for?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115245Z" creationid="yamato" creationdate="20140914T115245Z">
        <seg>どのカーネルでコンパイルされたか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which lexical scope am I in?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114646Z" creationid="yamato" creationdate="20140914T114646Z">
        <seg>どのレキシカルスコープの中にいるのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which line am I at?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114504Z" creationid="yamato" creationdate="20140914T114504Z">
        <seg>どの行に居るのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which means that you cannot assign to it anymore:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T133353Z" creationid="yamato" creationdate="20140914T133353Z">
        <seg>これはあなたがそれに何も割り当てられないことを意味する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which module am I in?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114722Z" creationid="yamato" creationdate="20140914T114722Z">
        <seg>どのモジュールの中にいるのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which package am I in?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114657Z" creationid="yamato" creationdate="20140914T114657Z">
        <seg>どのパッケージの中にいるのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which role am I in?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114756Z" creationid="yamato" creationdate="20140914T114756Z">
        <seg>どのロールの中にいるのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which routine am I in?</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T114516Z" creationid="yamato" creationdate="20140914T114516Z">
        <seg>どのルーチンの中にいるのか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which virtual machine am I compiling under</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115348Z" creationid="yamato" creationdate="20140914T115348Z">
        <seg>どの仮想マシンでコンパイルされたか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Perl 6 does enforce encapsulation on attributes, it also saves you from writing accessor methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T045805Z" creationid="Toshiyuki" creationdate="20140111T183310Z">
        <seg>Perl 6がカプセル化を属性に強制する間、それはアクセサメソッドを記述することも安全に保ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While attributes give objects state, methods give objects behaviors.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184924Z" creationid="Toshiyuki" creationdate="20140111T184924Z">
        <seg>属性がオブジェクト状態を与える間、メソッドはオブジェクトに作用を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While multiple inheritance is a useful concept to know and on occasion of use, it is important to understand that there are more useful OOP concepts.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T144941Z" creationid="Toshiyuki" creationdate="20140112T135006Z">
        <seg>多重継承は知ると役に立つ概念です。そして使用の時に、より役に立つOOP概念があることを理解するのは重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace and underscores are allowed but ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白文字とアンダーラインは、許されるが、無視される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace before adverbs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>副詞の前の空白文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is not allowed before the parens because it is parsed as a postfix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが接尾辞として解析されるので、空白文字は括弧の前に許されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is not allowed between a variable name and its subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白文字は、変数名とその添え字の間で許されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace is not allowed on either side of the slash or it will be split under normal quote-words semantics:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白文字はスラッシュの両側に許されない、または、それは通常の引用-ワード意味論の下で割られる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With &lt;c2&gt;.^methods&lt;/c2&gt; you can learn what you can do with it.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140112T161413Z" creationid="Toshiyuki" creationdate="20140112T161413Z">
        <seg>&lt;c2&gt;.^methods&lt;/c2&gt;で、あなたはそれをどうすることができるのかについて学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a target object or label, loop modifiers search lexotically for the scope to modify.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T103526Z" creationid="Toshiyuki" creationdate="20130806T103526Z">
        <seg>ターゲットオブジェクトかラベルを伴って、ループ修飾子はレギゾチックに変更するスコープを検索する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With subsequent declarations in the same scope the use of the pseudo-sigil is optional, since the bare type name is also declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>裸のタイプ名も宣言される時から、同じスコープの以降の宣言で、疑似シギルの使用はオプションである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a declaration, a class variable (either by itself or following an existing type name) declares a new type name and takes its parametric value from the actual type of the parameter it is associated with.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言の範囲内で、クラス変数（それ自体または既存のタイプ名に続くことによって）は新しいタイプ名を宣言して、それが関連するパラメータの実際の型から、そのパラメータの値をとる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a lexical scope, pragmas may specify the nature of temporary values, and how floating point is to behave under various circumstances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>レキシカルスコープの中で、プラグマは、テンポラリー値の性質と浮動小数点がいろいろな状況の下でふるまうことになっている方法を指定するかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within declarations the adverbial form is used to rename parameter declarations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言の範囲内で、副詞形はパラメタ宣言の名前を変えるのに用いられる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a target, however, they are purely dynamic, and choose the innermost dynamic loop, which may well be a &lt;c0&gt;map&lt;/c0&gt; or other implicitly looping function, including user-defined functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130808T130721Z" creationid="Toshiyuki" creationdate="20130808T130721Z">
        <seg>ターゲットなしで純粋に動的ならなんであれ、最も深い部分の動的ループを選ぶ。それは&lt;c0&gt;map&lt;/c0&gt;または他の暗黙のユーザー定義の関数を含むループ関数だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書きなさい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are free instead to write your own accessor method, if at some future point you need to do something more complex than return the value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T184610Z" creationid="Toshiyuki" creationdate="20140111T184610Z">
        <seg>将来、値を返すより複雑なことをしたいなら、貴方自身のアクセサメソッドを書いて結構です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also bind variables to other variables:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T133426Z" creationid="yamato" creationdate="20140914T133426Z">
        <seg>変数を別の変数にバインドすることができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use the :key($value) form to quote the keys of option pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、オプション一組のキーを引合いに出すために、:key($value)の形を使用することもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call methods on that instance, as long as they do not try to access any state; &lt;c1&gt;new&lt;/c1&gt; is an example, as it creates a new object rather than modifying or accessing an existing object.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141945Z" creationid="Toshiyuki" creationdate="20140112T091343Z">
        <seg>それらが何の状態にもアクセスしようとしない限り、あなたはそのインスタンスでメソッドを呼ぶことができます；&lt;c1&gt;new&lt;/c1&gt;がその例です。存在するオブジェクトを変更するよりも新しいオブジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can cause built-ins to automatically throw exceptions on failure using</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T165751Z" creationid="Toshiyuki" creationdate="20130817T165751Z">
        <seg>次を使ってビルトインを失敗時に例外を自動的にスローさせる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare a parameter read/write by including the "&lt;c0&gt;is rw&lt;/c0&gt;" trait.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112806Z" creationid="Toshiyuki" creationdate="20130810T112806Z">
        <seg>&lt;c0&gt;is rw&lt;/c0&gt;トレイトを付け加えることでパラメータのread/writeを宣言することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can exit any labeled block early by saying</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、言うことによって早く、何かラベル付きブロックを出ることができる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can explicitly break out of a &lt;c0&gt;when&lt;/c0&gt; block (and its surrounding topicalizer block) early using the &lt;c1&gt;succeed&lt;/c1&gt; verb.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130812T113107Z" creationid="Toshiyuki" creationdate="20130812T113107Z">
        <seg>&lt;c1&gt;succeed&lt;/c1&gt;を使って&lt;c0&gt;when&lt;/c0&gt;ブロック（トピカライザーブロックを囲っている）を明示的に早く脱出できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can explicitly leave a &lt;c0&gt;when&lt;/c0&gt; block and go to the next statement following the &lt;c1&gt;when&lt;/c1&gt; by using &lt;c2&gt;proceed&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T115044Z" creationid="Toshiyuki" creationdate="20130813T115044Z">
        <seg>&lt;c2&gt;proceed&lt;/c2&gt;を使うことで&lt;c0&gt;when&lt;/c0&gt;ブロックを明示的に抜け、&lt;c1&gt;when&lt;/c1&gt;に続く次の文に行くことができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass in arguments to the constructor as well:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、同様にコンストラクタに引数を渡すことができる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this method to find out if a given object is a type object or not:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140111T181736Z" creationid="Toshiyuki" creationdate="20140111T181736Z">
        <seg>あなたは、所定のオブジェクトが型オブジェクトであるかどうかこと知るために、このメソッドを使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don't have to use an explicit default--you can just fall off the last &lt;c1&gt;when&lt;/c1&gt; into ordinary code.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133614Z" creationid="Toshiyuki" creationdate="20130811T133614Z">
        <seg>明示的なdefaultを使う必要はない―普通のコードの最後の&lt;c1&gt;when&lt;/c1&gt;をただ離れることもできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have to split those contents into lines yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、自分でそれらの内容を線に分けなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You inherit a default constructor named &lt;c0&gt;new&lt;/c0&gt; from the base class &lt;c1&gt;Object&lt;/c1&gt;, but you are free to override &lt;c2&gt;new&lt;/c2&gt;, as this example does:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140314T141122Z" creationid="Toshiyuki" creationdate="20140111T193319Z">
        <seg>あなたは&lt;c0&gt;new&lt;/c0&gt;という名前のデフォルトコンストラクターをベースクラス &lt;c1&gt;Object&lt;/c1&gt;から継承します。しかし例のように&lt;c2&gt;new&lt;/c2&gt;をオーバーライドするのは自由です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may &lt;c0&gt;supersede&lt;/c0&gt; or &lt;c1&gt;augment&lt;/c1&gt; those languages in your current lexical scope by doing</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T110609Z" creationid="yamato" creationdate="20140914T110609Z">
        <seg>これらの言語をレキシカルスコープで&lt;c0&gt;supersede&lt;/c0&gt;または&lt;c1&gt;augment&lt;/c1&gt;できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may access the Pod tree which contains all Pod structures as a hierarchical data structure through &lt;c0&gt;$=pod&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T064514Z" creationid="yamato" creationdate="20140914T064514Z">
        <seg>&lt;c0&gt;$=pod&lt;/c0&gt;変数を通して階層的な全てのPod構造のツリーにアクセスできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also perform an existence test, either on a single item or a junction of items:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T085221Z" creationid="Toshiyuki" creationdate="20140329T085221Z">
        <seg>単独のアイテムかジャンクションで存在のテストを実行できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also put one or more decimal numbers inside the square brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、一つ以上の十進数も角括弧に入れるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may also supersede a sublang entirely if, for example, you just want to disable that sublanguage in the current lexical scope:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、ちょうど現在のレキシカルスコープでその部分言語を働かなくしたいならば、あなたは完全にsublangにも取って代わるかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may assign alternating keys and values just as in Perl 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Perl 5の場合のようにちょうど交互のキーと値を割り当てるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may call any Code object by dereferencing it with parens (which may, of course, contain arguments):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、何でも括弧（もちろん、引数を含むかもしれない）でそれを間接参照することによるCodeオブジェクトと呼ぶかもしれない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may force immediate conversion to a &lt;c0&gt;Capture&lt;/c0&gt; object by prefixing the parcel composer with a backslash:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T074659Z" creationid="Toshiyuki" creationdate="20140329T074659Z">
        <seg>バックスラッシュをパーセルコンポーザーの前に置くことによって&lt;c0&gt;Capture&lt;/c0&gt;オブジェクトへの即時の変換を強制できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have one &lt;c2&gt;CATCH&lt;/c2&gt; block and one &lt;c3&gt;CONTROL&lt;/c3&gt; block, since some user-defined constructs may wish to supply an implicit &lt;c4&gt;CONTROL&lt;/c4&gt; block to your closure, but let you define your own &lt;c5&gt;CATCH&lt;/c5&gt; block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130816T130520Z" creationid="Toshiyuki" creationdate="20130816T130520Z">
        <seg>一つの&lt;c2&gt;CATCH&lt;/c2&gt;ブロックと一つの&lt;c3&gt;CONTROL&lt;/c3&gt;ブロックを持つこともできる。なのでいくつかのユーザー定義の構造が暗黙の&lt;c4&gt;CONTROL&lt;/c4&gt;ブロックをあなたのクロージャに与えたいと思うかもしれないが、あなたに独自の&lt;c5&gt;CATCH&lt;/c5&gt;ブロックを定義させる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have to parenthesize or force list context if some other operator that is tighter than comma would appear to be topmost:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、コンマより別のよりきつい若干の演算子がそうであるように見えるリストコンテキストもしもを括弧に入れなければならないかもしれないか、強制しなければならないかもしれない一番上の：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may not go into a &lt;c7&gt;given&lt;/c7&gt; or a &lt;c8&gt;for&lt;/c8&gt;, though, because that would bypass a formal parameter binding (not to mention list generation in the case of &lt;c9&gt;for&lt;/c9&gt;).</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T142603Z" creationid="Toshiyuki" creationdate="20130817T142603Z">
        <seg>あたなは&lt;c7&gt;given&lt;/c7&gt;または&lt;c8&gt;for&lt;/c8&gt;には行かないだろうけれど、それは仮パラメータのバインディングをバイパスするだろう（&lt;c9&gt;for&lt;/c9&gt;のケースのリスト生成の言及ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may not use any lexically scoped symbol table, either by name or by reference, to add symbols to a lexical scope that is done compiling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シンボルを編集することをされるレキシカルスコープに加えるために、名前で、または、参照によって、少しも辞書的に捜し出されたシンボルテーブルを使用しなくてもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may not use whitespace or alphanumerics for delimiters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デリミタのために空白文字または英数字を使わなくてもよい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may suppress this by modifying the first declaration with &lt;c0&gt;proto&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T130153Z" creationid="Toshiyuki" creationdate="20130730T130153Z">
        <seg>最初の宣言を&lt;c0&gt;proto&lt;/c0&gt;を付けて変更すればこれを抑制できるだろう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may use :!exists to test for non-existence.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T085449Z" creationid="Toshiyuki" creationdate="20140329T085449Z">
        <seg>:!existsで存在しないことをテストできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may, in fact, mix the two forms, as long as the pairs come when a key is expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーが予想されるとき組が来る限り、あなたは、実際、2つの形を混ぜるかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must rely on constructors and constant folding:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、コンストラクタと定数畳込みに頼らなければならない：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must use &lt;c2&gt;last&lt;/c2&gt; (or some more violent control exception such as &lt;c3&gt;return&lt;/c3&gt;) to break out of the entire loop early.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130813T120133Z" creationid="Toshiyuki" creationdate="20130813T120133Z">
        <seg>全体のループを早期に抜けるために&lt;c2&gt;last&lt;/c2&gt;（または&lt;c3&gt;return&lt;/c3&gt;のようないくつかのより乱暴な制御例外）を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must use an explicit radix marker for that.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それの明示的根標識を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need a wormhole for that.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T092259Z" creationid="Toshiyuki" creationdate="20130818T092259Z">
        <seg>あなたはそれのためにワームホールを必要とする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not assume that these will have the same value as their compile-time cousins.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、これらが彼らのコンパイル時いとこと同じ値を持つと仮定するべきでない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should officially not care about that (much).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それ（非常に）が公式に好きであるべきでない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You still must declare your subroutines, but a bareword with an unrecognized name is provisionally compiled as a subroutine call, on the assumption that such a declaration will occur by the end of the current compilation unit:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまだサブルーチンを宣言しなければならない、しかし、そのような宣言が現在のコンパイル単位の終りまでに起こるという仮定に関して、認められていない名前によるbarewordはサブルーチン呼出しとして仮に編集される：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You've already seen these in previous chapters.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140313T135232Z" creationid="Toshiyuki" creationdate="20140111T181238Z">
        <seg>あなたは、前の章でこれらを既に見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You've seen this situation before: it is exactly what happened with the signature parameter marked as &lt;c0&gt;is rw&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T133757Z" creationid="yamato" creationdate="20140914T133757Z">
        <seg>この状況をあなたは前に見ている：それはまさに&lt;c0&gt;is rw&lt;/c0&gt;としてマークされたシグネチャパラメータで起こったことだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Conjecture: a bare &lt;c0&gt;next($retval)&lt;/c0&gt; function could be taught to do the same, as long as &lt;c1&gt;$retval&lt;/c1&gt; isn't a loop label.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130806T102953Z" creationid="Toshiyuki" creationdate="20130806T102953Z">
        <seg>[推測：裸の&lt;c0&gt;next($retval)&lt;/c0&gt;関数は同じ事をするように教えられるかもしれない。&lt;c1&gt;$retval&lt;/c1&gt;がループラベルでない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Conjecture: all unhandled exceptions within a routine could be stored in &lt;c0&gt;@!&lt;/c0&gt;, with the most recent first.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T152234Z" creationid="Toshiyuki" creationdate="20130817T152234Z">
        <seg>［推測：ルーチン内の全てのハンドルされない例外は最も最近のものが&lt;c0&gt;@!&lt;/c0&gt;に格納される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Conjecture: we may someday find a way to make strings bind a little looser than the numeric types, but for now we conservatively outlaw the dispatch as ambiguous, and watch how this plays out in use.]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>［推測する：我々は方法が文字列苦境を数値型より少し不安定にするといつかわかるかもしれない、しかし、今のところ、あいまいであるように、我々は保守的にディスパッチを非合法化して、これがどのように使用中に尽きるかについて見る。］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Note: none of the official Unicode character names contains comma.]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>［注意する：公式ユニコード文字名のどれもコンマを含まない。］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Some conjectural suggestions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>［いくらかの推測的な提案：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>actually means:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実は、以下を意味する：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>add 1 to the result of the do block.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124258Z" creationid="Toshiyuki" creationdate="20130811T124258Z">
        <seg>はdoブロックの結果に1を加算する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>although with different optimization options for the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラのために異なる最適化オプションであるが。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and &lt;c0&gt;@a&lt;/c0&gt; actually stores three scalar containers.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T135022Z" creationid="yamato" creationdate="20140914T135022Z">
        <seg>そして&lt;c0&gt;@a&lt;/c0&gt;は実際に3つのスカラーコンテナを保存している。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and is equivalent to</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、等価物である</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and never as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、決してでなく、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and that is equivalent to:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130805T183828Z" creationid="Toshiyuki" creationdate="20130805T161429Z">
        <seg>そしてそれは以下と同じだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and the colons are not introducing pairs, but rather introducing the argument list of the method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、コロンは一組を導入していなくて、メソッドの引数の並びをむしろ導入している。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and the user may use loop control phasers as if they were directly in the loop block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、まるでそれらが直接ループブロックにあるように、ユーザーはループ制御フェイザー銃を使うかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>are autoprimed into closures of one or two arguments:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1、2引数のクロージャにautoprimedされる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>are the same as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下と同じようにある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>attribute (class member)</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120709Z" creationid="yamato" creationdate="20140914T120709Z">
        <seg>属性（クラスメンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but never as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、決してでなく、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calls the &lt;c0&gt;foo&lt;/c0&gt; function with three arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124219Z" creationid="Toshiyuki" creationdate="20130811T124219Z">
        <seg>は&lt;c0&gt;foo&lt;/c0&gt;関数を三つの引数で呼ぶ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>causes &lt;c0&gt;$x&lt;/c0&gt; to start with its current value.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140153Z" creationid="Toshiyuki" creationdate="20130802T140153Z">
        <seg>は&lt;c0&gt;$x&lt;/c0&gt;をその現在の値で始める。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>command line, or C&lt;-e&gt; if perl was invoked with the -e flag.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T115658Z" creationid="yamato" creationdate="20140914T115658Z">
        <seg>perlが-eフラグで起動されたならC&lt;-e&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>compile-time "constant"</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120718Z" creationid="yamato" creationdate="20140914T120718Z">
        <seg>コンパイル時「定数」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>deletes the entries &lt;i0&gt;en passant&lt;/i0&gt; while returning them.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T084807Z" creationid="Toshiyuki" creationdate="20140329T084807Z">
        <seg>はそれらを返す&lt;i0&gt;ついでに&lt;/i0&gt;エントリーを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>description</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043916Z" creationid="Toshiyuki" creationdate="20140322T043916Z">
        <seg>概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>digit</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124735Z" creationid="Toshiyuki" creationdate="20140322T124735Z">
        <seg>数字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>does not make a list of closures, but is equivalent to</seg>
      </tuv>
      <tuv lang="JA">
        <seg>doesは、クロージャのリストをしない、等しくない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dynamic</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120656Z" creationid="yamato" creationdate="20140914T120656Z">
        <seg>動的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>executable is in PATH.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120033Z" creationid="yamato" creationdate="20140914T120033Z">
        <seg>実行ファイルがPATHに入っている保証がないからだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>has two formal parameters, namely &lt;c0&gt;$first&lt;/c0&gt; and &lt;c1&gt;$second&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T062213Z" creationid="yamato" creationdate="20140914T062213Z">
        <seg>これは2つのパラメータ&lt;c0&gt;$first&lt;/c0&gt;と&lt;c1&gt;$second&lt;/c1&gt;を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if we're gonna blow past</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T110705Z" creationid="Toshiyuki" creationdate="20130814T110705Z">
        <seg>もし我々が過去を吹きとばそうとしているなら</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if you mean the postfix method call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが接尾辞メソッドを意味するならば、電話しなさい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in Perl 6 you should use a &lt;c0&gt;for&lt;/c0&gt; instead:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T062641Z" creationid="Toshiyuki" creationdate="20130810T062641Z">
        <seg>Perl 6では代わりに&lt;c0&gt;for&lt;/c0&gt;を使うべきだ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>index into match object (not really a variable)</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120816Z" creationid="yamato" creationdate="20140914T120816Z">
        <seg>マッチオブジェクトへのインデックス（本当は変数ではない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125737Z" creationid="Toshiyuki" creationdate="20130730T125623Z">
        <seg>と代わりに書く必要がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is a syntax error (two terms in a row).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構文エラー（列の2つの項）である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is actually short for:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114018Z" creationid="Toshiyuki" creationdate="20130810T114018Z">
        <seg>は実際は以下の略だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is always parsed as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>常に解析される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is dead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>死んでいる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is effectively primed into:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下に効果的に準備をされる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T132901Z" creationid="yamato" creationdate="20140914T132901Z">
        <seg>は次と同じだ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to the Cish idiom:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T060605Z" creationid="Toshiyuki" creationdate="20130810T060605Z">
        <seg>はC言語風のイディオムと同等だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下に等しい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is exactly equivalent to</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T133252Z" creationid="Toshiyuki" creationdate="20130811T133252Z">
        <seg>は以下とまさに同等だ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is parsed as:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130811T124611Z" creationid="Toshiyuki" creationdate="20130811T124611Z">
        <seg>は以下のようにパースされる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is really just short for:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T072238Z" creationid="Toshiyuki" creationdate="20130817T072238Z">
        <seg>は実際は以下の略だ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is rewritten as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書き直す：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it is an end-of-line comment, not an embedded comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、行末コメント（埋め込みコメントでない）である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it is like:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、以下のようにある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it is really a method on this pseudo-object, and</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、本当にこの疑似オブジェクトのメソッドである、そして、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>it was always exit from your lexically scoped &lt;c0&gt;LINE&lt;/c0&gt; loop, even if some inner dynamic scope you can't see happens to also have that label.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T074659Z" creationid="Toshiyuki" creationdate="20130817T074659Z">
        <seg>それは常にレキシカルスコープな&lt;c0&gt;LINE&lt;/c0&gt;ループから抜け出す。あなたが見ることができないいくつかのダイナミックスコープがたまたまそのラベルを持っていても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>just calls the methods &lt;c0&gt;x&lt;/c0&gt; and &lt;c1&gt;y&lt;/c1&gt; on &lt;c2&gt;self&lt;/c2&gt;, which are automatically generated for you because you used the &lt;c3&gt;.&lt;/c3&gt; twigil as you declared your attributes.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T061107Z" creationid="yamato" creationdate="20140914T061107Z">
        <seg>は単にメソッド&lt;c0&gt;x&lt;/c0&gt;と&lt;c1&gt;y&lt;/c1&gt;を&lt;c2&gt;self&lt;/c2&gt;で呼ぶだけで、それは&lt;c3&gt;.&lt;/c3&gt;を使って属性を宣言することで自動生成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>list, flat, item, and .tree</seg>
      </tuv>
      <tuv lang="JA">
        <seg>list、flat、itemと.tree</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>makes no guarantee about how many lines ahead the iterator has read.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>反復子が前にどれくらいの線を読み込んだかについて、保証を作らない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>marks only the last exception as handled.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130817T163350Z" creationid="Toshiyuki" creationdate="20130817T163350Z">
        <seg>は最後の例外だけハンドルされたとマークする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>means</seg>
      </tuv>
      <tuv lang="JA">
        <seg>手段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T043913Z" creationid="Toshiyuki" creationdate="20140322T043913Z">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>method (not really a variable)</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T121055Z" creationid="yamato" creationdate="20140914T121055Z">
        <seg>メソッド（本当は変数ではない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>my \degrees = pi / 180;
my \ﾎｸ       = 15 * degrees;</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120454Z" creationid="yamato" creationdate="20140914T120454Z">
        <seg>my \degrees = pi / 180;
my \θ       = 15 * degrees;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125614Z" creationid="Toshiyuki" creationdate="20130730T125614Z">
        <seg>または</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or as constants</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T124445Z" creationid="yamato" creationdate="20140914T124445Z">
        <seg>または定数として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently, using placeholders:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T125903Z" creationid="Toshiyuki" creationdate="20130810T125903Z">
        <seg>または同じようにプレースホルダーを使う：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T054724Z" creationid="Toshiyuki" creationdate="20130809T151429Z">
        <seg>または同様に：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or just put the autoprime in parens:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは、ちょうどautoprimeを括弧に置く：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>produces objects of classes defined as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定義されるクラスのオブジェクトを生じる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rather than</seg>
      </tuv>
      <tuv lang="JA">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rather than:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>むしろ以下より：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>really means</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本当に手段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>self-declared formal named parameter</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120903Z" creationid="yamato" creationdate="20140914T120903Z">
        <seg>自己宣言された名前付きの仮パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>self-declared formal positional parameter</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120849Z" creationid="yamato" creationdate="20140914T120849Z">
        <seg>自己宣言された位置の仮パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sets the variable to 0 at &lt;c0&gt;END&lt;/c0&gt; time, since that is when the "my" declaration is actually executed.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130818T085607Z" creationid="Toshiyuki" creationdate="20130818T085607Z">
        <seg>は&lt;c0&gt;END&lt;/c0&gt;時に変数を0にセットする。「my」宣言が実際に実行される時まで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>so you can modify the current list element in that case.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T114118Z" creationid="Toshiyuki" creationdate="20130810T114118Z">
        <seg>なのでその場合あなたは現在のリストの要素を変更できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the assignment &lt;c0&gt;$x = 42&lt;/c0&gt; stores a pointer to the &lt;c1&gt;Int&lt;/c1&gt; object 42 in the scalar container to which the lexpad entry for &lt;c2&gt;$x&lt;/c2&gt; points.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T131516Z" creationid="yamato" creationdate="20140914T131516Z">
        <seg>割り当て&lt;c0&gt;$x = 42&lt;/c0&gt;は&lt;c1&gt;Int&lt;/c1&gt;オブジェクト42へのポインタをスカラーコンテナに保存し、それは lexpadの&lt;c2&gt;$x&lt;/c2&gt;がポイントするエントリーだ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the result is a &lt;c0&gt;Parcel&lt;/c0&gt; object containing three &lt;c1&gt;Int&lt;/c1&gt; objects and a &lt;c2&gt;Pair&lt;/c2&gt; object, that is, four positional objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T073956Z" creationid="Toshiyuki" creationdate="20140329T073956Z">
        <seg>の結果は3つの&lt;c1&gt;Int&lt;/c1&gt;オブジェクトと&lt;c2&gt;Pair&lt;/c2&gt;オブジェクトを含む&lt;c0&gt;Parcel&lt;/c0&gt;、すなわち4つの位置依存オブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the sublanguage seen by the parser at this lexical spot</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120943Z" creationid="yamato" creationdate="20140914T120943Z">
        <seg>このレキシカルスポットでパーサーに見られるサブ言語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the syntactic &lt;c0&gt;Parcel&lt;/c0&gt; is translated (at compile time, in this case) into a &lt;c1&gt;Capture&lt;/c1&gt; object with three positionals and one named argument in preparation for binding.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140329T074309Z" creationid="Toshiyuki" creationdate="20140329T074309Z">
        <seg>構文法の&lt;c0&gt;Parcel&lt;/c0&gt;はバインディングに備えて3つの位置依存と名前付き引数の&lt;c1&gt;Capture&lt;/c1&gt;オブジェクトに変換（この場合はコンパイル時に） されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>then the lexpad entry for &lt;c0&gt;$x&lt;/c0&gt; directly points to the &lt;c1&gt;Int&lt;/c1&gt; 42.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T133258Z" creationid="yamato" creationdate="20140914T133258Z">
        <seg>&lt;c0&gt;$x&lt;/c0&gt;のlexpadエントリーは直接&lt;c1&gt;Int&lt;/c1&gt; 42をポイントする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to automatically assign to &lt;c0&gt;$_&lt;/c0&gt; is not carried over to Perl 6.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T111849Z" creationid="Toshiyuki" creationdate="20130810T111731Z">
        <seg>を自動的に&lt;c0&gt;$_&lt;/c0&gt;へ割り当てることはPerl 6へは持ち越されない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get buffers of signed integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号付き整数のバッファを得ること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to get the Perl 5 behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130802T140241Z" creationid="Toshiyuki" creationdate="20130802T140241Z">
        <seg>Perl 5の振る舞いを得るために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to mean the other thing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のものを意味すること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where each call to the block would bind a new invocant for the &lt;c0&gt;.waste&lt;/c0&gt; method, each of which is likely different from the original invocant to the &lt;c1&gt;.haste&lt;/c1&gt; method.)</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130804T103305Z" creationid="Toshiyuki" creationdate="20130804T103305Z">
        <seg>それぞれのブロックへの呼び出しが&lt;c0&gt;.waste&lt;/c0&gt;メソッドへの新しいインボカントをバインドするようなら、それぞれは&lt;c1&gt;.haste&lt;/c1&gt;メソッドのオリジナルのインボカントとおそらく違う。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is short for</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130810T112030Z" creationid="Toshiyuki" creationdate="20130810T112030Z">
        <seg>それは以下の略だ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is the same as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてそれは以下と同じようにある：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてそれは以下の通りである：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which prints</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T062129Z" creationid="yamato" creationdate="20140914T062129Z">
        <seg>は次のように出力する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>whitespace</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20140322T124741Z" creationid="Toshiyuki" creationdate="20140322T124741Z">
        <seg>空白</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will always be interpreted as</seg>
      </tuv>
      <tuv lang="JA">
        <seg>常に通訳される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will no longer see the value of the outer &lt;c0&gt;$x&lt;/c0&gt;; you'll need to say either</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130730T125609Z" creationid="Toshiyuki" creationdate="20130730T125609Z">
        <seg>はもやは外側の&lt;c0&gt;$x&lt;/c0&gt;の値を見ない；あなたは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would slice out pairs for the given the keys out of one hash into another.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1の中の鍵がもう一つにハッシュする既知の事実のために、一組を外にスライスさせる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would work just as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>仕事は、ちょうど同様にそうする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you now write</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、現在書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>you're really calling into a &lt;i0&gt;catch lambda&lt;/i0&gt; that works something like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="Toshiyuki" changedate="20130814T110054Z" creationid="Toshiyuki" creationdate="20130814T110054Z">
        <seg>実際にはこれの何かのように動作する&lt;i0&gt;catch lambda&lt;/i0&gt;の中へ呼んでいる：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ﾎｸ = 3; # Dies with the error "Cannot modify an immutable Int"</seg>
      </tuv>
      <tuv lang="JA" changeid="yamato" changedate="20140914T120513Z" creationid="yamato" creationdate="20140914T120513Z">
        <seg>θ = 3; # Dies with the error "Cannot modify an immutable Int"</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
